"# Prompt:

""Import the QuantumCircuit class from the qiskit library.
Then, create a quantum circuit with 3 qubits. 
Ensure to include the necessary import statement for the qiskit library.""


# Context:
""""""Document 0:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 1:::
---
title: QuantumCircuit
description: API reference for qiskit.circuit.QuantumCircuit
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.QuantumCircuit
---

# QuantumCircuit

<Class id=""qiskit.circuit.QuantumCircuit"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L106-L4951"" signature=""qiskit.circuit.QuantumCircuit(*regs, name=None, global_phase=0, metadata=None)"" modifiers=""class"">
  Bases: [`object`](https://docs.python.org/3/library/functions.html#object ""(in Python v3.12)"")

  Create a new circuit.

  A circuit is a list of instructions bound to some registers.

  **Parameters**

  *   **regs** (list([`Register`](qiskit.circuit.Register ""qiskit.circuit.Register"")) or list(`int`) or list(list([`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"")))) –

      The registers to be included in the circuit.

      *   If a list of [`Register`](qiskit.circuit.Register ""qiskit.circuit.Register"") objects, represents the [`QuantumRegister`](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"") and/or [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") objects to include in the circuit.

          For example:

          > *   `QuantumCircuit(QuantumRegister(4))`
          > *   `QuantumCircuit(QuantumRegister(4), ClassicalRegister(3))`
          > *   `QuantumCircuit(QuantumRegister(4, 'qr0'), QuantumRegister(2, 'qr1'))`

      *   If a list of `int`, the amount of qubits and/or classical bits to include in the circuit. It can either be a single int for just the number of quantum bits, or 2 ints for the number of quantum bits and classical bits, respectively.

          For example:

          > *   `QuantumCircuit(4) # A QuantumCircuit with 4 qubits`
          > *   `QuantumCircuit(4, 3) # A QuantumCircuit with 4 qubits and 3 classical bits`

      *   If a list of python lists containing [`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"") objects, a collection of [`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"") s to be added to the circuit.

  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – the name of the quantum circuit. If not set, an automatically generated string will be assigned.

  *   **global\_phase** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *or*[*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.ParameterExpression"")) – The global phase of the circuit in radians.

  *   **metadata** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – Arbitrary key value metadata to associate with the circuit. This gets stored as free-form data in a dict in the [`metadata`](#qiskit.circuit.QuantumCircuit.metadata ""qiskit.circuit.QuantumCircuit.metadata"") attribute. It will not be directly used in the circuit.

  **Raises**

  [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if the circuit name, if given, is not valid.

  **Examples**

  Construct a simple Bell state circuit.

  ```python
  from qiskit import QuantumCircuit

  qc = QuantumCircuit(2, 2)
  qc.h(0)
  qc.cx(0, 1)
  qc.measure([0, 1], [0, 1])
  qc.draw('mpl')
  ```

  ![../\_images/qiskit-circuit-QuantumCircuit-1.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-1.png)

  Construct a 5-qubit GHZ circuit.

  ```python
  from qiskit import QuantumCircuit

  qc = QuantumCircuit(5)
  qc.h(0)
  qc.cx(0, range(1, 5))
  qc.measure_all()
  ```

  Construct a 4-qubit Bernstein-Vazirani circuit using registers.

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

  qr = QuantumRegister(3, 'q')
  anc = QuantumRegister(1, 'ancilla')
  cr = ClassicalRegister(3, 'c')
  qc = QuantumCircuit(qr, anc, cr)

  qc.x(anc[0])
  qc.h(anc[0])
  qc.h(qr[0:3])
  qc.cx(qr[0:3], anc[0])
  qc.h(qr[0:3])
  qc.barrier(qr)
  qc.measure(qr, cr)

  qc.draw('mpl')
  ```

  ![../\_images/qiskit-circuit-QuantumCircuit-2.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-2.png)

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.QuantumCircuit.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.QuantumCircuit.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>Document 2:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 3:::
</Function>

Both of these two functions raise [`QASM3ImporterError`](#qiskit.qasm3.QASM3ImporterError ""qiskit.qasm3.QASM3ImporterError"") on failure.

### QASM3ImporterError

<Class id=""qiskit.qasm3.QASM3ImporterError"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/qasm3/exceptions.py#L26-L27"" signature=""qiskit.qasm3.QASM3ImporterError(*message)"" modifiers=""exception"">
  An error raised during the OpenQASM 3 importer.

  Set the error message.
</Class>

For example, we can define a quantum program using OpenQASM 3, and use [`loads()`](#qiskit.qasm3.loads ""qiskit.qasm3.loads"") to directly convert it into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit""):

```python
import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")
```

![../\_images/qasm3-1.png](/images/api/qiskit/1.0/qasm3-1.png)

### Experimental import interface

The import functions given above rely on the ANTLR-based reference parser from the OpenQASM project itself, which is more intended as a language reference than a performant parser. You need to have the extension `qiskit-qasm3-import` installed to use it.

Qiskit is developing a native parser, written in Rust, which is available as part of the core Qiskit package. This parser is still in its early experimental stages, so is missing features and its interface is changing and expanding, but it is typically orders of magnitude more performant for the subset of OpenQASM 3 it currently supports, and its internals produce better error diagnostics on parsing failures.

You can use the experimental interface immediately, with similar functions to the main interface above:

#### load\_experimental

<Function id=""qiskit.qasm3.load_experimental"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/qasm3/__init__.py"" signature=""qiskit.qasm3.load_experimental(pathlike_or_filelike, /, *, custom_gates=None, include_path=None)"">
  Load an OpenQASM 3 program from a source file into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  <Admonition title=""Warning"" type=""caution"">
    This native version of the OpenQASM 3 importer is currently experimental. It is typically much faster than [`load()`](#qiskit.qasm3.load ""qiskit.qasm3.load""), but has a reduced supported feature set, which will expand over time.
  </Admonition>

  **Parameters**

  *   **pathlike\_or\_filelike** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*os.PathLike*](https://docs.python.org/3/library/os.html#os.PathLike ""(in Python v3.12)"")  *|*[*io.TextIOBase*](https://docs.python.org/3/library/io.html#io.TextIOBase ""(in Python v3.12)"")) – the program source. This can either be given as a filepath, or an open text stream object. If the stream is already opened it is consumed in Python space, whereas filenames are opened and consumed in Rust space; there might be slightly different performance characteristics, depending on your system and how the streams are buffered by default.
  *   **custom\_gates** (*Iterable\[*[*CustomGate*](#qiskit.qasm3.CustomGate ""qiskit.qasm3.CustomGate"")*]*) – Python constructors to use for particular named gates. If not supplied, Qiskit will use its own standard-library constructors for gates defined in the OpenQASM 3.0 standard-library file `stdgates.inc`.
  *   **include\_path** (*Iterable\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – the path to search when resolving `include` statements. If not given, Qiskit will arrange for this to point to a location containing `stdgates.inc` only. Paths are tried in the sequence order.

  **Returns**

  the constructed circuit object.

  **Return type**

  [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  **.QASM3ImporterError** – if an error occurred during parsing or semantic analysis. In the case of a parsing error, most of the error messages are printed to the terminal and formatted, for better legibility.
</Function>

#### loads\_experimentalDocument 4:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter
    >>> angles = [Parameter(""angle_1""), Parameter(""angle_2""), Parameter(""angle_10"")]
    >>> circuit = QuantumCircuit(1)
    >>> circuit.u(*angles, 0)
    >>> circuit.draw()
       ┌─────────────────────────────┐
    q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.CDKMRippleCarryAdder.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.CDKMRippleCarryAdder.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""Import the QuantumCircuit class from the qiskit library. 
Then, create a quantum circuit with 3 qubits and apply a Hadamard
gate to the second qubit.
Ensure to include the necessary import statement for the qiskit library.""


# Context:
""""""Document 0:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 1:::
</Function>

Both of these two functions raise [`QASM3ImporterError`](#qiskit.qasm3.QASM3ImporterError ""qiskit.qasm3.QASM3ImporterError"") on failure.

### QASM3ImporterError

<Class id=""qiskit.qasm3.QASM3ImporterError"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/qasm3/exceptions.py#L26-L27"" signature=""qiskit.qasm3.QASM3ImporterError(*message)"" modifiers=""exception"">
  An error raised during the OpenQASM 3 importer.

  Set the error message.
</Class>

For example, we can define a quantum program using OpenQASM 3, and use [`loads()`](#qiskit.qasm3.loads ""qiskit.qasm3.loads"") to directly convert it into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit""):

```python
import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")
```

![../\_images/qasm3-1.png](/images/api/qiskit/1.0/qasm3-1.png)

### Experimental import interface

The import functions given above rely on the ANTLR-based reference parser from the OpenQASM project itself, which is more intended as a language reference than a performant parser. You need to have the extension `qiskit-qasm3-import` installed to use it.

Qiskit is developing a native parser, written in Rust, which is available as part of the core Qiskit package. This parser is still in its early experimental stages, so is missing features and its interface is changing and expanding, but it is typically orders of magnitude more performant for the subset of OpenQASM 3 it currently supports, and its internals produce better error diagnostics on parsing failures.

You can use the experimental interface immediately, with similar functions to the main interface above:

#### load\_experimental

<Function id=""qiskit.qasm3.load_experimental"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/qasm3/__init__.py"" signature=""qiskit.qasm3.load_experimental(pathlike_or_filelike, /, *, custom_gates=None, include_path=None)"">
  Load an OpenQASM 3 program from a source file into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  <Admonition title=""Warning"" type=""caution"">
    This native version of the OpenQASM 3 importer is currently experimental. It is typically much faster than [`load()`](#qiskit.qasm3.load ""qiskit.qasm3.load""), but has a reduced supported feature set, which will expand over time.
  </Admonition>

  **Parameters**

  *   **pathlike\_or\_filelike** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*os.PathLike*](https://docs.python.org/3/library/os.html#os.PathLike ""(in Python v3.12)"")  *|*[*io.TextIOBase*](https://docs.python.org/3/library/io.html#io.TextIOBase ""(in Python v3.12)"")) – the program source. This can either be given as a filepath, or an open text stream object. If the stream is already opened it is consumed in Python space, whereas filenames are opened and consumed in Rust space; there might be slightly different performance characteristics, depending on your system and how the streams are buffered by default.
  *   **custom\_gates** (*Iterable\[*[*CustomGate*](#qiskit.qasm3.CustomGate ""qiskit.qasm3.CustomGate"")*]*) – Python constructors to use for particular named gates. If not supplied, Qiskit will use its own standard-library constructors for gates defined in the OpenQASM 3.0 standard-library file `stdgates.inc`.
  *   **include\_path** (*Iterable\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – the path to search when resolving `include` statements. If not given, Qiskit will arrange for this to point to a location containing `stdgates.inc` only. Paths are tried in the sequence order.

  **Returns**

  the constructed circuit object.

  **Return type**

  [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  **.QASM3ImporterError** – if an error occurred during parsing or semantic analysis. In the case of a parsing error, most of the error messages are printed to the terminal and formatted, for better legibility.
</Function>

#### loads\_experimentalDocument 2:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 3:::
---
title: IQP
description: API reference for qiskit.circuit.library.IQP
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.IQP
---

# IQP

<Class id=""qiskit.circuit.library.IQP"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/iqp.py#L22-L96"" signature=""qiskit.circuit.library.IQP(interactions)"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  Instantaneous quantum polynomial (IQP) circuit.

  The circuit consists of a column of Hadamard gates, a column of powers of T gates, a sequence of powers of CS gates (up to $\frac{n^2-n}{2}$ of them), and a final column of Hadamard gates, as introduced in \[1].

  The circuit is parameterized by an n x n interactions matrix. The powers of each T gate are given by the diagonal elements of the interactions matrix. The powers of the CS gates are given by the upper triangle of the interactions matrix.

  **Reference Circuit:**

  ![../\_images/qiskit-circuit-library-IQP-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-IQP-1.png)

  **Expanded Circuit:**

  > ![../\_images/qiskit-circuit-library-IQP-2.png](/images/api/qiskit/1.0/qiskit-circuit-library-IQP-2.png)

  **References:**

  \[1] M. J. Bremner et al. Average-case complexity versus approximate simulation of commuting quantum computations, Phys. Rev. Lett. 117, 080501 (2016). [arXiv:1504.07999](https://arxiv.org/abs/1504.07999)

  Create IQP circuit.

  **Parameters**

  **interactions** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"") *| np.ndarray*) – input n-by-n symmetric matrix.

  **Raises**

  [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if the inputs is not as symmetric matrix.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.IQP.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.IQP.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.IQP.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.IQP.data"">
    Return the circuit data (instructions and context).

    **Returns**

    a list-like object containing the [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")s for each instruction.

    **Return type**

    QuantumCircuitData
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.IQP.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### instances

  <Attribute id=""qiskit.circuit.library.IQP.instances"" attributeValue=""181"" />

  ### layout

  <Attribute id=""qiskit.circuit.library.IQP.layout"">
    Return any associated layout information about the circuit

    This attribute contains an optional [`TranspileLayout`](qiskit.transpiler.TranspileLayout ""qiskit.transpiler.TranspileLayout"") object. This is typically set on the output from [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") or [`PassManager.run()`](qiskit.transpiler.PassManager#run ""qiskit.transpiler.PassManager.run"") to retain information about the permutations caused on the input circuit by transpilation.

    There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.
  </Attribute>

  ### metadata

  <Attribute id=""qiskit.circuit.library.IQP.metadata"">
    The user provided metadata associated with the circuit.

    The metadata for the circuit is a user provided `dict` of metadata for the circuit. It will not be used to influence the execution or operation of the circuit, but it is expected to be passed between all transforms of the circuit (ie transpilation) and that providers will associate any circuit metadata with the results it returns from execution of that circuit.
  </Attribute>

  ### num\_ancillas

  <Attribute id=""qiskit.circuit.library.IQP.num_ancillas"">
    Return the number of ancilla qubits.
  </Attribute>

  ### num\_clbits

  <Attribute id=""qiskit.circuit.library.IQP.num_clbits"">
    Return number of classical bits.
  </Attribute>

  ### num\_parameters

  <Attribute id=""qiskit.circuit.library.IQP.num_parameters"">
    The number of parameter objects in the circuit.Document 4:::
**Returns**

  the constructed circuit object.

  **Return type**

  [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  **.QASM3ImporterError** – if an error occurred during parsing or semantic analysis. In the case of a parsing error, most of the error messages are printed to the terminal and formatted, for better legibility.
</Function>

#### loads\_experimental

<Function id=""qiskit.qasm3.loads_experimental"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/qasm3/__init__.py"" signature=""qiskit.qasm3.loads_experimental(source, /, *, custom_gates=None, include_path=None)"">
  Load an OpenQASM 3 program from a string into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  <Admonition title=""Warning"" type=""caution"">
    This native version of the OpenQASM 3 importer is currently experimental. It is typically much faster than [`loads()`](#qiskit.qasm3.loads ""qiskit.qasm3.loads""), but has a reduced supported feature set, which will expand over time.
  </Admonition>

  **Parameters**

  *   **source** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – the program source in a Python string.
  *   **custom\_gates** (*Iterable\[*[*CustomGate*](#qiskit.qasm3.CustomGate ""qiskit.qasm3.CustomGate"")*]*) – Python constructors to use for particular named gates. If not supplied, Qiskit will use its own standard-library constructors for gates defined in the OpenQASM 3.0 standard-library file `stdgates.inc`.
  *   **include\_path** (*Iterable\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – the path to search when resolving `include` statements. If not given, Qiskit will arrange for this to point to a location containing `stdgates.inc` only. Paths are tried in the sequence order.

  **Returns**

  the constructed circuit object.

  **Return type**

  [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  **.QASM3ImporterError** – if an error occurred during parsing or semantic analysis. In the case of a parsing error, most of the error messages are printed to the terminal and formatted, for better legibility.
</Function>

These two functions are both experimental, meaning they issue an [`ExperimentalWarning`](exceptions#qiskit.exceptions.ExperimentalWarning ""qiskit.exceptions.ExperimentalWarning"") on usage, and their interfaces may be subject to change within the Qiskit 1.x release series. In particular, the native parser may be promoted to be the default version of [`load()`](#qiskit.qasm3.load ""qiskit.qasm3.load"") and [`loads()`](#qiskit.qasm3.loads ""qiskit.qasm3.loads""). If you are happy to accept the risk of using the experimental interface, you can disable the warning by doing:

```python
import warnings
from qiskit.exceptions import ExperimentalWarning

warnings.filterwarnings(""ignore"", category=ExperimentalWarning, module=""qiskit.qasm3"")
```

These two functions allow for specifying include paths as an iterable of paths, and for specifying custom Python constructors to use for particular gates. These custom constructors are specified by using the [`CustomGate`](#qiskit.qasm3.CustomGate ""qiskit.qasm3.CustomGate"") object:

#### CustomGate

<Class id=""qiskit.qasm3.CustomGate"" signature=""qiskit.qasm3.CustomGate"" modifiers=""class"">
  Information received from Python space about how to construct a Python-space object to represent a given gate that might be declared.
</Class>

In `custom_gates` is not given, Qiskit will attempt to use its standard-library gate objects for the gates defined in OpenQASM 3 standard library file `stdgates.inc`. This sequence of gates is available on this module, if you wish to build on top of it:

**qiskit.qasm3.STDGATES\_INC\_GATES**

A tuple of [`CustomGate`](#qiskit.qasm3.CustomGate ""qiskit.qasm3.CustomGate"") objects specifying the Qiskit constructors to use for the `stdgates.inc` include file.""""""
# Generate Code here:
"
"# Prompt:

""Import the QuantumCircuit class from the qiskit library. 
Create a quantum circuit with 3 qubits. Apply a CNOT gate with the
 first qubit as the control and the third qubit as the target. Then, apply 
a Hadamard gate to the second qubit. Ensure to include the
 necessary import statement for the qiskit library.""


# Context:
""""""Document 0:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 1:::
---
title: MCMT
description: API reference for qiskit.circuit.library.MCMT
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.MCMT
---

# MCMT

<Class id=""qiskit.circuit.library.MCMT"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L27-L155"" signature=""qiskit.circuit.library.MCMT(gate, num_ctrl_qubits, num_target_qubits)"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  The multi-controlled multi-target gate, for an arbitrary singly controlled target gate.

  For example, the H gate controlled on 3 qubits and acting on 2 target qubit is represented as:

  ```python
  ───■────
     │
  ───■────
     │
  ───■────
  ┌──┴───┐
  ┤0     ├
  │  2-H │
  ┤1     ├
  └──────┘
  ```

  This default implementations requires no ancilla qubits, by broadcasting the target gate to the number of target qubits and using Qiskit’s generic control routine to control the broadcasted target on the control qubits. If ancilla qubits are available, a more efficient variant using the so-called V-chain decomposition can be used. This is implemented in [`MCMTVChain`](qiskit.circuit.library.MCMTVChain ""qiskit.circuit.library.MCMTVChain"").

  Create a new multi-control multi-target gate.

  **Parameters**

  *   **gate** ([*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| Callable\[\[*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*,* [*circuit.Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*,* [*circuit.Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*],* [*circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")*]*) – The gate to be applied controlled on the control qubits and applied to the target qubits. Can be either a Gate or a circuit method. If it is a callable, it will be casted to a Gate.
  *   **num\_ctrl\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The number of control qubits.
  *   **num\_target\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The number of target qubits.

  **Raises**

  *   [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError ""(in Python v3.12)"") – If the gate cannot be casted to a controlled gate.
  *   [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError ""(in Python v3.12)"") – If the number of controls or targets is 0.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.MCMT.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.MCMT.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.MCMT.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.MCMT.data"">
    Return the circuit data (instructions and context).

    **Returns**

    a list-like object containing the [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")s for each instruction.

    **Return type**

    QuantumCircuitData
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.MCMT.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### instances

  <Attribute id=""qiskit.circuit.library.MCMT.instances"" attributeValue=""196"" />

  ### layout

  <Attribute id=""qiskit.circuit.library.MCMT.layout"">
    Return any associated layout information about the circuit

    This attribute contains an optional [`TranspileLayout`](qiskit.transpiler.TranspileLayout ""qiskit.transpiler.TranspileLayout"") object. This is typically set on the output from [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") or [`PassManager.run()`](qiskit.transpiler.PassManager#run ""qiskit.transpiler.PassManager.run"") to retain information about the permutations caused on the input circuit by transpilation.

    There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.
  </Attribute>

  ### metadata

  <Attribute id=""qiskit.circuit.library.MCMT.metadata"">
    The user provided metadata associated with the circuit.Document 2:::
*   **target\_qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) targeted by the gate.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### rccx

  <Function id=""qiskit.circuit.QuantumCircuit.rccx"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3065-L3085"" signature=""rccx(control_qubit1, control_qubit2, target_qubit)"">
    Apply [`RCCXGate`](qiskit.circuit.library.RCCXGate ""qiskit.circuit.library.RCCXGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit1** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) used as the first control.
    *   **control\_qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) used as the second control.
    *   **target\_qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) targeted by the gate.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### remove\_final\_measurements

  <Function id=""qiskit.circuit.QuantumCircuit.remove_final_measurements"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2341-L2402"" signature=""remove_final_measurements(inplace=True)"">
    Removes final measurements and barriers on all qubits if they are present. Deletes the classical registers that were used to store the values from these measurements that become idle as a result of this operation, and deletes classical bits that are referenced only by removed registers, or that aren’t referenced at all but have become idle as a result of this operation.

    Measurements and barriers are considered final if they are followed by no other operations (aside from other measurements or barriers.)

    **Parameters**

    **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – All measurements removed inplace or return new circuit.

    **Returns**

    Returns the resulting circuit when `inplace=False`, else None.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### repeatDocument 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 4:::
**Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **References**

  1.  S. Bravyi, D. Maslov, *Hadamard-free circuits expose the structure of the Clifford group*, [arXiv:2003.09412 \[quant-ph\]](https://arxiv.org/abs/2003.09412)
  2.  Dmitri Maslov, Martin Roetteler, *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*, [arXiv:1705.09176](https://arxiv.org/abs/1705.09176).
  3.  Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary Hadamard-free Clifford transformations they generate*, [arXiv:2210.16195](https://arxiv.org/abs/2210.16195).
</Function>

## CNOTDihedral Synthesis

### synth\_cnotdihedral\_full

<Function id=""qiskit.synthesis.synth_cnotdihedral_full"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_full.py#L25-L52"" signature=""qiskit.synthesis.synth_cnotdihedral_full(elem)"">
  Decompose a [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  For $N \leq 2$ qubits this is based on optimal CX-cost decomposition from reference \[1]. For $N > 2$ qubits this is done using the general non-optimal compilation routine from reference \[2].

  **Parameters**

  **elem** ([*CNOTDihedral*](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.operators.dihedral.dihedral.CNOTDihedral"")) – A [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element.

  **Returns**

  A circuit implementation of the [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element.

  **Return type**

  [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  **References**

  1.  Shelly Garion and Andrew W. Cross, *Synthesis of CNOT-Dihedral circuits with optimal number of two qubit gates*, [Quantum 4(369), 2020](https://quantum-journal.org/papers/q-2020-12-07-369/)
  2.  Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta, *Scalable randomised benchmarking of non-Clifford gates*, npj Quantum Inf 2, 16012 (2016).
</Function>

### synth\_cnotdihedral\_two\_qubits

<Function id=""qiskit.synthesis.synth_cnotdihedral_two_qubits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_two_qubits.py#L22-L266"" signature=""qiskit.synthesis.synth_cnotdihedral_two_qubits(elem)"">
  Decompose a [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element on a single qubit and two qubits into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit""). This decomposition has an optimal number of [`CXGate`](qiskit.circuit.library.CXGate ""qiskit.circuit.library.CXGate"")s.

  **Parameters**

  **elem** ([*CNOTDihedral*](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.operators.dihedral.dihedral.CNOTDihedral"")) – A [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element.

  **Returns**

  A circuit implementation of the [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the element in not 1-qubit or 2-qubit [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"").

  **Return type**

  [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  **References**

  1.  Shelly Garion and Andrew W. Cross, *On the structure of the CNOT-Dihedral group*, [arXiv:2006.12042 \[quant-ph\]](https://arxiv.org/abs/2006.12042)
</Function>

### synth\_cnotdihedral\_general

<Function id=""qiskit.synthesis.synth_cnotdihedral_general"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_general.py#L22-L141"" signature=""qiskit.synthesis.synth_cnotdihedral_general(elem)"">
  Decompose a [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  Decompose a general [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") elements. The number of CX gates is not necessarily optimal. For a decomposition of a 1-qubit or 2-qubit element, call [`synth_cnotdihedral_two_qubits()`](#qiskit.synthesis.synth_cnotdihedral_two_qubits ""qiskit.synthesis.synth_cnotdihedral_two_qubits"").

  **Parameters**""""""
# Generate Code here:
"
"# Prompt:

""Import the QuantumCircuit class from the qiskit library and create
 a quantum circuit with 3 qubits. Apply a CNOT gate with the first qubit
 as the control and the third qubit as the target. Then, apply a Hadamard
 gate to the second qubit. Import the Statevector class from
qiskit.quantum_info, initialize it to the |0⟩ state for 3 qubits, and
 evolve this state using the created quantum circuit. Ensure to include
 the necessary import statements for the qiskit library.
Do not execute the circuit, stop after evolving the state.""


# Context:
""""""Document 0:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 1:::
---
title: AND
description: API reference for qiskit.circuit.library.AND
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.AND
---

# AND

<Class id=""qiskit.circuit.library.AND"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/boolean_logic/quantum_and.py#L21-L97"" signature=""qiskit.circuit.library.AND(num_variable_qubits, flags=None, mcx_mode='noancilla')"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  A circuit implementing the logical AND operation on a number of qubits.

  For the AND operation the state $|1\rangle$ is interpreted as `True`. The result qubit is flipped, if the state of all variable qubits is `True`. In this format, the AND operation equals a multi-controlled X gate, which is controlled on all variable qubits. Using a list of flags however, qubits can be skipped or negated. Practically, the flags allow to skip controls or to apply pre- and post-X gates to the negated qubits.

  The AND gate without special flags equals the multi-controlled-X gate:

  ![../\_images/qiskit-circuit-library-AND-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-AND-1.png)

  Using flags we can negate qubits or skip them. For instance, if we have 5 qubits and want to return `True` if the first qubit is `False` and the last two are `True` we use the flags `[-1, 0, 0, 1, 1]`.

  ![../\_images/qiskit-circuit-library-AND-2.png](/images/api/qiskit/1.0/qiskit-circuit-library-AND-2.png)

  Create a new logical AND circuit.

  **Parameters**

  *   **num\_variable\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The qubits of which the OR is computed. The result will be written into an additional result qubit.
  *   **flags** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*] | None*) – A list of +1/0/-1 marking negations or omissions of qubits.
  *   **mcx\_mode** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – The mode to be used to implement the multi-controlled X gate.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.AND.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.AND.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.AND.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.AND.data"">
    Return the circuit data (instructions and context).

    **Returns**

    a list-like object containing the [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")s for each instruction.

    **Return type**

    QuantumCircuitData
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.AND.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### instances

  <Attribute id=""qiskit.circuit.library.AND.instances"" attributeValue=""161"" />

  ### layout

  <Attribute id=""qiskit.circuit.library.AND.layout"">
    Return any associated layout information about the circuit

    This attribute contains an optional [`TranspileLayout`](qiskit.transpiler.TranspileLayout ""qiskit.transpiler.TranspileLayout"") object. This is typically set on the output from [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") or [`PassManager.run()`](qiskit.transpiler.PassManager#run ""qiskit.transpiler.PassManager.run"") to retain information about the permutations caused on the input circuit by transpilation.

    There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.
  </Attribute>

  ### metadata

  <Attribute id=""qiskit.circuit.library.AND.metadata"">
    The user provided metadata associated with the circuit.

    The metadata for the circuit is a user provided `dict` of metadata for the circuit. It will not be used to influence the execution or operation of the circuit, but it is expected to be passed between all transforms of the circuit (ie transpilation) and that providers will associate any circuit metadata with the results it returns from execution of that circuit.
  </Attribute>

  ### num\_ancillas

  <Attribute id=""qiskit.circuit.library.AND.num_ancillas"">
    Return the number of ancilla qubits.
  </Attribute>

  ### num\_clbitsDocument 2:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 3:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")Document 4:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""Create a quantum circuit with 2 qubits and apply a Hadamard gate to
 the first qubit. Then, transpile the circuit for execution on the
 AerSimulator backend from qiskit_aer. Finally, run the transpiled
 circuit using backend.run with 128 shots. Ensure not to use or
 import the execute function from qiskit.""


# Context:
""""""Document 0:::
---
title: transpiler
description: API reference for qiskit.transpiler
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.transpiler
---

<span id=""module-qiskit.transpiler"" />

<span id=""qiskit-transpiler"" />

<span id=""transpiler-qiskit-transpiler"" />

# Transpiler

<span id=""module-qiskit.transpiler"" />

`qiskit.transpiler`

## Overview

Transpilation is the process of rewriting a given input circuit to match the topology of a specific quantum device, and/or to optimize the circuit for execution on present day noisy quantum systems.

Most circuits must undergo a series of transformations that make them compatible with a given target device, and optimize them to reduce the effects of noise on the resulting outcomes. Rewriting quantum circuits to match hardware constraints and optimizing for performance can be far from trivial. The flow of logic in the rewriting tool chain need not be linear, and can often have iterative sub-loops, conditional branches, and other complex behaviors. That being said, the standard compilation flow follows the structure given below:

![../\_images/transpiling\_core\_steps.png](/images/api/qiskit/1.0/transpiling_core_steps.png)

Qiskit has four pre-built transpilation pipelines available here: [`qiskit.transpiler.preset_passmanagers`](transpiler_preset#module-qiskit.transpiler.preset_passmanagers ""qiskit.transpiler.preset_passmanagers""). Unless the reader is familiar with quantum circuit optimization methods and their usage, it is best to use one of these ready-made routines. By default the preset pass managers are composed of six stages:

1.  `init` - This stage runs any initial passes that are required before we start embedding the circuit to the backend. This typically involves unrolling custom instructions and converting the circuit to all 1 and 2 qubit gates.
2.  `layout` - This stage applies a layout, mapping the virtual qubits in the circuit to the physical qubits on a backend. See [Layout Stage](#layout-stage) for more details.
3.  `routing` - This stage runs after a layout has been applied and will inject gates (i.e. swaps) into the original circuit to make it compatible with the backend’s connectivity. See [Routing Stage](#routing-stage) for more details.
4.  `translation` - This stage translates the gates in the circuit to the target backend’s basis set. See [Translation Stage](#translation-stage) for more details.
5.  `optimization` - This stage runs the main optimization loop repeatedly until a condition (such as fixed depth) is reached. See [Optimization Stage](#optimization-stage) for more details.
6.  `scheduling` - This stage is for any hardware-aware scheduling passes. See [Scheduling Stage](#scheduling-stage) for more details.

When using [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile""), the implementation of each stage can be modified with the `*_method` arguments (e.g. `layout_method`). These can be set to one of the built-in methods and can also refer to available external plugins. See [`qiskit.transpiler.preset_passmanagers.plugin`](transpiler_plugins#module-qiskit.transpiler.preset_passmanagers.plugin ""qiskit.transpiler.preset_passmanagers.plugin"") for details on this plugin interface.

<span id=""id1"" />

## Working with Preset Pass Managers

Qiskit includes functions to build preset [`PassManager`](qiskit.transpiler.PassManager ""qiskit.transpiler.PassManager"") objects. These preset passmanagers are used by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function for each optimization level. There are 4 optimization levels ranging from 0 to 3, where higher optimization levels take more time and computational effort but may yield a more optimal circuit. Optimization level 0 is intended for device characterization experiments and, as such, only maps the input circuit to the constraints of the target backend, without performing any optimizations. Optimization level 3 spends the most effort to optimize the circuit. However, as many of the optimization techniques in the transpiler are heuristic based, spending more computational effort does not always result in an improvement in the quality of the output circuit.

If you’d like to work directly with a preset pass manager you can use the [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager ""qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager"") function to easily generate one. For example:

```python
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.providers.fake_provider import GenericBackendV2

backend = GenericBackendV2(num_qubits=5)
pass_manager = generate_preset_pass_manager(3, backend)
```

which will generate a [`StagedPassManager`](qiskit.transpiler.StagedPassManager ""qiskit.transpiler.StagedPassManager"") object for optimization level 3 targeting the [`GenericBackendV2`](qiskit.providers.fake_provider.GenericBackendV2 ""qiskit.providers.fake_provider.GenericBackendV2"") backend (equivalent to what is used internally by [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") with `backend=GenericBackendV2(5)` and `optimization_level=3`). You can use this just like you would any other [`PassManager`](qiskit.transpiler.PassManager ""qiskit.transpiler.PassManager""). However, because it is a [`StagedPassManager`](qiskit.transpiler.StagedPassManager ""qiskit.transpiler.StagedPassManager"") it also makes it easy to compose and/or replace stages of the pipeline. For example, if you wanted to run a custom scheduling stage using dynamical decoupling (via the [`PadDynamicalDecoupling`](qiskit.transpiler.passes.PadDynamicalDecoupling ""qiskit.transpiler.passes.PadDynamicalDecoupling"") pass) and also add initial logical optimization prior to routing, you would do something like (building off the previous example):

```python
import numpy as np
from qiskit.circuit.library import HGate, PhaseGate, RXGate, TdgGate, TGate, XGate
from qiskit.transpiler import PassManager
from qiskit.transpiler.passes import (
    ALAPScheduleAnalysis,
    CXCancellation,
    InverseCancellation,
    PadDynamicalDecoupling,
)

dd_sequence = [XGate(), XGate()]
scheduling_pm = PassManager(
    [
        ALAPScheduleAnalysis(target=backend.target),Document 1:::
---
title: compiler
description: API reference for qiskit.compiler
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.compiler
---

<span id=""module-qiskit.compiler"" />

<span id=""qiskit-compiler"" />

<span id=""compilation-routines-qiskit-compiler"" />

# Compilation Routines

<span id=""module-qiskit.compiler"" />

`qiskit.compiler`

## Circuit and Pulse Compilation Functions

### assemble

<Function id=""qiskit.compiler.assemble"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/compiler/assembler.py#L42-L220"" signature=""qiskit.compiler.assemble(experiments, backend=None, qobj_id=None, qobj_header=None, shots=None, memory=False, seed_simulator=None, qubit_lo_freq=None, meas_lo_freq=None, qubit_lo_range=None, meas_lo_range=None, schedule_los=None, meas_level=MeasLevel.CLASSIFIED, meas_return=MeasReturnType.AVERAGE, meas_map=None, memory_slot_size=100, rep_time=None, rep_delay=None, parameter_binds=None, parametric_pulses=None, init_qubits=True, **run_config)"">
  Assemble a list of circuits or pulse schedules into a `Qobj`.

  This function serializes the payloads, which could be either circuits or schedules, to create `Qobj` “experiments”. It further annotates the experiment payload with header and configurations.

  NOTE: Backend.options is not used within assemble. The required values (previously given by backend.set\_options) should be manually extracted from options and supplied directly when calling.

  **Parameters**

  *   **experiments** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")*] |* [*Schedule*](qiskit.pulse.Schedule ""qiskit.pulse.schedule.Schedule"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*Schedule*](qiskit.pulse.Schedule ""qiskit.pulse.schedule.Schedule"")*] |* [*ScheduleBlock*](qiskit.pulse.ScheduleBlock ""qiskit.pulse.schedule.ScheduleBlock"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*ScheduleBlock*](qiskit.pulse.ScheduleBlock ""qiskit.pulse.schedule.ScheduleBlock"")*]*) – Circuit(s) or pulse schedule(s) to execute

  *   **backend** ([*Backend*](qiskit.providers.Backend ""qiskit.providers.backend.Backend"") *| None*) – If set, some runtime options are automatically grabbed from `backend.configuration()` and `backend.defaults()`. If any other option is explicitly set (e.g., `rep_time`), it will override the backend’s. If any other options is set in the run\_config, it will also override the backend’s.

  *   **qobj\_id** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – String identifier to annotate the `Qobj`

  *   **qobj\_header** ([*QobjHeader*](qiskit.qobj.QobjHeader ""qiskit.qobj.common.QobjHeader"")  *|*[*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict ""(in Python v3.12)"") *| None*) – User input that will be inserted in `Qobj` header, and will also be copied to the corresponding Result header. Headers do not affect the run.

  *   **shots** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – Number of repetitions of each circuit, for sampling. Default: 1024 or `max_shots` from the backend configuration, whichever is smaller

  *   **memory** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"") *| None*) – If `True`, per-shot measurement bitstrings are returned as well (provided the backend supports it). For OpenPulse jobs, only measurement level 2 supports this option.

  *   **seed\_simulator** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – Random seed to control sampling, for when backend is a simulator

  *   **qubit\_lo\_freq** ([*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*] | None*) – List of job level qubit drive LO frequencies in Hz. Overridden by `schedule_los` if specified. Must have length `n_qubits.`

  *   **meas\_lo\_freq** ([*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*] | None*) – List of measurement LO frequencies in Hz. Overridden by `schedule_los` if specified. Must have length `n_qubits.`

  *   **qubit\_lo\_range** ([*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*] | None*) – List of job level drive LO ranges each of form `[range_min, range_max]` in Hz. Used to validate `qubit_lo_freq`. Must have length `n_qubits.`Document 2:::
**Parameters**

  *   **circuits** (*\_CircuitT*) – Circuit(s) to transpile

  *   **backend** ([*Backend*](qiskit.providers.Backend ""qiskit.providers.backend.Backend"") *| None*) – If set, the transpiler will compile the input circuit to this target device. If any other option is explicitly set (e.g., `coupling_map`), it will override the backend’s.

  *   **basis\_gates** ([*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*] | None*) – List of basis gate names to unroll to (e.g: `['u1', 'u2', 'u3', 'cx']`). If `None`, do not unroll.

  *   **inst\_map** ([*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*InstructionScheduleMap*](qiskit.pulse.InstructionScheduleMap ""qiskit.pulse.instruction_schedule_map.InstructionScheduleMap"")*] | None*) – Mapping of unrolled gates to pulse schedules. If this is not provided, transpiler tries to get from the backend. If any user defined calibration is found in the map and this is used in a circuit, transpiler attaches the custom gate definition to the circuit. This enables one to flexibly override the low-level instruction implementation. This feature is available iff the backend supports the pulse gate experiment.

  *   **coupling\_map** ([*CouplingMap*](qiskit.transpiler.CouplingMap ""qiskit.transpiler.coupling.CouplingMap"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]] | None*) –

      Directed coupling map (perhaps custom) to target in mapping. If the coupling map is symmetric, both directions need to be specified.

      Multiple formats are supported:

      1.  `CouplingMap` instance
      2.  List, must be given as an adjacency matrix, where each entry specifies all directed two-qubit interactions supported by backend, e.g: `[[0, 1], [0, 3], [1, 2], [1, 5], [2, 5], [4, 1], [5, 3]]`

  *   **backend\_properties** ([*BackendProperties*](qiskit.providers.models.BackendProperties ""qiskit.providers.models.backendproperties.BackendProperties"") *| None*) – properties returned by a backend, including information on gate errors, readout errors, qubit coherence times, etc. Find a backend that provides this information with: `backend.properties()`

  *   **initial\_layout** ([*Layout*](qiskit.transpiler.Layout ""qiskit.transpiler.layout.Layout"")  *|*[*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict ""(in Python v3.12)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"") *| None*) –

      Initial position of virtual qubits on physical qubits. If this layout makes the circuit compatible with the coupling\_map constraints, it will be used. The final layout is not guaranteed to be the same, as the transpiler may permute qubits through swaps or other means. Multiple formats are supported:

      1.  `Layout` instance

      2.  Dict \* virtual to physical:

          ```python
          {qr[0]: 0,
           qr[1]: 3,
           qr[2]: 5}
          ```

          *   physical to virtual:

              ```python
              {0: qr[0],
               3: qr[1],
               5: qr[2]}
              ```

      3.  List

          *   virtual to physical:

              ```python
              [0, 3, 5]  # virtual qubits are ordered (in addition to named)
              ```

          *   physical to virtual:

              ```python
              [qr[0], None, None, qr[1], None, qr[2]]
              ```

  *   **layout\_method** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Name of layout selection pass (‘trivial’, ‘dense’, ‘sabre’). This can also be the external plugin name to use for the `layout` stage. You can see a list of installed plugins by using [`list_stage_plugins()`](transpiler_plugins#qiskit.transpiler.preset_passmanagers.plugin.list_stage_plugins ""qiskit.transpiler.preset_passmanagers.plugin.list_stage_plugins"") with `""layout""` for the `stage_name` argument.

  *   **routing\_method** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Name of routing pass (‘basic’, ‘lookahead’, ‘stochastic’, ‘sabre’, ‘none’). Note This can also be the external plugin name to use for the `routing` stage. You can see a list of installed plugins by using [`list_stage_plugins()`](transpiler_plugins#qiskit.transpiler.preset_passmanagers.plugin.list_stage_plugins ""qiskit.transpiler.preset_passmanagers.plugin.list_stage_plugins"") with `""routing""` for the `stage_name` argument.Document 3:::
for kwarg in kwargs:
            if not hasattr(kwarg, self.options):
                warnings.warn(
                    ""Option %s is not used by this backend"" % kwarg,
                    UserWarning, stacklevel=2)
        options = {
            'shots': kwargs.get('shots', self.options.shots),
            'memory': kwargs.get('memory', self.options.shots),
        }
        job_json = convert_to_wire_format(circuit, options)
        job_handle = submit_to_backend(job_jsonb)
        return MyJob(self. job_handle, job_json, circuit)
```

### Transpiler Interface

The key piece of the [`Backend`](qiskit.providers.Backend ""qiskit.providers.Backend"") object is how it describes itself to the compiler. This is handled with the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target"") class which defines a model of a backend for the transpiler. A backend object will need to return a [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target"") object from the [`target`](qiskit.providers.BackendV2#target ""qiskit.providers.BackendV2.target"") attribute which the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function will use as its model of a backend target for compilation.

<span id=""id3"" />

#### Custom Basis Gates

1.  If your backend doesn’t use gates in the Qiskit circuit library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library ""qiskit.circuit.library"")) you can integrate support for this into your provider. The basic method for doing this is first to define a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") subclass for each custom gate in the basis set. For example:

    ```python
    import numpy as np

    from qiskit.circuit import Gate
    from qiskit.circuit import QuantumCircuit

    class SYGate(Gate):
        def __init__(self, label=None):
            super().__init__(""sy"", 1, [], label=label)

        def _define(self):
            qc = QuantumCircuit(1)
            q.ry(np.pi / 2, 0)
            self.definition = qc
    ```

    The key thing to ensure is that for any custom gates in your Backend’s basis set your custom gate’s name attribute (the first param on `super().__init__()` in the `__init__` definition above) does not conflict with the name of any other gates. The name attribute is what is used to identify the gate in the basis set for the transpiler. If there is a conflict the transpiler will not know which gate to use.

2.  Add the custom gate to the target for your backend. This can be done with the [`Target.add_instruction()`](qiskit.transpiler.Target#add_instruction ""qiskit.transpiler.Target.add_instruction"") method. You’ll need to add an instance of `SYGate` and its parameters to the target so the transpiler knows it exists. For example, assuming this is part of your [`BackendV2`](qiskit.providers.BackendV2 ""qiskit.providers.BackendV2"") implementation for your backend:

    ```python
    from qiskit.transpiler import InstructionProperties

    sy_props = {
        (0,): InstructionProperties(duration=2.3e-6, error=0.0002)
        (1,): InstructionProperties(duration=2.1e-6, error=0.0001)
        (2,): InstructionProperties(duration=2.5e-6, error=0.0003)
        (3,): InstructionProperties(duration=2.2e-6, error=0.0004)
    }
    self.target.add_instruction(SYGate(), sy_props)
    ```

    The keys in `sy_props` define the qubits where the backend `SYGate` can be used on, and the values define the properties of `SYGate` on that qubit. For multiqubit gates the tuple keys contain all qubit combinations the gate works on (order is significant, i.e. `(0, 1)` is different from `(1, 0)`).

3.  After you’ve defined the custom gates to use for the backend’s basis set then you need to add equivalence rules to the standard equivalence library so that the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function and [`transpiler`](transpiler#module-qiskit.transpiler ""qiskit.transpiler"") module can convert an arbitrary circuit using the custom basis set. This can be done by defining equivalent circuits, in terms of the custom gate, for standard gates. Typically if you can convert from a [`CXGate`](qiskit.circuit.library.CXGate ""qiskit.circuit.library.CXGate"") (if your basis doesn’t include a standard 2 qubit gate) and some commonly used single qubit rotation gates like the [`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"") and [`UGate`](qiskit.circuit.library.UGate ""qiskit.circuit.library.UGate"") that should be sufficient for the transpiler to translate any circuit into the custom basis gates. But, the more equivalence rules that are defined from standard gates to your basis the more efficient translation from an arbitrary circuit to the target basis will be (although not always, and there is a diminishing margin of return).

    For example, if you were to add some rules for the above custom `SYGate` we could define the [`U2Gate`](qiskit.circuit.library.U2Gate ""qiskit.circuit.library.U2Gate"") and [`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate""):

    ```python
    from qiskit.circuit.equivalence_library import SessionEquivalenceLibrary
    from qiskit.circuit.library import HGate
    from qiskit.circuit.library import ZGate
    from qiskit.circuit.library import RZGate
    from qiskit.circuit.library import U2Gate


    # H => Z SY
    q = qiskit.QuantumRegister(1, ""q"")
    def_sy_h = qiskit.QuantumCircuit(q)
    def_sy_h.append(ZGate(), [q[0]], [])
    def_sy_h.append(SYGate(), [q[0]], [])
    SessionEquivalenceLibrary.add_equivalence(
        HGate(), def_sy_h)

    # u2 => Z SY Z
    phi = qiskit.circuit.Parameter('phi')
    lam = qiskit.circuit.Parameter('lambda')Document 4:::
| [`plot_gate_map`](qiskit.visualization.plot_gate_map ""qiskit.visualization.plot_gate_map"")(backend\[, figsize, ...])                   | Plots the gate map of a device.                                     |
| [`plot_error_map`](qiskit.visualization.plot_error_map ""qiskit.visualization.plot_error_map"")(backend\[, figsize, ...])                | Plots the error map of a given backend.                             |
| [`plot_circuit_layout`](qiskit.visualization.plot_circuit_layout ""qiskit.visualization.plot_circuit_layout"")(circuit, backend\[, ...]) | Plot the layout of a circuit transpiled for a given target backend. |
| [`plot_coupling_map`](qiskit.visualization.plot_coupling_map ""qiskit.visualization.plot_coupling_map"")(num\_qubits, ...\[, ...])       | Plots an arbitrary coupling map of qubits (embedded in a plane).    |

## Circuit Visualizations

|                                                                                                                                 |                           |
| ------------------------------------------------------------------------------------------------------------------------------- | ------------------------- |
| [`circuit_drawer`](qiskit.visualization.circuit_drawer ""qiskit.visualization.circuit_drawer"")(circuit\[, scale, filename, ...]) | Draw the quantum circuit. |

## DAG Visualizations

|                                                                                                                   |                                                                                                 |
| ----------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| [`dag_drawer`](qiskit.visualization.dag_drawer ""qiskit.visualization.dag_drawer"")(dag\[, scale, filename, style]) | Plot the directed acyclic graph (dag) to represent operation dependencies in a quantum circuit. |

## Pass Manager Visualizations

|                                                                                                                                     |                         |
| ----------------------------------------------------------------------------------------------------------------------------------- | ----------------------- |
| [`pass_manager_drawer`](qiskit.visualization.pass_manager_drawer ""qiskit.visualization.pass_manager_drawer"")(pass\_manager\[, ...]) | Draws the pass manager. |

## Timeline Visualizations

|                                                                                                                          |                                                             |
| ------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------- |
| [`timeline_drawer`](qiskit.visualization.timeline_drawer ""qiskit.visualization.timeline_drawer"")(program\[, style, ...]) | Generate visualization data for scheduled circuit programs. |

## Single Qubit State Transition Visualizations

|                                                                                                                                         |                                                                                                   |
| --------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| [`visualize_transition`](qiskit.visualization.visualize_transition ""qiskit.visualization.visualize_transition"")(circuit\[, trace, ...]) | Creates animation showing transitions between states of a single qubit by applying quantum gates. |

<span id=""array-matrix-visualizations"" />

## Array/Matrix Visualizations

|                                                                                                                                 |                                                                       |
| ------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| [`array_to_latex`](qiskit.visualization.array_to_latex ""qiskit.visualization.array_to_latex"")(array\[, precision, prefix, ...]) | Latex representation of a complex numpy array (with dimension 1 or 2) |

## Exceptions""""""
# Generate Code here:
"
"# Prompt:

""Create a quantum circuit with one QuantumRegister. Apply a U gate
 with the parameters pi/4, pi/3, pi/2 to the qubit in the register.
Ensure to include necessary imports from qiskit.
from qiskit import QuantumCircuit, QuantumRegister
from math import pi""


# Context:
""""""Document 0:::
---
title: QuantumRegister
description: API reference for qiskit.circuit.QuantumRegister
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.QuantumRegister
---

# QuantumRegister

<Class id=""qiskit.circuit.QuantumRegister"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumregister.py#L50-L57"" signature=""qiskit.circuit.QuantumRegister(size=None, name=None, bits=None)"" modifiers=""class"">
  Bases: [`Register`](qiskit.circuit.Register ""qiskit.circuit.register.Register"")

  Implement a quantum register.

  Create a new generic register.

  Either the `size` or the `bits` argument must be provided. If `size` is not None, the register will be pre-populated with bits of the correct type.

  **Parameters**

  *   **size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Optional. The number of bits to include in the register.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional. The name of the register. If not provided, a unique name will be auto-generated from the register type.
  *   **bits** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*Bit*](qiskit.circuit.Bit ""qiskit.circuit.Bit"")*]*) – Optional. A list of Bit() instances to be used to populate the register.

  **Raises**

  *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if both the `size` and `bits` arguments are provided, or if neither are.
  *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `size` is not valid.
  *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `name` is not a valid name according to the OpenQASM spec.
  *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `bits` contained duplicated bits.
  *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `bits` contained bits of an incorrect type.

  ## Attributes

  ### instances\_counter

  <Attribute id=""qiskit.circuit.QuantumRegister.instances_counter"" attributeValue=""count(5)"" />

  ### name

  <Attribute id=""qiskit.circuit.QuantumRegister.name"">
    Get the register name.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.QuantumRegister.prefix"" attributeValue=""'q'"" />

  ### size

  <Attribute id=""qiskit.circuit.QuantumRegister.size"">
    Get the register size.
  </Attribute>

  ## Methods

  ### index

  <Function id=""qiskit.circuit.QuantumRegister.index"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/register.py#L183-L191"" signature=""index(bit)"">
    Find the index of the provided bit within this register.
  </Function>
</Class>Document 1:::
---
title: Qubit
description: API reference for qiskit.circuit.Qubit
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.Qubit
---

# Qubit

<Class id=""qiskit.circuit.Qubit"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumregister.py#L26-L47"" signature=""qiskit.circuit.Qubit(register=None, index=None)"" modifiers=""class"">
  Bases: [`Bit`](qiskit.circuit.Bit ""qiskit.circuit.bit.Bit"")

  Implement a quantum bit.

  Creates a qubit.

  **Parameters**

  *   **register** ([*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"")) – Optional. A quantum register containing the bit.
  *   **index** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Optional. The index of the bit in its containing register.

  **Raises**

  [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if the provided register is not a valid [`QuantumRegister`](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"")
</Class>Document 2:::
---
title: QuantumCircuit
description: API reference for qiskit.circuit.QuantumCircuit
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.QuantumCircuit
---

# QuantumCircuit

<Class id=""qiskit.circuit.QuantumCircuit"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L106-L4951"" signature=""qiskit.circuit.QuantumCircuit(*regs, name=None, global_phase=0, metadata=None)"" modifiers=""class"">
  Bases: [`object`](https://docs.python.org/3/library/functions.html#object ""(in Python v3.12)"")

  Create a new circuit.

  A circuit is a list of instructions bound to some registers.

  **Parameters**

  *   **regs** (list([`Register`](qiskit.circuit.Register ""qiskit.circuit.Register"")) or list(`int`) or list(list([`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"")))) –

      The registers to be included in the circuit.

      *   If a list of [`Register`](qiskit.circuit.Register ""qiskit.circuit.Register"") objects, represents the [`QuantumRegister`](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"") and/or [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") objects to include in the circuit.

          For example:

          > *   `QuantumCircuit(QuantumRegister(4))`
          > *   `QuantumCircuit(QuantumRegister(4), ClassicalRegister(3))`
          > *   `QuantumCircuit(QuantumRegister(4, 'qr0'), QuantumRegister(2, 'qr1'))`

      *   If a list of `int`, the amount of qubits and/or classical bits to include in the circuit. It can either be a single int for just the number of quantum bits, or 2 ints for the number of quantum bits and classical bits, respectively.

          For example:

          > *   `QuantumCircuit(4) # A QuantumCircuit with 4 qubits`
          > *   `QuantumCircuit(4, 3) # A QuantumCircuit with 4 qubits and 3 classical bits`

      *   If a list of python lists containing [`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"") objects, a collection of [`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"") s to be added to the circuit.

  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – the name of the quantum circuit. If not set, an automatically generated string will be assigned.

  *   **global\_phase** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *or*[*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.ParameterExpression"")) – The global phase of the circuit in radians.

  *   **metadata** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – Arbitrary key value metadata to associate with the circuit. This gets stored as free-form data in a dict in the [`metadata`](#qiskit.circuit.QuantumCircuit.metadata ""qiskit.circuit.QuantumCircuit.metadata"") attribute. It will not be directly used in the circuit.

  **Raises**

  [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if the circuit name, if given, is not valid.

  **Examples**

  Construct a simple Bell state circuit.

  ```python
  from qiskit import QuantumCircuit

  qc = QuantumCircuit(2, 2)
  qc.h(0)
  qc.cx(0, 1)
  qc.measure([0, 1], [0, 1])
  qc.draw('mpl')
  ```

  ![../\_images/qiskit-circuit-QuantumCircuit-1.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-1.png)

  Construct a 5-qubit GHZ circuit.

  ```python
  from qiskit import QuantumCircuit

  qc = QuantumCircuit(5)
  qc.h(0)
  qc.cx(0, range(1, 5))
  qc.measure_all()
  ```

  Construct a 4-qubit Bernstein-Vazirani circuit using registers.

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

  qr = QuantumRegister(3, 'q')
  anc = QuantumRegister(1, 'ancilla')
  cr = ClassicalRegister(3, 'c')
  qc = QuantumCircuit(qr, anc, cr)

  qc.x(anc[0])
  qc.h(anc[0])
  qc.h(qr[0:3])
  qc.cx(qr[0:3], anc[0])
  qc.h(qr[0:3])
  qc.barrier(qr)
  qc.measure(qr, cr)

  qc.draw('mpl')
  ```

  ![../\_images/qiskit-circuit-QuantumCircuit-2.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-2.png)

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.QuantumCircuit.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.QuantumCircuit.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>Document 3:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 4:::
*   **qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### ry

  <Function id=""qiskit.circuit.QuantumCircuit.ry"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3181-L3198"" signature=""ry(theta, qubit, label=None)"">
    Apply [`RYGate`](qiskit.circuit.library.RYGate ""qiskit.circuit.library.RYGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** (*ParameterValueType*) – The rotation angle of the gate.
    *   **qubit** (*QubitSpecifier*) – The qubit(s) to apply the gate to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### ryy

  <Function id=""qiskit.circuit.QuantumCircuit.ryy"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3230-L3247"" signature=""ryy(theta, qubit1, qubit2)"">
    Apply [`RYYGate`](qiskit.circuit.library.RYYGate ""qiskit.circuit.library.RYYGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** ([*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.parameterexpression.ParameterExpression"")  *|*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The rotation angle of the gate.
    *   **qubit1** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.
    *   **qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### rz

  <Function id=""qiskit.circuit.QuantumCircuit.rz"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3249-L3263"" signature=""rz(phi, qubit)"">
    Apply [`RZGate`](qiskit.circuit.library.RZGate ""qiskit.circuit.library.RZGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **phi** ([*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.parameterexpression.ParameterExpression"")  *|*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The rotation angle of the gate.""""""
# Generate Code here:
"
"# Prompt:

""Create a TwoLocal ansatz and an SLSQP optimizer. The SLSQP 
optimizer should have 1000 maxiters and the TwoLocal ansatz should 
use the “ry” and “cz” gates and have 2 qubits.
from qiskit.circuit.library import TwoLocal
from qiskit_algorithms.optimizers import SLSQP""


# Context:
""""""Document 0:::
---
title: AQC
description: API reference for qiskit.synthesis.unitary.aqc.AQC
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.synthesis.unitary.aqc.AQC
---

# AQC

<Class id=""qiskit.synthesis.unitary.aqc.AQC"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/unitary/aqc/aqc.py#L77-L175"" signature=""qiskit.synthesis.unitary.aqc.AQC(optimizer=None, seed=None)"" modifiers=""class"">
  Bases: [`object`](https://docs.python.org/3/library/functions.html#object ""(in Python v3.12)"")

  A generic implementation of the Approximate Quantum Compiler. This implementation is agnostic of the underlying implementation of the approximate circuit, objective, and optimizer. Users may pass corresponding implementations of the abstract classes:

  *   The *optimizer* is an implementation of the `Minimizer` protocol, a callable used to run the optimization process. The choice of optimizer may affect overall convergence, required time for the optimization process and achieved objective value.
  *   The *approximate circuit* represents a template which parameters we want to optimize. Currently, there’s only one implementation based on 4-rotations CNOT unit blocks: [`CNOTUnitCircuit`](qiskit.synthesis.unitary.aqc.CNOTUnitCircuit ""qiskit.synthesis.unitary.aqc.CNOTUnitCircuit""). See the paper for more details.
  *   The *approximate objective* is tightly coupled with the approximate circuit implementation and provides two methods for computing objective function and gradient with respect to approximate circuit parameters. This objective is passed to the optimizer. Currently, there are two implementations based on 4-rotations CNOT unit blocks: [`DefaultCNOTUnitObjective`](qiskit.synthesis.unitary.aqc.DefaultCNOTUnitObjective ""qiskit.synthesis.unitary.aqc.DefaultCNOTUnitObjective"") and its accelerated version [`FastCNOTUnitObjective`](qiskit.synthesis.unitary.aqc.FastCNOTUnitObjective ""qiskit.synthesis.unitary.aqc.FastCNOTUnitObjective""). Both implementations share the same idea of maximization the Hilbert-Schmidt product between the target matrix and its approximation. The former implementation approach should be considered as a baseline one. It may suffer from performance issues, and is mostly suitable for a small number of qubits (up to 5 or 6), whereas the latter, accelerated one, can be applied to larger problems.
  *   One should take into consideration the exponential growth of matrix size with the number of qubits because the implementation not only creates a potentially large target matrix, but also allocates a number of temporary memory buffers comparable in size to the target matrix.

  **Parameters**

  *   **optimizer** (*Minimizer | None*) – an optimizer to be used in the optimization procedure of the search for the best approximate circuit. By default, the scipy minimizer with the `L-BFGS-B` method is used with max iterations set to 1000.
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – a seed value to be used by a random number generator.

  ## Methods

  ### compile\_unitary

  <Function id=""qiskit.synthesis.unitary.aqc.AQC.compile_unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/unitary/aqc/aqc.py#L127-L175"" signature=""compile_unitary(target_matrix, approximate_circuit, approximating_objective, initial_point=None)"">
    Approximately compiles a circuit represented as a unitary matrix by solving an optimization problem defined by `approximating_objective` and using `approximate_circuit` as a template for the approximate circuit.

    **Parameters**

    *   **target\_matrix** (*np.ndarray*) – a unitary matrix to approximate.
    *   **approximate\_circuit** ([*ApproximateCircuit*](qiskit.synthesis.unitary.aqc.ApproximateCircuit ""qiskit.synthesis.unitary.aqc.ApproximateCircuit"")) – a template circuit that will be filled with the parameter values obtained in the optimization procedure.
    *   **approximating\_objective** ([*ApproximatingObjective*](qiskit.synthesis.unitary.aqc.ApproximatingObjective ""qiskit.synthesis.unitary.aqc.ApproximatingObjective"")) – a definition of the optimization problem.
    *   **initial\_point** (*np.ndarray | None*) – initial values of angles/parameters to start optimization from.
  </Function>
</Class>Document 1:::
---
title: TwoQubitBasisDecomposer
description: API reference for qiskit.synthesis.TwoQubitBasisDecomposer
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.synthesis.TwoQubitBasisDecomposer
---

# TwoQubitBasisDecomposer

<Class id=""qiskit.synthesis.TwoQubitBasisDecomposer"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/two_qubit/two_qubit_decompose.py#L891-L1480"" signature=""qiskit.synthesis.TwoQubitBasisDecomposer(gate, basis_fidelity=1.0, euler_basis='U', pulse_optimize=None)"" modifiers=""class"">
  Bases: [`object`](https://docs.python.org/3/library/functions.html#object ""(in Python v3.12)"")

  A class for decomposing 2-qubit unitaries into minimal number of uses of a 2-qubit basis gate.

  **Parameters**

  *   **gate** ([*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"")) – Two-qubit gate to be used in the KAK decomposition.
  *   **basis\_fidelity** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – Fidelity to be assumed for applications of KAK Gate. Defaults to `1.0`.
  *   **euler\_basis** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Basis string to be provided to [`OneQubitEulerDecomposer`](qiskit.synthesis.OneQubitEulerDecomposer ""qiskit.synthesis.OneQubitEulerDecomposer"") for 1Q synthesis. Valid options are \[`'ZYZ'`, `'ZXZ'`, `'XYX'`, `'U'`, `'U3'`, `'U1X'`, `'PSX'`, `'ZSX'`, `'RR'`].
  *   **pulse\_optimize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"") *| None*) – If `True`, try to do decomposition which minimizes local unitaries in between entangling gates. This will raise an exception if an optimal decomposition is not implemented. Currently, only \[\{CX, SX, RZ}] is known. If `False`, don’t attempt optimization. If `None`, attempt optimization but don’t raise if unknown.

  ### \_\_call\_\_

  <Function id=""qiskit.synthesis.TwoQubitBasisDecomposer.__call__"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/two_qubit/two_qubit_decompose.py#L1150-L1214"" signature=""__call__(unitary, basis_fidelity=None, approximate=True, *, _num_basis_uses=None)"">
    Decompose a two-qubit `unitary` over fixed basis and $SU(2)$ using the best approximation given that each basis application has a finite `basis_fidelity`.

    **Parameters**

    *   **unitary** ([*Operator*](qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"") *or ndarray*) – $4 \times 4$ unitary to synthesize.
    *   **basis\_fidelity** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"") *or None*) – Fidelity to be assumed for applications of KAK Gate. If given, overrides `basis_fidelity` given at init.
    *   **approximate** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Approximates if basis fidelities are less than 1.0.
    *   **\_num\_basis\_uses** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – force a particular approximation by passing a number in \[0, 3].

    **Returns**

    Synthesized quantum circuit.

    **Return type**

    [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if `pulse_optimize` is True but we don’t know how to do it.
  </Function>

  ## Methods

  ### decomp0

  <Function id=""qiskit.synthesis.TwoQubitBasisDecomposer.decomp0"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/two_qubit/two_qubit_decompose.py#L1067-L1083"" signature=""decomp0(target)"" modifiers=""static"">
    Decompose target $\sim U_d(x, y, z)$ with $0$ uses of the basis gate. Result $U_r$ has trace:

$$
\Big\vert\text{Tr}(U_r\cdot U_\text{target}^{\dag})\Big\vert =
4\Big\vert (\cos(x)\cos(y)\cos(z)+ j \sin(x)\sin(y)\sin(z)\Big\vert
$$

    which is optimal for all targets and bases
  </Function>

  ### decomp1

  <Function id=""qiskit.synthesis.TwoQubitBasisDecomposer.decomp1"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/two_qubit/two_qubit_decompose.py#L1085-L1103"" signature=""decomp1(target)"">
    Decompose target $\sim U_d(x, y, z)$ with $1$ use of the basis gate $\sim U_d(a, b, c)$. Result $U_r$ has trace:

$$
\Big\vert\text{Tr}(U_r \cdot U_\text{target}^{\dag})\Big\vert =Document 2:::
**The operators to be evolved**

    (and circuits) in this ansatz.

    **Return type**

    List\[Union\[BaseOperator, OperatorBase, [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")]]
  </Attribute>

  ### ordered\_parameters

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.ordered_parameters"">
    The parameters used in the underlying circuit.

    This includes float values and duplicates.

    **Examples**

    ```python
    >>> # prepare circuit ...
    >>> print(nlocal)
         ┌───────┐┌──────────┐┌──────────┐┌──────────┐
    q_0: ┤ Ry(1) ├┤ Ry(θ[1]) ├┤ Ry(θ[1]) ├┤ Ry(θ[3]) ├
         └───────┘└──────────┘└──────────┘└──────────┘
    >>> nlocal.parameters
    {Parameter(θ[1]), Parameter(θ[3])}
    >>> nlocal.ordered_parameters
    [1, Parameter(θ[1]), Parameter(θ[1]), Parameter(θ[3])]
    ```

    **Returns**

    The parameters objects used in the circuit.
  </Attribute>

  ### parameter\_bounds

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.parameter_bounds"">
    The parameter bounds for the unbound parameters in the circuit.

    **Returns**

    A list of pairs indicating the bounds, as (lower, upper). None indicates an unbounded parameter in the corresponding direction. If None is returned, problem is fully unbounded.
  </Attribute>

  ### parameters

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.parameters"" />

  ### preferred\_init\_points

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.preferred_init_points"">
    Getter of preferred initial points based on the given initial state.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.prefix"" attributeValue=""'circuit'"" />

  ### qregs

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.qregs"" attributeTypeHint=""list[QuantumRegister]"">
    A list of the quantum registers associated with the circuit.
  </Attribute>

  ### qubits

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ### reps

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.reps"">
    Returns the reps parameter, which determines the depth of the circuit.
  </Attribute>

  ### rotation\_blocks

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.rotation_blocks"">
    The blocks in the rotation layers.

    **Returns**

    The blocks in the rotation layers.
  </Attribute>
</Class>Document 3:::
---
title: QAOAAnsatz
description: API reference for qiskit.circuit.library.QAOAAnsatz
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.QAOAAnsatz
---

# QAOAAnsatz

<Class id=""qiskit.circuit.library.QAOAAnsatz"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/n_local/qaoa_ansatz.py#L28-L289"" signature=""qiskit.circuit.library.QAOAAnsatz(cost_operator=None, reps=1, initial_state=None, mixer_operator=None, name='QAOA', flatten=None)"" modifiers=""class"">
  Bases: [`EvolvedOperatorAnsatz`](qiskit.circuit.library.EvolvedOperatorAnsatz ""qiskit.circuit.library.n_local.evolved_operator_ansatz.EvolvedOperatorAnsatz"")

  A generalized QAOA quantum circuit with a support of custom initial states and mixers.

  **References**

  **\[1]: Farhi et al., A Quantum Approximate Optimization Algorithm.**

  [arXiv:1411.4028](https://arxiv.org/pdf/1411.4028)

  **Parameters**

  *   **cost\_operator** (*BaseOperator or OperatorBase, optional*) – The operator representing the cost of the optimization problem, denoted as $U(C, \gamma)$ in the original paper. Must be set either in the constructor or via property setter.
  *   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The integer parameter p, which determines the depth of the circuit, as specified in the original paper, default is 1.
  *   **initial\_state** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*, optional*) – An optional initial state to use. If None is passed then a set of Hadamard gates is applied as an initial state to all qubits.
  *   **mixer\_operator** (*BaseOperator or OperatorBase or* [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*, optional*) – An optional custom mixer to use instead of the global X-rotations, denoted as $U(B, \beta)$ in the original paper. Can be an operator or an optionally parameterized quantum circuit.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – A name of the circuit, default ‘qaoa’
  *   **flatten** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"") *| None*) – Set this to `True` to output a flat circuit instead of nesting it inside multiple layers of gate objects. By default currently the contents of the output circuit will be wrapped in nested objects for cleaner visualization. However, if you’re using this circuit for anything besides visualization its **strongly** recommended to set this flag to `True` to avoid a large performance overhead for parameter binding.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### cost\_operator

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.cost_operator"">
    Returns an operator representing the cost of the optimization problem.

    **Returns**

    cost operator.

    **Return type**

    BaseOperator or OperatorBase
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.data"" />

  ### entanglement

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.entanglement"">
    Get the entanglement strategy.

    **Returns**

    The entanglement strategy, see `get_entangler_map()` for more detail on how the format is interpreted.
  </Attribute>

  ### entanglement\_blocks

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.entanglement_blocks"">
    The blocks in the entanglement layers.

    **Returns**

    The blocks in the entanglement layers.
  </Attribute>

  ### evolution

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.evolution"">
    The evolution converter used to compute the evolution.

    **Returns**

    The evolution converter used to compute the evolution.

    **Return type**

    [EvolutionSynthesis](qiskit.synthesis.EvolutionSynthesis ""qiskit.synthesis.EvolutionSynthesis"")
  </Attribute>

  ### flatten

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.flatten"">
    Returns whether the circuit is wrapped in nested gates/instructions or flattened.
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### initial\_state

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.initial_state"">
    Returns an optional initial state as a circuit
  </Attribute>

  ### insert\_barriers

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.insert_barriers"">Document 4:::
---
title: Optimize1qGates
description: API reference for qiskit.transpiler.passes.Optimize1qGates
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.transpiler.passes.Optimize1qGates
---

# Optimize1qGates

<Class id=""qiskit.transpiler.passes.Optimize1qGates"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/transpiler/passes/optimization/optimize_1q_gates.py#L34-L364"" signature=""qiskit.transpiler.passes.Optimize1qGates(*args, **kwargs)"" modifiers=""class"">
  Bases: [`TransformationPass`](qiskit.transpiler.TransformationPass ""qiskit.transpiler.basepasses.TransformationPass"")

  Optimize chains of single-qubit u1, u2, u3 gates by combining them into a single gate.

  Optimize1qGates initializer.

  **Parameters**

  *   **basis** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – Basis gates to consider, e.g. \[‘u3’, ‘cx’]. For the effects of this pass, the basis is the set intersection between the basis parameter and the set \{‘u1’,’u2’,’u3’, ‘u’, ‘p’}.
  *   **eps** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – EPS to check against
  *   **target** ([*Target*](qiskit.transpiler.Target ""qiskit.transpiler.Target"")) – The [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target"") representing the target backend, if both `basis` and `target` are specified then this argument will take precedence and `basis` will be ignored.

  ## Attributes

  ### is\_analysis\_pass

  <Attribute id=""qiskit.transpiler.passes.Optimize1qGates.is_analysis_pass"">
    Check if the pass is an analysis pass.

    If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set. Modifications on the DAG are not allowed by this kind of pass.
  </Attribute>

  ### is\_transformation\_pass

  <Attribute id=""qiskit.transpiler.passes.Optimize1qGates.is_transformation_pass"">
    Check if the pass is a transformation pass.

    If the pass is a TransformationPass, that means that the pass can manipulate the DAG, but cannot modify the property set (but it can be read).
  </Attribute>

  ## Methods

  ### compose\_u3

  <Function id=""qiskit.transpiler.passes.Optimize1qGates.compose_u3"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/transpiler/passes/optimization/optimize_1q_gates.py#L326-L339"" signature=""compose_u3(theta1, phi1, lambda1, theta2, phi2, lambda2)"" modifiers=""static"">
    Return a triple theta, phi, lambda for the product.

    **u3(theta, phi, lambda)**

    \= u3(theta1, phi1, lambda1).u3(theta2, phi2, lambda2) = Rz(phi1).Ry(theta1).Rz(lambda1+phi2).Ry(theta2).Rz(lambda2) = Rz(phi1).Rz(phi’).Ry(theta’).Rz(lambda’).Rz(lambda2) = u3(theta’, phi1 + phi’, lambda2 + lambda’)

    Return theta, phi, lambda.
  </Function>

  ### execute

  <Function id=""qiskit.transpiler.passes.Optimize1qGates.execute"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/transpiler/basepasses.py#L189-L211"" signature=""execute(passmanager_ir, state, callback=None)"">
    Execute optimization task for input Qiskit IR.

    **Parameters**

    *   **passmanager\_ir** ([*Any*](https://docs.python.org/3/library/typing.html#typing.Any ""(in Python v3.12)"")) – Qiskit IR to optimize.
    *   **state** ([*PassManagerState*](qiskit.passmanager.PassManagerState ""qiskit.passmanager.compilation_status.PassManagerState"")) – State associated with workflow execution by the pass manager itself.
    *   **callback** ([*Callable*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable ""(in Python v3.12)"") *| None*) – A callback function which is caller per execution of optimization task.

    **Returns**

    Optimized Qiskit IR and state of the workflow.

    **Return type**

    [tuple](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")\[[*Any*](https://docs.python.org/3/library/typing.html#typing.Any ""(in Python v3.12)""), [qiskit.passmanager.compilation\_status.PassManagerState](qiskit.passmanager.PassManagerState ""qiskit.passmanager.compilation_status.PassManagerState"")]
  </Function>

  ### name

  <Function id=""qiskit.transpiler.passes.Optimize1qGates.name"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/passmanager/base_tasks.py#L68-L70"" signature=""name()"">
    Name of the pass.

    **Return type**

    [str](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")
  </Function>

  ### run""""""
# Generate Code here:
"
"# Prompt:

""Create an ansatz with a 5-qubit parameter theta to be used for
 projecting the update steps of the p-VQD algorithm. Ensure the ansatz
 is parameterized and structured appropriately for a quantum algorithm.
from qiskit.circuit import QuantumCircuit, ParameterVector""


# Context:
""""""Document 0:::
**The operators to be evolved**

    (and circuits) in this ansatz.

    **Return type**

    List\[Union\[BaseOperator, OperatorBase, [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")]]
  </Attribute>

  ### ordered\_parameters

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.ordered_parameters"">
    The parameters used in the underlying circuit.

    This includes float values and duplicates.

    **Examples**

    ```python
    >>> # prepare circuit ...
    >>> print(nlocal)
         ┌───────┐┌──────────┐┌──────────┐┌──────────┐
    q_0: ┤ Ry(1) ├┤ Ry(θ[1]) ├┤ Ry(θ[1]) ├┤ Ry(θ[3]) ├
         └───────┘└──────────┘└──────────┘└──────────┘
    >>> nlocal.parameters
    {Parameter(θ[1]), Parameter(θ[3])}
    >>> nlocal.ordered_parameters
    [1, Parameter(θ[1]), Parameter(θ[1]), Parameter(θ[3])]
    ```

    **Returns**

    The parameters objects used in the circuit.
  </Attribute>

  ### parameter\_bounds

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.parameter_bounds"">
    The parameter bounds for the unbound parameters in the circuit.

    **Returns**

    A list of pairs indicating the bounds, as (lower, upper). None indicates an unbounded parameter in the corresponding direction. If None is returned, problem is fully unbounded.
  </Attribute>

  ### parameters

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.parameters"" />

  ### preferred\_init\_points

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.preferred_init_points"">
    Getter of preferred initial points based on the given initial state.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.prefix"" attributeValue=""'circuit'"" />

  ### qregs

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.qregs"" attributeTypeHint=""list[QuantumRegister]"">
    A list of the quantum registers associated with the circuit.
  </Attribute>

  ### qubits

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ### reps

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.reps"">
    Returns the reps parameter, which determines the depth of the circuit.
  </Attribute>

  ### rotation\_blocks

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.rotation_blocks"">
    The blocks in the rotation layers.

    **Returns**

    The blocks in the rotation layers.
  </Attribute>
</Class>Document 1:::
---
title: QAOAAnsatz
description: API reference for qiskit.circuit.library.QAOAAnsatz
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.QAOAAnsatz
---

# QAOAAnsatz

<Class id=""qiskit.circuit.library.QAOAAnsatz"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/n_local/qaoa_ansatz.py#L28-L289"" signature=""qiskit.circuit.library.QAOAAnsatz(cost_operator=None, reps=1, initial_state=None, mixer_operator=None, name='QAOA', flatten=None)"" modifiers=""class"">
  Bases: [`EvolvedOperatorAnsatz`](qiskit.circuit.library.EvolvedOperatorAnsatz ""qiskit.circuit.library.n_local.evolved_operator_ansatz.EvolvedOperatorAnsatz"")

  A generalized QAOA quantum circuit with a support of custom initial states and mixers.

  **References**

  **\[1]: Farhi et al., A Quantum Approximate Optimization Algorithm.**

  [arXiv:1411.4028](https://arxiv.org/pdf/1411.4028)

  **Parameters**

  *   **cost\_operator** (*BaseOperator or OperatorBase, optional*) – The operator representing the cost of the optimization problem, denoted as $U(C, \gamma)$ in the original paper. Must be set either in the constructor or via property setter.
  *   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The integer parameter p, which determines the depth of the circuit, as specified in the original paper, default is 1.
  *   **initial\_state** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*, optional*) – An optional initial state to use. If None is passed then a set of Hadamard gates is applied as an initial state to all qubits.
  *   **mixer\_operator** (*BaseOperator or OperatorBase or* [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*, optional*) – An optional custom mixer to use instead of the global X-rotations, denoted as $U(B, \beta)$ in the original paper. Can be an operator or an optionally parameterized quantum circuit.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – A name of the circuit, default ‘qaoa’
  *   **flatten** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"") *| None*) – Set this to `True` to output a flat circuit instead of nesting it inside multiple layers of gate objects. By default currently the contents of the output circuit will be wrapped in nested objects for cleaner visualization. However, if you’re using this circuit for anything besides visualization its **strongly** recommended to set this flag to `True` to avoid a large performance overhead for parameter binding.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### cost\_operator

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.cost_operator"">
    Returns an operator representing the cost of the optimization problem.

    **Returns**

    cost operator.

    **Return type**

    BaseOperator or OperatorBase
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.data"" />

  ### entanglement

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.entanglement"">
    Get the entanglement strategy.

    **Returns**

    The entanglement strategy, see `get_entangler_map()` for more detail on how the format is interpreted.
  </Attribute>

  ### entanglement\_blocks

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.entanglement_blocks"">
    The blocks in the entanglement layers.

    **Returns**

    The blocks in the entanglement layers.
  </Attribute>

  ### evolution

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.evolution"">
    The evolution converter used to compute the evolution.

    **Returns**

    The evolution converter used to compute the evolution.

    **Return type**

    [EvolutionSynthesis](qiskit.synthesis.EvolutionSynthesis ""qiskit.synthesis.EvolutionSynthesis"")
  </Attribute>

  ### flatten

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.flatten"">
    Returns whether the circuit is wrapped in nested gates/instructions or flattened.
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### initial\_state

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.initial_state"">
    Returns an optional initial state as a circuit
  </Attribute>

  ### insert\_barriers

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.insert_barriers"">Document 2:::
| [`EfficientSU2`](qiskit.circuit.library.EfficientSU2 ""qiskit.circuit.library.EfficientSU2"")(\[num\_qubits, su2\_gates, ...])                    | The hardware efficient SU(2) 2-local circuit.                                          |
| [`EvolvedOperatorAnsatz`](qiskit.circuit.library.EvolvedOperatorAnsatz ""qiskit.circuit.library.EvolvedOperatorAnsatz"")(\[operators, reps, ...]) | The evolved operator ansatz.                                                           |
| [`ExcitationPreserving`](qiskit.circuit.library.ExcitationPreserving ""qiskit.circuit.library.ExcitationPreserving"")(\[num\_qubits, mode, ...])  | The heuristic excitation-preserving wave function ansatz.                              |
| [`QAOAAnsatz`](qiskit.circuit.library.QAOAAnsatz ""qiskit.circuit.library.QAOAAnsatz"")(\[cost\_operator, reps, ...])                             | A generalized QAOA quantum circuit with a support of custom initial states and mixers. |

## Data encoding circuits

These `BlueprintCircuit` encode classical data in quantum states and are used as feature maps for classification.

|                                                                                                                                        |                                            |
| -------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------ |
| [`PauliFeatureMap`](qiskit.circuit.library.PauliFeatureMap ""qiskit.circuit.library.PauliFeatureMap"")(\[feature\_dimension, reps, ...]) | The Pauli Expansion circuit.               |
| [`ZFeatureMap`](qiskit.circuit.library.ZFeatureMap ""qiskit.circuit.library.ZFeatureMap"")(feature\_dimension\[, reps, ...])             | The first order Pauli Z-evolution circuit. |
| [`ZZFeatureMap`](qiskit.circuit.library.ZZFeatureMap ""qiskit.circuit.library.ZZFeatureMap"")(feature\_dimension\[, reps, ...])          | Second-order Pauli-Z evolution circuit.    |
| [`StatePreparation`](qiskit.circuit.library.StatePreparation ""qiskit.circuit.library.StatePreparation"")(params\[, num\_qubits, ...])   | Complex amplitude state preparation.       |
| [`Initialize`](qiskit.circuit.library.Initialize ""qiskit.circuit.library.Initialize"")(params\[, num\_qubits, normalize])               | Complex amplitude initialization.          |

## Template circuits

Templates are functions that return circuits that compute the identity. They are used at circuit optimization where matching part of the template allows the compiler to replace the match with the inverse of the remainder from the template.

In this example, the identity constant in a template is checked:

```python
from qiskit.circuit.library.templates import template_nct_4b_1
from qiskit.quantum_info import Operator
import numpy as np

template = template_nct_4b_1()

identity = np.identity(2 ** len(template.qubits), dtype=complex)
data = Operator(template).data
np.allclose(data, identity)  # True, template_nct_4b_1 is the identity
```

### NCT (Not-CNOT-Toffoli) template circuits

Template circuits for [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate""), [`CXGate`](qiskit.circuit.library.CXGate ""qiskit.circuit.library.CXGate""), and [`CCXGate`](qiskit.circuit.library.CCXGate ""qiskit.circuit.library.CCXGate"") (Toffoli) gates.

**Reference:** Maslov, D. and Dueck, G. W. and Miller, D. M., Techniques for the synthesis of reversible Toffoli networks, 2007 [http://dx.doi.org/10.1145/1278349.1278355](http://dx.doi.org/10.1145/1278349.1278355)

#### template\_nct\_2a\_1

<Function id=""qiskit.circuit.library.templates.nct.template_nct_2a_1"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/templates/nct/template_nct_2a_1.py#L24-L32"" signature=""qiskit.circuit.library.templates.nct.template_nct_2a_1()"">
  **Returns**

  template as a quantum circuit.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
</Function>

#### template\_nct\_2a\_2

<Function id=""qiskit.circuit.library.templates.nct.template_nct_2a_2"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/templates/nct/template_nct_2a_2.py#L25-L33"" signature=""qiskit.circuit.library.templates.nct.template_nct_2a_2()"">
  **Returns**

  template as a quantum circuit.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
</Function>

#### template\_nct\_2a\_3

<Function id=""qiskit.circuit.library.templates.nct.template_nct_2a_3"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/templates/nct/template_nct_2a_3.py#L27-L35"" signature=""qiskit.circuit.library.templates.nct.template_nct_2a_3()"">
  **Returns**

  template as a quantum circuit.

  **Return type**Document 3:::
**Data Access**

  The individual qubit Paulis can be accessed and updated using the `[]` operator which accepts integer, lists, or slices for selecting subsets of Paulis. Note that selecting subsets of Pauli’s will discard the phase of the current Pauli.

  For example

  ```python
  p = Pauli('-iXYZ')

  print('P[0] =', repr(P[0]))
  print('P[1] =', repr(P[1]))
  print('P[2] =', repr(P[2]))
  print('P[:] =', repr(P[:]))
  print('P[::-1] =, repr(P[::-1]))
  ```

  Initialize the Pauli.

  When using the symplectic array input data both z and x arguments must be provided, however the first (z) argument can be used alone for string label, Pauli operator, or ScalarOp input data.

  **Parameters**

  **data** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *or*[*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")  *or*[*Pauli*](#qiskit.quantum_info.Pauli ""qiskit.quantum_info.Pauli"")  *or*[*ScalarOp*](qiskit.quantum_info.ScalarOp ""qiskit.quantum_info.ScalarOp"")) – input data for Pauli. If input is a tuple it must be of the form `(z, x)` or (z, x, phase)\`\` where `z` and `x` are boolean Numpy arrays, and phase is an integer from Z\_4. If input is a string, it must be a concatenation of a phase and a Pauli string (e.g. ‘XYZ’, ‘-iZIZ’) where a phase string is a combination of at most three characters from \[‘+’, ‘-’, ‘’], \[‘1’, ‘’], and \[‘i’, ‘j’, ‘’] in this order, e.g. ‘’, ‘-1j’ while a Pauli string is 1 or more characters of ‘I’, ‘X’, ‘Y’ or ‘Z’, e.g. ‘Z’, ‘XIYY’.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if input array is invalid shape.

  ## Attributes

  ### dim

  <Attribute id=""qiskit.quantum_info.Pauli.dim"">
    Return tuple (input\_shape, output\_shape).
  </Attribute>

  ### name

  <Attribute id=""qiskit.quantum_info.Pauli.name"">
    Unique string identifier for operation type.
  </Attribute>

  ### num\_clbits

  <Attribute id=""qiskit.quantum_info.Pauli.num_clbits"">
    Number of classical bits.
  </Attribute>

  ### num\_qubits

  <Attribute id=""qiskit.quantum_info.Pauli.num_qubits"">
    Return the number of qubits if a N-qubit operator or None otherwise.
  </Attribute>

  ### phase

  <Attribute id=""qiskit.quantum_info.Pauli.phase"">
    Return the group phase exponent for the Pauli.
  </Attribute>

  ### qargs

  <Attribute id=""qiskit.quantum_info.Pauli.qargs"">
    Return the qargs for the operator.
  </Attribute>

  ### settings

  <Attribute id=""qiskit.quantum_info.Pauli.settings"">
    Return settings.
  </Attribute>

  ### x

  <Attribute id=""qiskit.quantum_info.Pauli.x"">
    The x vector for the Pauli.
  </Attribute>

  ### z

  <Attribute id=""qiskit.quantum_info.Pauli.z"">
    The z vector for the Pauli.
  </Attribute>

  ## Methods

  ### adjoint

  <Function id=""qiskit.quantum_info.Pauli.adjoint"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/symplectic/pauli.py#L518-L519"" signature=""adjoint()"">
    Return the adjoint of the Operator.
  </Function>

  ### anticommutes

  <Function id=""qiskit.quantum_info.Pauli.anticommutes"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/symplectic/pauli.py#L548-L558"" signature=""anticommutes(other, qargs=None)"">
    Return True if other Pauli anticommutes with self.

    **Parameters**

    *   **other** ([*Pauli*](#qiskit.quantum_info.Pauli ""qiskit.quantum_info.Pauli"")) – another Pauli operator.
    *   **qargs** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")) – qubits to apply dot product on (default: None).

    **Returns**

    True if Pauli’s anticommute, False if they commute.

    **Return type**

    [bool](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")
  </Function>

  ### commutes

  <Function id=""qiskit.quantum_info.Pauli.commutes"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/symplectic/pauli.py#L529-L546"" signature=""commutes(other, qargs=None)"">
    Return True if the Pauli commutes with other.

    **Parameters**Document 4:::
### num\_parameters

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.num_parameters"" />

  ### num\_parameters\_settable

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.num_parameters_settable"">
    The number of distinct parameters.
  </Attribute>

  ### num\_qubits

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.num_qubits"">
    Returns the number of qubits in this circuit.

    **Returns**

    The number of qubits.
  </Attribute>

  ### op\_start\_times

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.op_start_times"">
    Return a list of operation start times.

    This attribute is enabled once one of scheduling analysis passes runs on the quantum circuit.

    **Returns**

    List of integers representing instruction start times. The index corresponds to the index of instruction in `QuantumCircuit.data`.

    **Raises**

    [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError ""(in Python v3.12)"") – When circuit is not scheduled.
  </Attribute>

  ### ordered\_parameters

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.ordered_parameters"">
    The parameters used in the underlying circuit.

    This includes float values and duplicates.

    **Examples**

    ```python
    >>> # prepare circuit ...
    >>> print(nlocal)
         ┌───────┐┌──────────┐┌──────────┐┌──────────┐
    q_0: ┤ Ry(1) ├┤ Ry(θ[1]) ├┤ Ry(θ[1]) ├┤ Ry(θ[3]) ├
         └───────┘└──────────┘└──────────┘└──────────┘
    >>> nlocal.parameters
    {Parameter(θ[1]), Parameter(θ[3])}
    >>> nlocal.ordered_parameters
    [1, Parameter(θ[1]), Parameter(θ[1]), Parameter(θ[3])]
    ```

    **Returns**

    The parameters objects used in the circuit.
  </Attribute>

  ### parameter\_bounds

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.parameter_bounds"">
    The parameter bounds for the unbound parameters in the circuit.

    **Returns**

    A list of pairs indicating the bounds, as (lower, upper). None indicates an unbounded parameter in the corresponding direction. If `None` is returned, problem is fully unbounded.
  </Attribute>

  ### parameters

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.parameters"" />

  ### paulis

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.paulis"">
    The Pauli strings used in the entanglement of the qubits.

    **Returns**

    The Pauli strings as list.
  </Attribute>

  ### preferred\_init\_points

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.preferred_init_points"">
    The initial points for the parameters. Can be stored as initial guess in optimization.

    **Returns**

    The initial values for the parameters, or None, if none have been set.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.prefix"" attributeValue=""'circuit'"" />

  ### qregs

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.qregs"" attributeTypeHint=""list[QuantumRegister]"">
    A list of the quantum registers associated with the circuit.
  </Attribute>

  ### qubits

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ### reps

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.reps"">
    The number of times rotation and entanglement block are repeated.

    **Returns**

    The number of repetitions.
  </Attribute>

  ### rotation\_blocks

  <Attribute id=""qiskit.circuit.library.ZFeatureMap.rotation_blocks"">
    The blocks in the rotation layers.

    **Returns**

    The blocks in the rotation layers.
  </Attribute>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""Create a quantum circuit with 3 qubits and apply a Hadamard gate
 to the second qubit. Then, create a subcircuit with 2 qubits that applies
 the following operations: a Hadamard gate to the first qubit, a barrier,
 and a U gate to the first qubit with parameters 1, 2, -2. Finally, apply
 this subcircuit to the second and third qubits in the main circuit.
 Draw the decomposed version of this circuit. Include all necessary
 imports and provide comments explaining each step.
from qiskit import *""


# Context:
""""""Document 0:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 1:::
**Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **References**

  1.  S. Bravyi, D. Maslov, *Hadamard-free circuits expose the structure of the Clifford group*, [arXiv:2003.09412 \[quant-ph\]](https://arxiv.org/abs/2003.09412)
  2.  Dmitri Maslov, Martin Roetteler, *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*, [arXiv:1705.09176](https://arxiv.org/abs/1705.09176).
  3.  Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary Hadamard-free Clifford transformations they generate*, [arXiv:2210.16195](https://arxiv.org/abs/2210.16195).
</Function>

## CNOTDihedral Synthesis

### synth\_cnotdihedral\_full

<Function id=""qiskit.synthesis.synth_cnotdihedral_full"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_full.py#L25-L52"" signature=""qiskit.synthesis.synth_cnotdihedral_full(elem)"">
  Decompose a [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  For $N \leq 2$ qubits this is based on optimal CX-cost decomposition from reference \[1]. For $N > 2$ qubits this is done using the general non-optimal compilation routine from reference \[2].

  **Parameters**

  **elem** ([*CNOTDihedral*](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.operators.dihedral.dihedral.CNOTDihedral"")) – A [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element.

  **Returns**

  A circuit implementation of the [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element.

  **Return type**

  [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  **References**

  1.  Shelly Garion and Andrew W. Cross, *Synthesis of CNOT-Dihedral circuits with optimal number of two qubit gates*, [Quantum 4(369), 2020](https://quantum-journal.org/papers/q-2020-12-07-369/)
  2.  Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta, *Scalable randomised benchmarking of non-Clifford gates*, npj Quantum Inf 2, 16012 (2016).
</Function>

### synth\_cnotdihedral\_two\_qubits

<Function id=""qiskit.synthesis.synth_cnotdihedral_two_qubits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_two_qubits.py#L22-L266"" signature=""qiskit.synthesis.synth_cnotdihedral_two_qubits(elem)"">
  Decompose a [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element on a single qubit and two qubits into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit""). This decomposition has an optimal number of [`CXGate`](qiskit.circuit.library.CXGate ""qiskit.circuit.library.CXGate"")s.

  **Parameters**

  **elem** ([*CNOTDihedral*](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.operators.dihedral.dihedral.CNOTDihedral"")) – A [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element.

  **Returns**

  A circuit implementation of the [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the element in not 1-qubit or 2-qubit [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"").

  **Return type**

  [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  **References**

  1.  Shelly Garion and Andrew W. Cross, *On the structure of the CNOT-Dihedral group*, [arXiv:2006.12042 \[quant-ph\]](https://arxiv.org/abs/2006.12042)
</Function>

### synth\_cnotdihedral\_general

<Function id=""qiskit.synthesis.synth_cnotdihedral_general"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_general.py#L22-L141"" signature=""qiskit.synthesis.synth_cnotdihedral_general(elem)"">
  Decompose a [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") element into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  Decompose a general [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral ""qiskit.quantum_info.CNOTDihedral"") elements. The number of CX gates is not necessarily optimal. For a decomposition of a 1-qubit or 2-qubit element, call [`synth_cnotdihedral_two_qubits()`](#qiskit.synthesis.synth_cnotdihedral_two_qubits ""qiskit.synthesis.synth_cnotdihedral_two_qubits"").

  **Parameters**Document 2:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 3:::
Run the algorithm.

    **Parameters**

    *   **gate\_matrix** (*np.ndarray*) – The 2x2 matrix representing the gate. This matrix has to be SU(2) up to global phase.
    *   **recursion\_degree** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The recursion degree, called $n$ in the paper.
    *   **return\_dag** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` return a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit ""qiskit.dagcircuit.DAGCircuit""), else a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").
    *   **check\_input** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` check that the input matrix is valid for the decomposition.

    **Returns**

    A one-qubit circuit approximating the `gate_matrix` in the specified discrete basis.

    **Return type**

    QuantumCircuit’ | ‘DAGCircuit
  </Function>
</Class>Document 4:::
*   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Optional number of times the circuit should be decomposed. For instance, `reps=2` equals calling `circuit.decompose().decompose()`. can decompose specific gates specific time

    **Returns**

    a circuit one level decomposed

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### delay

  <Function id=""qiskit.circuit.QuantumCircuit.delay"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2847-L2871"" signature=""delay(duration, qarg=None, unit='dt')"">
    Apply [`Delay`](qiskit.circuit.Delay ""qiskit.circuit.Delay""). If qarg is `None`, applies to all qubits. When applying to multiple qubits, delays with the same duration will be created.

    **Parameters**

    *   **duration** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *or*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *or*[*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.ParameterExpression"")) – duration of the delay.
    *   **qarg** (*Object*) – qubit argument to apply this delay.
    *   **unit** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – unit of the duration. Supported units: `'s'`, `'ms'`, `'us'`, `'ns'`, `'ps'`, and `'dt'`. Default is `'dt'`, i.e. integer time unit depending on the target backend.

    **Returns**

    handle to the added instructions.

    **Return type**

    [qiskit.circuit.InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if arguments have bad format.
  </Function>

  ### depth

  <Function id=""qiskit.circuit.QuantumCircuit.depth"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1839-L1913"" signature=""depth(filter_function=<function QuantumCircuit.<lambda>>)"">
    Return circuit depth (i.e., length of critical path).

    **Parameters**

    **filter\_function** (*callable*) – A function to filter instructions. Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)). Instructions for which the function returns False are ignored in the computation of the circuit depth. By default filters out “directives”, such as barrier or snapshot.

    **Returns**

    Depth of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")

    **Notes**

    The circuit depth and the DAG depth need not be the same.
  </Function>

  ### draw

  <Function id=""qiskit.circuit.QuantumCircuit.draw"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1655-L1819"" signature=""draw(output=None, scale=None, filename=None, style=None, interactive=False, plot_barriers=True, reverse_bits=None, justify=None, vertical_compression='medium', idle_wires=True, with_layout=True, fold=None, ax=None, initial_state=False, cregbundle=None, wire_order=None, expr_len=30)"">
    Draw the quantum circuit. Use the output parameter to choose the drawing format:

    **text**: ASCII art TextDrawing that can be printed in the console.

    **mpl**: images with color rendered purely in Python using matplotlib.

    **latex**: high-quality images compiled via latex.

    **latex\_source**: raw uncompiled latex output.

    <Admonition title=""Warning"" type=""caution"">
      Support for [`Expr`](circuit_classical#qiskit.circuit.classical.expr.Expr ""qiskit.circuit.classical.expr.Expr"") nodes in conditions and `SwitchCaseOp.target` fields is preliminary and incomplete. The `text` and `mpl` drawers will make a best-effort attempt to show data dependencies, but the LaTeX-based drawers will skip these completely.
    </Admonition>

    **Parameters**

    *   **output** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Select the output method to use for drawing the circuit. Valid choices are `text`, `mpl`, `latex`, `latex_source`. By default the text drawer is used unless the user config file (usually `~/.qiskit/settings.conf`) has an alternative backend set as the default. For example, `circuit_drawer = latex`. If the output kwarg is set, that backend will always be used over the default in the user config file.

    *   **scale** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"") *| None*) – Scale of image to draw (shrink if `< 1.0`). Only used by the `mpl`, `latex` and `latex_source` outputs. Defaults to `1.0`.

    *   **filename** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – File path to save image to. Defaults to `None` (result not saved in a file).""""""
# Generate Code here:
"
"# Prompt:

""Make a circuit with 2 qubits and apply a Hadamard (H) gate to the first
 qubit. Then, use pulse.build to create a pulse scheduler with the
 parameters: duration=256, amp=0.2, and sigma=50. Add the pulse
 schedule to the circuit.
from qiskit import QuantumCircuit
from qiskit.pulse import Play, Schedule
from qiskit.pulse.library import Gaussian
from qiskit.pulse.channels import DriveChannel""


# Context:
""""""Document 0:::
# Start at t=30.
            pulse.play(gaussian_pulse, d0)
            # Start at t=30.
            pulse.play(gaussian_pulse, d1)
        # Context ends at t=40.

        # Alignment context where all pulse instructions are
        # aligned to the right, ie., as late as possible.
        with pulse.align_right():
            # Shift the phase of a pulse channel.
            pulse.shift_phase(math.pi, d1)
            # Starts at t=40.
            pulse.delay(100, d0)
            # Ends at t=140.

            # Starts at t=130.
            pulse.play(gaussian_pulse, d1)
            # Ends at t=140.

        # Acquire data for a qubit and store in a memory slot.
        pulse.acquire(100, 0, pulse.MemorySlot(0))

        # We also support a variety of macros for common operations.

        # Measure all qubits.
        pulse.measure_all()

        # Delay on some qubits.
        # This requires knowledge of which channels belong to which qubits.
        # delay for 100 cycles on qubits 0 and 1.
        pulse.delay_qubits(100, 0, 1)

        # Call a schedule for a quantum circuit thereby inserting into
        # the pulse schedule.
        qc = QuantumCircuit(2, 2)
        qc.cx(0, 1)
        qc_sched = schedule(qc, backend)
        pulse.call(qc_sched)


        # It is also be possible to call a preexisting schedule
        tmp_sched = pulse.Schedule()
        tmp_sched += pulse.Play(gaussian_pulse, d0)
        pulse.call(tmp_sched)

        # We also support:

        # frequency instructions
        pulse.set_frequency(5.0e9, d0)

        # phase instructions
        pulse.shift_phase(0.1, d0)

        # offset contexts
        with pulse.phase_offset(math.pi, d0):
            pulse.play(gaussian_pulse, d0)
```

The above is just a small taste of what is possible with the builder. See the rest of the module documentation for more information on its capabilities.

### build

<Function id=""qiskit.pulse.builder.build"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/pulse/builder.py#L774-L821"" signature=""qiskit.pulse.builder.build(backend=None, schedule=None, name=None, default_alignment='left')"">
  Create a context manager for launching the imperative pulse builder DSL.

  To enter a building context and starting building a pulse program:

  ```python
  from qiskit import transpile, pulse
  from qiskit.providers.fake_provider import FakeOpenPulse2Q

  backend = FakeOpenPulse2Q()

  d0 = pulse.DriveChannel(0)

  with pulse.build() as pulse_prog:
      pulse.play(pulse.Constant(100, 0.5), d0)
  ```

  While the output program `pulse_prog` cannot be executed as we are using a mock backend. If a real backend is being used, executing the program is done with:

  ```python
  backend.run(transpile(pulse_prog, backend))
  ```

  **Parameters**

  *   **backend** ([*Backend*](qiskit.providers.Backend ""qiskit.providers.Backend"")) – A Qiskit backend. If not supplied certain builder functionality will be unavailable.
  *   **schedule** ([*ScheduleBlock*](qiskit.pulse.ScheduleBlock ""qiskit.pulse.ScheduleBlock"") *| None*) – A pulse `ScheduleBlock` in which your pulse program will be built.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Name of pulse program to be built.
  *   **default\_alignment** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*AlignmentKind*](#qiskit.pulse.transforms.AlignmentKind ""qiskit.pulse.transforms.AlignmentKind"") *| None*) – Default scheduling alignment for builder. One of `left`, `right`, `sequential` or an alignment context.

  **Returns**

  A new builder context which has the active builder initialized.

  **Return type**

  ContextManager\[[ScheduleBlock](qiskit.pulse.ScheduleBlock ""qiskit.pulse.ScheduleBlock"")]
</Function>

### Channels

Methods to return the correct channels for the respective qubit indices.

```python
from qiskit import pulse
from qiskit.providers.fake_provider import GenericBackendV2

backend = GenericBackendV2(num_qubits=2, calibrate_instructions=True)

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    print(d0)
```

```python
DriveChannel(0)
```

#### acquire\_channel

<Function id=""qiskit.pulse.builder.acquire_channel"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/pulse/builder.py#L1425-L1445"" signature=""qiskit.pulse.builder.acquire_channel(qubit)"">
  Return `AcquireChannel` for `qubit` on the active builder backend.

  Examples:

  ```python
  from qiskit import pulse
  from qiskit.providers.fake_provider import FakeOpenPulse2Q

  backend = FakeOpenPulse2Q()

  with pulse.build(backend):
      assert pulse.acquire_channel(0) == pulse.AcquireChannel(0)
  ```

  <Admonition title=""Note"" type=""note"">
    Requires the active builder context to have a backend set.
  </Admonition>

  **Return type**

  [*AcquireChannel*](qiskit.pulse.channels.AcquireChannel ""qiskit.pulse.channels.AcquireChannel"")Document 1:::
with pulse.build() as udd_sched:
      pulse.play(x90, d0)
      with pulse.align_func(duration=300, func=udd10_pos):
          for _ in range(10):
              pulse.play(x180, d0)
      pulse.play(x90, d0)

  udd_sched.draw()
  ```

  ![../\_images/pulse-7.png](/images/api/qiskit/1.0/pulse-7.png)

  **Parameters**

  *   **duration** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.ParameterExpression"")) – Duration of context. This should be larger than the schedule duration.
  *   **func** (*Callable\[\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*],* [*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – A function that takes an index of sub-schedule and returns the fractional coordinate of of that sub-schedule. The returned value should be defined within \[0, 1]. The pulse index starts from 1.

  **Yields**

  None

  **Return type**

  Generator\[None, None, None]

  **Notes**

  The scheduling is performed for sub-schedules within the context rather than channel-wise. If you want to apply the numerical context for each channel, you need to apply the context independently to channels.
</Function>

#### align\_left

<Function id=""qiskit.pulse.builder.align_left"" signature=""qiskit.pulse.builder.align_left()"">
  Left alignment pulse scheduling context.

  Pulse instructions within this context are scheduled as early as possible by shifting them left to the earliest available time.

  Examples:

  ```python
  from qiskit import pulse

  d0 = pulse.DriveChannel(0)
  d1 = pulse.DriveChannel(1)

  with pulse.build() as pulse_prog:
      with pulse.align_left():
          # this pulse will start at t=0
          pulse.play(pulse.Constant(100, 1.0), d0)
          # this pulse will start at t=0
          pulse.play(pulse.Constant(20, 1.0), d1)
  pulse_prog = pulse.transforms.block_to_schedule(pulse_prog)

  assert pulse_prog.ch_start_time(d0) == pulse_prog.ch_start_time(d1)
  ```

  **Yields**

  None

  **Return type**

  [*Generator*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator ""(in Python v3.12)"")\[None, None, None]
</Function>

#### align\_right

<Function id=""qiskit.pulse.builder.align_right"" signature=""qiskit.pulse.builder.align_right()"">
  Right alignment pulse scheduling context.

  Pulse instructions within this context are scheduled as late as possible by shifting them right to the latest available time.

  Examples:

  ```python
  from qiskit import pulse

  d0 = pulse.DriveChannel(0)
  d1 = pulse.DriveChannel(1)

  with pulse.build() as pulse_prog:
      with pulse.align_right():
          # this pulse will start at t=0
          pulse.play(pulse.Constant(100, 1.0), d0)
          # this pulse will start at t=80
          pulse.play(pulse.Constant(20, 1.0), d1)
  pulse_prog = pulse.transforms.block_to_schedule(pulse_prog)

  assert pulse_prog.ch_stop_time(d0) == pulse_prog.ch_stop_time(d1)
  ```

  **Yields**

  None

  **Return type**

  [*Generator*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator ""(in Python v3.12)"")\[None, None, None]
</Function>

#### align\_sequential

<Function id=""qiskit.pulse.builder.align_sequential"" signature=""qiskit.pulse.builder.align_sequential()"">
  Sequential alignment pulse scheduling context.

  Pulse instructions within this context are scheduled sequentially in time such that no two instructions will be played at the same time.

  Examples:

  ```python
  from qiskit import pulse

  d0 = pulse.DriveChannel(0)
  d1 = pulse.DriveChannel(1)

  with pulse.build() as pulse_prog:
      with pulse.align_sequential():
          # this pulse will start at t=0
          pulse.play(pulse.Constant(100, 1.0), d0)
          # this pulse will also start at t=100
          pulse.play(pulse.Constant(20, 1.0), d1)
  pulse_prog = pulse.transforms.block_to_schedule(pulse_prog)

  assert pulse_prog.ch_stop_time(d0) == pulse_prog.ch_start_time(d1)
  ```

  **Yields**

  None

  **Return type**

  [*Generator*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator ""(in Python v3.12)"")\[None, None, None]
</Function>

#### frequency\_offset

<Function id=""qiskit.pulse.builder.frequency_offset"" signature=""qiskit.pulse.builder.frequency_offset(frequency, *channels, compensate_phase=False)"">
  Shift the frequency of inputs channels on entry into context and undo on exit.

  Examples:

  ```python
  from qiskit import pulse

  d0 = pulse.DriveChannel(0)

  with pulse.build(backend) as pulse_prog:
      # shift frequency by 1GHzDocument 2:::
*   **backend** ([*BackendV1*](qiskit.providers.BackendV1 ""qiskit.providers.backend.BackendV1"")  *|*[*BackendV2*](qiskit.providers.BackendV2 ""qiskit.providers.backend.BackendV2"") *| None*) – A backend used to build the Schedule, the backend could be BackendV1 or BackendV2.

  **Returns**

  A schedule corresponding to the input `circuit` with pulses occurring as early as possible.

  **Return type**

  [*Schedule*](qiskit.pulse.Schedule ""qiskit.pulse.schedule.Schedule"")
</Function>

### as\_late\_as\_possible

<Function id=""qiskit.scheduler.methods.as_late_as_possible"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/scheduler/methods/basic.py#L81-L137"" signature=""qiskit.scheduler.methods.as_late_as_possible(circuit, schedule_config, backend=None)"">
  Return the pulse Schedule which implements the input circuit using an “as late as possible” (alap) scheduling policy.

  Circuit instructions are first each mapped to equivalent pulse Schedules according to the command definition given by the schedule\_config. Then, this circuit instruction-equivalent Schedule is appended at the latest time that it can be without allowing unnecessary time between instructions or allowing instructions with common qubits to overlap.

  This method should improves the outcome fidelity over ASAP scheduling, because we may maximize the time that the qubit remains in the ground state.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")) – The quantum circuit to translate.
  *   **schedule\_config** ([*ScheduleConfig*](#qiskit.scheduler.ScheduleConfig ""qiskit.scheduler.config.ScheduleConfig"")) – Backend specific parameters used for building the Schedule.
  *   **backend** ([*BackendV1*](qiskit.providers.BackendV1 ""qiskit.providers.backend.BackendV1"")  *|*[*BackendV2*](qiskit.providers.BackendV2 ""qiskit.providers.backend.BackendV2"") *| None*) – A backend used to build the Schedule, the backend could be BackendV1 or BackendV2.

  **Returns**

  A schedule corresponding to the input `circuit` with pulses occurring as late as possible.

  **Return type**

  [*Schedule*](qiskit.pulse.Schedule ""qiskit.pulse.schedule.Schedule"")
</Function>Document 3:::
with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()
```

![../\_images/pulse-4.png](/images/api/qiskit/1.0/pulse-4.png)

#### acquire

<Function id=""qiskit.pulse.builder.acquire"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/pulse/builder.py#L1537-L1587"" signature=""qiskit.pulse.builder.acquire(duration, qubit_or_channel, register, **metadata)"">
  Acquire for a `duration` on a `channel` and store the result in a `register`.

  Examples:

  ```python
  from qiskit import pulse

  acq0 = pulse.AcquireChannel(0)
  mem0 = pulse.MemorySlot(0)

  with pulse.build() as pulse_prog:
      pulse.acquire(100, acq0, mem0)

      # measurement metadata
      kernel = pulse.configuration.Kernel('linear_discriminator')
      pulse.acquire(100, acq0, mem0, kernel=kernel)
  ```

  <Admonition title=""Note"" type=""note"">
    The type of data acquire will depend on the execution `meas_level`.
  </Admonition>

  **Parameters**

  *   **duration** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Duration to acquire data for
  *   **qubit\_or\_channel** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| chans.AcquireChannel*) – Either the qubit to acquire data for or the specific [`AcquireChannel`](qiskit.pulse.channels.AcquireChannel ""qiskit.pulse.channels.AcquireChannel"") to acquire on.
  *   **register** (*StorageLocation*) – Location to store measured result.
  *   **metadata** (*Unpack\[\_MetaDataType]*) – Additional metadata for measurement. See [`Acquire`](qiskit.pulse.instructions.Acquire ""qiskit.pulse.instructions.Acquire"") for more information.

  **Raises**

  [**exceptions.PulseError**](#qiskit.pulse.PulseError ""qiskit.pulse.exceptions.PulseError"") – If the register type is not supported.
</Function>

#### barrier

<Function id=""qiskit.pulse.builder.barrier"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/pulse/builder.py#L1923-L1992"" signature=""qiskit.pulse.builder.barrier(*channels_or_qubits, name=None)"">
  Barrier directive for a set of channels and qubits.

  This directive prevents the compiler from moving instructions across the barrier. Consider the case where we want to enforce that one pulse happens after another on separate channels, this can be done with:

  ```python
  from qiskit import pulse
  from qiskit.providers.fake_provider import FakeOpenPulse2Q

  backend = FakeOpenPulse2Q()

  d0 = pulse.DriveChannel(0)
  d1 = pulse.DriveChannel(1)

  with pulse.build(backend) as barrier_pulse_prog:
      pulse.play(pulse.Constant(10, 1.0), d0)
      pulse.barrier(d0, d1)
      pulse.play(pulse.Constant(10, 1.0), d1)
  ```

  Of course this could have been accomplished with:

  ```python
  from qiskit.pulse import transforms

  with pulse.build(backend) as aligned_pulse_prog:
      with pulse.align_sequential():
          pulse.play(pulse.Constant(10, 1.0), d0)
          pulse.play(pulse.Constant(10, 1.0), d1)

  barrier_pulse_prog = transforms.target_qobj_transform(barrier_pulse_prog)
  aligned_pulse_prog = transforms.target_qobj_transform(aligned_pulse_prog)

  assert barrier_pulse_prog == aligned_pulse_prog
  ```

  The barrier allows the pulse compiler to take care of more advanced scheduling alignment operations across channels. For example in the case where we are calling an outside circuit or schedule and want to align a pulse at the end of one call:

  ```python
  import math

  d0 = pulse.DriveChannel(0)

  with pulse.build(backend) as pulse_prog:
      with pulse.align_right():
          pulse.call(backend.defaults.instruction_schedule_map.get('x', (1,)))
          # Barrier qubit 1 and d0.
          pulse.barrier(1, d0)
          # Due to barrier this will play before the gate on qubit 1.
          pulse.play(pulse.Constant(10, 1.0), d0)
          # This will end at the same time as the pulse above due to
          # the barrier.
          pulse.call(backend.defaults.instruction_schedule_map.get('x', (1,)))
  ```

  <Admonition title=""Note"" type=""note"">
    Requires the active builder context to have a backend set if qubits are barriered on.
  </Admonition>

  **Parameters**

  *   **channels\_or\_qubits** (*chans.Channel |* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Channels or qubits to barrier.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Name for the barrier
</Function>

#### callDocument 4:::
pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()
```

![../\_images/pulse-1.png](/images/api/qiskit/1.0/pulse-1.png)

To begin pulse programming we must first initialize our program builder context with [`build()`](#qiskit.pulse.builder.build ""qiskit.pulse.builder.build""), after which we can begin adding program statements. For example, below we write a simple program that [`play()`](#qiskit.pulse.builder.play ""qiskit.pulse.builder.play"")s a pulse:

```python
from qiskit import pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()
```

![../\_images/pulse-2.png](/images/api/qiskit/1.0/pulse-2.png)

The builder initializes a [`pulse.Schedule`](qiskit.pulse.Schedule ""qiskit.pulse.Schedule""), `pulse_prog` and then begins to construct the program within the context. The output pulse schedule will survive after the context is exited and can be transpiled and executed like a normal Qiskit schedule using `backend.run(transpile(pulse_prog, backend))`.

Pulse programming has a simple imperative style. This leaves the programmer to worry about the raw experimental physics of pulse programming and not constructing cumbersome data structures.

We can optionally pass a [`Backend`](qiskit.providers.Backend ""qiskit.providers.Backend"") to [`build()`](#qiskit.pulse.builder.build ""qiskit.pulse.builder.build"") to enable enhanced functionality. Below, we prepare a Bell state by automatically compiling the required pulses from their gate-level representations, while simultaneously applying a long decoupling pulse to a neighboring qubit. We terminate the experiment with a measurement to observe the state we prepared. This program which mixes circuits and pulses will be automatically lowered to be run as a pulse program:

```python
from math import pi
from qiskit.compiler import schedule
from qiskit.circuit import QuantumCircuit

from qiskit import pulse
from qiskit.providers.fake_provider import GenericBackendV2

backend = GenericBackendV2(num_qubits=5, calibrate_instructions=True)

d2 = pulse.DriveChannel(2)

qc = QuantumCircuit(2)
# Hadamard
qc.rz(pi/2, 0)
qc.sx(0)
qc.rz(pi/2, 0)

qc.cx(0, 1)

bell_sched = schedule(qc, backend)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_sched)
        pulse.play(pulse.Constant(bell_sched.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()
```

![../\_images/pulse-3.png](/images/api/qiskit/1.0/pulse-3.png)

With the pulse builder we are able to blend programming on qubits and channels. While the pulse schedule is based on instructions that operate on channels, the pulse builder automatically handles the mapping from qubits to channels for you.

In the example below we demonstrate some more features of the pulse builder:

```python
import math
from qiskit.compiler import schedule

from qiskit import pulse, QuantumCircuit
from qiskit.pulse import library
from qiskit.providers.fake_provider import FakeOpenPulse2Q

backend = FakeOpenPulse2Q()

qc = QuantumCircuit(2, 2)
qc.cx(0, 1)

with pulse.build(backend) as pulse_prog:
    # Create a pulse.
    gaussian_pulse = library.gaussian(10, 1.0, 2)
    # Get the qubit's corresponding drive channel from the backend.
    d0 = pulse.drive_channel(0)
    d1 = pulse.drive_channel(1)
    # Play a pulse at t=0.
    pulse.play(gaussian_pulse, d0)
    # Play another pulse directly after the previous pulse at t=10.
    pulse.play(gaussian_pulse, d0)
    # The default scheduling behavior is to schedule pulses in parallel
    # across channels. For example, the statement below
    # plays the same pulse on a different channel at t=0.
    pulse.play(gaussian_pulse, d1)

    # We also provide pulse scheduling alignment contexts.
    # The default alignment context is align_left.

    # The sequential context schedules pulse instructions sequentially in time.
    # This context starts at t=10 due to earlier pulses above.
    with pulse.align_sequential():
        pulse.play(gaussian_pulse, d0)
        # Play another pulse after at t=20.
        pulse.play(gaussian_pulse, d1)

        # We can also nest contexts as each instruction is
        # contained in its local scheduling context.
        # The output of a child context is a context-schedule
        # with the internal instructions timing fixed relative to
        # one another. This is schedule is then called in the parent context.

        # Context starts at t=30.
        with pulse.align_left():
            # Start at t=30.
            pulse.play(gaussian_pulse, d0)
            # Start at t=30.
            pulse.play(gaussian_pulse, d1)
        # Context ends at t=40.

        # Alignment context where all pulse instructions are
        # aligned to the right, ie., as late as possible.
        with pulse.align_right():
            # Shift the phase of a pulse channel.
            pulse.shift_phase(math.pi, d1)
            # Starts at t=40.
            pulse.delay(100, d0)
            # Ends at t=140.

            # Starts at t=130.""""""
# Generate Code here:
"
"# Prompt:

""import math

# Imports from Qiskit
from qiskit import QuantumCircuit
from qiskit.circuit.library import MCMT, ZGate

def grover_oracle(marked_states):
Build a Grover oracle for multiple marked states

Here we assume all input marked states have the same number of bits

Parameters:
marked_states (str or list): Marked states of oracle

Returns:
QuantumCircuit: Quantum circuit representing Grover oracle
""


# Context:
""""""Document 0:::
**Returns**

  the circuit representing the input dag.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.dagcircuit import DAGCircuit
  from qiskit.converters import circuit_to_dag
  from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
  from qiskit.converters import dag_to_circuit

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  dag = circuit_to_dag(circ)
  circuit = dag_to_circuit(dag)
  circuit.draw('mpl')
  ```

  ![../\_images/converters-1.png](/images/api/qiskit/1.0/converters-1.png)
</Function>

### circuit\_to\_instruction

<Function id=""qiskit.converters.circuit_to_instruction"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_instruction.py#L21-L145"" signature=""qiskit.converters.circuit_to_instruction(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build an [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the instruction. If None, existing circuit parameters will also parameterize the instruction.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted instruction will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional instruction label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if parameter\_map is not compatible with circuit

  **Returns**

  an instruction equivalent to the action of the input circuit. Upon decomposition, this instruction will yield the components comprising the original circuit.

  **Return type**

  [qiskit.circuit.Instruction](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.converters import circuit_to_instruction

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  circuit_to_instruction(circ)
  ```
</Function>

### circuit\_to\_gate

<Function id=""qiskit.converters.circuit_to_gate"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_gate.py#L30-L109"" signature=""qiskit.converters.circuit_to_gate(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The gate is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The gate will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the gate. If None, existing circuit parameters will also parameterize the Gate.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted gate will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional gate label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if circuit is non-unitary or if parameter\_map is not compatible with circuit

  **Returns**

  a Gate equivalent to the action of the input circuit. Upon decomposition, this gate will yield the components comprising the original circuit.

  **Return type**

  [Gate](qiskit.circuit.Gate ""qiskit.circuit.Gate"")Document 1:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 2:::
q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.GroverOperator.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.GroverOperator.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ### reflection\_qubits

  <Attribute id=""qiskit.circuit.library.GroverOperator.reflection_qubits"">
    Reflection qubits, on which S0 is applied (if S0 is not user-specified).
  </Attribute>

  ### state\_preparation

  <Attribute id=""qiskit.circuit.library.GroverOperator.state_preparation"">
    The subcircuit implementing the A operator or Hadamards.
  </Attribute>

  ### zero\_reflection

  <Attribute id=""qiskit.circuit.library.GroverOperator.zero_reflection"">
    The subcircuit implementing the reflection about 0.
  </Attribute>
</Class>Document 3:::
---
title: GroverOperator
description: API reference for qiskit.circuit.library.GroverOperator
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.GroverOperator
---

# GroverOperator

<Class id=""qiskit.circuit.library.GroverOperator"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/grover_operator.py#L25-L285"" signature=""qiskit.circuit.library.GroverOperator(oracle, state_preparation=None, zero_reflection=None, reflection_qubits=None, insert_barriers=False, mcx_mode='noancilla', name='Q')"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  The Grover operator.

  Grover’s search algorithm \[1, 2] consists of repeated applications of the so-called Grover operator used to amplify the amplitudes of the desired output states. This operator, $\mathcal{Q}$, consists of the phase oracle, $\mathcal{S}_f$, zero phase-shift or zero reflection, $\mathcal{S}_0$, and an input state preparation $\mathcal{A}$:

$$
\mathcal{Q} = \mathcal{A} \mathcal{S}_0 \mathcal{A}^\dagger \mathcal{S}_f


$$

  In the standard Grover search we have $\mathcal{A} = H^{\otimes n}$:

$$
\mathcal{Q} = H^{\otimes n} \mathcal{S}_0 H^{\otimes n} \mathcal{S}_f
= D \mathcal{S_f}


$$

  The operation $D = H^{\otimes n} \mathcal{S}_0 H^{\otimes n}$ is also referred to as diffusion operator. In this formulation we can see that Grover’s operator consists of two steps: first, the phase oracle multiplies the good states by -1 (with $\mathcal{S}_f$) and then the whole state is reflected around the mean (with $D$).

  This class allows setting a different state preparation, as in quantum amplitude amplification (a generalization of Grover’s algorithm), $\mathcal{A}$ might not be a layer of Hardamard gates \[3].

  The action of the phase oracle $\mathcal{S}_f$ is defined as

$$
\mathcal{S}_f: |x\rangle \mapsto (-1)^{f(x)}|x\rangle


$$

  where $f(x) = 1$ if $x$ is a good state and 0 otherwise. To highlight the fact that this oracle flips the phase of the good states and does not flip the state of a result qubit, we call $\mathcal{S}_f$ a phase oracle.

  Note that you can easily construct a phase oracle from a bitflip oracle by sandwiching the controlled X gate on the result qubit by a X and H gate. For instance

  ```python
  Bitflip oracle     Phaseflip oracle
  q_0: ──■──         q_0: ────────────■────────────
       ┌─┴─┐              ┌───┐┌───┐┌─┴─┐┌───┐┌───┐
  out: ┤ X ├         out: ┤ X ├┤ H ├┤ X ├┤ H ├┤ X ├
       └───┘              └───┘└───┘└───┘└───┘└───┘
  ```

  There is some flexibility in defining the oracle and $\mathcal{A}$ operator. Before the Grover operator is applied in Grover’s algorithm, the qubits are first prepared with one application of the $\mathcal{A}$ operator (or Hadamard gates in the standard formulation). Thus, we always have operation of the form $\mathcal{A} \mathcal{S}_f \mathcal{A}^\dagger$. Therefore it is possible to move bitflip logic into $\mathcal{A}$ and leaving the oracle only to do phaseflips via Z gates based on the bitflips. One possible use-case for this are oracles that do not uncompute the state qubits.

  The zero reflection $\mathcal{S}_0$ is usually defined as

$$
\mathcal{S}_0 = 2 |0\rangle^{\otimes n} \langle 0|^{\otimes n} - \mathbb{I}_n


$$

  where $\mathbb{I}_n$ is the identity on $n$ qubits. By default, this class implements the negative version $2 |0\rangle^{\otimes n} \langle 0|^{\otimes n} - \mathbb{I}_n$, since this can simply be implemented with a multi-controlled Z sandwiched by X gates on the target qubit and the introduced global phase does not matter for Grover’s algorithm.

  **Examples**

  ```python
  >>> from qiskit.circuit import QuantumCircuit
  >>> from qiskit.circuit.library import GroverOperator
  >>> oracle = QuantumCircuit(2)
  >>> oracle.z(0)  # good state = first qubit is |1>
  >>> grover_op = GroverOperator(oracle, insert_barriers=True)
  >>> grover_op.decompose().draw()
           ┌───┐ ░ ┌───┐ ░ ┌───┐          ┌───┐      ░ ┌───┐
  state_0: ┤ Z ├─░─┤ H ├─░─┤ X ├───────■──┤ X ├──────░─┤ H ├
           └───┘ ░ ├───┤ ░ ├───┤┌───┐┌─┴─┐├───┤┌───┐ ░ ├───┤
  state_1: ──────░─┤ H ├─░─┤ X ├┤ H ├┤ X ├┤ H ├┤ X ├─░─┤ H ├
                 ░ └───┘ ░ └───┘└───┘└───┘└───┘└───┘ ░ └───┘
  ```

  ```python
  >>> oracle = QuantumCircuit(1)
  >>> oracle.z(0)  # the qubit state |1> is the good state
  >>> state_preparation = QuantumCircuit(1)
  >>> state_preparation.ry(0.2, 0)  # non-uniform state preparation
  >>> grover_op = GroverOperator(oracle, state_preparation)
  >>> grover_op.decompose().draw()
           ┌───┐┌──────────┐┌───┐┌───┐┌───┐┌─────────┐
  state_0: ┤ Z ├┤ RY(-0.2) ├┤ X ├┤ Z ├┤ X ├┤ RY(0.2) ├
           └───┘└──────────┘└───┘└───┘└───┘└─────────┘
  ```

  ```python
  >>> oracle = QuantumCircuit(4)
  >>> oracle.z(3)
  >>> reflection_qubits = [0, 3]
  >>> state_preparation = QuantumCircuit(4)
  >>> state_preparation.cry(0.1, 0, 3)
  >>> state_preparation.ry(0.5, 3)
  >>> grover_op = GroverOperator(oracle, state_preparation,
  ... reflection_qubits=reflection_qubits)Document 4:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### r""""""
# Generate Code here:
"
"# Prompt:

""“””Append three qc’s to the larger_qc using the to_instruction method.
 The first should use parameter theta on qubits 0 to 2, the second 
parameter phi on 3 to 5 and the last parameter gamma on qubits 6 to 8.
 Then decompose and draw the final circuit.

p = Parameter('p')
qc = QuantumCircuit(3, name='oracle')
qc.rz(p, 0)
qc.cx(0, 1)
qc.rz(p, 1)
qc.cx(1, 2)
qc.rz(p, 2)

theta = Parameter('theta')
phi = Parameter('phi')
gamma = Parameter('gamma')

qr = QuantumRegister(9)
larger_qc = QuantumCircuit(qr)""


# Context:
""""""Document 0:::
qreg = QuantumRegister(3)
    creg = ClassicalRegister(3)
    qc = QuantumCircuit(qreg, creg)
    qc.h([0, 1, 2])
    qc.measure([0, 1, 2], [0, 1, 2])

    with qc.switch(creg) as case:
        with case(0):
            qc.x(0)
        with case(1, 2):
            qc.z(1)
        with case(case.DEFAULT):
            qc.cx(0, 1)
    ```

    **Parameters**

    *   **target** (*Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]*) – The classical value to switch one. This must be integer-like.
    *   **cases** (*Iterable\[Tuple\[*[*Any*](https://docs.python.org/3/library/typing.html#typing.Any ""(in Python v3.12)"")*,* [*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]]*) – A sequence of case specifiers. Each tuple defines one case body (the second item). The first item of the tuple can be either a single integer value, the special value [`CASE_DEFAULT`](circuit#qiskit.circuit.CASE_DEFAULT ""qiskit.circuit.CASE_DEFAULT""), or a tuple of several integer values. Each of the integer values will be tried in turn; control will then pass to the body corresponding to the first match. [`CASE_DEFAULT`](circuit#qiskit.circuit.CASE_DEFAULT ""qiskit.circuit.CASE_DEFAULT"") matches all possible values. Omit in context-manager form.
    *   **qubits** (*Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]*) – The circuit qubits over which all case bodies execute. Omit in context-manager form.
    *   **clbits** (*Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]*) – The circuit clbits over which all case bodies execute. Omit in context-manager form.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will return an object that can be repeatedly entered to produce cases for the switch statement. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or SwitchCaseContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### sx

  <Function id=""qiskit.circuit.QuantumCircuit.sx"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3500-L3513"" signature=""sx(qubit)"">
    Apply [`SXGate`](qiskit.circuit.library.SXGate ""qiskit.circuit.library.SXGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### sxdg

  <Function id=""qiskit.circuit.QuantumCircuit.sxdg"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3515-L3528"" signature=""sxdg(qubit)"">
    Apply [`SXdgGate`](qiskit.circuit.library.SXdgGate ""qiskit.circuit.library.SXdgGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.Document 1:::
qr = QuantumRegister(2)
    cr = ClassicalRegister(2)
    qc = QuantumCircuit(qr, cr)
    qc.h(range(2))
    qc.measure(range(2), range(2))

    # apply x gate if the classical register has the value 2 (10 in binary)
    qc.x(0).c_if(cr, 2)

    # apply y gate if bit 0 is set to 1
    qc.y(1).c_if(0, 1)

    qc.draw('mpl')
    ```

    ![../\_images/qiskit-circuit-InstructionSet-1.png](/images/api/qiskit/1.0/qiskit-circuit-InstructionSet-1.png)
  </Function>

  ### inverse

  <Function id=""qiskit.circuit.InstructionSet.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/instructionset.py#L89-L102"" signature=""inverse(annotated=False)"">
    Invert all instructions.
  </Function>
</Class>Document 2:::
ParameterView([Parameter(a), Parameter(b), Parameter(elephant)])
    ```

    Bear in mind that alphabetical sorting might be unintuitive when it comes to numbers. The literal “10” comes before “2” in strict alphabetical sorting.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter
    >>> angles = [Parameter(""angle_1""), Parameter(""angle_2""), Parameter(""angle_10"")]
    >>> circuit = QuantumCircuit(1)
    >>> circuit.u(*angles, 0)
    >>> circuit.draw()
       ┌─────────────────────────────┐
    q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.QuantumCircuit.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.QuantumCircuit.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### add\_bits

  <Function id=""qiskit.circuit.QuantumCircuit.add_bits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1512-L1533"" signature=""add_bits(bits)"">
    Add Bits to the circuit.
  </Function>

  ### add\_calibration

  <Function id=""qiskit.circuit.QuantumCircuit.add_calibration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4806-L4854"" signature=""add_calibration(gate, qubits, schedule, params=None)"">
    Register a low-level, custom pulse definition for the given gate.

    **Parameters**

    *   **gate** (*Union\[*[*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – Gate information.
    *   **qubits** (*Union\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*, Tuple\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]]*) – List of qubits to be measured.
    *   **schedule** ([*Schedule*](qiskit.pulse.Schedule ""qiskit.pulse.Schedule"")) – Schedule information.
    *   **params** (*Optional\[List\[Union\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*,* [*Parameter*](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"")*]]]*) – A list of parameters.

    **Raises**

    [**Exception**](https://docs.python.org/3/library/exceptions.html#Exception ""(in Python v3.12)"") – if the gate is of type string and params is None.
  </Function>

  ### add\_register

  <Function id=""qiskit.circuit.QuantumCircuit.add_register"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1441-L1510"" signature=""add_register(*regs)"">
    Add registers.
  </Function>

  ### append

  <Function id=""qiskit.circuit.QuantumCircuit.append"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1204-L1285"" signature=""append(instruction, qargs=None, cargs=None)"">
    Append one or more instructions to the end of the circuit, modifying the circuit in place.

    The `qargs` and `cargs` will be expanded and broadcast according to the rules of the given [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction""), and any non-[`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"") specifiers (such as integer indices) will be resolved into the relevant instances.

    If a [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"") is given, it will be unwrapped, verified in the context of this circuit, and a new object will be appended to the circuit. In this case, you may not pass `qargs` or `cargs` separately.

    **Parameters**

    *   **instruction** ([*Operation*](qiskit.circuit.Operation ""qiskit.circuit.Operation"")  *|*[*CircuitInstruction*](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")) – [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") instance to append, or a [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"") with all its context.Document 3:::
\frac{9}{16} 4^n - \frac{3}{2} 2^n
$$

  If `opt_a1 = True`, the default, the CX count is reduced by:

$$
\frac{1}{3} 4^{n - 2} - 1.
$$

  If `opt_a2 = True`, the default, the CX count is reduced by:

$$
4^{n-2} - 1.
$$

  **Parameters**

  *   **mat** (*np.ndarray*) – unitary matrix to decompose
  *   **opt\_a1** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – whether to try optimization A.1 from Shende et al. \[1]. This should eliminate 1 `cx` per call. If `True`, [`CZGate`](qiskit.circuit.library.CZGate ""qiskit.circuit.library.CZGate"")s are left in the output. If desired these can be further decomposed to [`CXGate`](qiskit.circuit.library.CXGate ""qiskit.circuit.library.CXGate"")s.
  *   **opt\_a2** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – whether to try optimization A.2 from Shende et al. \[1]. This decomposes two qubit unitaries into a diagonal gate and a two cx unitary and reduces overall cx count by $4^{n-2} - 1$.
  *   **decomposer\_1q** (*Callable\[\[np.ndarray],* [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*] | None*) – optional 1Q decomposer. If None, uses [`OneQubitEulerDecomposer`](qiskit.synthesis.OneQubitEulerDecomposer ""qiskit.synthesis.OneQubitEulerDecomposer"").
  *   **decomposer\_2q** (*Callable\[\[np.ndarray],* [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*] | None*) – optional 2Q decomposer. If None, uses [`TwoQubitBasisDecomposer`](qiskit.synthesis.TwoQubitBasisDecomposer ""qiskit.synthesis.TwoQubitBasisDecomposer"").

  **Returns**

  Decomposed quantum circuit.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **References**

  1.  Shende, Bullock, Markov, *Synthesis of Quantum Logic Circuits*, [arXiv:0406176 \[quant-ph\]](https://arxiv.org/abs/quant-ph/0406176)
</Function>

The Approximate Quantum Compiler is available here:

|                                                                                                                                   |                                                             |
| --------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| [`qiskit.synthesis.unitary.aqc`](qiskit.synthesis.unitary.aqc#module-qiskit.synthesis.unitary.aqc ""qiskit.synthesis.unitary.aqc"") | Approximate Quantum Compiler (qiskit.synthesis.unitary.aqc) |

## One-Qubit Synthesis

|                                                                                                                                      |                                                                       |
| ------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------- |
| [`OneQubitEulerDecomposer`](qiskit.synthesis.OneQubitEulerDecomposer ""qiskit.synthesis.OneQubitEulerDecomposer"")(\[basis, use\_dag]) | A class for decomposing 1-qubit unitaries into Euler angle rotations. |

## Two-Qubit Synthesis

|                                                                                                                                             |                                                                                                                                                                                     |
| ------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`TwoQubitBasisDecomposer`](qiskit.synthesis.TwoQubitBasisDecomposer ""qiskit.synthesis.TwoQubitBasisDecomposer"")(gate\[, ...])              | A class for decomposing 2-qubit unitaries into minimal number of uses of a 2-qubit basis gate.                                                                                      |Document 4:::
---
title: OneQubitEulerDecomposer
description: API reference for qiskit.synthesis.OneQubitEulerDecomposer
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.synthesis.OneQubitEulerDecomposer
---

# OneQubitEulerDecomposer

<Class id=""qiskit.synthesis.OneQubitEulerDecomposer"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/one_qubit/one_qubit_decompose.py#L72-L287"" signature=""qiskit.synthesis.OneQubitEulerDecomposer(basis='U3', use_dag=False)"" modifiers=""class"">
  Bases: [`object`](https://docs.python.org/3/library/functions.html#object ""(in Python v3.12)"")

  A class for decomposing 1-qubit unitaries into Euler angle rotations.

  The resulting decomposition is parameterized by 3 Euler rotation angle parameters $(\theta, \phi, \lambda)$, and a phase parameter $\gamma$. The value of the parameters for an input unitary depends on the decomposition basis. Allowed bases and the resulting circuits are shown in the following table. Note that for the non-Euler bases ($U3$, $U1X$, $RR$), the $ZYZ$ Euler parameters are used.

  | Basis  | Euler Angle Basis              | Decomposition Circuit                                                                                                    |
  | ------ | ------------------------------ | ------------------------------------------------------------------------------------------------------------------------ |
  | ‘ZYZ’  | $Z(\phi) Y(\theta) Z(\lambda)$ | $e^{i\gamma} R_Z(\phi).R_Y(\theta).R_Z(\lambda)$                                                                         |
  | ‘ZXZ’  | $Z(\phi) X(\theta) Z(\lambda)$ | $e^{i\gamma} R_Z(\phi).R_X(\theta).R_Z(\lambda)$                                                                         |
  | ‘XYX’  | $X(\phi) Y(\theta) X(\lambda)$ | $e^{i\gamma} R_X(\phi).R_Y(\theta).R_X(\lambda)$                                                                         |
  | ‘XZX’  | $X(\phi) Z(\theta) X(\lambda)$ | $e^{i\gamma} R_X(\phi).R_Z(\theta).R_X(\lambda)$                                                                         |
  | ‘U3’   | $Z(\phi) Y(\theta) Z(\lambda)$ | $e^{i\gamma} U_3(\theta,\phi,\lambda)$                                                                                   |
  | ‘U321’ | $Z(\phi) Y(\theta) Z(\lambda)$ | $e^{i\gamma} U_3(\theta,\phi,\lambda)$                                                                                   |
  | ‘U’    | $Z(\phi) Y(\theta) Z(\lambda)$ | $e^{i\gamma} U_3(\theta,\phi,\lambda)$                                                                                   |
  | ‘PSX’  | $Z(\phi) Y(\theta) Z(\lambda)$ | $e^{i\gamma} U_1(\phi+\pi).R_X\left(\frac{\pi}{2}\right).$ $U_1(\theta+\pi).R_X\left(\frac{\pi}{2}\right).U_1(\lambda)$  |
  | ‘ZSX’  | $Z(\phi) Y(\theta) Z(\lambda)$ | $e^{i\gamma} R_Z(\phi+\pi).\sqrt{X}.$ $R_Z(\theta+\pi).\sqrt{X}.R_Z(\lambda)$                                            |
  | ‘ZSXX’ | $Z(\phi) Y(\theta) Z(\lambda)$ | $e^{i\gamma} R_Z(\phi+\pi).\sqrt{X}.R_Z(\theta+\pi).\sqrt{X}.R_Z(\lambda)$ or $e^{i\gamma} R_Z(\phi+\pi).X.R_Z(\lambda)$ |
  | ‘U1X’  | $Z(\phi) Y(\theta) Z(\lambda)$ | $e^{i\gamma} U_1(\phi+\pi).R_X\left(\frac{\pi}{2}\right).$ $U_1(\theta+\pi).R_X\left(\frac{\pi}{2}\right).U_1(\lambda)$  |
  | ‘RR’   | $Z(\phi) Y(\theta) Z(\lambda)$ | $e^{i\gamma} R\left(-\pi,\frac{\phi-\lambda+\pi}{2}\right).$ $R\left(\theta+\pi,\frac{\pi}{2}-\lambda\right)$            |

  ### \_\_call\_\_

  <Function id=""qiskit.synthesis.OneQubitEulerDecomposer.__call__"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/one_qubit/one_qubit_decompose.py#L184-L221"" signature=""__call__(unitary, simplify=True, atol=1e-12)"">
    Decompose single qubit gate into a circuit.

    **Parameters**

    *   **unitary** ([*Operator*](qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"")  *|*[*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| np.ndarray*) – 1-qubit unitary matrix
    *   **simplify** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – reduce gate count in decomposition \[Default: True].
    *   **atol** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – absolute tolerance for checking angles when simplifying returned circuit \[Default: 1e-12].

    **Returns**

    the decomposed single-qubit gate circuit

    **Return type**

    [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Raises**""""""
# Generate Code here:
"
"# Prompt:

""import scipy as sc

def exact(final_time, timestep, hamiltonian, initial_state):
Get the exact values for energy and the observable in the p-VQD
 algorithm.
Returns:
Times, energ, magn
Times: list of timepoints at which energy/obs are evaluated
Energ, magn: list of energies and magnetizations evaluated at
 timesteps timestep

O = observable.to_matrix()
H = hamiltonian.to_matrix()""


# Context:
""""""Document 0:::
> | 0           | avg          | np.ndarray\[memory\_slots, memory\_slot\_size]        |
    > | 1           | single       | np.ndarray\[shots, memory\_slots]                     |
    > | 1           | avg          | np.ndarray\[memory\_slots]                            |
    > | 2           | memory=True  | list                                                  |

    **Return type**

    List\[[str](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")] or np.ndarray

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if there is no memory data for the circuit.
  </Function>

  ### get\_statevector

  <Function id=""qiskit.result.Result.get_statevector"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/result/result.py#L297-L317"" signature=""get_statevector(experiment=None, decimals=None)"">
    Get the final statevector of an experiment.

    **Parameters**

    *   **experiment** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *or*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")  *or*[*Schedule*](qiskit.pulse.Schedule ""qiskit.pulse.Schedule"")  *or*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *or None*) – the index of the experiment, as specified by `data()`.
    *   **decimals** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – the number of decimals in the statevector. If None, does not round.

    **Returns**

    list of 2^num\_qubits complex amplitudes.

    **Return type**

    [list](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")\[[complex](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")]

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if there is no statevector for the experiment.
  </Function>

  ### get\_unitary

  <Function id=""qiskit.result.Result.get_unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/result/result.py#L319-L338"" signature=""get_unitary(experiment=None, decimals=None)"">
    Get the final unitary of an experiment.

    **Parameters**

    *   **experiment** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *or*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")  *or*[*Schedule*](qiskit.pulse.Schedule ""qiskit.pulse.Schedule"")  *or*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *or None*) – the index of the experiment, as specified by `data()`.
    *   **decimals** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – the number of decimals in the unitary. If None, does not round.

    **Returns**

    **list of 2^num\_qubits x 2^num\_qubits complex**

    amplitudes.

    **Return type**

    [list](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")\[[list](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")\[[complex](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")]]

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if there is no unitary for the experiment.
  </Function>

  ### to\_dict

  <Function id=""qiskit.result.Result.to_dict"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/result/result.py#L93-L111"" signature=""to_dict()"">
    Return a dictionary format representation of the Result

    **Returns**

    The dictionary form of the Result

    **Return type**

    [dict](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")
  </Function>
</Class>Document 1:::
```

    for the state prepared by

    ```python
    circ = circuits[i]
    ```

    with bound parameters

    ```python
    values = parameter_values[i].
    ```

    **Parameters**

    *   **circuits** (*Sequence\[*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*] |* [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – one or more circuit objects.
    *   **observables** (*Sequence\[BaseOperator |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*] | BaseOperator |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – one or more observable objects. Several formats are allowed; importantly, `str` should follow the string representation format for [`Pauli`](qiskit.quantum_info.Pauli ""qiskit.quantum_info.Pauli"") objects.
    *   **parameter\_values** (*Sequence\[Sequence\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]] | Sequence\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*] |* [*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"") *| None*) – concrete parameters to be bound.
    *   **run\_options** – runtime options used for circuit execution.

    **Returns**

    The job object of EstimatorResult.

    **Raises**

    *   [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError ""(in Python v3.12)"") – Invalid argument type given.
    *   [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError ""(in Python v3.12)"") – Invalid argument values given.

    **Return type**

    T
  </Function>

  ### set\_options

  <Function id=""qiskit.primitives.BaseEstimatorV1.set_options"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/primitives/base/base_primitive.py#L39-L45"" signature=""set_options(**fields)"">
    Set options values for the estimator.

    **Parameters**

    **\*\*fields** – The fields to update the options
  </Function>
</Class>Document 2:::
```

    for the state prepared by

    ```python
    circ = circuits[i]
    ```

    with bound parameters

    ```python
    values = parameter_values[i].
    ```

    **Parameters**

    *   **circuits** (*Sequence\[*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*] |* [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – one or more circuit objects.
    *   **observables** (*Sequence\[BaseOperator |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*] | BaseOperator |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – one or more observable objects. Several formats are allowed; importantly, `str` should follow the string representation format for [`Pauli`](qiskit.quantum_info.Pauli ""qiskit.quantum_info.Pauli"") objects.
    *   **parameter\_values** (*Sequence\[Sequence\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]] | Sequence\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*] |* [*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"") *| None*) – concrete parameters to be bound.
    *   **run\_options** – runtime options used for circuit execution.

    **Returns**

    The job object of EstimatorResult.

    **Raises**

    *   [**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError ""(in Python v3.12)"") – Invalid argument type given.
    *   [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError ""(in Python v3.12)"") – Invalid argument values given.

    **Return type**

    T
  </Function>

  ### set\_options

  <Function id=""qiskit.primitives.BackendEstimator.set_options"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/primitives/base/base_primitive.py#L39-L45"" signature=""set_options(**fields)"">
    Set options values for the estimator.

    **Parameters**

    **\*\*fields** – The fields to update the options
  </Function>

  ### set\_transpile\_options

  <Function id=""qiskit.primitives.BackendEstimator.set_transpile_options"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/primitives/backend_estimator.py#L152-L158"" signature=""set_transpile_options(**fields)"">
    Set the transpiler options for transpiler. :param \*\*fields: The fields to update the options
  </Function>
</Class>Document 3:::
## Expectation values

### sampled\_expectation\_value

<Function id=""qiskit.result.sampled_expectation_value"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/result/sampled_expval.py#L26-L75"" signature=""qiskit.result.sampled_expectation_value(dist, oper)"">
  Computes expectation value from a sampled distribution

  Note that passing a raw dict requires bit-string keys.

  **Parameters**

  *   **dist** ([*Counts*](qiskit.result.Counts ""qiskit.result.Counts"")  *or*[*QuasiDistribution*](qiskit.result.QuasiDistribution ""qiskit.result.QuasiDistribution"")  *or*[*ProbDistribution*](qiskit.result.ProbDistribution ""qiskit.result.ProbDistribution"")  *or*[*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – Input sampled distribution
  *   **oper** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *or*[*Pauli*](qiskit.quantum_info.Pauli ""qiskit.quantum_info.Pauli"")  *or PauliOp or PauliSumOp or*[*SparsePauliOp*](qiskit.quantum_info.SparsePauliOp ""qiskit.quantum_info.SparsePauliOp"")) – The operator for the observable

  **Returns**

  The expectation value

  **Return type**

  [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the input distribution or operator is an invalid type
</Function>

## Mitigation

|                                                                                                                                         |                                                 |
| --------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------- |
| [`BaseReadoutMitigator`](qiskit.result.BaseReadoutMitigator ""qiskit.result.BaseReadoutMitigator"")()                                     | Base readout error mitigator class.             |
| [`CorrelatedReadoutMitigator`](qiskit.result.CorrelatedReadoutMitigator ""qiskit.result.CorrelatedReadoutMitigator"")(assignment\_matrix) | N-qubit readout error mitigator.                |
| [`LocalReadoutMitigator`](qiskit.result.LocalReadoutMitigator ""qiskit.result.LocalReadoutMitigator"")(\[assignment\_matrices, ...])      | 1-qubit tensor product readout error mitigator. |Document 4:::
</Function>

  ### sample\_memory

  <Function id=""qiskit.quantum_info.DensityMatrix.sample_memory"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/quantum_state.py#L246-L275"" signature=""sample_memory(shots, qargs=None)"">
    Sample a list of qubit measurement outcomes in the computational basis.

    **Parameters**

    *   **shots** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – number of samples to generate.
    *   **qargs** (*None or* [*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")) – subsystems to sample measurements for, if None sample measurement of all subsystems (Default: None).

    **Returns**

    list of sampled counts if the order sampled.

    **Return type**

    np.array

    Additional Information:

    > This function *samples* measurement outcomes using the measure [`probabilities()`](#qiskit.quantum_info.DensityMatrix.probabilities ""qiskit.quantum_info.DensityMatrix.probabilities"") for the current state and qargs. It does not actually implement the measurement so the current state is not modified.
    >
    > The seed for random number generator used for sampling can be set to a fixed value by using the stats [`seed()`](#qiskit.quantum_info.DensityMatrix.seed ""qiskit.quantum_info.DensityMatrix.seed"") method.
  </Function>

  ### seed

  <Function id=""qiskit.quantum_info.DensityMatrix.seed"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/quantum_state.py#L78-L85"" signature=""seed(value=None)"">
    Set the seed for the quantum state RNG.
  </Function>

  ### tensor

  <Function id=""qiskit.quantum_info.DensityMatrix.tensor"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/densitymatrix.py#L230-L247"" signature=""tensor(other)"">
    Return the tensor product state self ⊗ other.

    **Parameters**

    **other** ([*DensityMatrix*](#qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")) – a quantum state object.

    **Returns**

    the tensor product operator self ⊗ other.

    **Return type**

    [DensityMatrix](#qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if other is not a quantum state.
  </Function>

  ### to\_dict

  <Function id=""qiskit.quantum_info.DensityMatrix.to_dict"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/densitymatrix.py#L631-L709"" signature=""to_dict(decimals=None)"">
    Convert the density matrix to dictionary form.

    This dictionary representation uses a Ket-like notation where the dictionary keys are qudit strings for the subsystem basis vectors. If any subsystem has a dimension greater than 10 comma delimiters are inserted between integers so that subsystems can be distinguished.

    **Parameters**

    **decimals** (*None or* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – the number of decimal places to round values. If None no rounding is done (Default: None).

    **Returns**

    the dictionary form of the DensityMatrix.

    **Return type**

    [dict](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")

    **Examples**

    The ket-form of a 2-qubit density matrix $rho = |-\rangle\!\langle -|\otimes |0\rangle\!\langle 0|$

    ```python
    from qiskit.quantum_info import DensityMatrix

    rho = DensityMatrix.from_label('-0')
    print(rho.to_dict())
    ```

    ```python
    {
        '00|00': (0.4999999999999999+0j),
        '10|00': (-0.4999999999999999-0j),
        '00|10': (-0.4999999999999999+0j),
        '10|10': (0.4999999999999999+0j)
    }
    ```

    For non-qubit subsystems the integer range can go from 0 to 9. For example in a qutrit system

    ```python
    import numpy as np
    from qiskit.quantum_info import DensityMatrix

    mat = np.zeros((9, 9))
    mat[0, 0] = 0.25
    mat[3, 3] = 0.25
    mat[6, 6] = 0.25
    mat[-1, -1] = 0.25
    rho = DensityMatrix(mat, dims=(3, 3))
    print(rho.to_dict())
    ```

    ```python
    {'00|00': (0.25+0j), '10|10': (0.25+0j), '20|20': (0.25+0j), '22|22': (0.25+0j)}
    ```

    For large subsystem dimensions delimiters are required. The following example is for a 20-dimensional system consisting of a qubit and 10-dimensional qudit.

    ```python
    import numpy as np
    from qiskit.quantum_info import DensityMatrix""""""
# Generate Code here:
"
"# Prompt:

""# Prompt: Complete the function that creates a basic quantum circuit
 with a Hadamard gate applied to qubit 0.
from qiskit import QuantumCircuit

def create_basic_circuit(n_qubits: int) -> QuantumCircuit:
 Creates a quantum circuit with the specified number of qubits and
 applies a Hadamard gate to the first qubit (qubit 0).
Parameters: n_qubits (int): Number of qubits in the circuit.
Returns: QuantumCircuit: The constructed quantum circuit. ""


# Context:
""""""Document 0:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 1:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### t

  <Function id=""qiskit.circuit.QuantumCircuit.t"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3560-L3573"" signature=""t(qubit)"">
    Apply [`TGate`](qiskit.circuit.library.TGate ""qiskit.circuit.library.TGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### tdg

  <Function id=""qiskit.circuit.QuantumCircuit.tdg"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3575-L3588"" signature=""tdg(qubit)"">
    Apply [`TdgGate`](qiskit.circuit.library.TdgGate ""qiskit.circuit.library.TdgGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### tensor

  <Function id=""qiskit.circuit.QuantumCircuit.tensor"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1023-L1111"" signature=""tensor(other, inplace=False)"">
    Tensor `self` with `other`.

    Remember that in the little-endian convention the leftmost operation will be at the bottom of the circuit. See also [the docs](/build/circuit-construction) for more information.

    ```python
         ┌────────┐        ┌─────┐          ┌─────┐
    q_0: ┤ bottom ├ ⊗ q_0: ┤ top ├  = q_0: ─┤ top ├──
         └────────┘        └─────┘         ┌┴─────┴─┐
                                      q_1: ┤ bottom ├
                                           └────────┘
    ```

    **Parameters**

    *   **other** ([*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – The other circuit to tensor this circuit with.
    *   **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, modify the object. Otherwise return composed circuit.

    **Return type**

    [*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"") | None

    **Examples**

    ```python
    from qiskit import QuantumCircuit
    top = QuantumCircuit(1)
    top.x(0);
    bottom = QuantumCircuit(2)
    bottom.cry(0.2, 0, 1);
    tensored = bottom.tensor(top)
    tensored.draw('mpl')
    ```

    ![../\_images/qiskit-circuit-QuantumCircuit-6.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-6.png)

    **Returns**

    The tensored circuit (returns None if inplace==True).

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### to\_gateDocument 2:::
</Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### x

  <Function id=""qiskit.circuit.QuantumCircuit.x"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3652-L3666"" signature=""x(qubit, label=None)"">
    Apply [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **qubit** (*QubitSpecifier*) – The qubit(s) to apply the gate to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### y

  <Function id=""qiskit.circuit.QuantumCircuit.y"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3821-L3834"" signature=""y(qubit)"">
    Apply [`YGate`](qiskit.circuit.library.YGate ""qiskit.circuit.library.YGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### z

  <Function id=""qiskit.circuit.QuantumCircuit.z"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3864-L3877"" signature=""z(qubit)"">
    Apply [`ZGate`](qiskit.circuit.library.ZGate ""qiskit.circuit.library.ZGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>
</Class>Document 3:::
*   **qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### ry

  <Function id=""qiskit.circuit.QuantumCircuit.ry"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3181-L3198"" signature=""ry(theta, qubit, label=None)"">
    Apply [`RYGate`](qiskit.circuit.library.RYGate ""qiskit.circuit.library.RYGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** (*ParameterValueType*) – The rotation angle of the gate.
    *   **qubit** (*QubitSpecifier*) – The qubit(s) to apply the gate to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### ryy

  <Function id=""qiskit.circuit.QuantumCircuit.ryy"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3230-L3247"" signature=""ryy(theta, qubit1, qubit2)"">
    Apply [`RYYGate`](qiskit.circuit.library.RYYGate ""qiskit.circuit.library.RYYGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** ([*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.parameterexpression.ParameterExpression"")  *|*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The rotation angle of the gate.
    *   **qubit1** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.
    *   **qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### rz

  <Function id=""qiskit.circuit.QuantumCircuit.rz"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3249-L3263"" signature=""rz(phi, qubit)"">
    Apply [`RZGate`](qiskit.circuit.library.RZGate ""qiskit.circuit.library.RZGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **phi** ([*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.parameterexpression.ParameterExpression"")  *|*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The rotation angle of the gate.Document 4:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit, ClassicalRegister
 Write a function that adds a classical register to the quantum circuit
 and measures all qubits. Parameters:
qc (QuantumCircuit): The quantum circuit to which measurement is to
 be added.
n_bits (int): Number of classical bits, should be equal to the number of
 qubits.
Returns: QuantumCircuit: The quantum circuit with measurement 
added. ""


# Context:
""""""Document 0:::
**Parameters**

    **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – All measurements inplace or return new circuit.

    **Returns**

    Returns circuit with measurements when inplace = False.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### measure\_all

  <Function id=""qiskit.circuit.QuantumCircuit.measure_all"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2296-L2339"" signature=""measure_all(inplace=True, add_bits=True)"">
    Adds measurement to all qubits.

    By default, adds new classical bits in a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") to store these measurements. If `add_bits=False`, the results of the measurements will instead be stored in the already existing classical bits, with qubit `n` being measured into classical bit `n`.

    Returns a new circuit with measurements if `inplace=False`.

    **Parameters**

    *   **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – All measurements inplace or return new circuit.
    *   **add\_bits** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to add new bits to store the results.

    **Returns**

    Returns circuit with measurements when `inplace=False`.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `add_bits=False` but there are not enough classical bits.
  </Function>

  ### ms

  <Function id=""qiskit.circuit.QuantumCircuit.ms"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2931-L2946"" signature=""ms(theta, qubits)"">
    Apply [`MSGate`](qiskit.circuit.library.MSGate ""qiskit.circuit.library.MSGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** ([*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.parameterexpression.ParameterExpression"")  *|*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The angle of the rotation.
    *   **qubits** ([*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]]*) – The qubits to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### num\_connected\_components

  <Function id=""qiskit.circuit.QuantumCircuit.num_connected_components"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1977-L2048"" signature=""num_connected_components(unitary_only=False)"">
    How many non-entangled subcircuits can the circuit be factored to.

    **Parameters**

    **unitary\_only** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Compute only unitary part of graph.

    **Returns**

    Number of connected components in circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### num\_nonlocal\_gates

  <Function id=""qiskit.circuit.QuantumCircuit.num_nonlocal_gates"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1953-L1964"" signature=""num_nonlocal_gates()"">
    Return number of non-local gates (i.e. involving 2+ qubits).

    Conditional nonlocal gates are also included.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### num\_tensor\_factorsDocument 1:::
```python
      from qiskit.circuit import QuantumCircuit, Qubit, Clbit
      bits = [Qubit(), Qubit(), Clbit()]
      qc = QuantumCircuit(bits)
      qc.h(0)
      qc.cx(0, 1)
      qc.measure(0, 0)
      with qc.if_test((bits[2], 0)) as else_:
          qc.h(0)
      with else_:
          qc.x(0)
      ```
    </Admonition>

    **Parameters**

    *   **condition** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*] |* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*,* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*] |* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*,* [*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")*]*) – A condition to be evaluated at circuit runtime which, if true, will trigger the evaluation of `true_body`. Can be specified as either a tuple of a `ClassicalRegister` to be tested for equality with a given `int`, or as a tuple of a `Clbit` to be compared to either a `bool` or an `int`.
    *   **true\_body** ([*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – The circuit body to be run if `condition` is true.
    *   **false\_body** ([*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – The circuit to be run if `condition` is false.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits over which the if/else should be run.
    *   **clbits** (*Sequence\[ClbitSpecifier]*) – The circuit clbits over which the if/else should be run.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the instruction in the circuit.

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the provided condition references Clbits outside the enclosing circuit.

    **Returns**

    A handle to the instruction created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### if\_test

  <Function id=""qiskit.circuit.QuantumCircuit.if_test"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4516-L4602"" signature=""if_test(condition: tuple[ClassicalRegister | Clbit, int], true_body: None, qubits: None, clbits: None, *, label: str | None) → IfContext"" extraSignatures={[""if_test(condition: tuple[ClassicalRegister | Clbit, int], true_body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None = None) → InstructionSet""]}>
    Create an `if` statement on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a [`IfElseOp`](qiskit.circuit.IfElseOp ""qiskit.circuit.IfElseOp"") with the given `true_body`, and there will be no branch for the `false` condition (see also the [`if_else()`](#qiskit.circuit.QuantumCircuit.if_else ""qiskit.circuit.QuantumCircuit.if_else"") method). However, if `true_body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which can be used to build `if` statements. The return value of the `with` statement is a chainable context manager, which can be used to create subsequent `else` blocks. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    For example:

    ```python
    from qiskit.circuit import QuantumCircuit, Qubit, Clbit
    bits = [Qubit(), Qubit(), Qubit(), Clbit(), Clbit()]
    qc = QuantumCircuit(bits)

    qc.h(0)
    qc.cx(0, 1)
    qc.measure(0, 0)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure(0, 1)

    with qc.if_test((bits[3], 0)) as else_:
        qc.x(2)
    with else_:
        qc.h(2)
        qc.z(2)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – A condition to be evaluated at circuit runtime which, if true, will trigger the evaluation of `true_body`. Can be specified as either a tuple of a `ClassicalRegister` to be tested for equality with a given `int`, or as a tuple of a `Clbit` to be compared to either a `bool` or an `int`.Document 2:::
**Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### measure

  <Function id=""qiskit.circuit.QuantumCircuit.measure"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2189-L2264"" signature=""measure(qubit, cbit)"">
    Measure a quantum bit (`qubit`) in the Z basis into a classical bit (`cbit`).

    When a quantum state is measured, a qubit is projected in the computational (Pauli Z) basis to either $\lvert 0 \rangle$ or $\lvert 1 \rangle$. The classical bit `cbit` indicates the result of that projection as a `0` or a `1` respectively. This operation is non-reversible.

    **Parameters**

    *   **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – qubit(s) to measure.
    *   **cbit** ([*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.classicalregister.Clbit"")  *|*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.classicalregister.ClassicalRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.classicalregister.Clbit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – classical bit(s) to place the measurement result(s) in.

    **Returns**

    handle to the added instructions.

    **Return type**

    [qiskit.circuit.InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if arguments have bad format.

    **Examples**

    In this example, a qubit is measured and the result of that measurement is stored in the classical bit (usually expressed in diagrams as a double line):

    ```python
    from qiskit import QuantumCircuit
    circuit = QuantumCircuit(1, 1)
    circuit.h(0)
    circuit.measure(0, 0)
    circuit.draw()
    ```

    ```python
         ┌───┐┌─┐
      q: ┤ H ├┤M├
         └───┘└╥┘
    c: 1/══════╩═
               0
    ```

    It is possible to call `measure` with lists of `qubits` and `cbits` as a shortcut for one-to-one measurement. These two forms produce identical results:

    ```python
    circuit = QuantumCircuit(2, 2)
    circuit.measure([0,1], [0,1])
    ```

    ```python
    circuit = QuantumCircuit(2, 2)
    circuit.measure(0, 0)
    circuit.measure(1, 1)
    ```

    Instead of lists, you can use [`QuantumRegister`](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"") and [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") under the same logic.

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    qreg = QuantumRegister(2, ""qreg"")
    creg = ClassicalRegister(2, ""creg"")
    circuit = QuantumCircuit(qreg, creg)
    circuit.measure(qreg, creg)
    ```

    This is equivalent to:

    ```python
    circuit = QuantumCircuit(qreg, creg)
    circuit.measure(qreg[0], creg[0])
    circuit.measure(qreg[1], creg[1])
    ```
  </Function>

  ### measure\_active

  <Function id=""qiskit.circuit.QuantumCircuit.measure_active"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2266-L2294"" signature=""measure_active(inplace=True)"">
    Adds measurement to all non-idle qubits. Creates a new ClassicalRegister with a size equal to the number of non-idle qubits being measured.

    Returns a new circuit with measurements if inplace=False.

    **Parameters**

    **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – All measurements inplace or return new circuit.

    **Returns**

    Returns circuit with measurements when inplace = False.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### measure\_allDocument 3:::
qreg = QuantumRegister(3)
    creg = ClassicalRegister(3)
    qc = QuantumCircuit(qreg, creg)
    qc.h([0, 1, 2])
    qc.measure([0, 1, 2], [0, 1, 2])

    with qc.switch(creg) as case:
        with case(0):
            qc.x(0)
        with case(1, 2):
            qc.z(1)
        with case(case.DEFAULT):
            qc.cx(0, 1)
    ```

    **Parameters**

    *   **target** (*Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]*) – The classical value to switch one. This must be integer-like.
    *   **cases** (*Iterable\[Tuple\[*[*Any*](https://docs.python.org/3/library/typing.html#typing.Any ""(in Python v3.12)"")*,* [*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]]*) – A sequence of case specifiers. Each tuple defines one case body (the second item). The first item of the tuple can be either a single integer value, the special value [`CASE_DEFAULT`](circuit#qiskit.circuit.CASE_DEFAULT ""qiskit.circuit.CASE_DEFAULT""), or a tuple of several integer values. Each of the integer values will be tried in turn; control will then pass to the body corresponding to the first match. [`CASE_DEFAULT`](circuit#qiskit.circuit.CASE_DEFAULT ""qiskit.circuit.CASE_DEFAULT"") matches all possible values. Omit in context-manager form.
    *   **qubits** (*Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]*) – The circuit qubits over which all case bodies execute. Omit in context-manager form.
    *   **clbits** (*Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]*) – The circuit clbits over which all case bodies execute. Omit in context-manager form.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will return an object that can be repeatedly entered to produce cases for the switch statement. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or SwitchCaseContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### sx

  <Function id=""qiskit.circuit.QuantumCircuit.sx"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3500-L3513"" signature=""sx(qubit)"">
    Apply [`SXGate`](qiskit.circuit.library.SXGate ""qiskit.circuit.library.SXGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### sxdg

  <Function id=""qiskit.circuit.QuantumCircuit.sxdg"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3515-L3528"" signature=""sxdg(qubit)"">
    Apply [`SXdgGate`](qiskit.circuit.library.SXdgGate ""qiskit.circuit.library.SXdgGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.Document 4:::
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```

![../\_images/circuit-4.png](/images/api/qiskit/1.0/circuit-4.png)

From the plot, it is easy to see that this circuit has 12 qubits, and a collection of Hadamard, CNOT, X, and SWAP gates. But how to quantify this programmatically? Because we can do single-qubit gates on all the qubits simultaneously, the number of qubits in this circuit is equal to the **width** of the circuit:

```python
qc.width()
```

```python
12
```

We can also just get the number of qubits directly:

```python
qc.num_qubits
```

```python
12
```

<Admonition title=""Important"" type=""danger"">
  For a quantum circuit composed from just qubits, the circuit width is equal to the number of qubits. This is the definition used in quantum computing. However, for more complicated circuits with classical registers, and classically controlled gates, this equivalence breaks down. As such, from now on we will not refer to the number of qubits in a quantum circuit as the width.
</Admonition>

It is also straightforward to get the number and type of the gates in a circuit using [`QuantumCircuit.count_ops()`](qiskit.circuit.QuantumCircuit#count_ops ""qiskit.circuit.QuantumCircuit.count_ops""):

```python
qc.count_ops()
```

```python
OrderedDict([('cx', 8), ('h', 5), ('x', 3), ('swap', 3)])
```

We can also get just the raw count of operations by computing the circuits [`QuantumCircuit.size()`](qiskit.circuit.QuantumCircuit#size ""qiskit.circuit.QuantumCircuit.size""):

```python
qc.size()
```

```python
19
```

A particularly important circuit property is known as the circuit **depth**. The depth of a quantum circuit is a measure of how many “layers” of quantum gates, executed in parallel, it takes to complete the computation defined by the circuit. Because quantum gates take time to implement, the depth of a circuit roughly corresponds to the amount of time it takes the quantum computer to execute the circuit. Thus, the depth of a circuit is one important quantity used to measure if a quantum circuit can be run on a device.

The depth of a quantum circuit has a mathematical definition as the longest path in a directed acyclic graph (DAG). However, such a definition is a bit hard to grasp, even for experts. Fortunately, the depth of a circuit can be easily understood by anyone familiar with playing [Tetris](https://en.wikipedia.org/wiki/Tetris). Lets see how to compute this graphically:

![../\_images/depth.gif](/images/api/qiskit/1.0/depth.gif)

We can verify our graphical result using [`QuantumCircuit.depth()`](qiskit.circuit.QuantumCircuit#depth ""qiskit.circuit.QuantumCircuit.depth""):

```python
qc.depth()
```

```python
9
```

## Quantum Circuit API

### Quantum Circuit Construction

|                                                                                                                        |                                                                                                                                                                 |
| ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")(\*regs\[, name, global\_phase, ...]) | Create a new circuit.                                                                                                                                           |
| [`QuantumRegister`](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"")(\[size, name, bits])              | Implement a quantum register.                                                                                                                                   |
| [`Qubit`](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")(\[register, index])                                             | Implement a quantum bit.                                                                                                                                        |
| [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")(\[size, name, bits])        | Implement a classical register.                                                                                                                                 |
| [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")(\[register, index])                                             | Implement a classical bit.                                                                                                                                      |
| [`AncillaRegister`](qiskit.circuit.AncillaRegister ""qiskit.circuit.AncillaRegister"")(\[size, name, bits])              | Implement an ancilla register.                                                                                                                                  |
| [`AncillaQubit`](qiskit.circuit.AncillaQubit ""qiskit.circuit.AncillaQubit"")(\[register, index])                        | A qubit used as ancillary qubit.                                                                                                                                |
| [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")                          | A single instruction in a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit""), comprised of the `operation` and various operands. |""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit

 Write a function that creates a quantum circuit that prepares a Bell
 state using two qubits.
Returns: QuantumCircuit: The quantum circuit that prepares the
 Bell state. 


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 2:::
Initialize two qubits from an array of complex amplitudes.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌────────────────────────────────────┐
    q_0: ┤0                                   ├
         │  Initialize(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                   ├
         └────────────────────────────────────┘
    ```
  </Function>

  ### inverse

  <Function id=""qiskit.circuit.QuantumCircuit.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L665-L715"" signature=""inverse(annotated=False)"">
    Invert (take adjoint of) this circuit.

    This is done by recursively inverting all gates.

    **Parameters**

    **annotated** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – indicates whether the inverse gate can be implemented as an annotated gate.

    **Returns**

    the inverted circuit

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if the circuit cannot be inverted.

    **Examples**

    input:

    ```python
         ┌───┐
    q_0: ┤ H ├─────■──────
         └───┘┌────┴─────┐
    q_1: ─────┤ RX(1.57) ├
              └──────────┘
    ```

    output:

    ```python
                      ┌───┐
    q_0: ──────■──────┤ H ├
         ┌─────┴─────┐└───┘
    q_1: ┤ RX(-1.57) ├─────
         └───────────┘
    ```
  </Function>

  ### iswap

  <Function id=""qiskit.circuit.QuantumCircuit.iswap"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3453-L3466"" signature=""iswap(qubit1, qubit2)"">
    Apply [`iSwapGate`](qiskit.circuit.library.iSwapGate ""qiskit.circuit.library.iSwapGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **qubit1** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubits to apply the gate to.
    *   **qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubits to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### mcp

  <Function id=""qiskit.circuit.QuantumCircuit.mcp"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2994-L3017"" signature=""mcp(lam, control_qubits, target_qubit)"">
    Apply [`MCPhaseGate`](qiskit.circuit.library.MCPhaseGate ""qiskit.circuit.library.MCPhaseGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **lam** ([*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.parameterexpression.ParameterExpression"")  *|*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The angle of the rotation.Document 3:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")Document 4:::
**Returns**

  the circuit representing the input dag.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.dagcircuit import DAGCircuit
  from qiskit.converters import circuit_to_dag
  from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
  from qiskit.converters import dag_to_circuit

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  dag = circuit_to_dag(circ)
  circuit = dag_to_circuit(dag)
  circuit.draw('mpl')
  ```

  ![../\_images/converters-1.png](/images/api/qiskit/1.0/converters-1.png)
</Function>

### circuit\_to\_instruction

<Function id=""qiskit.converters.circuit_to_instruction"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_instruction.py#L21-L145"" signature=""qiskit.converters.circuit_to_instruction(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build an [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the instruction. If None, existing circuit parameters will also parameterize the instruction.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted instruction will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional instruction label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if parameter\_map is not compatible with circuit

  **Returns**

  an instruction equivalent to the action of the input circuit. Upon decomposition, this instruction will yield the components comprising the original circuit.

  **Return type**

  [qiskit.circuit.Instruction](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.converters import circuit_to_instruction

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  circuit_to_instruction(circ)
  ```
</Function>

### circuit\_to\_gate

<Function id=""qiskit.converters.circuit_to_gate"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_gate.py#L30-L109"" signature=""qiskit.converters.circuit_to_gate(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The gate is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The gate will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the gate. If None, existing circuit parameters will also parameterize the Gate.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted gate will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional gate label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if circuit is non-unitary or if parameter\_map is not compatible with circuit

  **Returns**

  a Gate equivalent to the action of the input circuit. Upon decomposition, this gate will yield the components comprising the original circuit.

  **Return type**

  [Gate](qiskit.circuit.Gate ""qiskit.circuit.Gate"")""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit

Create a function that applies a controlled-NOT (CNOT) gate to the
 given quantum circuit with control qubit 0 and target qubit 1.
Parameters: qc (QuantumCircuit): The quantum circuit to which the
 CNOT gate is to be applied. 
Returns: QuantumCircuit: The quantum
 circuit with the CNOT gate applied.


# Context:
""""""Document 0:::
Apply [`CSdgGate`](qiskit.circuit.library.CSdgGate ""qiskit.circuit.library.CSdgGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### cswap

  <Function id=""qiskit.circuit.QuantumCircuit.cswap"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3468-L3498"" signature=""cswap(control_qubit, target_qubit1, target_qubit2, label=None, ctrl_state=None)"">
    Apply [`CSwapGate`](qiskit.circuit.library.CSwapGate ""qiskit.circuit.library.CSwapGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit1** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **target\_qubit2** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. `'1'`). Defaults to controlling on the `'1'` state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### csx

  <Function id=""qiskit.circuit.QuantumCircuit.csx"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3530-L3558"" signature=""csx(control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CSXGate`](qiskit.circuit.library.CSXGate ""qiskit.circuit.library.CSXGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### cu

  <Function id=""qiskit.circuit.QuantumCircuit.cu"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3614-L3650"" signature=""cu(theta, phi, lam, gamma, control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CUGate`](qiskit.circuit.library.CUGate ""qiskit.circuit.library.CUGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** (*ParameterValueType*) – The $\theta$ rotation angle of the gate.
    *   **phi** (*ParameterValueType*) – The $\phi$ rotation angle of the gate.
    *   **lam** (*ParameterValueType*) – The $\lambda$ rotation angle of the gate.
    *   **gamma** (*ParameterValueType*) – The global phase applied of the U gate, if applied.
    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.Document 1:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")Document 2:::
Initialize two qubits from an array of complex amplitudes.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌────────────────────────────────────┐
    q_0: ┤0                                   ├
         │  Initialize(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                   ├
         └────────────────────────────────────┘
    ```
  </Function>

  ### inverse

  <Function id=""qiskit.circuit.QuantumCircuit.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L665-L715"" signature=""inverse(annotated=False)"">
    Invert (take adjoint of) this circuit.

    This is done by recursively inverting all gates.

    **Parameters**

    **annotated** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – indicates whether the inverse gate can be implemented as an annotated gate.

    **Returns**

    the inverted circuit

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if the circuit cannot be inverted.

    **Examples**

    input:

    ```python
         ┌───┐
    q_0: ┤ H ├─────■──────
         └───┘┌────┴─────┐
    q_1: ─────┤ RX(1.57) ├
              └──────────┘
    ```

    output:

    ```python
                      ┌───┐
    q_0: ──────■──────┤ H ├
         ┌─────┴─────┐└───┘
    q_1: ┤ RX(-1.57) ├─────
         └───────────┘
    ```
  </Function>

  ### iswap

  <Function id=""qiskit.circuit.QuantumCircuit.iswap"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3453-L3466"" signature=""iswap(qubit1, qubit2)"">
    Apply [`iSwapGate`](qiskit.circuit.library.iSwapGate ""qiskit.circuit.library.iSwapGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **qubit1** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubits to apply the gate to.
    *   **qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubits to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### mcp

  <Function id=""qiskit.circuit.QuantumCircuit.mcp"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2994-L3017"" signature=""mcp(lam, control_qubits, target_qubit)"">
    Apply [`MCPhaseGate`](qiskit.circuit.library.MCPhaseGate ""qiskit.circuit.library.MCPhaseGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **lam** ([*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.parameterexpression.ParameterExpression"")  *|*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The angle of the rotation.Document 3:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### cry

  <Function id=""qiskit.circuit.QuantumCircuit.cry"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3200-L3228"" signature=""cry(theta, control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CRYGate`](qiskit.circuit.library.CRYGate ""qiskit.circuit.library.CRYGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** (*ParameterValueType*) – The angle of the rotation.
    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### crz

  <Function id=""qiskit.circuit.QuantumCircuit.crz"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3265-L3293"" signature=""crz(theta, control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CRZGate`](qiskit.circuit.library.CRZGate ""qiskit.circuit.library.CRZGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** (*ParameterValueType*) – The angle of the rotation.
    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### cs

  <Function id=""qiskit.circuit.QuantumCircuit.cs"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3378-L3406"" signature=""cs(control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CSGate`](qiskit.circuit.library.CSGate ""qiskit.circuit.library.CSGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### csdg

  <Function id=""qiskit.circuit.QuantumCircuit.csdg"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3408-L3436"" signature=""csdg(control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CSdgGate`](qiskit.circuit.library.CSdgGate ""qiskit.circuit.library.CSdgGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.Document 4:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### t

  <Function id=""qiskit.circuit.QuantumCircuit.t"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3560-L3573"" signature=""t(qubit)"">
    Apply [`TGate`](qiskit.circuit.library.TGate ""qiskit.circuit.library.TGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### tdg

  <Function id=""qiskit.circuit.QuantumCircuit.tdg"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3575-L3588"" signature=""tdg(qubit)"">
    Apply [`TdgGate`](qiskit.circuit.library.TdgGate ""qiskit.circuit.library.TdgGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### tensor

  <Function id=""qiskit.circuit.QuantumCircuit.tensor"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1023-L1111"" signature=""tensor(other, inplace=False)"">
    Tensor `self` with `other`.

    Remember that in the little-endian convention the leftmost operation will be at the bottom of the circuit. See also [the docs](/build/circuit-construction) for more information.

    ```python
         ┌────────┐        ┌─────┐          ┌─────┐
    q_0: ┤ bottom ├ ⊗ q_0: ┤ top ├  = q_0: ─┤ top ├──
         └────────┘        └─────┘         ┌┴─────┴─┐
                                      q_1: ┤ bottom ├
                                           └────────┘
    ```

    **Parameters**

    *   **other** ([*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – The other circuit to tensor this circuit with.
    *   **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, modify the object. Otherwise return composed circuit.

    **Return type**

    [*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"") | None

    **Examples**

    ```python
    from qiskit import QuantumCircuit
    top = QuantumCircuit(1)
    top.x(0);
    bottom = QuantumCircuit(2)
    bottom.cry(0.2, 0, 1);
    tensored = bottom.tensor(top)
    tensored.draw('mpl')
    ```

    ![../\_images/qiskit-circuit-QuantumCircuit-6.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-6.png)

    **Returns**

    The tensored circuit (returns None if inplace==True).

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### to\_gate""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit_ibm_runtime.fake_provider import FakeHanoi

Write a function that executes the given quantum circuit on the 
FakeHanoi backend and returns the result counts.
Parameters: qc (QuantumCircuit): The quantum circuit to be executed.
Returns: dict: The result counts of the simulation. 


# Context:
""""""Document 0:::
---
title: fake_provider
description: API reference for qiskit_ibm_runtime.fake_provider
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit_ibm_runtime.fake_provider
---

<span id=""fake-provider-qiskit-ibm-runtime-fake-provider"" />

<span id=""module-qiskit_ibm_runtime.fake_provider"" />

# Fake Provider

<span id=""module-qiskit_ibm_runtime.fake_provider"" />

`qiskit_ibm_runtime.fake_provider`

## Overview

The fake provider module contains fake providers and fake backends classes. The fake backends are built to mimic the behaviors of IBM Quantum systems using system snapshots. The system snapshots contain important information about the quantum system such as coupling map, basis gates, qubit properties (T1, T2, error rate, etc.) which are useful for testing the transpiler and performing noisy simulations of the system.

## Example Usage

Here is an example of using a fake backend for transpilation and simulation.

```python
from qiskit import QuantumCircuit
from qiskit import transpile
from qiskit.visualization import plot_histogram
from qiskit_ibm_runtime import SamplerV2
from qiskit_ibm_runtime.fake_provider import FakeManilaV2

# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl', style=""iqp"")

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl', style=""iqp"")

# Run the transpiled circuit using the simulated fake backend
sampler = SamplerV2(backend)
job = sampler.run([transpiled_circuit])
pub_result = job.result()[0]
counts = pub_result.data.meas.get_counts()
plot_histogram(counts)
```

![../\_images/fake\_provider-1\_00.png](/images/api/qiskit-ibm-runtime/0.25/fake_provider-1_00.png)

![../\_images/fake\_provider-1\_01.png](/images/api/qiskit-ibm-runtime/0.25/fake_provider-1_01.png)

![../\_images/fake\_provider-1\_02.png](/images/api/qiskit-ibm-runtime/0.25/fake_provider-1_02.png)

<Admonition title=""Important"" type=""danger"">
  Please note that the simulation is done using a noise model generated from system snapshots obtained in the past (sometimes a few years ago) and the results are not representative of the latest behaviours of the real quantum system which the fake backend is mimicking. If you want to run noisy simulations to compare with the real quantum system, you should use the `qiskit_aer` library. After installation, you can follow the steps below to generate a simulator that mimics a real quantum system with the latest calibration results.

  ```python
  from qiskit_ibm_runtime import QiskitRuntimeService
  from qiskit_aer import AerSimulator

  # get a real backend from the runtime service
  service = QiskitRuntimeService()
  backend = service.backend('ibmq_manila')

  # generate a simulator that mimics the real quantum system with the latest calibration results
  backend_sim = AerSimulator.from_backend(backend)
  ```
</Admonition>

## Fake Providers

Fake providers provide access to a list of fake backends.

|                                                                                                                                                       |                                            |
| ----------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------ |
| [`FakeProviderForBackendV2`](qiskit_ibm_runtime.fake_provider.FakeProviderForBackendV2 ""qiskit_ibm_runtime.fake_provider.FakeProviderForBackendV2"")() | Fake provider containing fake V2 backends. |
| [`FakeProvider`](qiskit_ibm_runtime.fake_provider.FakeProvider ""qiskit_ibm_runtime.fake_provider.FakeProvider"")()                                     | Fake provider containing fake V1 backends. |

## Fake Backends

### Fake V2 Backends

Fake V2 backends are fake backends with IBM Quantum systems snapshots implemented with `BackendV2` interface. They are all subclasses of `FakeBackendV2`.

|                                                                                                                                              |                                                                                       |
| -------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| [`FakeAlgiers`](qiskit_ibm_runtime.fake_provider.FakeAlgiers ""qiskit_ibm_runtime.fake_provider.FakeAlgiers"")()                               | A fake 27 qubit backend.                                                              |Document 1:::
---
title: fake_provider
description: API reference for qiskit.providers.fake_provider
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.providers.fake_provider
---

<span id=""module-qiskit.providers.fake_provider"" />

<span id=""qiskit-providers-fakeprovider"" />

<span id=""fake-provider-qiskit-providers-fake-provider"" />

# Fake Provider

<span id=""module-qiskit.providers.fake_provider"" />

`qiskit.providers.fake_provider`

## Overview

The fake provider module in Qiskit contains fake (simulated) backend classes useful for testing the transpiler and other backend-facing functionality.

## Example Usage

Here is an example of using a simulated backend for transpilation and running.

```python
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import GenericBackendV2
from qiskit.visualization import plot_histogram

# Generate a 5-qubit simulated backend
backend = GenericBackendV2(num_qubits=5)

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)
```

![../\_images/providers\_fake\_provider-1\_00.png](/images/api/qiskit/1.0/providers_fake_provider-1_00.png)

![../\_images/providers\_fake\_provider-1\_01.png](/images/api/qiskit/1.0/providers_fake_provider-1_01.png)

![../\_images/providers\_fake\_provider-1\_02.png](/images/api/qiskit/1.0/providers_fake_provider-1_02.png)

## V2 Simulated Backends

|                                                                                                                                                            |                                                                                                                                |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| [`GenericBackendV2`](qiskit.providers.fake_provider.GenericBackendV2 ""qiskit.providers.fake_provider.GenericBackendV2"")(num\_qubits\[, basis\_gates, ...]) | Generic [`BackendV2`](qiskit.providers.BackendV2 ""qiskit.providers.BackendV2"") implementation with a configurable constructor. |

## V1 Fake Backends (Legacy interface)

|                                                                                                                        |                                                              |
| ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| [`FakeOpenPulse2Q`](qiskit.providers.fake_provider.FakeOpenPulse2Q ""qiskit.providers.fake_provider.FakeOpenPulse2Q"")() | A fake 2 qubit backend for pulse test.                       |
| [`FakeOpenPulse3Q`](qiskit.providers.fake_provider.FakeOpenPulse3Q ""qiskit.providers.fake_provider.FakeOpenPulse3Q"")() | Trivial extension of the FakeOpenPulse2Q.                    |
| [`Fake1Q`](qiskit.providers.fake_provider.Fake1Q ""qiskit.providers.fake_provider.Fake1Q"")()                            | A fake 1Q backend.                                           |
| [`Fake5QV1`](qiskit.providers.fake_provider.Fake5QV1 ""qiskit.providers.fake_provider.Fake5QV1"")()                      | A fake backend with the following characteristics:           |
| [`Fake20QV1`](qiskit.providers.fake_provider.Fake20QV1 ""qiskit.providers.fake_provider.Fake20QV1"")()                   | A fake backend with the following characteristics:           |
| [`Fake7QPulseV1`](qiskit.providers.fake_provider.Fake7QPulseV1 ""qiskit.providers.fake_provider.Fake7QPulseV1"")()       | A fake **pulse** backend with the following characteristics: |
| [`Fake27QPulseV1`](qiskit.providers.fake_provider.Fake27QPulseV1 ""qiskit.providers.fake_provider.Fake27QPulseV1"")()    | A fake **pulse** backend with the following characteristics: |
| [`Fake127QPulseV1`](qiskit.providers.fake_provider.Fake127QPulseV1 ""qiskit.providers.fake_provider.Fake127QPulseV1"")() | A fake **pulse** backend with the following characteristics: |

## Fake Backend Base Classes

The V1 fake backends are based on a set of base classes:

### FakeBackendDocument 2:::
Return the measure stimulus channel for the given qubit.

    This is required to be implemented if the backend supports Pulse scheduling.

    **Returns**

    The Qubit measurement stimulus line

    **Return type**

    MeasureChannel
  </Function>

  ### qubit\_properties

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeJohannesburgV2.qubit_properties"" signature=""qubit_properties(qubit)"">
    Return QubitProperties for a given qubit.

    If there are no defined or the backend doesn’t support querying these details this method does not need to be implemented.

    **Parameters**

    **qubit** (`Union`\[`int`, `List`\[`int`]]) – The qubit to get the `QubitProperties` object for. This can be a single integer for 1 qubit or a list of qubits and a list of `QubitProperties` objects will be returned in the same order

    **Return type**

    `Union`\[`QubitProperties`, `List`\[`QubitProperties`]]

    **Returns**

    The `QubitProperties` object for the specified qubit. If a list of qubits is provided a list will be returned. If properties are missing for a qubit this can be `None`.

    **Raises**

    **NotImplementedError** – if the backend doesn’t support querying the qubit properties
  </Function>

  ### refresh

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeJohannesburgV2.refresh"" github=""https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.25/qiskit_ibm_runtime/fake_provider/fake_backend.py#L469-L526"" signature=""refresh(service)"">
    Update the data files from its real counterpart

    This method pulls the latest backend data files from their real counterpart and overwrites the corresponding files in the local installation: \* ../fake\_provider/backends/\{backend\_name}/conf\_\{backend\_name}.json \* ../fake\_provider/backends/\{backend\_name}/defs\_\{backend\_name}.json \* ../fake\_provider/backends/\{backend\_name}/props\_\{backend\_name}.json

    **The new data files will persist through sessions so the files will stay updated unless they**

    are manually reverted locally or when qiskit-ibm-runtime is upgraded/reinstalled.

    **Parameters**

    **service** ([`QiskitRuntimeService`](qiskit_ibm_runtime.QiskitRuntimeService ""qiskit_ibm_runtime.qiskit_runtime_service.QiskitRuntimeService"")) – A `QiskitRuntimeService` instance

    **Raises**

    **Exception** – If the real target doesn’t exist or can’t be accessed

    **Return type**

    `None`
  </Function>

  ### run

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeJohannesburgV2.run"" github=""https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.25/qiskit_ibm_runtime/fake_provider/fake_backend.py#L320-L381"" signature=""run(run_input, **options)"">
    Run on the fake backend using a simulator.

    This method runs circuit jobs (an individual or a list of QuantumCircuit ) and pulse jobs (an individual or a list of Schedule or ScheduleBlock) using BasicSimulator or Aer simulator and returns a `Job` object.

    If qiskit-aer is installed, jobs will be run using AerSimulator with noise model of the fake backend. Otherwise, jobs will be run using BasicSimulator without noise.

    Currently noisy simulation of a pulse job is not supported yet in FakeBackendV2.

    **Parameters**

    *   **run\_input** (*QuantumCircuit or Schedule or ScheduleBlock or list*) – An individual or a list of `QuantumCircuit`, `ScheduleBlock`, or `Schedule` objects to run on the backend.
    *   **options** – Any kwarg options to pass to the backend for running the config. If a key is also present in the options attribute/object then the expectation is that the value specified will be used instead of what’s set in the options object.

    **Returns**

    The job object for the run

    **Return type**

    Job

    **Raises**

    **QiskitError** – If a pulse job is supplied and qiskit-aer is not installed.
  </Function>

  ### set\_options

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeJohannesburgV2.set_options"" signature=""set_options(**fields)"">
    Set the options fields for the backend

    This method is used to update the options of a backend. If you need to change any of the options prior to running just pass in the kwarg with the new value for the options.

    **Parameters**

    **fields** – The fields to update the options

    **Raises**

    **AttributeError** – If the field passed in is not part of the options
  </Function>
</Class>Document 3:::
Return the measure stimulus channel for the given qubit.

    This is required to be implemented if the backend supports Pulse scheduling.

    **Returns**

    The Qubit measurement stimulus line

    **Return type**

    MeasureChannel
  </Function>

  ### qubit\_properties

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeSingaporeV2.qubit_properties"" signature=""qubit_properties(qubit)"">
    Return QubitProperties for a given qubit.

    If there are no defined or the backend doesn’t support querying these details this method does not need to be implemented.

    **Parameters**

    **qubit** (`Union`\[`int`, `List`\[`int`]]) – The qubit to get the `QubitProperties` object for. This can be a single integer for 1 qubit or a list of qubits and a list of `QubitProperties` objects will be returned in the same order

    **Return type**

    `Union`\[`QubitProperties`, `List`\[`QubitProperties`]]

    **Returns**

    The `QubitProperties` object for the specified qubit. If a list of qubits is provided a list will be returned. If properties are missing for a qubit this can be `None`.

    **Raises**

    **NotImplementedError** – if the backend doesn’t support querying the qubit properties
  </Function>

  ### refresh

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeSingaporeV2.refresh"" github=""https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.25/qiskit_ibm_runtime/fake_provider/fake_backend.py#L469-L526"" signature=""refresh(service)"">
    Update the data files from its real counterpart

    This method pulls the latest backend data files from their real counterpart and overwrites the corresponding files in the local installation: \* ../fake\_provider/backends/\{backend\_name}/conf\_\{backend\_name}.json \* ../fake\_provider/backends/\{backend\_name}/defs\_\{backend\_name}.json \* ../fake\_provider/backends/\{backend\_name}/props\_\{backend\_name}.json

    **The new data files will persist through sessions so the files will stay updated unless they**

    are manually reverted locally or when qiskit-ibm-runtime is upgraded/reinstalled.

    **Parameters**

    **service** ([`QiskitRuntimeService`](qiskit_ibm_runtime.QiskitRuntimeService ""qiskit_ibm_runtime.qiskit_runtime_service.QiskitRuntimeService"")) – A `QiskitRuntimeService` instance

    **Raises**

    **Exception** – If the real target doesn’t exist or can’t be accessed

    **Return type**

    `None`
  </Function>

  ### run

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeSingaporeV2.run"" github=""https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.25/qiskit_ibm_runtime/fake_provider/fake_backend.py#L320-L381"" signature=""run(run_input, **options)"">
    Run on the fake backend using a simulator.

    This method runs circuit jobs (an individual or a list of QuantumCircuit ) and pulse jobs (an individual or a list of Schedule or ScheduleBlock) using BasicSimulator or Aer simulator and returns a `Job` object.

    If qiskit-aer is installed, jobs will be run using AerSimulator with noise model of the fake backend. Otherwise, jobs will be run using BasicSimulator without noise.

    Currently noisy simulation of a pulse job is not supported yet in FakeBackendV2.

    **Parameters**

    *   **run\_input** (*QuantumCircuit or Schedule or ScheduleBlock or list*) – An individual or a list of `QuantumCircuit`, `ScheduleBlock`, or `Schedule` objects to run on the backend.
    *   **options** – Any kwarg options to pass to the backend for running the config. If a key is also present in the options attribute/object then the expectation is that the value specified will be used instead of what’s set in the options object.

    **Returns**

    The job object for the run

    **Return type**

    Job

    **Raises**

    **QiskitError** – If a pulse job is supplied and qiskit-aer is not installed.
  </Function>

  ### set\_options

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeSingaporeV2.set_options"" signature=""set_options(**fields)"">
    Set the options fields for the backend

    This method is used to update the options of a backend. If you need to change any of the options prior to running just pass in the kwarg with the new value for the options.

    **Parameters**

    **fields** – The fields to update the options

    **Raises**

    **AttributeError** – If the field passed in is not part of the options
  </Function>
</Class>Document 4:::
Return the measure stimulus channel for the given qubit.

    This is required to be implemented if the backend supports Pulse scheduling.

    **Returns**

    The Qubit measurement stimulus line

    **Return type**

    MeasureChannel
  </Function>

  ### qubit\_properties

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeBoeblingenV2.qubit_properties"" signature=""qubit_properties(qubit)"">
    Return QubitProperties for a given qubit.

    If there are no defined or the backend doesn’t support querying these details this method does not need to be implemented.

    **Parameters**

    **qubit** (`Union`\[`int`, `List`\[`int`]]) – The qubit to get the `QubitProperties` object for. This can be a single integer for 1 qubit or a list of qubits and a list of `QubitProperties` objects will be returned in the same order

    **Return type**

    `Union`\[`QubitProperties`, `List`\[`QubitProperties`]]

    **Returns**

    The `QubitProperties` object for the specified qubit. If a list of qubits is provided a list will be returned. If properties are missing for a qubit this can be `None`.

    **Raises**

    **NotImplementedError** – if the backend doesn’t support querying the qubit properties
  </Function>

  ### refresh

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeBoeblingenV2.refresh"" github=""https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.25/qiskit_ibm_runtime/fake_provider/fake_backend.py#L469-L526"" signature=""refresh(service)"">
    Update the data files from its real counterpart

    This method pulls the latest backend data files from their real counterpart and overwrites the corresponding files in the local installation: \* ../fake\_provider/backends/\{backend\_name}/conf\_\{backend\_name}.json \* ../fake\_provider/backends/\{backend\_name}/defs\_\{backend\_name}.json \* ../fake\_provider/backends/\{backend\_name}/props\_\{backend\_name}.json

    **The new data files will persist through sessions so the files will stay updated unless they**

    are manually reverted locally or when qiskit-ibm-runtime is upgraded/reinstalled.

    **Parameters**

    **service** ([`QiskitRuntimeService`](qiskit_ibm_runtime.QiskitRuntimeService ""qiskit_ibm_runtime.qiskit_runtime_service.QiskitRuntimeService"")) – A `QiskitRuntimeService` instance

    **Raises**

    **Exception** – If the real target doesn’t exist or can’t be accessed

    **Return type**

    `None`
  </Function>

  ### run

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeBoeblingenV2.run"" github=""https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.25/qiskit_ibm_runtime/fake_provider/fake_backend.py#L320-L381"" signature=""run(run_input, **options)"">
    Run on the fake backend using a simulator.

    This method runs circuit jobs (an individual or a list of QuantumCircuit ) and pulse jobs (an individual or a list of Schedule or ScheduleBlock) using BasicSimulator or Aer simulator and returns a `Job` object.

    If qiskit-aer is installed, jobs will be run using AerSimulator with noise model of the fake backend. Otherwise, jobs will be run using BasicSimulator without noise.

    Currently noisy simulation of a pulse job is not supported yet in FakeBackendV2.

    **Parameters**

    *   **run\_input** (*QuantumCircuit or Schedule or ScheduleBlock or list*) – An individual or a list of `QuantumCircuit`, `ScheduleBlock`, or `Schedule` objects to run on the backend.
    *   **options** – Any kwarg options to pass to the backend for running the config. If a key is also present in the options attribute/object then the expectation is that the value specified will be used instead of what’s set in the options object.

    **Returns**

    The job object for the run

    **Return type**

    Job

    **Raises**

    **QiskitError** – If a pulse job is supplied and qiskit-aer is not installed.
  </Function>

  ### set\_options

  <Function id=""qiskit_ibm_runtime.fake_provider.FakeBoeblingenV2.set_options"" signature=""set_options(**fields)"">
    Set the options fields for the backend

    This method is used to update the options of a backend. If you need to change any of the options prior to running just pass in the kwarg with the new value for the options.

    **Parameters**

    **fields** – The fields to update the options

    **Raises**

    **AttributeError** – If the field passed in is not part of the options
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
import math

Write a function that applies the Quantum Fourier Transform (QFT) 
to all qubits in the given quantum circuit.
Parameters: qc (QuantumCircuit): The quantum circuit to which the 
QFT is to be applied. 
Returns: QuantumCircuit: The quantum circuit 
after applying QFT.


# Context:
""""""Document 0:::
---
title: QFT
description: API reference for qiskit.circuit.library.QFT
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.QFT
---

# QFT

<Class id=""qiskit.circuit.library.QFT"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/basis_change/qft.py#L24-L295"" signature=""qiskit.circuit.library.QFT(num_qubits=None, approximation_degree=0, do_swaps=True, inverse=False, insert_barriers=False, name=None)"" modifiers=""class"">
  Bases: `BlueprintCircuit`

  Quantum Fourier Transform Circuit.

  The Quantum Fourier Transform (QFT) on $n$ qubits is the operation

$$
|j\rangle \mapsto \frac{1}{2^{n/2}} \sum_{k=0}^{2^n - 1} e^{2\pi ijk / 2^n} |k\rangle
$$

  The circuit that implements this transformation can be implemented using Hadamard gates on each qubit, a series of controlled-U1 (or Z, depending on the phase) gates and a layer of Swap gates. The layer of Swap gates can in principle be dropped if the QFT appears at the end of the circuit, since then the re-ordering can be done classically. They can be turned off using the `do_swaps` attribute.

  For 4 qubits, the circuit that implements this transformation is:

  ![../\_images/qiskit-circuit-library-QFT-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-1.png)

  The inverse QFT can be obtained by calling the `inverse` method on this class. The respective circuit diagram is:

  ![../\_images/qiskit-circuit-library-QFT-2.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-2.png)

  One method to reduce circuit depth is to implement the QFT approximately by ignoring controlled-phase rotations where the angle is beneath a threshold. This is discussed in more detail in [https://arxiv.org/abs/quant-ph/9601018](https://arxiv.org/abs/quant-ph/9601018) or [https://arxiv.org/abs/quant-ph/0403071](https://arxiv.org/abs/quant-ph/0403071).

  Here, this can be adjusted using the `approximation_degree` attribute: the smallest `approximation_degree` rotation angles are dropped from the QFT. For instance, a QFT on 5 qubits with approximation degree 2 yields (the barriers are dropped in this example):

  ![../\_images/qiskit-circuit-library-QFT-3.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-3.png)

  Construct a new QFT circuit.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The number of qubits on which the QFT acts.
  *   **approximation\_degree** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The degree of approximation (0 for no approximation).
  *   **do\_swaps** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to include the final swaps in the QFT.
  *   **inverse** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, the inverse Fourier transform is constructed.
  *   **insert\_barriers** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, barriers are inserted as visualization improvement.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The name of the circuit.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.QFT.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### approximation\_degree

  <Attribute id=""qiskit.circuit.library.QFT.approximation_degree"">
    The approximation degree of the QFT.

    **Returns**

    The currently set approximation degree.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.QFT.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.QFT.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.QFT.data"" />

  ### do\_swaps

  <Attribute id=""qiskit.circuit.library.QFT.do_swaps"">
    Whether the final swaps of the QFT are applied or not.

    **Returns**

    True, if the final swaps are applied, False if not.
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.QFT.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### insert\_barriers

  <Attribute id=""qiskit.circuit.library.QFT.insert_barriers"">
    Whether barriers are inserted for better visualization or not.

    **Returns**

    True, if barriers are inserted, False if not.
  </Attribute>

  ### instancesDocument 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
**Returns**

  the circuit representing the input dag.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.dagcircuit import DAGCircuit
  from qiskit.converters import circuit_to_dag
  from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
  from qiskit.converters import dag_to_circuit

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  dag = circuit_to_dag(circ)
  circuit = dag_to_circuit(dag)
  circuit.draw('mpl')
  ```

  ![../\_images/converters-1.png](/images/api/qiskit/1.0/converters-1.png)
</Function>

### circuit\_to\_instruction

<Function id=""qiskit.converters.circuit_to_instruction"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_instruction.py#L21-L145"" signature=""qiskit.converters.circuit_to_instruction(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build an [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the instruction. If None, existing circuit parameters will also parameterize the instruction.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted instruction will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional instruction label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if parameter\_map is not compatible with circuit

  **Returns**

  an instruction equivalent to the action of the input circuit. Upon decomposition, this instruction will yield the components comprising the original circuit.

  **Return type**

  [qiskit.circuit.Instruction](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.converters import circuit_to_instruction

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  circuit_to_instruction(circ)
  ```
</Function>

### circuit\_to\_gate

<Function id=""qiskit.converters.circuit_to_gate"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_gate.py#L30-L109"" signature=""qiskit.converters.circuit_to_gate(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The gate is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The gate will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the gate. If None, existing circuit parameters will also parameterize the Gate.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted gate will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional gate label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if circuit is non-unitary or if parameter\_map is not compatible with circuit

  **Returns**

  a Gate equivalent to the action of the input circuit. Upon decomposition, this gate will yield the components comprising the original circuit.

  **Return type**

  [Gate](qiskit.circuit.Gate ""qiskit.circuit.Gate"")Document 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 4:::
circuit.draw('mpl')
    circuit.assign_parameters({params[0]: params[2]}, inplace=True)
    circuit.draw('mpl')
    ```

    ![../\_images/qiskit-circuit-QuantumCircuit-3\_00.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-3_00.png)

    ![../\_images/qiskit-circuit-QuantumCircuit-3\_01.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-3_01.png)

    Bind the values out-of-place by list and get a copy of the original circuit.

    ```python
    from qiskit.circuit import QuantumCircuit, ParameterVector

    circuit = QuantumCircuit(2)
    params = ParameterVector('P', 2)
    circuit.ry(params[0], 0)
    circuit.crx(params[1], 0, 1)

    bound_circuit = circuit.assign_parameters([1, 2])
    bound_circuit.draw('mpl')

    circuit.draw('mpl')
    ```

    ![../\_images/qiskit-circuit-QuantumCircuit-4\_00.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-4_00.png)

    ![../\_images/qiskit-circuit-QuantumCircuit-4\_01.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-4_01.png)
  </Function>

  ### barrier

  <Function id=""qiskit.circuit.QuantumCircuit.barrier"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2824-L2845"" signature=""barrier(*qargs, label=None)"">
    Apply [`Barrier`](qiskit.circuit.library.Barrier ""qiskit.circuit.library.Barrier""). If `qargs` is empty, applies to all qubits in the circuit.

    **Parameters**

    *   **qargs** (*QubitSpecifier*) – Specification for one or more qubit arguments.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – The string label of the barrier.

    **Returns**

    handle to the added instructions.

    **Return type**

    [qiskit.circuit.InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### break\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.break_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4750-L4775"" signature=""break_loop()"">
    Apply [`BreakLoopOp`](qiskit.circuit.BreakLoopOp ""qiskit.circuit.BreakLoopOp"").

    <Admonition title=""Warning"" type=""caution"">
      If you are using the context-manager “builder” forms of [`if_test()`](#qiskit.circuit.QuantumCircuit.if_test ""qiskit.circuit.QuantumCircuit.if_test""), [`for_loop()`](#qiskit.circuit.QuantumCircuit.for_loop ""qiskit.circuit.QuantumCircuit.for_loop"") or [`while_loop()`](#qiskit.circuit.QuantumCircuit.while_loop ""qiskit.circuit.QuantumCircuit.while_loop""), you can only call this method if you are within a loop context, because otherwise the “resource width” of the operation cannot be determined. This would quickly lead to invalid circuits, and so if you are trying to construct a reusable loop body (without the context managers), you must also use the non-context-manager form of [`if_test()`](#qiskit.circuit.QuantumCircuit.if_test ""qiskit.circuit.QuantumCircuit.if_test"") and [`if_else()`](#qiskit.circuit.QuantumCircuit.if_else ""qiskit.circuit.QuantumCircuit.if_else""). Take care that the [`BreakLoopOp`](qiskit.circuit.BreakLoopOp ""qiskit.circuit.BreakLoopOp"") instruction must span all the resources of its containing loop, not just the immediate scope.
    </Admonition>

    **Returns**

    A handle to the instruction created.

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if this method was called within a builder context, but not contained within a loop.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### cast

  <Function id=""qiskit.circuit.QuantumCircuit.cast"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1166-L1172"" signature=""cast(value, type_)"" modifiers=""static"">
    Best effort to cast value to type. Otherwise, returns the value.

    **Return type**

    *S* | *T*
  </Function>

  ### cbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.cbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1189-L1202"" signature=""cbit_argument_conversion(clbit_representation)"">
    Converts several classical bit representations (such as indexes, range, etc.) into a list of classical bits.

    **Parameters**

    **clbit\_representation** (*Object*) – representation to expand

    **Returns**

    Where each tuple is a classical bit.

    **Return type**

    List([tuple](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)""))
  </Function>

  ### ccx""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit

Create a function that implements the Quantum Phase Estimation 
(QPE) algorithm using 3 counting qubits and 1 eigenstate qubit.
Returns: QuantumCircuit: The quantum circuit implementing QPE.


# Context:
""""""Document 0:::
---
title: PhaseEstimation
description: API reference for qiskit.circuit.library.PhaseEstimation
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.PhaseEstimation
---

# PhaseEstimation

<Class id=""qiskit.circuit.library.PhaseEstimation"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/phase_estimation.py#L22-L99"" signature=""qiskit.circuit.library.PhaseEstimation(num_evaluation_qubits, unitary, iqft=None, name='QPE')"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  Phase Estimation circuit.

  In the Quantum Phase Estimation (QPE) algorithm \[1, 2, 3], the Phase Estimation circuit is used to estimate the phase $\phi$ of an eigenvalue $e^{2\pi i\phi}$ of a unitary operator $U$, provided with the corresponding eigenstate $|\psi\rangle$. That is

$$
U|\psi\rangle = e^{2\pi i\phi} |\psi\rangle
$$

  This estimation (and thereby this circuit) is a central routine to several well-known algorithms, such as Shor’s algorithm or Quantum Amplitude Estimation.

  **References:**

  **\[1]: Kitaev, A. Y. (1995). Quantum measurements and the Abelian Stabilizer Problem. 1–22.**

  [quant-ph/9511026](http://arxiv.org/abs/quant-ph/9511026)

  **\[2]: Michael A. Nielsen and Isaac L. Chuang. 2011.**

  Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.). Cambridge University Press, New York, NY, USA.

  **\[3]: Qiskit**

  [textbook](https://github.com/Qiskit/textbook/blob/main/notebooks/ch-algorithms/quantum-phase-estimation.ipynb)

  **Parameters**

  *   **num\_evaluation\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The number of evaluation qubits.
  *   **unitary** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")) – The unitary operation $U$ which will be repeated and controlled.
  *   **iqft** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"") *| None*) – A inverse Quantum Fourier Transform, per default the inverse of [`QFT`](qiskit.circuit.library.QFT ""qiskit.circuit.library.QFT"") is used. Note that the QFT should not include the usual swaps!
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – The name of the circuit.

  <Admonition title=""Note"" type=""note"">
    The inverse QFT should not include a swap of the qubit order.
  </Admonition>

  **Reference Circuit:**

  ![../\_images/qiskit-circuit-library-PhaseEstimation-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-PhaseEstimation-1.png)

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.data"">
    Return the circuit data (instructions and context).

    **Returns**

    a list-like object containing the [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")s for each instruction.

    **Return type**

    QuantumCircuitData
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### instances

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.instances"" attributeValue=""202"" />

  ### layout

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.layout"">
    Return any associated layout information about the circuit

    This attribute contains an optional [`TranspileLayout`](qiskit.transpiler.TranspileLayout ""qiskit.transpiler.TranspileLayout"") object. This is typically set on the output from [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") or [`PassManager.run()`](qiskit.transpiler.PassManager#run ""qiskit.transpiler.PassManager.run"") to retain information about the permutations caused on the input circuit by transpilation.

    There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.Document 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
---
title: QFT
description: API reference for qiskit.circuit.library.QFT
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.QFT
---

# QFT

<Class id=""qiskit.circuit.library.QFT"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/basis_change/qft.py#L24-L295"" signature=""qiskit.circuit.library.QFT(num_qubits=None, approximation_degree=0, do_swaps=True, inverse=False, insert_barriers=False, name=None)"" modifiers=""class"">
  Bases: `BlueprintCircuit`

  Quantum Fourier Transform Circuit.

  The Quantum Fourier Transform (QFT) on $n$ qubits is the operation

$$
|j\rangle \mapsto \frac{1}{2^{n/2}} \sum_{k=0}^{2^n - 1} e^{2\pi ijk / 2^n} |k\rangle
$$

  The circuit that implements this transformation can be implemented using Hadamard gates on each qubit, a series of controlled-U1 (or Z, depending on the phase) gates and a layer of Swap gates. The layer of Swap gates can in principle be dropped if the QFT appears at the end of the circuit, since then the re-ordering can be done classically. They can be turned off using the `do_swaps` attribute.

  For 4 qubits, the circuit that implements this transformation is:

  ![../\_images/qiskit-circuit-library-QFT-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-1.png)

  The inverse QFT can be obtained by calling the `inverse` method on this class. The respective circuit diagram is:

  ![../\_images/qiskit-circuit-library-QFT-2.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-2.png)

  One method to reduce circuit depth is to implement the QFT approximately by ignoring controlled-phase rotations where the angle is beneath a threshold. This is discussed in more detail in [https://arxiv.org/abs/quant-ph/9601018](https://arxiv.org/abs/quant-ph/9601018) or [https://arxiv.org/abs/quant-ph/0403071](https://arxiv.org/abs/quant-ph/0403071).

  Here, this can be adjusted using the `approximation_degree` attribute: the smallest `approximation_degree` rotation angles are dropped from the QFT. For instance, a QFT on 5 qubits with approximation degree 2 yields (the barriers are dropped in this example):

  ![../\_images/qiskit-circuit-library-QFT-3.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-3.png)

  Construct a new QFT circuit.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The number of qubits on which the QFT acts.
  *   **approximation\_degree** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The degree of approximation (0 for no approximation).
  *   **do\_swaps** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to include the final swaps in the QFT.
  *   **inverse** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, the inverse Fourier transform is constructed.
  *   **insert\_barriers** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, barriers are inserted as visualization improvement.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The name of the circuit.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.QFT.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### approximation\_degree

  <Attribute id=""qiskit.circuit.library.QFT.approximation_degree"">
    The approximation degree of the QFT.

    **Returns**

    The currently set approximation degree.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.QFT.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.QFT.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.QFT.data"" />

  ### do\_swaps

  <Attribute id=""qiskit.circuit.library.QFT.do_swaps"">
    Whether the final swaps of the QFT are applied or not.

    **Returns**

    True, if the final swaps are applied, False if not.
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.QFT.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### insert\_barriers

  <Attribute id=""qiskit.circuit.library.QFT.insert_barriers"">
    Whether barriers are inserted for better visualization or not.

    **Returns**

    True, if barriers are inserted, False if not.
  </Attribute>

  ### instancesDocument 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 4:::
**Returns**

  the circuit representing the input dag.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.dagcircuit import DAGCircuit
  from qiskit.converters import circuit_to_dag
  from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
  from qiskit.converters import dag_to_circuit

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  dag = circuit_to_dag(circ)
  circuit = dag_to_circuit(dag)
  circuit.draw('mpl')
  ```

  ![../\_images/converters-1.png](/images/api/qiskit/1.0/converters-1.png)
</Function>

### circuit\_to\_instruction

<Function id=""qiskit.converters.circuit_to_instruction"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_instruction.py#L21-L145"" signature=""qiskit.converters.circuit_to_instruction(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build an [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the instruction. If None, existing circuit parameters will also parameterize the instruction.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted instruction will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional instruction label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if parameter\_map is not compatible with circuit

  **Returns**

  an instruction equivalent to the action of the input circuit. Upon decomposition, this instruction will yield the components comprising the original circuit.

  **Return type**

  [qiskit.circuit.Instruction](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.converters import circuit_to_instruction

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  circuit_to_instruction(circ)
  ```
</Function>

### circuit\_to\_gate

<Function id=""qiskit.converters.circuit_to_gate"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_gate.py#L30-L109"" signature=""qiskit.converters.circuit_to_gate(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The gate is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The gate will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the gate. If None, existing circuit parameters will also parameterize the Gate.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted gate will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional gate label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if circuit is non-unitary or if parameter\_map is not compatible with circuit

  **Returns**

  a Gate equivalent to the action of the input circuit. Upon decomposition, this gate will yield the components comprising the original circuit.

  **Return type**

  [Gate](qiskit.circuit.Gate ""qiskit.circuit.Gate"")""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit

 Write a function that creates a quantum circuit that implements the
 quantum teleportation protocol.
Returns: QuantumCircuit: The quantum circuit for quantum
 teleportation. 


# Context:
""""""Document 0:::
**Returns**

  the circuit representing the input dag.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.dagcircuit import DAGCircuit
  from qiskit.converters import circuit_to_dag
  from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
  from qiskit.converters import dag_to_circuit

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  dag = circuit_to_dag(circ)
  circuit = dag_to_circuit(dag)
  circuit.draw('mpl')
  ```

  ![../\_images/converters-1.png](/images/api/qiskit/1.0/converters-1.png)
</Function>

### circuit\_to\_instruction

<Function id=""qiskit.converters.circuit_to_instruction"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_instruction.py#L21-L145"" signature=""qiskit.converters.circuit_to_instruction(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build an [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the instruction. If None, existing circuit parameters will also parameterize the instruction.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted instruction will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional instruction label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if parameter\_map is not compatible with circuit

  **Returns**

  an instruction equivalent to the action of the input circuit. Upon decomposition, this instruction will yield the components comprising the original circuit.

  **Return type**

  [qiskit.circuit.Instruction](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.converters import circuit_to_instruction

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  circuit_to_instruction(circ)
  ```
</Function>

### circuit\_to\_gate

<Function id=""qiskit.converters.circuit_to_gate"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_gate.py#L30-L109"" signature=""qiskit.converters.circuit_to_gate(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The gate is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The gate will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the gate. If None, existing circuit parameters will also parameterize the Gate.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted gate will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional gate label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if circuit is non-unitary or if parameter\_map is not compatible with circuit

  **Returns**

  a Gate equivalent to the action of the input circuit. Upon decomposition, this gate will yield the components comprising the original circuit.

  **Return type**

  [Gate](qiskit.circuit.Gate ""qiskit.circuit.Gate"")Document 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")Document 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 4:::
### from\_qasm\_str

  <Function id=""qiskit.circuit.QuantumCircuit.from_qasm_str"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2429-L2450"" signature=""from_qasm_str(qasm_str)"" modifiers=""static"">
    Convert a string containing an OpenQASM 2.0 program to a [`QuantumCircuit`](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

    **Parameters**

    **qasm\_str** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – A string containing an OpenQASM 2.0 program.

    **Returns**

    The QuantumCircuit object for the input OpenQASM 2

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    <Admonition title=""See also"" type=""note"">
      [`qasm2.loads()`](qasm2#qiskit.qasm2.loads ""qiskit.qasm2.loads""): the complete interface to the OpenQASM 2 importer.
    </Admonition>
  </Function>

  ### get\_instructions

  <Function id=""qiskit.circuit.QuantumCircuit.get_instructions"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1966-L1975"" signature=""get_instructions(name)"">
    Get instructions matching name.

    **Parameters**

    **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – The name of instruction to.

    **Returns**

    list of (instruction, qargs, cargs).

    **Return type**

    [list](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")([tuple](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)""))
  </Function>

  ### get\_parameter

  <Function id=""qiskit.circuit.QuantumCircuit.get_parameter"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1380-L1420"" signature=""get_parameter(name: str, default: T) → Parameter | T"" extraSignatures={[""get_parameter(name: str, default: ellipsis = Ellipsis) → Parameter""]}>
    Retrieve a compile-time parameter that is accessible in this circuit scope by name.

    **Parameters**

    *   **name** – the name of the parameter to retrieve.
    *   **default** – if given, this value will be returned if the parameter is not present. If it is not given, a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError ""(in Python v3.12)"") is raised instead.

    **Returns**

    The corresponding parameter.

    **Raises**

    [**KeyError**](https://docs.python.org/3/library/exceptions.html#KeyError ""(in Python v3.12)"") – if no default is given, but the parameter does not exist in the circuit.

    **Examples**

    Retrieve a parameter by name from a circuit:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter

    my_param = Parameter(""my_param"")

    # Create a parametrised circuit.
    qc = QuantumCircuit(1)
    qc.rx(my_param, 0)

    # We can use 'my_param' as a parameter, but let's say we've lost the Python object
    # and need to retrieve it.
    my_param_again = qc.get_parameter(""my_param"")

    assert my_param is my_param_again
    ```

    Get a variable from a circuit by name, returning some default if it is not present:

    ```python
    assert qc.get_parameter(""my_param"", None) is my_param
    assert qc.get_parameter(""unknown_param"", None) is None
    ```
  </Function>

  ### h

  <Function id=""qiskit.circuit.QuantumCircuit.h"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2873-L2886"" signature=""h(qubit)"">
    Apply [`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit

Write a function that creates a quantum circuit implementing the 
Deutsch-Jozsa algorithm. The oracle should distinguish between a
 balanced and a constant function for `n_qubits`. 
Parameters: n_qubits (int): Number of qubits, excluding the oracle qubit.
 Returns: QuantumCircuit: The quantum circuit implementing the
 Deutsch-Jozsa algorithm.


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
Run the algorithm.

    **Parameters**

    *   **gate\_matrix** (*np.ndarray*) – The 2x2 matrix representing the gate. This matrix has to be SU(2) up to global phase.
    *   **recursion\_degree** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The recursion degree, called $n$ in the paper.
    *   **return\_dag** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` return a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit ""qiskit.dagcircuit.DAGCircuit""), else a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").
    *   **check\_input** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` check that the input matrix is valid for the decomposition.

    **Returns**

    A one-qubit circuit approximating the `gate_matrix` in the specified discrete basis.

    **Return type**

    QuantumCircuit’ | ‘DAGCircuit
  </Function>
</Class>Document 2:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter
    >>> angles = [Parameter(""angle_1""), Parameter(""angle_2""), Parameter(""angle_10"")]
    >>> circuit = QuantumCircuit(1)
    >>> circuit.u(*angles, 0)
    >>> circuit.draw()
       ┌─────────────────────────────┐
    q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.QuadraticForm.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.QuadraticForm.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### required\_result\_qubits

  <Function id=""qiskit.circuit.library.QuadraticForm.required_result_qubits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/arithmetic/quadratic_form.py#L165-L197"" signature=""required_result_qubits(quadratic, linear, offset)"" modifiers=""static"">
    Get the number of required result qubits.

    **Parameters**

    *   **quadratic** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]]*) – A matrix containing the quadratic coefficients.
    *   **linear** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – An array containing the linear coefficients.
    *   **offset** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – A constant offset.

    **Returns**

    The number of qubits needed to represent the value of the quadratic form in twos complement.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>
</Class>Document 4:::
</Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### x

  <Function id=""qiskit.circuit.QuantumCircuit.x"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3652-L3666"" signature=""x(qubit, label=None)"">
    Apply [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **qubit** (*QubitSpecifier*) – The qubit(s) to apply the gate to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### y

  <Function id=""qiskit.circuit.QuantumCircuit.y"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3821-L3834"" signature=""y(qubit)"">
    Apply [`YGate`](qiskit.circuit.library.YGate ""qiskit.circuit.library.YGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### z

  <Function id=""qiskit.circuit.QuantumCircuit.z"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3864-L3877"" signature=""z(qubit)"">
    Apply [`ZGate`](qiskit.circuit.library.ZGate ""qiskit.circuit.library.ZGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function to implement the Quantum Approximate
 Optimization Algorithm (QAOA) for a given number of qubits.
 The function should generate a quantum circuit with a mixing operator
 and a problem Hamiltonian operator.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
 p (int): Number of layers in the QAOA.
Returns: QuantumCircuit: The quantum circuit implementing QAOA.


# Context:
""""""Document 0:::
---
title: QAOAAnsatz
description: API reference for qiskit.circuit.library.QAOAAnsatz
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.QAOAAnsatz
---

# QAOAAnsatz

<Class id=""qiskit.circuit.library.QAOAAnsatz"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/n_local/qaoa_ansatz.py#L28-L289"" signature=""qiskit.circuit.library.QAOAAnsatz(cost_operator=None, reps=1, initial_state=None, mixer_operator=None, name='QAOA', flatten=None)"" modifiers=""class"">
  Bases: [`EvolvedOperatorAnsatz`](qiskit.circuit.library.EvolvedOperatorAnsatz ""qiskit.circuit.library.n_local.evolved_operator_ansatz.EvolvedOperatorAnsatz"")

  A generalized QAOA quantum circuit with a support of custom initial states and mixers.

  **References**

  **\[1]: Farhi et al., A Quantum Approximate Optimization Algorithm.**

  [arXiv:1411.4028](https://arxiv.org/pdf/1411.4028)

  **Parameters**

  *   **cost\_operator** (*BaseOperator or OperatorBase, optional*) – The operator representing the cost of the optimization problem, denoted as $U(C, \gamma)$ in the original paper. Must be set either in the constructor or via property setter.
  *   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The integer parameter p, which determines the depth of the circuit, as specified in the original paper, default is 1.
  *   **initial\_state** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*, optional*) – An optional initial state to use. If None is passed then a set of Hadamard gates is applied as an initial state to all qubits.
  *   **mixer\_operator** (*BaseOperator or OperatorBase or* [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*, optional*) – An optional custom mixer to use instead of the global X-rotations, denoted as $U(B, \beta)$ in the original paper. Can be an operator or an optionally parameterized quantum circuit.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – A name of the circuit, default ‘qaoa’
  *   **flatten** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"") *| None*) – Set this to `True` to output a flat circuit instead of nesting it inside multiple layers of gate objects. By default currently the contents of the output circuit will be wrapped in nested objects for cleaner visualization. However, if you’re using this circuit for anything besides visualization its **strongly** recommended to set this flag to `True` to avoid a large performance overhead for parameter binding.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### cost\_operator

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.cost_operator"">
    Returns an operator representing the cost of the optimization problem.

    **Returns**

    cost operator.

    **Return type**

    BaseOperator or OperatorBase
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.data"" />

  ### entanglement

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.entanglement"">
    Get the entanglement strategy.

    **Returns**

    The entanglement strategy, see `get_entangler_map()` for more detail on how the format is interpreted.
  </Attribute>

  ### entanglement\_blocks

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.entanglement_blocks"">
    The blocks in the entanglement layers.

    **Returns**

    The blocks in the entanglement layers.
  </Attribute>

  ### evolution

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.evolution"">
    The evolution converter used to compute the evolution.

    **Returns**

    The evolution converter used to compute the evolution.

    **Return type**

    [EvolutionSynthesis](qiskit.synthesis.EvolutionSynthesis ""qiskit.synthesis.EvolutionSynthesis"")
  </Attribute>

  ### flatten

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.flatten"">
    Returns whether the circuit is wrapped in nested gates/instructions or flattened.
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### initial\_state

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.initial_state"">
    Returns an optional initial state as a circuit
  </Attribute>

  ### insert\_barriers

  <Attribute id=""qiskit.circuit.library.QAOAAnsatz.insert_barriers"">Document 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
---
title: ApproximateCircuit
description: API reference for qiskit.synthesis.unitary.aqc.ApproximateCircuit
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.synthesis.unitary.aqc.ApproximateCircuit
---

# ApproximateCircuit

<Class id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/unitary/aqc/approximate.py#L21-L52"" signature=""qiskit.synthesis.unitary.aqc.ApproximateCircuit(num_qubits, name=None)"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit""), [`ABC`](https://docs.python.org/3/library/abc.html#abc.ABC ""(in Python v3.12)"")

  A base class that represents an approximate circuit.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – number of qubit this circuit will span.
  *   **name** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – a name of the circuit.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.data"">
    Return the circuit data (instructions and context).

    **Returns**

    a list-like object containing the [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")s for each instruction.

    **Return type**

    QuantumCircuitData
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### instances

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.instances"" attributeValue=""158"" />

  ### layout

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.layout"">
    Return any associated layout information about the circuit

    This attribute contains an optional [`TranspileLayout`](qiskit.transpiler.TranspileLayout ""qiskit.transpiler.TranspileLayout"") object. This is typically set on the output from [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") or [`PassManager.run()`](qiskit.transpiler.PassManager#run ""qiskit.transpiler.PassManager.run"") to retain information about the permutations caused on the input circuit by transpilation.

    There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.
  </Attribute>

  ### metadata

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.metadata"">
    The user provided metadata associated with the circuit.

    The metadata for the circuit is a user provided `dict` of metadata for the circuit. It will not be used to influence the execution or operation of the circuit, but it is expected to be passed between all transforms of the circuit (ie transpilation) and that providers will associate any circuit metadata with the results it returns from execution of that circuit.
  </Attribute>

  ### num\_ancillas

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.num_ancillas"">
    Return the number of ancilla qubits.
  </Attribute>

  ### num\_clbits

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.num_clbits"">
    Return number of classical bits.
  </Attribute>

  ### num\_parameters

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.num_parameters"">
    The number of parameter objects in the circuit.
  </Attribute>

  ### num\_qubits

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.num_qubits"">
    Return number of qubits.
  </Attribute>

  ### op\_start\_times

  <Attribute id=""qiskit.synthesis.unitary.aqc.ApproximateCircuit.op_start_times"">
    Return a list of operation start times.

    This attribute is enabled once one of scheduling analysis passes runs on the quantum circuit.

    **Returns**

    List of integers representing instruction start times. The index corresponds to the index of instruction in `QuantumCircuit.data`.

    **Raises**Document 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 4:::
</Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### x

  <Function id=""qiskit.circuit.QuantumCircuit.x"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3652-L3666"" signature=""x(qubit, label=None)"">
    Apply [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **qubit** (*QubitSpecifier*) – The qubit(s) to apply the gate to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### y

  <Function id=""qiskit.circuit.QuantumCircuit.y"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3821-L3834"" signature=""y(qubit)"">
    Apply [`YGate`](qiskit.circuit.library.YGate ""qiskit.circuit.library.YGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### z

  <Function id=""qiskit.circuit.QuantumCircuit.z"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3864-L3877"" signature=""z(qubit)"">
    Apply [`ZGate`](qiskit.circuit.library.ZGate ""qiskit.circuit.library.ZGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit

Write a function that prepares a GHZ state for `n_qubits`. The
 function should return a quantum circuit that creates this entangled
 state.
Parameters: n_qubits (int): Number of qubits in the GHZ state.
Returns: QuantumCircuit: The quantum circuit that prepares the
 GHZ state.


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 2:::
*   **true\_body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The circuit body to be run if `condition` is true.
    *   **qubits** (*Optional\[Sequence\[QubitSpecifier]]*) – The circuit qubits over which the if/else should be run.
    *   **clbits** (*Optional\[Sequence\[ClbitSpecifier]]*) – The circuit clbits over which the if/else should be run.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    depending on the call signature, either a context manager for creating the `if` block (it will automatically be added to the circuit at the end of the block), or an [`InstructionSet`](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") handle to the appended conditional operation.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or IfContext

    **Raises**

    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the provided condition references Clbits outside the enclosing circuit.
    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.

    **Returns**

    A handle to the instruction created.
  </Function>

  ### initialize

  <Function id=""qiskit.circuit.QuantumCircuit.initialize"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4069-L4178"" signature=""initialize(params, qubits=None, normalize=False)"">
    Initialize qubits in a specific state.

    Qubit initialization is done by first resetting the qubits to $|0\rangle$ followed by calling [`StatePreparation`](qiskit.circuit.library.StatePreparation ""qiskit.circuit.library.StatePreparation"") class to prepare the qubits in a specified state. Both these steps are included in the [`Initialize`](qiskit.circuit.library.Initialize ""qiskit.circuit.library.Initialize"") instruction.

    **Parameters**

    *   **params** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"") *| Sequence\[*[*complex*](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")*] |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –

        The state to initialize to, can be either of the following.

        *   Statevector or vector of complex amplitudes to initialize to.
        *   Labels of basis states of the Pauli eigenstates Z, X, Y. See [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label""). Notice the order of the labels is reversed with respect to the qubit index to be applied to. Example label ‘01’ initializes the qubit zero to $|1\rangle$ and the qubit one to $|0\rangle$.
        *   An integer that is used as a bitmap indicating which qubits to initialize to $|1\rangle$. Example: setting params to 5 would initialize qubit 0 and qubit 2 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    *   **qubits** (*Sequence\[QubitSpecifier] | None*) – Qubits to initialize. If `None` the initialization is applied to all qubits in the circuit.

    *   **normalize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to normalize an input array to a unit vector.

    **Returns**

    A handle to the instructions created.

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.initialize([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────────────────┐
    q_0: ┤ Initialize(0.70711,-0.70711) ├
         └──────────────────────────────┘
    ```

    Initialize from a string two qubits in the state $|10\rangle$. The order of the labels is reversed with respect to qubit index. More information about labels for basis states are in [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label"").

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────┐
    q_0: ┤0                 ├
         │  Initialize(0,1) │
    q_1: ┤1                 ├
         └──────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌────────────────────────────────────┐
    q_0: ┤0                                   ├
         │  Initialize(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                   ├Document 3:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### t

  <Function id=""qiskit.circuit.QuantumCircuit.t"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3560-L3573"" signature=""t(qubit)"">
    Apply [`TGate`](qiskit.circuit.library.TGate ""qiskit.circuit.library.TGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### tdg

  <Function id=""qiskit.circuit.QuantumCircuit.tdg"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3575-L3588"" signature=""tdg(qubit)"">
    Apply [`TdgGate`](qiskit.circuit.library.TdgGate ""qiskit.circuit.library.TdgGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### tensor

  <Function id=""qiskit.circuit.QuantumCircuit.tensor"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1023-L1111"" signature=""tensor(other, inplace=False)"">
    Tensor `self` with `other`.

    Remember that in the little-endian convention the leftmost operation will be at the bottom of the circuit. See also [the docs](/build/circuit-construction) for more information.

    ```python
         ┌────────┐        ┌─────┐          ┌─────┐
    q_0: ┤ bottom ├ ⊗ q_0: ┤ top ├  = q_0: ─┤ top ├──
         └────────┘        └─────┘         ┌┴─────┴─┐
                                      q_1: ┤ bottom ├
                                           └────────┘
    ```

    **Parameters**

    *   **other** ([*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – The other circuit to tensor this circuit with.
    *   **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, modify the object. Otherwise return composed circuit.

    **Return type**

    [*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"") | None

    **Examples**

    ```python
    from qiskit import QuantumCircuit
    top = QuantumCircuit(1)
    top.x(0);
    bottom = QuantumCircuit(2)
    bottom.cry(0.2, 0, 1);
    tensored = bottom.tensor(top)
    tensored.draw('mpl')
    ```

    ![../\_images/qiskit-circuit-QuantumCircuit-6.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-6.png)

    **Returns**

    The tensored circuit (returns None if inplace==True).

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### to\_gateDocument 4:::
**Parameters**

    **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – All measurements inplace or return new circuit.

    **Returns**

    Returns circuit with measurements when inplace = False.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### measure\_all

  <Function id=""qiskit.circuit.QuantumCircuit.measure_all"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2296-L2339"" signature=""measure_all(inplace=True, add_bits=True)"">
    Adds measurement to all qubits.

    By default, adds new classical bits in a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") to store these measurements. If `add_bits=False`, the results of the measurements will instead be stored in the already existing classical bits, with qubit `n` being measured into classical bit `n`.

    Returns a new circuit with measurements if `inplace=False`.

    **Parameters**

    *   **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – All measurements inplace or return new circuit.
    *   **add\_bits** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to add new bits to store the results.

    **Returns**

    Returns circuit with measurements when `inplace=False`.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `add_bits=False` but there are not enough classical bits.
  </Function>

  ### ms

  <Function id=""qiskit.circuit.QuantumCircuit.ms"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2931-L2946"" signature=""ms(theta, qubits)"">
    Apply [`MSGate`](qiskit.circuit.library.MSGate ""qiskit.circuit.library.MSGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** ([*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.parameterexpression.ParameterExpression"")  *|*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The angle of the rotation.
    *   **qubits** ([*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]]*) – The qubits to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### num\_connected\_components

  <Function id=""qiskit.circuit.QuantumCircuit.num_connected_components"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1977-L2048"" signature=""num_connected_components(unitary_only=False)"">
    How many non-entangled subcircuits can the circuit be factored to.

    **Parameters**

    **unitary\_only** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Compute only unitary part of graph.

    **Returns**

    Number of connected components in circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### num\_nonlocal\_gates

  <Function id=""qiskit.circuit.QuantumCircuit.num_nonlocal_gates"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1953-L1964"" signature=""num_nonlocal_gates()"">
    Return number of non-local gates (i.e. involving 2+ qubits).

    Conditional nonlocal gates are also included.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### num\_tensor\_factors""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit 
from qiskit.algorithms import Shor
Write a function that sets up Shor's algorithm for integer factorization
 of a given number `N`. The function should return the quantum circuit
 that implements the modular exponentiation part of Shor's algorithm.
Parameters: N (int): The integer to factorize.
Returns: QuantumCircuit: The quantum circuit implementing
 modular exponentiation. 


# Context:
""""""Document 0:::
### from\_qasm\_str

  <Function id=""qiskit.circuit.QuantumCircuit.from_qasm_str"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2429-L2450"" signature=""from_qasm_str(qasm_str)"" modifiers=""static"">
    Convert a string containing an OpenQASM 2.0 program to a [`QuantumCircuit`](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

    **Parameters**

    **qasm\_str** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – A string containing an OpenQASM 2.0 program.

    **Returns**

    The QuantumCircuit object for the input OpenQASM 2

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    <Admonition title=""See also"" type=""note"">
      [`qasm2.loads()`](qasm2#qiskit.qasm2.loads ""qiskit.qasm2.loads""): the complete interface to the OpenQASM 2 importer.
    </Admonition>
  </Function>

  ### get\_instructions

  <Function id=""qiskit.circuit.QuantumCircuit.get_instructions"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1966-L1975"" signature=""get_instructions(name)"">
    Get instructions matching name.

    **Parameters**

    **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – The name of instruction to.

    **Returns**

    list of (instruction, qargs, cargs).

    **Return type**

    [list](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")([tuple](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)""))
  </Function>

  ### get\_parameter

  <Function id=""qiskit.circuit.QuantumCircuit.get_parameter"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1380-L1420"" signature=""get_parameter(name: str, default: T) → Parameter | T"" extraSignatures={[""get_parameter(name: str, default: ellipsis = Ellipsis) → Parameter""]}>
    Retrieve a compile-time parameter that is accessible in this circuit scope by name.

    **Parameters**

    *   **name** – the name of the parameter to retrieve.
    *   **default** – if given, this value will be returned if the parameter is not present. If it is not given, a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError ""(in Python v3.12)"") is raised instead.

    **Returns**

    The corresponding parameter.

    **Raises**

    [**KeyError**](https://docs.python.org/3/library/exceptions.html#KeyError ""(in Python v3.12)"") – if no default is given, but the parameter does not exist in the circuit.

    **Examples**

    Retrieve a parameter by name from a circuit:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter

    my_param = Parameter(""my_param"")

    # Create a parametrised circuit.
    qc = QuantumCircuit(1)
    qc.rx(my_param, 0)

    # We can use 'my_param' as a parameter, but let's say we've lost the Python object
    # and need to retrieve it.
    my_param_again = qc.get_parameter(""my_param"")

    assert my_param is my_param_again
    ```

    Get a variable from a circuit by name, returning some default if it is not present:

    ```python
    assert qc.get_parameter(""my_param"", None) is my_param
    assert qc.get_parameter(""unknown_param"", None) is None
    ```
  </Function>

  ### h

  <Function id=""qiskit.circuit.QuantumCircuit.h"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2873-L2886"" signature=""h(qubit)"">
    Apply [`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**Document 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
Run the algorithm.

    **Parameters**

    *   **gate\_matrix** (*np.ndarray*) – The 2x2 matrix representing the gate. This matrix has to be SU(2) up to global phase.
    *   **recursion\_degree** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The recursion degree, called $n$ in the paper.
    *   **return\_dag** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` return a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit ""qiskit.dagcircuit.DAGCircuit""), else a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").
    *   **check\_input** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` check that the input matrix is valid for the decomposition.

    **Returns**

    A one-qubit circuit approximating the `gate_matrix` in the specified discrete basis.

    **Return type**

    QuantumCircuit’ | ‘DAGCircuit
  </Function>
</Class>Document 3:::
**Returns**

  the circuit representing the input dag.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.dagcircuit import DAGCircuit
  from qiskit.converters import circuit_to_dag
  from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
  from qiskit.converters import dag_to_circuit

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  dag = circuit_to_dag(circ)
  circuit = dag_to_circuit(dag)
  circuit.draw('mpl')
  ```

  ![../\_images/converters-1.png](/images/api/qiskit/1.0/converters-1.png)
</Function>

### circuit\_to\_instruction

<Function id=""qiskit.converters.circuit_to_instruction"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_instruction.py#L21-L145"" signature=""qiskit.converters.circuit_to_instruction(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build an [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the instruction. If None, existing circuit parameters will also parameterize the instruction.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted instruction will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional instruction label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if parameter\_map is not compatible with circuit

  **Returns**

  an instruction equivalent to the action of the input circuit. Upon decomposition, this instruction will yield the components comprising the original circuit.

  **Return type**

  [qiskit.circuit.Instruction](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.converters import circuit_to_instruction

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  circuit_to_instruction(circ)
  ```
</Function>

### circuit\_to\_gate

<Function id=""qiskit.converters.circuit_to_gate"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_gate.py#L30-L109"" signature=""qiskit.converters.circuit_to_gate(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The gate is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The gate will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the gate. If None, existing circuit parameters will also parameterize the Gate.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted gate will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional gate label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if circuit is non-unitary or if parameter\_map is not compatible with circuit

  **Returns**

  a Gate equivalent to the action of the input circuit. Upon decomposition, this gate will yield the components comprising the original circuit.

  **Return type**

  [Gate](qiskit.circuit.Gate ""qiskit.circuit.Gate"")Document 4:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function that implements the Quantum Walk algorithm
 on a cycle graph with `n_qubits` qubits. The function should create 
and return a quantum circuit that simulates one step of the quantum
 walk.
Parameters: n_qubits (int): Number of qubits in the cycle graph.
Returns: QuantumCircuit: The quantum circuit implementing the 
quantum walk.


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")Document 2:::
*   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Optional number of times the circuit should be decomposed. For instance, `reps=2` equals calling `circuit.decompose().decompose()`. can decompose specific gates specific time

    **Returns**

    a circuit one level decomposed

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### delay

  <Function id=""qiskit.circuit.QuantumCircuit.delay"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2847-L2871"" signature=""delay(duration, qarg=None, unit='dt')"">
    Apply [`Delay`](qiskit.circuit.Delay ""qiskit.circuit.Delay""). If qarg is `None`, applies to all qubits. When applying to multiple qubits, delays with the same duration will be created.

    **Parameters**

    *   **duration** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *or*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *or*[*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.ParameterExpression"")) – duration of the delay.
    *   **qarg** (*Object*) – qubit argument to apply this delay.
    *   **unit** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – unit of the duration. Supported units: `'s'`, `'ms'`, `'us'`, `'ns'`, `'ps'`, and `'dt'`. Default is `'dt'`, i.e. integer time unit depending on the target backend.

    **Returns**

    handle to the added instructions.

    **Return type**

    [qiskit.circuit.InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if arguments have bad format.
  </Function>

  ### depth

  <Function id=""qiskit.circuit.QuantumCircuit.depth"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1839-L1913"" signature=""depth(filter_function=<function QuantumCircuit.<lambda>>)"">
    Return circuit depth (i.e., length of critical path).

    **Parameters**

    **filter\_function** (*callable*) – A function to filter instructions. Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)). Instructions for which the function returns False are ignored in the computation of the circuit depth. By default filters out “directives”, such as barrier or snapshot.

    **Returns**

    Depth of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")

    **Notes**

    The circuit depth and the DAG depth need not be the same.
  </Function>

  ### draw

  <Function id=""qiskit.circuit.QuantumCircuit.draw"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1655-L1819"" signature=""draw(output=None, scale=None, filename=None, style=None, interactive=False, plot_barriers=True, reverse_bits=None, justify=None, vertical_compression='medium', idle_wires=True, with_layout=True, fold=None, ax=None, initial_state=False, cregbundle=None, wire_order=None, expr_len=30)"">
    Draw the quantum circuit. Use the output parameter to choose the drawing format:

    **text**: ASCII art TextDrawing that can be printed in the console.

    **mpl**: images with color rendered purely in Python using matplotlib.

    **latex**: high-quality images compiled via latex.

    **latex\_source**: raw uncompiled latex output.

    <Admonition title=""Warning"" type=""caution"">
      Support for [`Expr`](circuit_classical#qiskit.circuit.classical.expr.Expr ""qiskit.circuit.classical.expr.Expr"") nodes in conditions and `SwitchCaseOp.target` fields is preliminary and incomplete. The `text` and `mpl` drawers will make a best-effort attempt to show data dependencies, but the LaTeX-based drawers will skip these completely.
    </Admonition>

    **Parameters**

    *   **output** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Select the output method to use for drawing the circuit. Valid choices are `text`, `mpl`, `latex`, `latex_source`. By default the text drawer is used unless the user config file (usually `~/.qiskit/settings.conf`) has an alternative backend set as the default. For example, `circuit_drawer = latex`. If the output kwarg is set, that backend will always be used over the default in the user config file.

    *   **scale** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"") *| None*) – Scale of image to draw (shrink if `< 1.0`). Only used by the `mpl`, `latex` and `latex_source` outputs. Defaults to `1.0`.

    *   **filename** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – File path to save image to. Defaults to `None` (result not saved in a file).Document 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 4:::
**Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### r

  <Function id=""qiskit.circuit.QuantumCircuit.r"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3019-L3036"" signature=""r(theta, phi, qubit)"">
    Apply [`RGate`](qiskit.circuit.library.RGate ""qiskit.circuit.library.RGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** ([*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.parameterexpression.ParameterExpression"")  *|*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The angle of the rotation.
    *   **phi** ([*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.parameterexpression.ParameterExpression"")  *|*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The angle of the axis of rotation in the x-y plane.
    *   **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### rcccx

  <Function id=""qiskit.circuit.QuantumCircuit.rcccx"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3087-L3111"" signature=""rcccx(control_qubit1, control_qubit2, control_qubit3, target_qubit)"">
    Apply [`RC3XGate`](qiskit.circuit.library.RC3XGate ""qiskit.circuit.library.RC3XGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit1** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) used as the first control.
    *   **control\_qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) used as the second control.
    *   **control\_qubit3** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) used as the third control.""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit.circuit.library import Permutation
Write a function that applies a permutation operation on `n_qubits`
 using Qiskit's Permutation gate. The function should return a quantum
 circuit that applies a specific permutation, such as a swap, on the
 qubits.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
pattern (list): A list specifying the permutation pattern (e.g., [2, 1, 0]
 for reversing a 3-qubit order). Returns: QuantumCircuit: The quantum
 circuit with the permutation operation applied.


# Context:
""""""Document 0:::
---
title: Permutation
description: API reference for qiskit.circuit.library.Permutation
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.Permutation
---

# Permutation

<Class id=""qiskit.circuit.library.Permutation"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/permutation.py#L27-L94"" signature=""qiskit.circuit.library.Permutation(num_qubits, pattern=None, seed=None)"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  An n\_qubit circuit that permutes qubits.

  Return an n\_qubit permutation circuit implemented using SWAPs.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – circuit width.
  *   **pattern** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*] | np.ndarray | None*) – permutation pattern, describing which qubits occupy the positions 0, 1, 2, etc. after applying the permutation, that is `pattern[k] = m` when the permutation maps qubit `m` to position `k`. As an example, the pattern `[2, 4, 3, 0, 1]` means that qubit `2` goes to position `0`, qubit `4` goes to the position `1`, etc. The pattern can also be `None`, in which case a random permutation over `num_qubits` is created.
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – random seed in case a random permutation is requested.

  **Raises**

  [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if permutation pattern is malformed.

  **Reference Circuit:**

  ![../\_images/qiskit-circuit-library-Permutation-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-Permutation-1.png)

  **Expanded Circuit:**

  ![../\_images/qiskit-circuit-library-Permutation-2.png](/images/api/qiskit/1.0/qiskit-circuit-library-Permutation-2.png)

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.Permutation.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.Permutation.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.Permutation.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.Permutation.data"">
    Return the circuit data (instructions and context).

    **Returns**

    a list-like object containing the [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")s for each instruction.

    **Return type**

    QuantumCircuitData
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.Permutation.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### instances

  <Attribute id=""qiskit.circuit.library.Permutation.instances"" attributeValue=""225"" />

  ### layout

  <Attribute id=""qiskit.circuit.library.Permutation.layout"">
    Return any associated layout information about the circuit

    This attribute contains an optional [`TranspileLayout`](qiskit.transpiler.TranspileLayout ""qiskit.transpiler.TranspileLayout"") object. This is typically set on the output from [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") or [`PassManager.run()`](qiskit.transpiler.PassManager#run ""qiskit.transpiler.PassManager.run"") to retain information about the permutations caused on the input circuit by transpilation.

    There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.
  </Attribute>

  ### metadata

  <Attribute id=""qiskit.circuit.library.Permutation.metadata"">
    The user provided metadata associated with the circuit.

    The metadata for the circuit is a user provided `dict` of metadata for the circuit. It will not be used to influence the execution or operation of the circuit, but it is expected to be passed between all transforms of the circuit (ie transpilation) and that providers will associate any circuit metadata with the results it returns from execution of that circuit.
  </Attribute>

  ### num\_ancillas

  <Attribute id=""qiskit.circuit.library.Permutation.num_ancillas"">
    Return the number of ancilla qubits.
  </Attribute>

  ### num\_clbitsDocument 1:::
**Returns**

  The synthesized quantum circuit.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **References**

  1.  Samuel A. Kutin, David Petrie Moulton and Lawren M. Smithline. *Computation at a distance.*, [arXiv:quant-ph/0701194v1](https://arxiv.org/abs/quant-ph/0701194)
</Function>

### synth\_permutation\_basic

<Function id=""qiskit.synthesis.synth_permutation_basic"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/permutation/permutation_full.py#L27-L57"" signature=""qiskit.synthesis.synth_permutation_basic(pattern)"">
  Synthesize a permutation circuit for a fully-connected architecture using sorting.

  More precisely, if the input permutation is a cycle of length `m`, then this creates a quantum circuit with `m-1` SWAPs (and of depth `m-1`); if the input permutation consists of several disjoint cycles, then each cycle is essentially treated independently.

  **Parameters**

  **pattern** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*] | np.ndarray\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – Permutation pattern, describing which qubits occupy the positions 0, 1, 2, etc. after applying the permutation. That is, `pattern[k] = m` when the permutation maps qubit `m` to position `k`. As an example, the pattern `[2, 4, 3, 0, 1]` means that qubit `2` goes to position `0`, qubit `4` goes to position `1`, etc.

  **Returns**

  The synthesized quantum circuit.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
</Function>

### synth\_permutation\_acg

<Function id=""qiskit.synthesis.synth_permutation_acg"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/permutation/permutation_full.py#L60-L102"" signature=""qiskit.synthesis.synth_permutation_acg(pattern)"">
  Synthesize a permutation circuit for a fully-connected architecture using the Alon, Chung, Graham method.

  This produces a quantum circuit of depth 2 (measured in the number of SWAPs).

  This implementation is based on the Proposition 4.1 in reference \[1] with the detailed proof given in Theorem 2 in reference \[2]

  **Parameters**

  **pattern** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*] | np.ndarray\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – Permutation pattern, describing which qubits occupy the positions 0, 1, 2, etc. after applying the permutation. That is, `pattern[k] = m` when the permutation maps qubit `m` to position `k`. As an example, the pattern `[2, 4, 3, 0, 1]` means that qubit `2` goes to position `0`, qubit `4` goes to position `1`, etc.

  **Returns**

  The synthesized quantum circuit.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **References**

  1.  N. Alon, F. R. K. Chung, and R. L. Graham. *Routing Permutations on Graphs Via Matchings.*, Proceedings of the Twenty-Fifth Annual ACM Symposium on Theory of Computing(1993). Pages 583–591. [(Extended abstract) 10.1145/167088.167239](https://doi.org/10.1145/167088.167239)
  2.  N. Alon, F. R. K. Chung, and R. L. Graham. *Routing Permutations on Graphs Via Matchings.*, [(Full paper)](https://www.cs.tau.ac.il/~nogaa/PDFS/r.pdf)
</Function>

## Clifford Synthesis

### synth\_clifford\_full

<Function id=""qiskit.synthesis.synth_clifford_full"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/clifford/clifford_decompose_full.py#L24-L64"" signature=""qiskit.synthesis.synth_clifford_full(clifford, method=None)"">
  Decompose a [`Clifford`](qiskit.quantum_info.Clifford ""qiskit.quantum_info.Clifford"") operator into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  For $N \leq 3$ qubits this is based on optimal CX-cost decomposition from reference \[1]. For $N > 3$ qubits this is done using the general non-optimal greedy compilation routine from reference \[3], which typically yields better CX cost compared to the AG method in \[2].

  **Parameters**

  *   **clifford** ([*Clifford*](qiskit.quantum_info.Clifford ""qiskit.quantum_info.Clifford"")) – A Clifford operator.
  *   **method** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Optional, a synthesis method (`'AG'` or `'greedy'`). If set this overrides optimal decomposition for $N \leq 3$ qubits.

  **Returns**

  A circuit implementation of the Clifford.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **References**Document 2:::
There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.
  </Attribute>

  ### metadata

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.metadata"">
    The user provided metadata associated with the circuit.

    The metadata for the circuit is a user provided `dict` of metadata for the circuit. It will not be used to influence the execution or operation of the circuit, but it is expected to be passed between all transforms of the circuit (ie transpilation) and that providers will associate any circuit metadata with the results it returns from execution of that circuit.
  </Attribute>

  ### num\_ancilla\_qubits

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.num_ancilla_qubits"">
    The minimum number of ancilla qubits in the circuit.

    **Returns**

    The minimal number of ancillas required.
  </Attribute>

  ### num\_ancillas

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.num_ancillas"">
    Return the number of ancilla qubits.
  </Attribute>

  ### num\_clbits

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.num_clbits"">
    Return number of classical bits.
  </Attribute>

  ### num\_parameters

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.num_parameters"" />

  ### num\_qubits

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.num_qubits"">
    Return number of qubits.
  </Attribute>

  ### num\_state\_qubits

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.num_state_qubits"">
    The number of state qubits representing the state $|x\rangle$.

    **Returns**

    The number of state qubits.
  </Attribute>

  ### offset

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.offset"">
    The angle of the single qubit offset rotation on the target qubit.

    Before applying the controlled rotations, a single rotation of angle `offset` is applied to the target qubit.

    **Returns**

    The offset angle.
  </Attribute>

  ### op\_start\_times

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.op_start_times"">
    Return a list of operation start times.

    This attribute is enabled once one of scheduling analysis passes runs on the quantum circuit.

    **Returns**

    List of integers representing instruction start times. The index corresponds to the index of instruction in `QuantumCircuit.data`.

    **Raises**

    [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError ""(in Python v3.12)"") – When circuit is not scheduled.
  </Attribute>

  ### parameters

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.parameters"" />

  ### prefix

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.prefix"" attributeValue=""'circuit'"" />

  ### qregs

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.qregs"" attributeTypeHint=""list[QuantumRegister]"">
    A list of the quantum registers associated with the circuit.
  </Attribute>

  ### qubits

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ### slope

  <Attribute id=""qiskit.circuit.library.LinearPauliRotations.slope"">
    The multiplicative factor in the rotation angle of the controlled rotations.

    The rotation angles are `slope * 2^0`, `slope * 2^1`, … , `slope * 2^(n-1)` where `n` is the number of state qubits.

    **Returns**

    The rotation angle common in all controlled rotations.
  </Attribute>
</Class>Document 3:::
There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.
  </Attribute>

  ### metadata

  <Attribute id=""qiskit.circuit.library.TwoLocal.metadata"">
    The user provided metadata associated with the circuit.

    The metadata for the circuit is a user provided `dict` of metadata for the circuit. It will not be used to influence the execution or operation of the circuit, but it is expected to be passed between all transforms of the circuit (ie transpilation) and that providers will associate any circuit metadata with the results it returns from execution of that circuit.
  </Attribute>

  ### num\_ancillas

  <Attribute id=""qiskit.circuit.library.TwoLocal.num_ancillas"">
    Return the number of ancilla qubits.
  </Attribute>

  ### num\_clbits

  <Attribute id=""qiskit.circuit.library.TwoLocal.num_clbits"">
    Return number of classical bits.
  </Attribute>

  ### num\_layers

  <Attribute id=""qiskit.circuit.library.TwoLocal.num_layers"">
    Return the number of layers in the n-local circuit.

    **Returns**

    The number of layers in the circuit.
  </Attribute>

  ### num\_parameters

  <Attribute id=""qiskit.circuit.library.TwoLocal.num_parameters"" />

  ### num\_parameters\_settable

  <Attribute id=""qiskit.circuit.library.TwoLocal.num_parameters_settable"">
    The number of total parameters that can be set to distinct values.

    This does not change when the parameters are bound or exchanged for same parameters, and therefore is different from `num_parameters` which counts the number of unique [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects currently in the circuit.

    **Returns**

    The number of parameters originally available in the circuit.

    <Admonition title=""Note"" type=""note"">
      This quantity does not require the circuit to be built yet.
    </Admonition>
  </Attribute>

  ### num\_qubits

  <Attribute id=""qiskit.circuit.library.TwoLocal.num_qubits"">
    Returns the number of qubits in this circuit.

    **Returns**

    The number of qubits.
  </Attribute>

  ### op\_start\_times

  <Attribute id=""qiskit.circuit.library.TwoLocal.op_start_times"">
    Return a list of operation start times.

    This attribute is enabled once one of scheduling analysis passes runs on the quantum circuit.

    **Returns**

    List of integers representing instruction start times. The index corresponds to the index of instruction in `QuantumCircuit.data`.

    **Raises**

    [**AttributeError**](https://docs.python.org/3/library/exceptions.html#AttributeError ""(in Python v3.12)"") – When circuit is not scheduled.
  </Attribute>

  ### ordered\_parameters

  <Attribute id=""qiskit.circuit.library.TwoLocal.ordered_parameters"">
    The parameters used in the underlying circuit.

    This includes float values and duplicates.

    **Examples**

    ```python
    >>> # prepare circuit ...
    >>> print(nlocal)
         ┌───────┐┌──────────┐┌──────────┐┌──────────┐
    q_0: ┤ Ry(1) ├┤ Ry(θ[1]) ├┤ Ry(θ[1]) ├┤ Ry(θ[3]) ├
         └───────┘└──────────┘└──────────┘└──────────┘
    >>> nlocal.parameters
    {Parameter(θ[1]), Parameter(θ[3])}
    >>> nlocal.ordered_parameters
    [1, Parameter(θ[1]), Parameter(θ[1]), Parameter(θ[3])]
    ```

    **Returns**

    The parameters objects used in the circuit.
  </Attribute>

  ### parameter\_bounds

  <Attribute id=""qiskit.circuit.library.TwoLocal.parameter_bounds"">
    The parameter bounds for the unbound parameters in the circuit.

    **Returns**

    A list of pairs indicating the bounds, as (lower, upper). None indicates an unbounded parameter in the corresponding direction. If `None` is returned, problem is fully unbounded.
  </Attribute>

  ### parameters

  <Attribute id=""qiskit.circuit.library.TwoLocal.parameters"" />

  ### preferred\_init\_points

  <Attribute id=""qiskit.circuit.library.TwoLocal.preferred_init_points"">
    The initial points for the parameters. Can be stored as initial guess in optimization.

    **Returns**

    The initial values for the parameters, or None, if none have been set.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.TwoLocal.prefix"" attributeValue=""'circuit'"" />

  ### qregs

  <Attribute id=""qiskit.circuit.library.TwoLocal.qregs"" attributeTypeHint=""list[QuantumRegister]"">
    A list of the quantum registers associated with the circuit.
  </Attribute>

  ### qubits

  <Attribute id=""qiskit.circuit.library.TwoLocal.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ### reps

  <Attribute id=""qiskit.circuit.library.TwoLocal.reps"">
    The number of times rotation and entanglement block are repeated.

    **Returns**

    The number of repetitions.
  </Attribute>

  ### rotation\_blocksDocument 4:::
*   **final\_layout** ([*Layout*](qiskit.transpiler.Layout ""qiskit.transpiler.Layout"")) – If specified this kwarg can be used to represent the output permutation caused by swap insertions during the routing stage of the transpiler.

    **Returns**

    An operator representing the input circuit

    **Return type**

    [Operator](#qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"")
  </Function>

  ### from\_label

  <Function id=""qiskit.quantum_info.Operator.from_label"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/operator.py#L220-L275"" signature=""from_label(label)"" modifiers=""classmethod"">
    Return a tensor product of single-qubit operators.

    **Parameters**

    **label** (*string*) – single-qubit operator string.

    **Returns**

    The N-qubit operator.

    **Return type**

    [Operator](#qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the label contains invalid characters, or the length of the label is larger than an explicitly specified num\_qubits.

    **Additional Information:**

    The labels correspond to the single-qubit matrices: ‘I’: \[\[1, 0], \[0, 1]] ‘X’: \[\[0, 1], \[1, 0]] ‘Y’: \[\[0, -1j], \[1j, 0]] ‘Z’: \[\[1, 0], \[0, -1]] ‘H’: \[\[1, 1], \[1, -1]] / sqrt(2) ‘S’: \[\[1, 0], \[0 , 1j]] ‘T’: \[\[1, 0], \[0, (1+1j) / sqrt(2)]] ‘0’: \[\[1, 0], \[0, 0]] ‘1’: \[\[0, 0], \[0, 1]] ‘+’: \[\[0.5, 0.5], \[0.5 , 0.5]] ‘-’: \[\[0.5, -0.5], \[-0.5 , 0.5]] ‘r’: \[\[0.5, -0.5j], \[0.5j , 0.5]] ‘l’: \[\[0.5, 0.5j], \[-0.5j , 0.5]]
  </Function>

  ### input\_dims

  <Function id=""qiskit.quantum_info.Operator.input_dims"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/base_operator.py#L135-L137"" signature=""input_dims(qargs=None)"">
    Return tuple of input dimension for specified subsystems.
  </Function>

  ### is\_unitary

  <Function id=""qiskit.quantum_info.Operator.is_unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/operator.py#L429-L435"" signature=""is_unitary(atol=None, rtol=None)"">
    Return True if operator is a unitary matrix.
  </Function>

  ### output\_dims

  <Function id=""qiskit.quantum_info.Operator.output_dims"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/base_operator.py#L139-L141"" signature=""output_dims(qargs=None)"">
    Return tuple of output dimension for specified subsystems.
  </Function>

  ### power

  <Function id=""qiskit.quantum_info.Operator.power"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/operator.py#L511-L539"" signature=""power(n)"">
    Return the matrix power of the operator.

    **Parameters**

    **n** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – the power to raise the matrix to.

    **Returns**

    the resulting operator `O ** n`.

    **Return type**

    [Operator](#qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the input and output dimensions of the operator are not equal.
  </Function>

  ### reshape

  <Function id=""qiskit.quantum_info.Operator.reshape"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/base_operator.py#L106-L133"" signature=""reshape(input_dims=None, output_dims=None, num_qubits=None)"">
    Return a shallow copy with reshaped input and output subsystem dimensions.

    **Parameters**

    *   **input\_dims** (*None or* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")) – new subsystem input dimensions. If None the original input dims will be preserved \[Default: None].
    *   **output\_dims** (*None or* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")) – new subsystem output dimensions. If None the original output dims will be preserved \[Default: None].
    *   **num\_qubits** (*None or* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – reshape to an N-qubit operator \[Default: None].

    **Returns**""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function that constructs a quantum circuit to prepare a W
 state for `n_qubits`. The function should return the quantum circuit
 that generates the W state.
Parameters: n_qubits (int): Number of qubits in the W state.
Returns: QuantumCircuit: The quantum circuit that prepares the
 W state.


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 2:::
</Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### x

  <Function id=""qiskit.circuit.QuantumCircuit.x"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3652-L3666"" signature=""x(qubit, label=None)"">
    Apply [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **qubit** (*QubitSpecifier*) – The qubit(s) to apply the gate to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### y

  <Function id=""qiskit.circuit.QuantumCircuit.y"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3821-L3834"" signature=""y(qubit)"">
    Apply [`YGate`](qiskit.circuit.library.YGate ""qiskit.circuit.library.YGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### z

  <Function id=""qiskit.circuit.QuantumCircuit.z"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3864-L3877"" signature=""z(qubit)"">
    Apply [`ZGate`](qiskit.circuit.library.ZGate ""qiskit.circuit.library.ZGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>
</Class>Document 3:::
*   **true\_body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The circuit body to be run if `condition` is true.
    *   **qubits** (*Optional\[Sequence\[QubitSpecifier]]*) – The circuit qubits over which the if/else should be run.
    *   **clbits** (*Optional\[Sequence\[ClbitSpecifier]]*) – The circuit clbits over which the if/else should be run.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    depending on the call signature, either a context manager for creating the `if` block (it will automatically be added to the circuit at the end of the block), or an [`InstructionSet`](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") handle to the appended conditional operation.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or IfContext

    **Raises**

    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the provided condition references Clbits outside the enclosing circuit.
    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.

    **Returns**

    A handle to the instruction created.
  </Function>

  ### initialize

  <Function id=""qiskit.circuit.QuantumCircuit.initialize"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4069-L4178"" signature=""initialize(params, qubits=None, normalize=False)"">
    Initialize qubits in a specific state.

    Qubit initialization is done by first resetting the qubits to $|0\rangle$ followed by calling [`StatePreparation`](qiskit.circuit.library.StatePreparation ""qiskit.circuit.library.StatePreparation"") class to prepare the qubits in a specified state. Both these steps are included in the [`Initialize`](qiskit.circuit.library.Initialize ""qiskit.circuit.library.Initialize"") instruction.

    **Parameters**

    *   **params** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"") *| Sequence\[*[*complex*](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")*] |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –

        The state to initialize to, can be either of the following.

        *   Statevector or vector of complex amplitudes to initialize to.
        *   Labels of basis states of the Pauli eigenstates Z, X, Y. See [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label""). Notice the order of the labels is reversed with respect to the qubit index to be applied to. Example label ‘01’ initializes the qubit zero to $|1\rangle$ and the qubit one to $|0\rangle$.
        *   An integer that is used as a bitmap indicating which qubits to initialize to $|1\rangle$. Example: setting params to 5 would initialize qubit 0 and qubit 2 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    *   **qubits** (*Sequence\[QubitSpecifier] | None*) – Qubits to initialize. If `None` the initialization is applied to all qubits in the circuit.

    *   **normalize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to normalize an input array to a unit vector.

    **Returns**

    A handle to the instructions created.

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.initialize([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────────────────┐
    q_0: ┤ Initialize(0.70711,-0.70711) ├
         └──────────────────────────────┘
    ```

    Initialize from a string two qubits in the state $|10\rangle$. The order of the labels is reversed with respect to qubit index. More information about labels for basis states are in [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label"").

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────┐
    q_0: ┤0                 ├
         │  Initialize(0,1) │
    q_1: ┤1                 ├
         └──────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌────────────────────────────────────┐
    q_0: ┤0                                   ├
         │  Initialize(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                   ├Document 4:::
A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### power

  <Function id=""qiskit.circuit.QuantumCircuit.power"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L742-L783"" signature=""power(power, matrix_power=False)"">
    Raise this circuit to the power of `power`.

    If `power` is a positive integer and `matrix_power` is `False`, this implementation defaults to calling `repeat`. Otherwise, if the circuit is unitary, the matrix is computed to calculate the matrix power.

    **Parameters**

    *   **power** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The power to raise this circuit to.
    *   **matrix\_power** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, the circuit is converted to a matrix and then the matrix power is computed. If False, and `power` is a positive integer, the implementation defaults to `repeat`.

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the circuit needs to be converted to a gate but it is not unitary.

    **Returns**

    A circuit implementing this circuit raised to the power of `power`.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### prepare\_state

  <Function id=""qiskit.circuit.QuantumCircuit.prepare_state"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3957-L4067"" signature=""prepare_state(state, qubits=None, label=None, normalize=False)"">
    Prepare qubits in a specific state.

    This class implements a state preparing unitary. Unlike [`initialize()`](#qiskit.circuit.QuantumCircuit.initialize ""qiskit.circuit.QuantumCircuit.initialize"") it does not reset the qubits first.

    **Parameters**

    *   **state** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"") *| Sequence\[*[*complex*](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")*] |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –

        The state to initialize to, can be either of the following.

        *   Statevector or vector of complex amplitudes to initialize to.
        *   Labels of basis states of the Pauli eigenstates Z, X, Y. See [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label""). Notice the order of the labels is reversed with respect to the qubit index to be applied to. Example label ‘01’ initializes the qubit zero to $|1\rangle$ and the qubit one to $|0\rangle$.
        *   An integer that is used as a bitmap indicating which qubits to initialize to $|1\rangle$. Example: setting params to 5 would initialize qubit 0 and qubit 2 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    *   **qubits** (*Sequence\[QubitSpecifier] | None*) – Qubits to initialize. If `None` the initialization is applied to all qubits in the circuit.

    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – An optional label for the gate

    *   **normalize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to normalize an input array to a unit vector.

    **Returns**

    A handle to the instruction that was just initialized

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.prepare_state([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────────────────┐
    q_0: ┤ State Preparation(0.70711,-0.70711) ├
         └─────────────────────────────────────┘
    ```

    Prepare from a string two qubits in the state $|10\rangle$. The order of the labels is reversed with respect to qubit index. More information about labels for basis states are in [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label"").

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function that implements the Quantum Counting algorithm.
 The function should create a quantum circuit that estimates the number
 of solutions to a given oracle function using `n_qubits`.
Parameters: n_qubits (int): Number of qubits in the counting register.
Returns: QuantumCircuit: The quantum circuit implementing
 quantum counting. 


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
Run the algorithm.

    **Parameters**

    *   **gate\_matrix** (*np.ndarray*) – The 2x2 matrix representing the gate. This matrix has to be SU(2) up to global phase.
    *   **recursion\_degree** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The recursion degree, called $n$ in the paper.
    *   **return\_dag** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` return a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit ""qiskit.dagcircuit.DAGCircuit""), else a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").
    *   **check\_input** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` check that the input matrix is valid for the decomposition.

    **Returns**

    A one-qubit circuit approximating the `gate_matrix` in the specified discrete basis.

    **Return type**

    QuantumCircuit’ | ‘DAGCircuit
  </Function>
</Class>Document 2:::
ParameterView([Parameter(a), Parameter(b), Parameter(elephant)])
    ```

    Bear in mind that alphabetical sorting might be unintuitive when it comes to numbers. The literal “10” comes before “2” in strict alphabetical sorting.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter
    >>> angles = [Parameter(""angle_1""), Parameter(""angle_2""), Parameter(""angle_10"")]
    >>> circuit = QuantumCircuit(1)
    >>> circuit.u(*angles, 0)
    >>> circuit.draw()
       ┌─────────────────────────────┐
    q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.QuantumCircuit.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.QuantumCircuit.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### add\_bits

  <Function id=""qiskit.circuit.QuantumCircuit.add_bits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1512-L1533"" signature=""add_bits(bits)"">
    Add Bits to the circuit.
  </Function>

  ### add\_calibration

  <Function id=""qiskit.circuit.QuantumCircuit.add_calibration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4806-L4854"" signature=""add_calibration(gate, qubits, schedule, params=None)"">
    Register a low-level, custom pulse definition for the given gate.

    **Parameters**

    *   **gate** (*Union\[*[*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – Gate information.
    *   **qubits** (*Union\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*, Tuple\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]]*) – List of qubits to be measured.
    *   **schedule** ([*Schedule*](qiskit.pulse.Schedule ""qiskit.pulse.Schedule"")) – Schedule information.
    *   **params** (*Optional\[List\[Union\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*,* [*Parameter*](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"")*]]]*) – A list of parameters.

    **Raises**

    [**Exception**](https://docs.python.org/3/library/exceptions.html#Exception ""(in Python v3.12)"") – if the gate is of type string and params is None.
  </Function>

  ### add\_register

  <Function id=""qiskit.circuit.QuantumCircuit.add_register"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1441-L1510"" signature=""add_register(*regs)"">
    Add registers.
  </Function>

  ### append

  <Function id=""qiskit.circuit.QuantumCircuit.append"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1204-L1285"" signature=""append(instruction, qargs=None, cargs=None)"">
    Append one or more instructions to the end of the circuit, modifying the circuit in place.

    The `qargs` and `cargs` will be expanded and broadcast according to the rules of the given [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction""), and any non-[`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"") specifiers (such as integer indices) will be resolved into the relevant instances.

    If a [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"") is given, it will be unwrapped, verified in the context of this circuit, and a new object will be appended to the circuit. In this case, you may not pass `qargs` or `cargs` separately.

    **Parameters**

    *   **instruction** ([*Operation*](qiskit.circuit.Operation ""qiskit.circuit.Operation"")  *|*[*CircuitInstruction*](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")) – [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") instance to append, or a [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"") with all its context.Document 3:::
</Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### x

  <Function id=""qiskit.circuit.QuantumCircuit.x"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3652-L3666"" signature=""x(qubit, label=None)"">
    Apply [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **qubit** (*QubitSpecifier*) – The qubit(s) to apply the gate to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### y

  <Function id=""qiskit.circuit.QuantumCircuit.y"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3821-L3834"" signature=""y(qubit)"">
    Apply [`YGate`](qiskit.circuit.library.YGate ""qiskit.circuit.library.YGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### z

  <Function id=""qiskit.circuit.QuantumCircuit.z"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3864-L3877"" signature=""z(qubit)"">
    Apply [`ZGate`](qiskit.circuit.library.ZGate ""qiskit.circuit.library.ZGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>
</Class>Document 4:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function to construct a quantum circuit that simulates a 
quantum annealing process. The function should return a circuit that
 implements a simple Ising model Hamiltonian on `n_qubits`.
Parameters: n_qubits (int): Number of qubits in the quantum annealing
 simulation.
Returns: QuantumCircuit: The quantum circuit simulating quantum
 annealing.


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")Document 2:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 3:::
Run the algorithm.

    **Parameters**

    *   **gate\_matrix** (*np.ndarray*) – The 2x2 matrix representing the gate. This matrix has to be SU(2) up to global phase.
    *   **recursion\_degree** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The recursion degree, called $n$ in the paper.
    *   **return\_dag** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` return a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit ""qiskit.dagcircuit.DAGCircuit""), else a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").
    *   **check\_input** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` check that the input matrix is valid for the decomposition.

    **Returns**

    A one-qubit circuit approximating the `gate_matrix` in the specified discrete basis.

    **Return type**

    QuantumCircuit’ | ‘DAGCircuit
  </Function>
</Class>Document 4:::
*   **true\_body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The circuit body to be run if `condition` is true.
    *   **qubits** (*Optional\[Sequence\[QubitSpecifier]]*) – The circuit qubits over which the if/else should be run.
    *   **clbits** (*Optional\[Sequence\[ClbitSpecifier]]*) – The circuit clbits over which the if/else should be run.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    depending on the call signature, either a context manager for creating the `if` block (it will automatically be added to the circuit at the end of the block), or an [`InstructionSet`](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") handle to the appended conditional operation.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or IfContext

    **Raises**

    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the provided condition references Clbits outside the enclosing circuit.
    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.

    **Returns**

    A handle to the instruction created.
  </Function>

  ### initialize

  <Function id=""qiskit.circuit.QuantumCircuit.initialize"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4069-L4178"" signature=""initialize(params, qubits=None, normalize=False)"">
    Initialize qubits in a specific state.

    Qubit initialization is done by first resetting the qubits to $|0\rangle$ followed by calling [`StatePreparation`](qiskit.circuit.library.StatePreparation ""qiskit.circuit.library.StatePreparation"") class to prepare the qubits in a specified state. Both these steps are included in the [`Initialize`](qiskit.circuit.library.Initialize ""qiskit.circuit.library.Initialize"") instruction.

    **Parameters**

    *   **params** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"") *| Sequence\[*[*complex*](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")*] |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –

        The state to initialize to, can be either of the following.

        *   Statevector or vector of complex amplitudes to initialize to.
        *   Labels of basis states of the Pauli eigenstates Z, X, Y. See [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label""). Notice the order of the labels is reversed with respect to the qubit index to be applied to. Example label ‘01’ initializes the qubit zero to $|1\rangle$ and the qubit one to $|0\rangle$.
        *   An integer that is used as a bitmap indicating which qubits to initialize to $|1\rangle$. Example: setting params to 5 would initialize qubit 0 and qubit 2 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    *   **qubits** (*Sequence\[QubitSpecifier] | None*) – Qubits to initialize. If `None` the initialization is applied to all qubits in the circuit.

    *   **normalize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to normalize an input array to a unit vector.

    **Returns**

    A handle to the instructions created.

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.initialize([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────────────────┐
    q_0: ┤ Initialize(0.70711,-0.70711) ├
         └──────────────────────────────┘
    ```

    Initialize from a string two qubits in the state $|10\rangle$. The order of the labels is reversed with respect to qubit index. More information about labels for basis states are in [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label"").

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────┐
    q_0: ┤0                 ├
         │  Initialize(0,1) │
    q_1: ┤1                 ├
         └──────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌────────────────────────────────────┐
    q_0: ┤0                                   ├
         │  Initialize(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                   ├""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit.quantum_info import random_unitary
Write a function that applies a random unitary operation to a quantum
 circuit using `n_qubits`. The function should generate a random unitary
 matrix and apply it to all qubits in the circuit. 
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
Returns: QuantumCircuit: The quantum circuit with the random
 unitary operation applied.


# Context:
""""""Document 0:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")Document 1:::
Generate random circuit of arbitrary size and form.

  This function will generate a random circuit by randomly selecting gates from the set of standard gates in `qiskit.circuit.library.standard_gates`. For example:

  ```python
  from qiskit.circuit.random import random_circuit

  circ = random_circuit(2, 2, measure=True)
  circ.draw(output='mpl')
  ```

  ![../\_images/circuit-5.png](/images/api/qiskit/1.0/circuit-5.png)

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – number of quantum wires
  *   **depth** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – layers of operations (i.e. critical path length)
  *   **max\_operands** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – maximum qubit operands of each gate (between 1 and 4)
  *   **measure** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, measure all qubits at the end
  *   **conditional** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle measurements and conditionals
  *   **reset** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle resets
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – sets random seed (optional)

  **Returns**

  constructed circuit

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**CircuitError**](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – when invalid options given
</Function>

### Exceptions

Almost all circuit functions and methods will raise a [`CircuitError`](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") when encountering an error that is particular to usage of Qiskit (as opposed to regular typing or indexing problems, which will typically raise the corresponding standard Python error).

#### CircuitError

<Class id=""qiskit.circuit.CircuitError"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/exceptions.py#L18-L19"" signature=""qiskit.circuit.CircuitError(*message)"" modifiers=""exception"">
  Base class for errors raised while processing a circuit.

  Set the error message.
</Class>Document 2:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 3:::
---
title: utils
description: API reference for qiskit_transpiler_service.utils
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit_transpiler_service.utils
---

<span id=""utilities-qiskit-transpiler-service-utils"" />

<span id=""module-qiskit_transpiler_service.utils"" />

# Utilities

<span id=""module-qiskit_transpiler_service.utils"" />

`qiskit_transpiler_service.utils`

## Functions

### create\_random\_linear\_function

<Function id=""qiskit_transpiler_service.utils.create_random_linear_function"" signature=""qiskit_transpiler_service.utils.create_random_linear_function(n_qubits, seed=123)"">
  **Parameters**

  *   **n\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –

  **Return type**

  [*LinearFunction*](/api/qiskit/qiskit.circuit.library.LinearFunction ""(in Qiskit v1.1)"")
</Function>

### get\_metrics

<Function id=""qiskit_transpiler_service.utils.get_metrics"" signature=""qiskit_transpiler_service.utils.get_metrics(qc)"">
  Returns a dict with metrics from a QuantumCircuit

  **Parameters**

  **qc** ([*QuantumCircuit*](/api/qiskit/qiskit.circuit.QuantumCircuit ""(in Qiskit v1.1)"")) –

  **Return type**

  [dict](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")\[[str](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)""), [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")]
</Function>Document 4:::
*   **final\_layout** ([*Layout*](qiskit.transpiler.Layout ""qiskit.transpiler.Layout"")) – If specified this kwarg can be used to represent the output permutation caused by swap insertions during the routing stage of the transpiler.

    **Returns**

    An operator representing the input circuit

    **Return type**

    [Operator](#qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"")
  </Function>

  ### from\_label

  <Function id=""qiskit.quantum_info.Operator.from_label"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/operator.py#L220-L275"" signature=""from_label(label)"" modifiers=""classmethod"">
    Return a tensor product of single-qubit operators.

    **Parameters**

    **label** (*string*) – single-qubit operator string.

    **Returns**

    The N-qubit operator.

    **Return type**

    [Operator](#qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the label contains invalid characters, or the length of the label is larger than an explicitly specified num\_qubits.

    **Additional Information:**

    The labels correspond to the single-qubit matrices: ‘I’: \[\[1, 0], \[0, 1]] ‘X’: \[\[0, 1], \[1, 0]] ‘Y’: \[\[0, -1j], \[1j, 0]] ‘Z’: \[\[1, 0], \[0, -1]] ‘H’: \[\[1, 1], \[1, -1]] / sqrt(2) ‘S’: \[\[1, 0], \[0 , 1j]] ‘T’: \[\[1, 0], \[0, (1+1j) / sqrt(2)]] ‘0’: \[\[1, 0], \[0, 0]] ‘1’: \[\[0, 0], \[0, 1]] ‘+’: \[\[0.5, 0.5], \[0.5 , 0.5]] ‘-’: \[\[0.5, -0.5], \[-0.5 , 0.5]] ‘r’: \[\[0.5, -0.5j], \[0.5j , 0.5]] ‘l’: \[\[0.5, 0.5j], \[-0.5j , 0.5]]
  </Function>

  ### input\_dims

  <Function id=""qiskit.quantum_info.Operator.input_dims"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/base_operator.py#L135-L137"" signature=""input_dims(qargs=None)"">
    Return tuple of input dimension for specified subsystems.
  </Function>

  ### is\_unitary

  <Function id=""qiskit.quantum_info.Operator.is_unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/operator.py#L429-L435"" signature=""is_unitary(atol=None, rtol=None)"">
    Return True if operator is a unitary matrix.
  </Function>

  ### output\_dims

  <Function id=""qiskit.quantum_info.Operator.output_dims"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/base_operator.py#L139-L141"" signature=""output_dims(qargs=None)"">
    Return tuple of output dimension for specified subsystems.
  </Function>

  ### power

  <Function id=""qiskit.quantum_info.Operator.power"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/operator.py#L511-L539"" signature=""power(n)"">
    Return the matrix power of the operator.

    **Parameters**

    **n** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – the power to raise the matrix to.

    **Returns**

    the resulting operator `O ** n`.

    **Return type**

    [Operator](#qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the input and output dimensions of the operator are not equal.
  </Function>

  ### reshape

  <Function id=""qiskit.quantum_info.Operator.reshape"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/base_operator.py#L106-L133"" signature=""reshape(input_dims=None, output_dims=None, num_qubits=None)"">
    Return a shallow copy with reshaped input and output subsystem dimensions.

    **Parameters**

    *   **input\_dims** (*None or* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")) – new subsystem input dimensions. If None the original input dims will be preserved \[Default: None].
    *   **output\_dims** (*None or* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")) – new subsystem output dimensions. If None the original output dims will be preserved \[Default: None].
    *   **num\_qubits** (*None or* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – reshape to an N-qubit operator \[Default: None].

    **Returns**""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function that constructs a quantum circuit to simulate
 a boson sampling problem. The function should generate the circuit
 based on `n_qubits` corresponding to the number of photons and
 modes.
Parameters: n_qubits (int): Number of qubits, representing the number
 of photons and modes in the boson sampling.
Returns: QuantumCircuit: The quantum circuit that simulates the
 boson sampling.


# Context:
""""""Document 0:::
Generate random circuit of arbitrary size and form.

  This function will generate a random circuit by randomly selecting gates from the set of standard gates in `qiskit.circuit.library.standard_gates`. For example:

  ```python
  from qiskit.circuit.random import random_circuit

  circ = random_circuit(2, 2, measure=True)
  circ.draw(output='mpl')
  ```

  ![../\_images/circuit-5.png](/images/api/qiskit/1.0/circuit-5.png)

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – number of quantum wires
  *   **depth** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – layers of operations (i.e. critical path length)
  *   **max\_operands** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – maximum qubit operands of each gate (between 1 and 4)
  *   **measure** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, measure all qubits at the end
  *   **conditional** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle measurements and conditionals
  *   **reset** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle resets
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – sets random seed (optional)

  **Returns**

  constructed circuit

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**CircuitError**](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – when invalid options given
</Function>

### Exceptions

Almost all circuit functions and methods will raise a [`CircuitError`](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") when encountering an error that is particular to usage of Qiskit (as opposed to regular typing or indexing problems, which will typically raise the corresponding standard Python error).

#### CircuitError

<Class id=""qiskit.circuit.CircuitError"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/exceptions.py#L18-L19"" signature=""qiskit.circuit.CircuitError(*message)"" modifiers=""exception"">
  Base class for errors raised while processing a circuit.

  Set the error message.
</Class>Document 1:::
print(f""The primitive-job finished with result {job_result}"")
```

## Overview of SamplerV1

Sampler class calculates probabilities or quasi-probabilities of bitstrings from quantum circuits.

A sampler is initialized with an empty parameter set. The sampler is used to create a [`JobV1`](qiskit.providers.JobV1 ""qiskit.providers.JobV1""), via the [`qiskit.primitives.Sampler.run()`](qiskit.primitives.Sampler#run ""qiskit.primitives.Sampler.run"") method. This method is called with the following parameters

*   quantum circuits ($\psi_i(\theta)$): list of (parameterized) quantum circuits. (a list of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") objects)
*   parameter values ($\theta_k$): list of sets of parameter values to be bound to the parameters of the quantum circuits. (list of list of float)

The method returns a [`JobV1`](qiskit.providers.JobV1 ""qiskit.providers.JobV1"") object, calling [`qiskit.providers.JobV1.result()`](qiskit.providers.JobV1#result ""qiskit.providers.JobV1.result"") yields a [`SamplerResult`](qiskit.primitives.SamplerResult ""qiskit.primitives.SamplerResult"") object, which contains probabilities or quasi-probabilities of bitstrings, plus optional metadata like error bars in the samples.

Here is an example of how sampler is used.

```python
from qiskit.primitives import Sampler
from qiskit import QuantumCircuit
from qiskit.circuit.library import RealAmplitudes

# a Bell circuit
bell = QuantumCircuit(2)
bell.h(0)
bell.cx(0, 1)
bell.measure_all()

# two parameterized circuits
pqc = RealAmplitudes(num_qubits=2, reps=2)
pqc.measure_all()
pqc2 = RealAmplitudes(num_qubits=2, reps=3)
pqc2.measure_all()

theta1 = [0, 1, 1, 2, 3, 5]
theta2 = [0, 1, 2, 3, 4, 5, 6, 7]

# initialization of the sampler
sampler = Sampler()

# Sampler runs a job on the Bell circuit
job = sampler.run(
    circuits=[bell], parameter_values=[[]], parameters=[[]]
)
job_result = job.result()
print([q.binary_probabilities() for q in job_result.quasi_dists])

# Sampler runs a job on the parameterized circuits
job2 = sampler.run(
    circuits=[pqc, pqc2],
    parameter_values=[theta1, theta2],
    parameters=[pqc.parameters, pqc2.parameters])
job_result = job2.result()
print([q.binary_probabilities() for q in job_result.quasi_dists])
```

## Migration from Primitives V1 to V2

The formal distinction between the Primitives V1 and V2 APIs are the base classes from which primitives implementations inherit, which are all listed at the bottom of the page. At a conceptual level, however, here are some notable differences keep in mind when migrating from V1 to V2:

1.  The V2 primitives favour vectorized inputs, where single circuits can be grouped with vector-valued (or more generally, array-valued) specifications. Each group is called a primitive unified bloc (pub), and each pub gets its own result. For example, in the estimator, you can compare the following differences:

    ```python
    # Favoured V2 pattern. There is only one pub here, but there could be more.
    job = estimator_v2.run([(circuit, [obs1, obs2, obs3, obs4])])
    evs = job.result()[0].data.evs

    # V1 equivalent, where the same circuit must be provided four times.
    job = estimator_v1.run([circuit] * 4, [obs1, obs2, obs3, obs4])
    evs = job.result().values
    ```

    Not shown in the above example, for brevity, is that the circuit can be parametric, with arrays of parameter value sets broadcasted against the array of observables. The sampler is similar, but with no observables:

    ```python
    # Favoured V2 pattern. There is only one pub here, but there could be more.
    job = sampler_v2.run([(circuit, [vals1, vals2, vals3])])
    samples = job.result()[0].data

    # V1 equivalent, where the same circuit must be provided three times.
    sampler_v1.run([circuit] * 3, [vals1, vals2, vals3])
    quasi_dists = job.result().quasi_dists
    ```

2.  The V2 sampler returns samples of classical outcomes, preserving the shot order in which they were measured. This is in contrast to the V1 sampler that outputs quasi-probability distributions which are instead an *estimate of the distribution* over classical outcomes. Moreover, the V2 sampler result objects organize data in terms of their input circuits’ classical register names, which provides natural compatibility with dynamic circuits.

    The closest analog of quasi-probability distributions in the V2 interface is the [`get_counts()`](qiskit.primitives.BitArray#get_counts ""qiskit.primitives.BitArray.get_counts"") method, shown in the example below. However, we emphasize that for utility scale experiments (100+ qubits), the chances of measuring the same bitstring twice are small, so that binning like counts in a dictionary format will not typically be an efficient data processing strategy.

    ```python
    circuit = QuantumCircuit(QuantumRegister(2, ""qreg""), ClassicalRegister(2, ""alpha""))
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure([0, 1], [0, 1])

    # V1 sampler usage
    result = sampler_v1.run([circuit]).result()
    quasi_dist = result.quasi_dists[0]

    # V2 sampler usage
    result = sampler_v2.run([circuit]).result()
    # these are the bit values from the alpha register, over all shots
    bitvals = result[0].data.alpha
    # we can use it to generate a Counts mapping, which is similar to a quasi prob distribution
    counts = bitvals.get_counts()
    # which can in turn be converted to the V1 type through normalizationDocument 2:::
Following construction, a sampler is used by calling its [`run()`](qiskit.primitives.BaseSamplerV2#run ""qiskit.primitives.BaseSamplerV2.run"") method with a list of pubs (Primitive Unified Blocs). Each pub contains values that, together, define a computational unit of work for the sampler to complete:

*   A single [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit""), possibly parameterized.
*   A collection parameter value sets to bind the circuit against if it is parametric.
*   Optionally, the number of shots to sample, determined in the run method if not set.

Running an estimator returns a [`BasePrimitiveJob`](qiskit.primitives.BasePrimitiveJob ""qiskit.primitives.BasePrimitiveJob"") object, where calling the method [`result()`](qiskit.primitives.BasePrimitiveJob#result ""qiskit.primitives.BasePrimitiveJob.result"") results in output samples and metadata for each pub.

Here is an example of how a sampler is used.

```python
from qiskit.primitives import StatevectorSampler as Sampler
from qiskit import QuantumCircuit
from qiskit.circuit.library import RealAmplitudes

# create a Bell circuit
bell = QuantumCircuit(2)
bell.h(0)
bell.cx(0, 1)
bell.measure_all()

# create two parameterized circuits
pqc = RealAmplitudes(num_qubits=2, reps=2)
pqc.measure_all()
pqc2 = RealAmplitudes(num_qubits=2, reps=3)
pqc2.measure_all()

theta1 = [0, 1, 1, 2, 3, 5]
theta2 = [0, 1, 2, 3, 4, 5, 6, 7]

# initialization of the sampler
sampler = Sampler()

# collect 128 shots from the Bell circuit
job = sampler.run([bell], shots=128)
job_result = job.result()
print(f""The primitive-job finished with result {job_result}""))

# run a sampler job on the parameterized circuits
job2 = sampler.run([(pqc, theta1), (pqc2, theta2)]
job_result = job2.result()
print(f""The primitive-job finished with result {job_result}""))
```

## Overview of EstimatorV1

Estimator class estimates expectation values of quantum circuits and observables.

An estimator is initialized with an empty parameter set. The estimator is used to create a [`JobV1`](qiskit.providers.JobV1 ""qiskit.providers.JobV1""), via the [`qiskit.primitives.Estimator.run()`](qiskit.primitives.Estimator#run ""qiskit.primitives.Estimator.run"") method. This method is called with the following parameters

*   quantum circuits ($\psi_i(\theta)$): list of (parameterized) quantum circuits (a list of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") objects).
*   observables ($H_j$): a list of [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp ""qiskit.quantum_info.SparsePauliOp"") objects.
*   parameter values ($\theta_k$): list of sets of values to be bound to the parameters of the quantum circuits (list of list of float).

The method returns a [`JobV1`](qiskit.providers.JobV1 ""qiskit.providers.JobV1"") object, calling [`qiskit.providers.JobV1.result()`](qiskit.providers.JobV1#result ""qiskit.providers.JobV1.result"") yields the a list of expectation values plus optional metadata like confidence intervals for the estimation.

$$
\langle\psi_i(\theta_k)|H_j|\psi_i(\theta_k)\rangle
$$

Here is an example of how the estimator is used.

```python
from qiskit.primitives import Estimator
from qiskit.circuit.library import RealAmplitudes
from qiskit.quantum_info import SparsePauliOp

psi1 = RealAmplitudes(num_qubits=2, reps=2)
psi2 = RealAmplitudes(num_qubits=2, reps=3)

H1 = SparsePauliOp.from_list([(""II"", 1), (""IZ"", 2), (""XI"", 3)])
H2 = SparsePauliOp.from_list([(""IZ"", 1)])
H3 = SparsePauliOp.from_list([(""ZI"", 1), (""ZZ"", 1)])

theta1 = [0, 1, 1, 2, 3, 5]
theta2 = [0, 1, 1, 2, 3, 5, 8, 13]
theta3 = [1, 2, 3, 4, 5, 6]

estimator = Estimator()

# calculate [ <psi1(theta1)|H1|psi1(theta1)> ]
job = estimator.run([psi1], [H1], [theta1])
job_result = job.result() # It will block until the job finishes.
print(f""The primitive-job finished with result {job_result}""))

# calculate [ <psi1(theta1)|H1|psi1(theta1)>,
#             <psi2(theta2)|H2|psi2(theta2)>,
#             <psi1(theta3)|H3|psi1(theta3)> ]
job2 = estimator.run(
    [psi1, psi2, psi1],
    [H1, H2, H3],
    [theta1, theta2, theta3]
)
job_result = job2.result()
print(f""The primitive-job finished with result {job_result}"")
```

## Overview of SamplerV1

Sampler class calculates probabilities or quasi-probabilities of bitstrings from quantum circuits.

A sampler is initialized with an empty parameter set. The sampler is used to create a [`JobV1`](qiskit.providers.JobV1 ""qiskit.providers.JobV1""), via the [`qiskit.primitives.Sampler.run()`](qiskit.primitives.Sampler#run ""qiskit.primitives.Sampler.run"") method. This method is called with the following parametersDocument 3:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 4:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit.circuit.library import HamiltonianGate
Write a function that implements time evolution under
 a given Hamiltonian for a quantum system. The function should
 create a quantum circuit with `n_qubits` and apply the Hamiltonian
 evolution for a specified time `t`.
Parameters: hamiltonian (array): The Hamiltonian matrix for the
 quantum system.
n_qubits (int): Number of qubits in the quantum circuit.
t (float): Time for which the system evolves.
Returns: QuantumCircuit: The quantum circuit that implements
 the time evolution.


# Context:
""""""Document 0:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")Document 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter
    >>> angles = [Parameter(""angle_1""), Parameter(""angle_2""), Parameter(""angle_10"")]
    >>> circuit = QuantumCircuit(1)
    >>> circuit.u(*angles, 0)
    >>> circuit.draw()
       ┌─────────────────────────────┐
    q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.QuadraticForm.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.QuadraticForm.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### required\_result\_qubits

  <Function id=""qiskit.circuit.library.QuadraticForm.required_result_qubits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/arithmetic/quadratic_form.py#L165-L197"" signature=""required_result_qubits(quadratic, linear, offset)"" modifiers=""static"">
    Get the number of required result qubits.

    **Parameters**

    *   **quadratic** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]]*) – A matrix containing the quadratic coefficients.
    *   **linear** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – An array containing the linear coefficients.
    *   **offset** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – A constant offset.

    **Returns**

    The number of qubits needed to represent the value of the quadratic form in twos complement.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>
</Class>Document 4:::
**Returns**

  the circuit representing the input dag.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.dagcircuit import DAGCircuit
  from qiskit.converters import circuit_to_dag
  from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
  from qiskit.converters import dag_to_circuit

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  dag = circuit_to_dag(circ)
  circuit = dag_to_circuit(dag)
  circuit.draw('mpl')
  ```

  ![../\_images/converters-1.png](/images/api/qiskit/1.0/converters-1.png)
</Function>

### circuit\_to\_instruction

<Function id=""qiskit.converters.circuit_to_instruction"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_instruction.py#L21-L145"" signature=""qiskit.converters.circuit_to_instruction(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build an [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the instruction. If None, existing circuit parameters will also parameterize the instruction.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted instruction will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional instruction label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if parameter\_map is not compatible with circuit

  **Returns**

  an instruction equivalent to the action of the input circuit. Upon decomposition, this instruction will yield the components comprising the original circuit.

  **Return type**

  [qiskit.circuit.Instruction](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.converters import circuit_to_instruction

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  circuit_to_instruction(circ)
  ```
</Function>

### circuit\_to\_gate

<Function id=""qiskit.converters.circuit_to_gate"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_gate.py#L30-L109"" signature=""qiskit.converters.circuit_to_gate(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The gate is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The gate will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the gate. If None, existing circuit parameters will also parameterize the Gate.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted gate will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional gate label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if circuit is non-unitary or if parameter\_map is not compatible with circuit

  **Returns**

  a Gate equivalent to the action of the input circuit. Upon decomposition, this gate will yield the components comprising the original circuit.

  **Return type**

  [Gate](qiskit.circuit.Gate ""qiskit.circuit.Gate"")""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function that implements the Quantum Metropolis algorithm
 for simulating thermal states. The function should return a quantum
 circuit that approximates the thermal state of a quantum system with
 `n_qubits`.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
beta (float): Inverse temperature (1/kT) for the thermal state simulation.
Returns: QuantumCircuit: The quantum circuit implementing the
 Quantum Metropolis algorithm.


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
Run the algorithm.

    **Parameters**

    *   **gate\_matrix** (*np.ndarray*) – The 2x2 matrix representing the gate. This matrix has to be SU(2) up to global phase.
    *   **recursion\_degree** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The recursion degree, called $n$ in the paper.
    *   **return\_dag** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` return a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit ""qiskit.dagcircuit.DAGCircuit""), else a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").
    *   **check\_input** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` check that the input matrix is valid for the decomposition.

    **Returns**

    A one-qubit circuit approximating the `gate_matrix` in the specified discrete basis.

    **Return type**

    QuantumCircuit’ | ‘DAGCircuit
  </Function>
</Class>Document 2:::
**Raises**

  *   [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the input state is not a valid QuantumState.
  *   [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if input is not a bipartite QuantumState.
  *   [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if density matrix input is not a 2-qubit state.
</Function>

### entropy

<Function id=""qiskit.quantum_info.entropy"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/measures.py#L105-L131"" signature=""qiskit.quantum_info.entropy(state, base=2)"">
  Calculate the von-Neumann entropy of a quantum state.

  The entropy $S$ is given by

$$
S(\rho) = - Tr[\rho \log(\rho)]
$$

  **Parameters**

  *   **state** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"")  *or*[*DensityMatrix*](qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")) – a quantum state.
  *   **base** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – the base of the logarithm \[Default: 2].

  **Returns**

  The von-Neumann entropy S(rho).

  **Return type**

  [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the input state is not a valid QuantumState.
</Function>

### entanglement\_of\_formation

<Function id=""qiskit.quantum_info.entanglement_of_formation"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/measures.py#L225-L257"" signature=""qiskit.quantum_info.entanglement_of_formation(state)"">
  Calculate the entanglement of formation of quantum state.

  The input quantum state must be either a bipartite state vector, or a 2-qubit density matrix.

  **Parameters**

  **state** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"")  *or*[*DensityMatrix*](qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")) – a 2-qubit quantum state.

  **Returns**

  The entanglement of formation.

  **Return type**

  [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")

  **Raises**

  *   [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the input state is not a valid QuantumState.
  *   [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if input is not a bipartite QuantumState.
  *   [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if density matrix input is not a 2-qubit state.
</Function>

### mutual\_information

<Function id=""qiskit.quantum_info.mutual_information"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/measures.py#L134-L162"" signature=""qiskit.quantum_info.mutual_information(state, base=2)"">
  Calculate the mutual information of a bipartite state.

  The mutual information $I$ is given by:

$$
I(\rho_{AB}) = S(\rho_A) + S(\rho_B) - S(\rho_{AB})
$$

  where $\rho_A=Tr_B[\rho_{AB}], \rho_B=Tr_A[\rho_{AB}]$, are the reduced density matrices of the bipartite state $\rho_{AB}$.

  **Parameters**

  *   **state** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"")  *or*[*DensityMatrix*](qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")) – a bipartite state.
  *   **base** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – the base of the logarithm \[Default: 2].

  **Returns**

  The mutual information $I(\rho_{AB})$.

  **Return type**

  [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")

  **Raises**

  *   [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the input state is not a valid QuantumState.
  *   [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if input is not a bipartite QuantumState.
</Function>

## Utility Functions

|                                                                                       |                                    |Document 3:::
**Returns**

    The `QubitProperties` object for the specified qubit. If a list of qubits is provided a list will be returned. If properties are missing for a qubit this can be `None`.

    **Raises**

    **NotImplementedError** – if the backend doesn’t support querying the qubit properties
  </Function>

  ### run

  <Function id=""qiskit_ibm_provider.IBMBackend.run"" signature=""run(circuits, dynamic=None, job_tags=None, init_circuit=None, init_num_resets=None, header=None, shots=None, memory=None, meas_level=None, meas_return=None, rep_delay=None, init_qubits=None, use_measure_esp=None, noise_model=None, seed_simulator=None, **run_config)"">
    Run on the backend. If a keyword specified here is also present in the `options` attribute/object, the value specified here will be used for this run.

    **Parameters**

    *   **circuits** (`Union`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit ""(in Qiskit v0.46)""), `str`, `List`\[`Union`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit ""(in Qiskit v0.46)""), `str`]]]) – An individual or a list of `QuantumCircuit`.

    *   **dynamic** (`Optional`\[`bool`]) – Whether the circuit is dynamic (uses in-circuit conditionals)

    *   **job\_tags** (`Optional`\[`List`\[`str`]]) – Tags to be assigned to the job. The tags can subsequently be used as a filter in the `jobs()` function call.

    *   **init\_circuit** (`Optional`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit ""(in Qiskit v0.46)"")]) – A quantum circuit to execute for initializing qubits before each circuit. If specified, `init_num_resets` is ignored. Applicable only if `dynamic=True` is specified.

    *   **init\_num\_resets** (`Optional`\[`int`]) – The number of qubit resets to insert before each circuit execution.

    *   **or** (*The following parameters are applicable only if dynamic=False is specified*) –

    *   **to.** (*defaulted*) –

    *   **header** (`Optional`\[`Dict`]) – User input that will be attached to the job and will be copied to the corresponding result header. Headers do not affect the run. This replaces the old `Qobj` header.

    *   **shots** (`Union`\[`int`, `float`, `None`]) – Number of repetitions of each circuit, for sampling. Default: 4000 or `max_shots` from the backend configuration, whichever is smaller.

    *   **memory** (`Optional`\[`bool`]) – If `True`, per-shot measurement bitstrings are returned as well (provided the backend supports it). For OpenPulse jobs, only measurement level 2 supports this option.

    *   **meas\_level** (`Union`\[`int`, `MeasLevel`, `None`]) –

        Level of the measurement output for pulse experiments. See [OpenPulse specification](https://arxiv.org/pdf/1809.03452.pdf) for details:

        *   `0`, measurements of the raw signal (the measurement output pulse envelope)
        *   `1`, measurement kernel is selected (a complex number obtained after applying the measurement kernel to the measurement output signal)
        *   `2` (default), a discriminator is selected and the qubit state is stored (0 or 1)

    *   **meas\_return** (`Union`\[`str`, `MeasReturnType`, `None`]) –

        Level of measurement data for the backend to return. For `meas_level` 0 and 1:

        *   `single` returns information from every shot.
        *   `avg` returns average measurement output (averaged over number of shots).

    *   **rep\_delay** (`Optional`\[`float`]) – Delay between programs in seconds. Only supported on certain backends (if `backend.configuration().dynamic_reprate_enabled=True`). If supported, `rep_delay` must be from the range supplied by the backend (`backend.configuration().rep_delay_range`). Default is given by `backend.configuration().default_rep_delay`.

    *   **init\_qubits** (`Optional`\[`bool`]) – Whether to reset the qubits to the ground state for each shot. Default: `True`.

    *   **use\_measure\_esp** (`Optional`\[`bool`]) – Whether to use excited state promoted (ESP) readout for measurements which are the terminal instruction to a qubit. ESP readout can offer higher fidelity than standard measurement sequences. See [here](https://arxiv.org/pdf/2008.08571.pdf). Default: `True` if backend supports ESP readout, else `False`. Backend support for ESP readout is determined by the flag `measure_esp_enabled` in `backend.configuration()`.

    *   **noise\_model** (`Optional`\[`Any`]) – Noise model. (Simulators only)

    *   **seed\_simulator** (`Optional`\[`int`]) – Random seed to control sampling. (Simulators only)

    *   **\*\*run\_config** – Extra arguments used to configure the run.

    **Return type**

    `IBMJob`

    **Returns**

    The job to be executed.

    **Raises**

    *   [**IBMBackendApiError**](qiskit_ibm_provider.IBMBackendApiError ""qiskit_ibm_provider.IBMBackendApiError"") – If an unexpected error occurred while submitting the job.

    *   [**IBMBackendApiProtocolError**](qiskit_ibm_provider.IBMBackendApiProtocolError ""qiskit_ibm_provider.IBMBackendApiProtocolError"") – If an unexpected value received from the server.

    *   [**IBMBackendValueError**](qiskit_ibm_provider.IBMBackendValueError ""qiskit_ibm_provider.IBMBackendValueError"") –

        *   If an input parameter value is not valid. - If ESP readout is used and the backend does not support this.
  </Function>

  ### set\_options

  <Function id=""qiskit_ibm_provider.IBMBackend.set_options"" signature=""set_options(**fields)"">Document 4:::
*   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Optional number of times the circuit should be decomposed. For instance, `reps=2` equals calling `circuit.decompose().decompose()`. can decompose specific gates specific time

    **Returns**

    a circuit one level decomposed

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### delay

  <Function id=""qiskit.circuit.QuantumCircuit.delay"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2847-L2871"" signature=""delay(duration, qarg=None, unit='dt')"">
    Apply [`Delay`](qiskit.circuit.Delay ""qiskit.circuit.Delay""). If qarg is `None`, applies to all qubits. When applying to multiple qubits, delays with the same duration will be created.

    **Parameters**

    *   **duration** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *or*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *or*[*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.ParameterExpression"")) – duration of the delay.
    *   **qarg** (*Object*) – qubit argument to apply this delay.
    *   **unit** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – unit of the duration. Supported units: `'s'`, `'ms'`, `'us'`, `'ns'`, `'ps'`, and `'dt'`. Default is `'dt'`, i.e. integer time unit depending on the target backend.

    **Returns**

    handle to the added instructions.

    **Return type**

    [qiskit.circuit.InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if arguments have bad format.
  </Function>

  ### depth

  <Function id=""qiskit.circuit.QuantumCircuit.depth"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1839-L1913"" signature=""depth(filter_function=<function QuantumCircuit.<lambda>>)"">
    Return circuit depth (i.e., length of critical path).

    **Parameters**

    **filter\_function** (*callable*) – A function to filter instructions. Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)). Instructions for which the function returns False are ignored in the computation of the circuit depth. By default filters out “directives”, such as barrier or snapshot.

    **Returns**

    Depth of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")

    **Notes**

    The circuit depth and the DAG depth need not be the same.
  </Function>

  ### draw

  <Function id=""qiskit.circuit.QuantumCircuit.draw"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1655-L1819"" signature=""draw(output=None, scale=None, filename=None, style=None, interactive=False, plot_barriers=True, reverse_bits=None, justify=None, vertical_compression='medium', idle_wires=True, with_layout=True, fold=None, ax=None, initial_state=False, cregbundle=None, wire_order=None, expr_len=30)"">
    Draw the quantum circuit. Use the output parameter to choose the drawing format:

    **text**: ASCII art TextDrawing that can be printed in the console.

    **mpl**: images with color rendered purely in Python using matplotlib.

    **latex**: high-quality images compiled via latex.

    **latex\_source**: raw uncompiled latex output.

    <Admonition title=""Warning"" type=""caution"">
      Support for [`Expr`](circuit_classical#qiskit.circuit.classical.expr.Expr ""qiskit.circuit.classical.expr.Expr"") nodes in conditions and `SwitchCaseOp.target` fields is preliminary and incomplete. The `text` and `mpl` drawers will make a best-effort attempt to show data dependencies, but the LaTeX-based drawers will skip these completely.
    </Admonition>

    **Parameters**

    *   **output** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Select the output method to use for drawing the circuit. Valid choices are `text`, `mpl`, `latex`, `latex_source`. By default the text drawer is used unless the user config file (usually `~/.qiskit/settings.conf`) has an alternative backend set as the default. For example, `circuit_drawer = latex`. If the output kwarg is set, that backend will always be used over the default in the user config file.

    *   **scale** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"") *| None*) – Scale of image to draw (shrink if `< 1.0`). Only used by the `mpl`, `latex` and `latex_source` outputs. Defaults to `1.0`.

    *   **filename** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – File path to save image to. Defaults to `None` (result not saved in a file).""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function that creates a quantum circuit to simulate a
 simple quantum error correction code. The function should initialize
 three qubits, apply an encoding step to protect a single qubit, and then
 simulate an error by applying an X gate to one of the qubits. Finally,
 it should perform a decoding step and measure all qubits.
Returns: QuantumCircuit: The quantum circuit implementing the error
 correction code.


# Context:
""""""Document 0:::
</Function>

Both of these two functions raise [`QASM3ImporterError`](#qiskit.qasm3.QASM3ImporterError ""qiskit.qasm3.QASM3ImporterError"") on failure.

### QASM3ImporterError

<Class id=""qiskit.qasm3.QASM3ImporterError"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/qasm3/exceptions.py#L26-L27"" signature=""qiskit.qasm3.QASM3ImporterError(*message)"" modifiers=""exception"">
  An error raised during the OpenQASM 3 importer.

  Set the error message.
</Class>

For example, we can define a quantum program using OpenQASM 3, and use [`loads()`](#qiskit.qasm3.loads ""qiskit.qasm3.loads"") to directly convert it into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit""):

```python
import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")
```

![../\_images/qasm3-1.png](/images/api/qiskit/1.0/qasm3-1.png)

### Experimental import interface

The import functions given above rely on the ANTLR-based reference parser from the OpenQASM project itself, which is more intended as a language reference than a performant parser. You need to have the extension `qiskit-qasm3-import` installed to use it.

Qiskit is developing a native parser, written in Rust, which is available as part of the core Qiskit package. This parser is still in its early experimental stages, so is missing features and its interface is changing and expanding, but it is typically orders of magnitude more performant for the subset of OpenQASM 3 it currently supports, and its internals produce better error diagnostics on parsing failures.

You can use the experimental interface immediately, with similar functions to the main interface above:

#### load\_experimental

<Function id=""qiskit.qasm3.load_experimental"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/qasm3/__init__.py"" signature=""qiskit.qasm3.load_experimental(pathlike_or_filelike, /, *, custom_gates=None, include_path=None)"">
  Load an OpenQASM 3 program from a source file into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  <Admonition title=""Warning"" type=""caution"">
    This native version of the OpenQASM 3 importer is currently experimental. It is typically much faster than [`load()`](#qiskit.qasm3.load ""qiskit.qasm3.load""), but has a reduced supported feature set, which will expand over time.
  </Admonition>

  **Parameters**

  *   **pathlike\_or\_filelike** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*os.PathLike*](https://docs.python.org/3/library/os.html#os.PathLike ""(in Python v3.12)"")  *|*[*io.TextIOBase*](https://docs.python.org/3/library/io.html#io.TextIOBase ""(in Python v3.12)"")) – the program source. This can either be given as a filepath, or an open text stream object. If the stream is already opened it is consumed in Python space, whereas filenames are opened and consumed in Rust space; there might be slightly different performance characteristics, depending on your system and how the streams are buffered by default.
  *   **custom\_gates** (*Iterable\[*[*CustomGate*](#qiskit.qasm3.CustomGate ""qiskit.qasm3.CustomGate"")*]*) – Python constructors to use for particular named gates. If not supplied, Qiskit will use its own standard-library constructors for gates defined in the OpenQASM 3.0 standard-library file `stdgates.inc`.
  *   **include\_path** (*Iterable\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – the path to search when resolving `include` statements. If not given, Qiskit will arrange for this to point to a location containing `stdgates.inc` only. Paths are tried in the sequence order.

  **Returns**

  the constructed circuit object.

  **Return type**

  [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  **.QASM3ImporterError** – if an error occurred during parsing or semantic analysis. In the case of a parsing error, most of the error messages are printed to the terminal and formatted, for better legibility.
</Function>

#### loads\_experimentalDocument 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
*   **true\_body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The circuit body to be run if `condition` is true.
    *   **qubits** (*Optional\[Sequence\[QubitSpecifier]]*) – The circuit qubits over which the if/else should be run.
    *   **clbits** (*Optional\[Sequence\[ClbitSpecifier]]*) – The circuit clbits over which the if/else should be run.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    depending on the call signature, either a context manager for creating the `if` block (it will automatically be added to the circuit at the end of the block), or an [`InstructionSet`](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") handle to the appended conditional operation.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or IfContext

    **Raises**

    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the provided condition references Clbits outside the enclosing circuit.
    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.

    **Returns**

    A handle to the instruction created.
  </Function>

  ### initialize

  <Function id=""qiskit.circuit.QuantumCircuit.initialize"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4069-L4178"" signature=""initialize(params, qubits=None, normalize=False)"">
    Initialize qubits in a specific state.

    Qubit initialization is done by first resetting the qubits to $|0\rangle$ followed by calling [`StatePreparation`](qiskit.circuit.library.StatePreparation ""qiskit.circuit.library.StatePreparation"") class to prepare the qubits in a specified state. Both these steps are included in the [`Initialize`](qiskit.circuit.library.Initialize ""qiskit.circuit.library.Initialize"") instruction.

    **Parameters**

    *   **params** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"") *| Sequence\[*[*complex*](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")*] |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –

        The state to initialize to, can be either of the following.

        *   Statevector or vector of complex amplitudes to initialize to.
        *   Labels of basis states of the Pauli eigenstates Z, X, Y. See [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label""). Notice the order of the labels is reversed with respect to the qubit index to be applied to. Example label ‘01’ initializes the qubit zero to $|1\rangle$ and the qubit one to $|0\rangle$.
        *   An integer that is used as a bitmap indicating which qubits to initialize to $|1\rangle$. Example: setting params to 5 would initialize qubit 0 and qubit 2 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    *   **qubits** (*Sequence\[QubitSpecifier] | None*) – Qubits to initialize. If `None` the initialization is applied to all qubits in the circuit.

    *   **normalize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to normalize an input array to a unit vector.

    **Returns**

    A handle to the instructions created.

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.initialize([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────────────────┐
    q_0: ┤ Initialize(0.70711,-0.70711) ├
         └──────────────────────────────┘
    ```

    Initialize from a string two qubits in the state $|10\rangle$. The order of the labels is reversed with respect to qubit index. More information about labels for basis states are in [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label"").

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────┐
    q_0: ┤0                 ├
         │  Initialize(0,1) │
    q_1: ┤1                 ├
         └──────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌────────────────────────────────────┐
    q_0: ┤0                                   ├
         │  Initialize(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                   ├Document 3:::
Generate random circuit of arbitrary size and form.

  This function will generate a random circuit by randomly selecting gates from the set of standard gates in `qiskit.circuit.library.standard_gates`. For example:

  ```python
  from qiskit.circuit.random import random_circuit

  circ = random_circuit(2, 2, measure=True)
  circ.draw(output='mpl')
  ```

  ![../\_images/circuit-5.png](/images/api/qiskit/1.0/circuit-5.png)

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – number of quantum wires
  *   **depth** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – layers of operations (i.e. critical path length)
  *   **max\_operands** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – maximum qubit operands of each gate (between 1 and 4)
  *   **measure** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, measure all qubits at the end
  *   **conditional** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle measurements and conditionals
  *   **reset** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle resets
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – sets random seed (optional)

  **Returns**

  constructed circuit

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**CircuitError**](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – when invalid options given
</Function>

### Exceptions

Almost all circuit functions and methods will raise a [`CircuitError`](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") when encountering an error that is particular to usage of Qiskit (as opposed to regular typing or indexing problems, which will typically raise the corresponding standard Python error).

#### CircuitError

<Class id=""qiskit.circuit.CircuitError"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/exceptions.py#L18-L19"" signature=""qiskit.circuit.CircuitError(*message)"" modifiers=""exception"">
  Base class for errors raised while processing a circuit.

  Set the error message.
</Class>Document 4:::
**Returns**

  the constructed circuit object.

  **Return type**

  [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  **.QASM3ImporterError** – if an error occurred during parsing or semantic analysis. In the case of a parsing error, most of the error messages are printed to the terminal and formatted, for better legibility.
</Function>

#### loads\_experimental

<Function id=""qiskit.qasm3.loads_experimental"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/qasm3/__init__.py"" signature=""qiskit.qasm3.loads_experimental(source, /, *, custom_gates=None, include_path=None)"">
  Load an OpenQASM 3 program from a string into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  <Admonition title=""Warning"" type=""caution"">
    This native version of the OpenQASM 3 importer is currently experimental. It is typically much faster than [`loads()`](#qiskit.qasm3.loads ""qiskit.qasm3.loads""), but has a reduced supported feature set, which will expand over time.
  </Admonition>

  **Parameters**

  *   **source** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – the program source in a Python string.
  *   **custom\_gates** (*Iterable\[*[*CustomGate*](#qiskit.qasm3.CustomGate ""qiskit.qasm3.CustomGate"")*]*) – Python constructors to use for particular named gates. If not supplied, Qiskit will use its own standard-library constructors for gates defined in the OpenQASM 3.0 standard-library file `stdgates.inc`.
  *   **include\_path** (*Iterable\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – the path to search when resolving `include` statements. If not given, Qiskit will arrange for this to point to a location containing `stdgates.inc` only. Paths are tried in the sequence order.

  **Returns**

  the constructed circuit object.

  **Return type**

  [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  **.QASM3ImporterError** – if an error occurred during parsing or semantic analysis. In the case of a parsing error, most of the error messages are printed to the terminal and formatted, for better legibility.
</Function>

These two functions are both experimental, meaning they issue an [`ExperimentalWarning`](exceptions#qiskit.exceptions.ExperimentalWarning ""qiskit.exceptions.ExperimentalWarning"") on usage, and their interfaces may be subject to change within the Qiskit 1.x release series. In particular, the native parser may be promoted to be the default version of [`load()`](#qiskit.qasm3.load ""qiskit.qasm3.load"") and [`loads()`](#qiskit.qasm3.loads ""qiskit.qasm3.loads""). If you are happy to accept the risk of using the experimental interface, you can disable the warning by doing:

```python
import warnings
from qiskit.exceptions import ExperimentalWarning

warnings.filterwarnings(""ignore"", category=ExperimentalWarning, module=""qiskit.qasm3"")
```

These two functions allow for specifying include paths as an iterable of paths, and for specifying custom Python constructors to use for particular gates. These custom constructors are specified by using the [`CustomGate`](#qiskit.qasm3.CustomGate ""qiskit.qasm3.CustomGate"") object:

#### CustomGate

<Class id=""qiskit.qasm3.CustomGate"" signature=""qiskit.qasm3.CustomGate"" modifiers=""class"">
  Information received from Python space about how to construct a Python-space object to represent a given gate that might be declared.
</Class>

In `custom_gates` is not given, Qiskit will attempt to use its standard-library gate objects for the gates defined in OpenQASM 3 standard library file `stdgates.inc`. This sequence of gates is available on this module, if you wish to build on top of it:

**qiskit.qasm3.STDGATES\_INC\_GATES**

A tuple of [`CustomGate`](#qiskit.qasm3.CustomGate ""qiskit.qasm3.CustomGate"") objects specifying the Qiskit constructors to use for the `stdgates.inc` include file.""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
Write a function that transpiles a quantum circuit for a specific
 backend. The function should create a quantum circuit, apply a series
 of gates, and then transpile it for the AerSimulator backend with
 optimization level 3.
Parameters: qc (QuantumCircuit): The input quantum circuit to
 be transpiled.
Returns: QuantumCircuit: The transpiled quantum circuit.


# Context:
""""""Document 0:::
---
title: transpiler
description: API reference for qiskit.transpiler
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.transpiler
---

<span id=""module-qiskit.transpiler"" />

<span id=""qiskit-transpiler"" />

<span id=""transpiler-qiskit-transpiler"" />

# Transpiler

<span id=""module-qiskit.transpiler"" />

`qiskit.transpiler`

## Overview

Transpilation is the process of rewriting a given input circuit to match the topology of a specific quantum device, and/or to optimize the circuit for execution on present day noisy quantum systems.

Most circuits must undergo a series of transformations that make them compatible with a given target device, and optimize them to reduce the effects of noise on the resulting outcomes. Rewriting quantum circuits to match hardware constraints and optimizing for performance can be far from trivial. The flow of logic in the rewriting tool chain need not be linear, and can often have iterative sub-loops, conditional branches, and other complex behaviors. That being said, the standard compilation flow follows the structure given below:

![../\_images/transpiling\_core\_steps.png](/images/api/qiskit/1.0/transpiling_core_steps.png)

Qiskit has four pre-built transpilation pipelines available here: [`qiskit.transpiler.preset_passmanagers`](transpiler_preset#module-qiskit.transpiler.preset_passmanagers ""qiskit.transpiler.preset_passmanagers""). Unless the reader is familiar with quantum circuit optimization methods and their usage, it is best to use one of these ready-made routines. By default the preset pass managers are composed of six stages:

1.  `init` - This stage runs any initial passes that are required before we start embedding the circuit to the backend. This typically involves unrolling custom instructions and converting the circuit to all 1 and 2 qubit gates.
2.  `layout` - This stage applies a layout, mapping the virtual qubits in the circuit to the physical qubits on a backend. See [Layout Stage](#layout-stage) for more details.
3.  `routing` - This stage runs after a layout has been applied and will inject gates (i.e. swaps) into the original circuit to make it compatible with the backend’s connectivity. See [Routing Stage](#routing-stage) for more details.
4.  `translation` - This stage translates the gates in the circuit to the target backend’s basis set. See [Translation Stage](#translation-stage) for more details.
5.  `optimization` - This stage runs the main optimization loop repeatedly until a condition (such as fixed depth) is reached. See [Optimization Stage](#optimization-stage) for more details.
6.  `scheduling` - This stage is for any hardware-aware scheduling passes. See [Scheduling Stage](#scheduling-stage) for more details.

When using [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile""), the implementation of each stage can be modified with the `*_method` arguments (e.g. `layout_method`). These can be set to one of the built-in methods and can also refer to available external plugins. See [`qiskit.transpiler.preset_passmanagers.plugin`](transpiler_plugins#module-qiskit.transpiler.preset_passmanagers.plugin ""qiskit.transpiler.preset_passmanagers.plugin"") for details on this plugin interface.

<span id=""id1"" />

## Working with Preset Pass Managers

Qiskit includes functions to build preset [`PassManager`](qiskit.transpiler.PassManager ""qiskit.transpiler.PassManager"") objects. These preset passmanagers are used by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function for each optimization level. There are 4 optimization levels ranging from 0 to 3, where higher optimization levels take more time and computational effort but may yield a more optimal circuit. Optimization level 0 is intended for device characterization experiments and, as such, only maps the input circuit to the constraints of the target backend, without performing any optimizations. Optimization level 3 spends the most effort to optimize the circuit. However, as many of the optimization techniques in the transpiler are heuristic based, spending more computational effort does not always result in an improvement in the quality of the output circuit.

If you’d like to work directly with a preset pass manager you can use the [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager ""qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager"") function to easily generate one. For example:

```python
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.providers.fake_provider import GenericBackendV2

backend = GenericBackendV2(num_qubits=5)
pass_manager = generate_preset_pass_manager(3, backend)
```

which will generate a [`StagedPassManager`](qiskit.transpiler.StagedPassManager ""qiskit.transpiler.StagedPassManager"") object for optimization level 3 targeting the [`GenericBackendV2`](qiskit.providers.fake_provider.GenericBackendV2 ""qiskit.providers.fake_provider.GenericBackendV2"") backend (equivalent to what is used internally by [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") with `backend=GenericBackendV2(5)` and `optimization_level=3`). You can use this just like you would any other [`PassManager`](qiskit.transpiler.PassManager ""qiskit.transpiler.PassManager""). However, because it is a [`StagedPassManager`](qiskit.transpiler.StagedPassManager ""qiskit.transpiler.StagedPassManager"") it also makes it easy to compose and/or replace stages of the pipeline. For example, if you wanted to run a custom scheduling stage using dynamical decoupling (via the [`PadDynamicalDecoupling`](qiskit.transpiler.passes.PadDynamicalDecoupling ""qiskit.transpiler.passes.PadDynamicalDecoupling"") pass) and also add initial logical optimization prior to routing, you would do something like (building off the previous example):

```python
import numpy as np
from qiskit.circuit.library import HGate, PhaseGate, RXGate, TdgGate, TGate, XGate
from qiskit.transpiler import PassManager
from qiskit.transpiler.passes import (
    ALAPScheduleAnalysis,
    CXCancellation,
    InverseCancellation,
    PadDynamicalDecoupling,
)

dd_sequence = [XGate(), XGate()]
scheduling_pm = PassManager(
    [
        ALAPScheduleAnalysis(target=backend.target),Document 1:::
---
title: RXCalibrationBuilder
description: API reference for qiskit.transpiler.passes.RXCalibrationBuilder
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.transpiler.passes.RXCalibrationBuilder
---

# RXCalibrationBuilder

<Class id=""qiskit.transpiler.passes.RXCalibrationBuilder"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/transpiler/passes/calibration/rx_builder.py#L29-L138"" signature=""qiskit.transpiler.passes.RXCalibrationBuilder(*args, **kwargs)"" modifiers=""class"">
  Bases: `CalibrationBuilder`

  Add single-pulse RX calibrations that are bootstrapped from the SX calibration.

  <Admonition title=""Note"" type=""note"">
    Requirement: NormalizeRXAngles pass (one of the optimization passes).
  </Admonition>

  It is recommended to place this pass in the post-optimization stage of a passmanager. A simple demo:

  ```python
  from qiskit.providers.fake_provider import GenericBackendV2
  from qiskit.transpiler import PassManager, PassManagerConfig
  from qiskit.transpiler.preset_passmanagers import level_1_pass_manager
  from qiskit.circuit import Parameter
  from qiskit.circuit.library import QuantumVolume
  from qiskit.circuit.library.standard_gates import RXGate

  from calibration.rx_builder import RXCalibrationBuilder

  qv = QuantumVolume(4, 4, seed=1004)

  # Transpiling with single pulse RX gates enabled
  backend_with_single_pulse_rx = GenericBackendV2(5)
  rx_inst_props = {}
  for i in range(backend_with_single_pulse_rx.num_qubits):
    rx_inst_props[(i,)] = None
  backend_with_single_pulse_rx.target.add_instruction(RXGate(Parameter(""theta"")), rx_inst_props)
  config_with_rx = PassManagerConfig.from_backend(backend=backend_with_single_pulse_rx)
  pm_with_rx = level_1_pass_manager(pass_manager_config=config_with_rx)
  rx_builder = RXCalibrationBuilder(target=backend_with_single_pulse_rx.target)
  pm_with_rx.post_optimization = PassManager([rx_builder])
  transpiled_circ_with_single_pulse_rx = pm_with_rx.run(qv)
  transpiled_circ_with_single_pulse_rx.count_ops()

  # Conventional transpilation: each RX gate is decomposed into a sequence with two SX gates
  original_backend = GenericBackendV2(5)
  original_config = PassManagerConfig.from_backend(backend=original_backend)
  original_pm = level_1_pass_manager(pass_manager_config=original_config)
  original_transpiled_circ = original_pm.run(qv)
  original_transpiled_circ.count_ops()
  ```

  **References**

  *   \[1]: Gokhale et al. (2020), Optimized Quantum Compilation for Near-Term Algorithms with OpenPulse. arXiv:2004.11205 \<[https://arxiv.org/abs/2004.11205](https://arxiv.org/abs/2004.11205)>

  Bootstrap single-pulse RX gate calibrations from the (hardware-calibrated) SX gate calibration.

  **Parameters**

  *   **target** ([*Target*](qiskit.transpiler.Target ""qiskit.transpiler.Target"")) – Should contain a SX calibration that will be
  *   **calibrations.** (*used for bootstrapping RX*) –

  ## Attributes

  ### is\_analysis\_pass

  <Attribute id=""qiskit.transpiler.passes.RXCalibrationBuilder.is_analysis_pass"">
    Check if the pass is an analysis pass.

    If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set. Modifications on the DAG are not allowed by this kind of pass.
  </Attribute>

  ### is\_transformation\_pass

  <Attribute id=""qiskit.transpiler.passes.RXCalibrationBuilder.is_transformation_pass"">
    Check if the pass is a transformation pass.

    If the pass is a TransformationPass, that means that the pass can manipulate the DAG, but cannot modify the property set (but it can be read).
  </Attribute>

  ## Methods

  ### execute

  <Function id=""qiskit.transpiler.passes.RXCalibrationBuilder.execute"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/transpiler/basepasses.py#L189-L211"" signature=""execute(passmanager_ir, state, callback=None)"">
    Execute optimization task for input Qiskit IR.

    **Parameters**

    *   **passmanager\_ir** ([*Any*](https://docs.python.org/3/library/typing.html#typing.Any ""(in Python v3.12)"")) – Qiskit IR to optimize.
    *   **state** ([*PassManagerState*](qiskit.passmanager.PassManagerState ""qiskit.passmanager.compilation_status.PassManagerState"")) – State associated with workflow execution by the pass manager itself.
    *   **callback** ([*Callable*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable ""(in Python v3.12)"") *| None*) – A callback function which is caller per execution of optimization task.

    **Returns**

    Optimized Qiskit IR and state of the workflow.

    **Return type**Document 2:::
---
title: TranslateParameterizedGates
description: API reference for qiskit.transpiler.passes.TranslateParameterizedGates
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.transpiler.passes.TranslateParameterizedGates
---

# TranslateParameterizedGates

<Class id=""qiskit.transpiler.passes.TranslateParameterizedGates"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/transpiler/passes/basis/translate_parameterized.py#L29-L151"" signature=""qiskit.transpiler.passes.TranslateParameterizedGates(*args, **kwargs)"" modifiers=""class"">
  Bases: [`TransformationPass`](qiskit.transpiler.TransformationPass ""qiskit.transpiler.basepasses.TransformationPass"")

  Translate parameterized gates to a supported basis set.

  Once a parameterized instruction is found that is not in the `supported_gates` list, the instruction is decomposed one level and the parameterized sub-blocks are recursively decomposed. The recursion is stopped once all parameterized gates are in `supported_gates`, or if a gate has no definition and a translation to the basis is attempted (this might happen e.g. for the `UGate` if it’s not in the specified gate list).

  **Example**

  The following, multiply nested circuit:

  ```python
  from qiskit.circuit import QuantumCircuit, ParameterVector
  from qiskit.transpiler.passes import TranslateParameterizedGates

  x = ParameterVector(""x"", 4)
  block1 = QuantumCircuit(1)
  block1.rx(x[0], 0)

  sub_block = QuantumCircuit(2)
  sub_block.cx(0, 1)
  sub_block.rz(x[2], 0)

  block2 = QuantumCircuit(2)
  block2.ry(x[1], 0)
  block2.append(sub_block.to_gate(), [0, 1])

  block3 = QuantumCircuit(3)
  block3.ccx(0, 1, 2)

  circuit = QuantumCircuit(3)
  circuit.append(block1.to_gate(), [1])
  circuit.append(block2.to_gate(), [0, 1])
  circuit.append(block3.to_gate(), [0, 1, 2])
  circuit.cry(x[3], 0, 2)

  supported_gates = [""rx"", ""ry"", ""rz"", ""cp"", ""crx"", ""cry"", ""crz""]
  unrolled = TranslateParameterizedGates(supported_gates)(circuit)
  ```

  is decomposed to:

  ```python
       ┌──────────┐     ┌──────────┐┌─────────────┐
  q_0: ┤ Ry(x[1]) ├──■──┤ Rz(x[2]) ├┤0            ├─────■──────
       ├──────────┤┌─┴─┐└──────────┘│             │     │
  q_1: ┤ Rx(x[0]) ├┤ X ├────────────┤1 circuit-92 ├─────┼──────
       └──────────┘└───┘            │             │┌────┴─────┐
  q_2: ─────────────────────────────┤2            ├┤ Ry(x[3]) ├
                                    └─────────────┘└──────────┘
  ```

  **Parameters**

  *   **supported\_gates** – A list of suppported basis gates specified as string. If `None`, a `target` must be provided.
  *   **equivalence\_library** – The equivalence library to translate the gates. Defaults to the equivalence library of all Qiskit standard gates.
  *   **target** – A [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target"") containing the supported operations. If `None`, `supported_gates` must be set. Note that this argument takes precedence over `supported_gates`, if both are set.

  **Raises**

  [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError ""(in Python v3.12)"") – If neither of `supported_gates` and `target` are passed.

  ## Attributes

  ### is\_analysis\_pass

  <Attribute id=""qiskit.transpiler.passes.TranslateParameterizedGates.is_analysis_pass"">
    Check if the pass is an analysis pass.

    If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set. Modifications on the DAG are not allowed by this kind of pass.
  </Attribute>

  ### is\_transformation\_pass

  <Attribute id=""qiskit.transpiler.passes.TranslateParameterizedGates.is_transformation_pass"">
    Check if the pass is a transformation pass.

    If the pass is a TransformationPass, that means that the pass can manipulate the DAG, but cannot modify the property set (but it can be read).
  </Attribute>

  ## Methods

  ### execute

  <Function id=""qiskit.transpiler.passes.TranslateParameterizedGates.execute"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/transpiler/basepasses.py#L189-L211"" signature=""execute(passmanager_ir, state, callback=None)"">
    Execute optimization task for input Qiskit IR.

    **Parameters**

    *   **passmanager\_ir** ([*Any*](https://docs.python.org/3/library/typing.html#typing.Any ""(in Python v3.12)"")) – Qiskit IR to optimize.
    *   **state** ([*PassManagerState*](qiskit.passmanager.PassManagerState ""qiskit.passmanager.compilation_status.PassManagerState"")) – State associated with workflow execution by the pass manager itself.
    *   **callback** ([*Callable*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable ""(in Python v3.12)"") *| None*) – A callback function which is caller per execution of optimization task.

    **Returns**

    Optimized Qiskit IR and state of the workflow.

    **Return type**Document 3:::
# H => Z SY
    q = qiskit.QuantumRegister(1, ""q"")
    def_sy_h = qiskit.QuantumCircuit(q)
    def_sy_h.append(ZGate(), [q[0]], [])
    def_sy_h.append(SYGate(), [q[0]], [])
    SessionEquivalenceLibrary.add_equivalence(
        HGate(), def_sy_h)

    # u2 => Z SY Z
    phi = qiskit.circuit.Parameter('phi')
    lam = qiskit.circuit.Parameter('lambda')
    q = qiskit.QuantumRegister(1, ""q"")
    def_sy_u2 = qiskit.QuantumCircuit(q)
    def_sy_u2.append(RZGate(lam), [q[0]], [])
    def_sy_u2.append(SYGate(), [q[0]], [])
    def_sy_u2.append(RZGate(phi), [q[0]], [])
    SessionEquivalenceLibrary.add_equivalence(
        U2Gate(phi, lam), def_sy_u2)
    ```

    You will want this to be run on import so that as soon as the provider’s package is imported it will be run. This will ensure that any time the [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator ""qiskit.transpiler.passes.BasisTranslator"") pass is run with the custom gates the equivalence rules are defined.

    It’s also worth noting that depending on the basis you’re using, some optimization passes in the transpiler, such as [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition ""qiskit.transpiler.passes.Optimize1qGatesDecomposition""), may not be able to operate with your custom basis. For our `SYGate` example, the [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition ""qiskit.transpiler.passes.Optimize1qGatesDecomposition"") will not be able to simplify runs of single qubit gates into the SY basis. This is because the `OneQubitEulerDecomposer` class does not know how to work in the SY basis. To solve this the `SYGate` class would need to be added to Qiskit and `OneQubitEulerDecomposer` updated to support decomposing to the `SYGate`. Longer term that is likely a better direction for custom basis gates and contributing the definitions and support in the transpiler will ensure that it continues to be well supported by Qiskit moving forward.

<span id=""custom-transpiler-backend"" />

#### Custom Transpiler Passes

The transpiler supports the ability for backends to provide custom transpiler stage implementations to facilitate hardware specific optimizations and circuit transformations. Currently there are two stages supported, `get_translation_stage_plugin()` and `get_scheduling_stage_plugin()` which allow a backend to specify string plugin names to be used as the default translation and scheduling stages, respectively. These hook points in a [`BackendV2`](qiskit.providers.BackendV2 ""qiskit.providers.BackendV2"") class can be used if your backend has requirements for compilation that are not met by the current backend/[`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target"") interface. Please also consider submitting a Github issue describing your use case as there is interest in improving these interfaces to be able to describe more hardware architectures in greater depth.

To leverage these hook points you just need to add the methods to your [`BackendV2`](qiskit.providers.BackendV2 ""qiskit.providers.BackendV2"") implementation and have them return a string plugin name. For example:

```python
class Mybackend(BackendV2):

    def get_scheduling_stage_plugin(self):
        return ""SpecialDD""

    def get_translation_stage_plugin(self):
        return ""BasisTranslatorWithCustom1qOptimization""
```

This snippet of a backend implementation will now have the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function use the `SpecialDD` plugin for the scheduling stage and the `BasisTranslatorWithCustom1qOptimization` plugin for the translation stage by default when the target is set to `Mybackend`. Note that users may override these choices by explicitly selecting a different plugin name. For this interface to work though transpiler stage plugins must be implemented for the returned plugin name. You can refer to [`qiskit.transpiler.preset_passmanagers.plugin`](transpiler_plugins#module-qiskit.transpiler.preset_passmanagers.plugin ""qiskit.transpiler.preset_passmanagers.plugin"") module documentation for details on how to implement plugins. The typical expectation is that if your backend requires custom passes as part of a compilation stage the provider package will include the transpiler stage plugins that use those passes. However, this is not required and any valid method (from a built-in method or external plugin) can be used.

This way if these two compilation steps are **required** for running or providing efficient output on `Mybackend` the transpiler will be able to perform these custom steps without any manual user input.

### Run Method

Of key importance is the [`run()`](qiskit.providers.BackendV2#run ""qiskit.providers.BackendV2.run"") method, which is used to actually submit circuits to a device or simulator. The run method handles submitting the circuits to the backend to be executed and returning a [`Job`](qiskit.providers.Job ""qiskit.providers.Job"") object. Depending on the type of backend this typically involves serializing the circuit object into the API format used by a backend. For example, on IBM backends from the `qiskit-ibm-provider` package this involves converting from a quantum circuit and options into a [`qpy`](qpy#module-qiskit.qpy ""qiskit.qpy"") payload embedded in JSON and submitting that to the IBM Quantum API. Since every backend interface is different (and in the case of the local simulators serialization may not be needed) it is expected that the backend’s [`run`](qiskit.providers.BackendV2#run ""qiskit.providers.BackendV2.run"") method will handle this conversion.

An example run method would be something like:

```python
def run(self, circuits. **kwargs):
    for kwarg in kwargs:
        if not hasattr(kwarg, self.options):
            warnings.warn(
                ""Option %s is not used by this backend"" % kwarg,
                UserWarning, stacklevel=2)
    options = {
        'shots': kwargs.get('shots', self.options.shots)
        'memory': kwargs.get('memory', self.options.shots),
    }
    job_json = convert_to_wire_format(circuit, options)
    job_handle = submit_to_backend(job_jsonb)Document 4:::
---
title: AILinearFunctionSynthesis
description: API reference for qiskit_transpiler_service.ai.AILinearFunctionSynthesis
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit_transpiler_service.ai.AILinearFunctionSynthesis
---

# AILinearFunctionSynthesis

<Class id=""qiskit_transpiler_service.ai.AILinearFunctionSynthesis"" isDedicatedPage={true} signature=""qiskit_transpiler_service.ai.AILinearFunctionSynthesis(backend_name: str, replace_only_if_better: bool = True, max_threads: int | None = None)"" modifiers=""class"">
  Bases: `AISynthesis`

  Synthesis for Linear Function circuits (blocks of CX and SWAP gates). Currently up to 9 qubit blocks.

  **Parameters**

  *   **backend\_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Name of the backend used for doing the AI Linear Function synthesis.
  *   **replace\_only\_if\_better** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")*, optional*) – Determine if replace the original circuit with the synthesized one if it’s better, defaults to True.
  *   **max\_threads** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*, optional*) – Set the number of requests to send in parallel.

  ## Methods

  ### execute

  <Function id=""qiskit_transpiler_service.ai.AILinearFunctionSynthesis.execute"" signature=""execute(passmanager_ir, state, callback=None)"">
    Execute optimization task for input Qiskit IR.

    **Parameters**

    *   **passmanager\_ir** ([*Any*](https://docs.python.org/3/library/typing.html#typing.Any ""(in Python v3.12)"")) – Qiskit IR to optimize.
    *   **state** ([*PassManagerState*](/api/qiskit/qiskit.passmanager.PassManagerState ""(in Qiskit v1.1)"")) – State associated with workflow execution by the pass manager itself.
    *   **callback** ([*Callable*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable ""(in Python v3.12)"") *| None*) – A callback function which is caller per execution of optimization task.

    **Returns**

    Optimized Qiskit IR and state of the workflow.

    **Return type**

    [tuple](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")\[[*Any*](https://docs.python.org/3/library/typing.html#typing.Any ""(in Python v3.12)""), [*PassManagerState*](/api/qiskit/qiskit.passmanager.PassManagerState ""(in Qiskit v1.1)"")]
  </Function>

  ### name

  <Function id=""qiskit_transpiler_service.ai.AILinearFunctionSynthesis.name"" signature=""name()"">
    Name of the pass.

    **Return type**

    [str](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")
  </Function>

  ### run

  <Function id=""qiskit_transpiler_service.ai.AILinearFunctionSynthesis.run"" signature=""run(dag)"">
    Run a pass on the DAGCircuit. This is implemented by the pass developer.

    **Parameters**

    **dag** ([*DAGCircuit*](/api/qiskit/qiskit.dagcircuit.DAGCircuit ""(in Qiskit v1.1)"")) – the dag on which the pass is run.

    **Raises**

    [**NotImplementedError**](https://docs.python.org/3/library/exceptions.html#NotImplementedError ""(in Python v3.12)"") – when this is left unimplemented for a pass.
  </Function>

  ### synth\_node

  <Function id=""qiskit_transpiler_service.ai.AILinearFunctionSynthesis.synth_node"" signature=""synth_node(node)"" />

  ### update\_status

  <Function id=""qiskit_transpiler_service.ai.AILinearFunctionSynthesis.update_status"" signature=""update_status(state, run_state)"">
    Update workflow status.

    **Parameters**

    *   **state** ([*PassManagerState*](/api/qiskit/qiskit.passmanager.PassManagerState ""(in Qiskit v1.1)"")) – Pass manager state to update.
    *   **run\_state** (*RunState*) – Completion status of current task.

    **Returns**

    Updated pass manager state.

    **Return type**

    [*PassManagerState*](/api/qiskit/qiskit.passmanager.PassManagerState ""(in Qiskit v1.1)"")
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit.circuit.library import RealAmplitudes
Write a function that creates a variational quantum circuit using the
 RealAmplitudes ansatz with entanglement 'full'. The circuit should
 include `reps` repetitions of the circuit block. 
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
reps (int): Number of repetitions of the circuit block.
Returns: QuantumCircuit: The variational quantum circuit 
using RealAmplitudes ansatz.


# Context:
""""""Document 0:::
---
title: RealAmplitudes
description: API reference for qiskit.circuit.library.RealAmplitudes
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.RealAmplitudes
---

# RealAmplitudes

<Class id=""qiskit.circuit.library.RealAmplitudes"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/n_local/real_amplitudes.py#L25-L186"" signature=""qiskit.circuit.library.RealAmplitudes(num_qubits=None, entanglement='reverse_linear', reps=3, skip_unentangled_qubits=False, skip_final_rotation_layer=False, parameter_prefix='θ', insert_barriers=False, initial_state=None, name='RealAmplitudes', flatten=None)"" modifiers=""class"">
  Bases: [`TwoLocal`](qiskit.circuit.library.TwoLocal ""qiskit.circuit.library.n_local.two_local.TwoLocal"")

  The real-amplitudes 2-local circuit.

  The `RealAmplitudes` circuit is a heuristic trial wave function used as Ansatz in chemistry applications or classification circuits in machine learning. The circuit consists of alternating layers of $Y$ rotations and $CX$ entanglements. The entanglement pattern can be user-defined or selected from a predefined set. It is called `RealAmplitudes` since the prepared quantum states will only have real amplitudes, the complex part is always 0.

  For example a `RealAmplitudes` circuit with 2 repetitions on 3 qubits with `'reverse_linear'` entanglement is

  ```python
  ┌──────────┐ ░            ░ ┌──────────┐ ░            ░ ┌──────────┐
  ┤ Ry(θ[0]) ├─░────────■───░─┤ Ry(θ[3]) ├─░────────■───░─┤ Ry(θ[6]) ├
  ├──────────┤ ░      ┌─┴─┐ ░ ├──────────┤ ░      ┌─┴─┐ ░ ├──────────┤
  ┤ Ry(θ[1]) ├─░───■──┤ X ├─░─┤ Ry(θ[4]) ├─░───■──┤ X ├─░─┤ Ry(θ[7]) ├
  ├──────────┤ ░ ┌─┴─┐└───┘ ░ ├──────────┤ ░ ┌─┴─┐└───┘ ░ ├──────────┤
  ┤ Ry(θ[2]) ├─░─┤ X ├──────░─┤ Ry(θ[5]) ├─░─┤ X ├──────░─┤ Ry(θ[8]) ├
  └──────────┘ ░ └───┘      ░ └──────────┘ ░ └───┘      ░ └──────────┘
  ```

  The entanglement can be set using the `entanglement` keyword as string or a list of index-pairs. See the documentation of [`TwoLocal`](qiskit.circuit.library.TwoLocal ""qiskit.circuit.library.TwoLocal"") and `NLocal` for more detail. Additional options that can be set include the number of repetitions, skipping rotation gates on qubits that are not entangled, leaving out the final rotation layer and inserting barriers in between the rotation and entanglement layers.

  If some qubits are not entangled with other qubits it makes sense to not apply rotation gates on these qubits, since a sequence of $Y$ rotations can be reduced to a single $Y$ rotation with summed rotation angles.

  **Examples**

  ```python
  >>> ansatz = RealAmplitudes(3, reps=2)  # create the circuit on 3 qubits
  >>> print(ansatz)
       ┌──────────┐                 ┌──────────┐                 ┌──────────┐
  q_0: ┤ Ry(θ[0]) ├──────────■──────┤ Ry(θ[3]) ├──────────■──────┤ Ry(θ[6]) ├
       ├──────────┤        ┌─┴─┐    ├──────────┤        ┌─┴─┐    ├──────────┤
  q_1: ┤ Ry(θ[1]) ├──■─────┤ X ├────┤ Ry(θ[4]) ├──■─────┤ X ├────┤ Ry(θ[7]) ├
       ├──────────┤┌─┴─┐┌──┴───┴───┐└──────────┘┌─┴─┐┌──┴───┴───┐└──────────┘
  q_2: ┤ Ry(θ[2]) ├┤ X ├┤ Ry(θ[5]) ├────────────┤ X ├┤ Ry(θ[8]) ├────────────
       └──────────┘└───┘└──────────┘            └───┘└──────────┘
  ```

  ```python
  >>> ansatz = RealAmplitudes(3, entanglement='full', reps=2)  # it is the same unitary as above
  >>> print(ansatz)
       ┌──────────┐          ┌──────────┐                      ┌──────────┐
  q_0: ┤ RY(θ[0]) ├──■────■──┤ RY(θ[3]) ├──────────────■────■──┤ RY(θ[6]) ├────────────
       ├──────────┤┌─┴─┐  │  └──────────┘┌──────────┐┌─┴─┐  │  └──────────┘┌──────────┐
  q_1: ┤ RY(θ[1]) ├┤ X ├──┼───────■──────┤ RY(θ[4]) ├┤ X ├──┼───────■──────┤ RY(θ[7]) ├
       ├──────────┤└───┘┌─┴─┐   ┌─┴─┐    ├──────────┤└───┘┌─┴─┐   ┌─┴─┐    ├──────────┤
  q_2: ┤ RY(θ[2]) ├─────┤ X ├───┤ X ├────┤ RY(θ[5]) ├─────┤ X ├───┤ X ├────┤ RY(θ[8]) ├
       └──────────┘     └───┘   └───┘    └──────────┘     └───┘   └───┘    └──────────┘
  ```

  ```python
  >>> ansatz = RealAmplitudes(3, entanglement='linear', reps=2, insert_barriers=True)
  >>> qc = QuantumCircuit(3)  # create a circuit and append the RY variational form
  >>> qc.compose(ansatz, inplace=True)
  >>> qc.draw()
       ┌──────────┐ ░            ░ ┌──────────┐ ░            ░ ┌──────────┐
  q_0: ┤ RY(θ[0]) ├─░───■────────░─┤ RY(θ[3]) ├─░───■────────░─┤ RY(θ[6]) ├
       ├──────────┤ ░ ┌─┴─┐      ░ ├──────────┤ ░ ┌─┴─┐      ░ ├──────────┤
  q_1: ┤ RY(θ[1]) ├─░─┤ X ├──■───░─┤ RY(θ[4]) ├─░─┤ X ├──■───░─┤ RY(θ[7]) ├
       ├──────────┤ ░ └───┘┌─┴─┐ ░ ├──────────┤ ░ └───┘┌─┴─┐ ░ ├──────────┤
  q_2: ┤ RY(θ[2]) ├─░──────┤ X ├─░─┤ RY(θ[5]) ├─░──────┤ X ├─░─┤ RY(θ[8]) ├
       └──────────┘ ░      └───┘ ░ └──────────┘ ░      └───┘ ░ └──────────┘
  ```

  ```python
  >>> ansatz = RealAmplitudes(4, reps=1, entanglement='circular', insert_barriers=True)
  >>> print(ansatz)
       ┌──────────┐ ░ ┌───┐                ░ ┌──────────┐
  q_0: ┤ RY(θ[0]) ├─░─┤ X ├──■─────────────░─┤ RY(θ[4]) ├
       ├──────────┤ ░ └─┬─┘┌─┴─┐           ░ ├──────────┤
  q_1: ┤ RY(θ[1]) ├─░───┼──┤ X ├──■────────░─┤ RY(θ[5]) ├
       ├──────────┤ ░   │  └───┘┌─┴─┐      ░ ├──────────┤
  q_2: ┤ RY(θ[2]) ├─░───┼───────┤ X ├──■───░─┤ RY(θ[6]) ├
       ├──────────┤ ░   │       └───┘┌─┴─┐ ░ ├──────────┤
  q_3: ┤ RY(θ[3]) ├─░───■────────────┤ X ├─░─┤ RY(θ[7]) ├
       └──────────┘ ░                └───┘ ░ └──────────┘
  ```

  ```python
  >>> ansatz = RealAmplitudes(4, reps=2, entanglement=[[0,3], [0,2]],
  ... skip_unentangled_qubits=True)
  >>> print(ansatz)
       ┌──────────┐                 ┌──────────┐                 ┌──────────┐
  q_0: ┤ RY(θ[0]) ├──■───────■──────┤ RY(θ[3]) ├──■───────■──────┤ RY(θ[6]) ├
       └──────────┘  │       │      └──────────┘  │       │      └──────────┘
  q_1: ──────────────┼───────┼────────────────────┼───────┼──────────────────
       ┌──────────┐  │     ┌─┴─┐    ┌──────────┐  │     ┌─┴─┐    ┌──────────┐
  q_2: ┤ RY(θ[1]) ├──┼─────┤ X ├────┤ RY(θ[4]) ├──┼─────┤ X ├────┤ RY(θ[7]) ├
       ├──────────┤┌─┴─┐┌──┴───┴───┐└──────────┘┌─┴─┐┌──┴───┴───┐└──────────┘
  q_3: ┤ RY(θ[2]) ├┤ X ├┤ RY(θ[5]) ├────────────┤ X ├┤ RY(θ[8]) ├────────────
       └──────────┘└───┘└──────────┘            └───┘└──────────┘
  ```Document 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter
    >>> angles = [Parameter(""angle_1""), Parameter(""angle_2""), Parameter(""angle_10"")]
    >>> circuit = QuantumCircuit(1)
    >>> circuit.u(*angles, 0)
    >>> circuit.draw()
       ┌─────────────────────────────┐
    q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.QuadraticForm.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.QuadraticForm.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### required\_result\_qubits

  <Function id=""qiskit.circuit.library.QuadraticForm.required_result_qubits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/arithmetic/quadratic_form.py#L165-L197"" signature=""required_result_qubits(quadratic, linear, offset)"" modifiers=""static"">
    Get the number of required result qubits.

    **Parameters**

    *   **quadratic** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]]*) – A matrix containing the quadratic coefficients.
    *   **linear** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – An array containing the linear coefficients.
    *   **offset** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – A constant offset.

    **Returns**

    The number of qubits needed to represent the value of the quadratic form in twos complement.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>
</Class>Document 4:::
**Returns**

  the circuit representing the input dag.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.dagcircuit import DAGCircuit
  from qiskit.converters import circuit_to_dag
  from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
  from qiskit.converters import dag_to_circuit

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  dag = circuit_to_dag(circ)
  circuit = dag_to_circuit(dag)
  circuit.draw('mpl')
  ```

  ![../\_images/converters-1.png](/images/api/qiskit/1.0/converters-1.png)
</Function>

### circuit\_to\_instruction

<Function id=""qiskit.converters.circuit_to_instruction"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_instruction.py#L21-L145"" signature=""qiskit.converters.circuit_to_instruction(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build an [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the instruction. If None, existing circuit parameters will also parameterize the instruction.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted instruction will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional instruction label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if parameter\_map is not compatible with circuit

  **Returns**

  an instruction equivalent to the action of the input circuit. Upon decomposition, this instruction will yield the components comprising the original circuit.

  **Return type**

  [qiskit.circuit.Instruction](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.converters import circuit_to_instruction

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  circuit_to_instruction(circ)
  ```
</Function>

### circuit\_to\_gate

<Function id=""qiskit.converters.circuit_to_gate"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_gate.py#L30-L109"" signature=""qiskit.converters.circuit_to_gate(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The gate is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The gate will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the gate. If None, existing circuit parameters will also parameterize the Gate.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted gate will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional gate label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if circuit is non-unitary or if parameter\_map is not compatible with circuit

  **Returns**

  a Gate equivalent to the action of the input circuit. Upon decomposition, this gate will yield the components comprising the original circuit.

  **Return type**

  [Gate](qiskit.circuit.Gate ""qiskit.circuit.Gate"")""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function to create a quantum circuit that implements the 
Toffoli (CCX) gate using only basic gates like CX, H, T, and T-dagger. 
The function should take three qubits as input and construct the Toffoli 
gate step by step.
Parameters: control1 (int): The first control qubit index.
control2 (int): The second control qubit index.
target (int): The target qubit index.
Returns: QuantumCircuit: The quantum circuit implementing the 
Toffoli gate.


# Context:
""""""Document 0:::
Converts several classical bit representations (such as indexes, range, etc.) into a list of classical bits.

    **Parameters**

    **clbit\_representation** (*Object*) – representation to expand

    **Returns**

    Where each tuple is a classical bit.

    **Return type**

    List([tuple](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)""))
  </Function>

  ### ccx

  <Function id=""qiskit.circuit.QuantumCircuit.ccx"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3713-L3741"" signature=""ccx(control_qubit1, control_qubit2, target_qubit, ctrl_state=None)"">
    Apply [`CCXGate`](qiskit.circuit.library.CCXGate ""qiskit.circuit.library.CCXGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit1** (*QubitSpecifier*) – The qubit(s) used as the first control.
    *   **control\_qubit2** (*QubitSpecifier*) – The qubit(s) used as the second control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### ccz

  <Function id=""qiskit.circuit.QuantumCircuit.ccz"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3907-L3937"" signature=""ccz(control_qubit1, control_qubit2, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CCZGate`](qiskit.circuit.library.CCZGate ""qiskit.circuit.library.CCZGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit1** (*QubitSpecifier*) – The qubit(s) used as the first control.
    *   **control\_qubit2** (*QubitSpecifier*) – The qubit(s) used as the second control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘10’). Defaults to controlling on the ‘11’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### ch

  <Function id=""qiskit.circuit.QuantumCircuit.ch"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2888-L2914"" signature=""ch(control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CHGate`](qiskit.circuit.library.CHGate ""qiskit.circuit.library.CHGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### clear

  <Function id=""qiskit.circuit.QuantumCircuit.clear"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2144-L2152"" signature=""clear()"">
    Clear all instructions in self.

    Clearing the circuits will keep the metadata and calibrations.
  </Function>

  ### cls\_instancesDocument 1:::
For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the controls.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### dcx

  <Function id=""qiskit.circuit.QuantumCircuit.dcx"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3697-L3711"" signature=""dcx(qubit1, qubit2)"">
    Apply [`DCXGate`](qiskit.circuit.library.DCXGate ""qiskit.circuit.library.DCXGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **qubit1** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.
    *   **qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### decompose

  <Function id=""qiskit.circuit.QuantumCircuit.decompose"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1620-L1653"" signature=""decompose(gates_to_decompose=None, reps=1)"">
    Call a decomposition pass on this circuit, to decompose one level (shallow decompose).

    **Parameters**

    *   **gates\_to\_decompose** ([*type*](https://docs.python.org/3/library/functions.html#type ""(in Python v3.12)"")  *or*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *or*[*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*(*[*type*](https://docs.python.org/3/library/functions.html#type ""(in Python v3.12)"")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*)*) – Optional subset of gates to decompose. Can be a gate type, such as `HGate`, or a gate name, such as ‘h’, or a gate label, such as ‘My H Gate’, or a list of any combination of these. If a gate name is entered, it will decompose all gates with that name, whether the gates have labels or not. Defaults to all gates in circuit.
    *   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Optional number of times the circuit should be decomposed. For instance, `reps=2` equals calling `circuit.decompose().decompose()`. can decompose specific gates specific time

    **Returns**

    a circuit one level decomposed

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### delayDocument 2:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### size

  <Function id=""qiskit.circuit.QuantumCircuit.size"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1821-L1837"" signature=""size(filter_function=<function QuantumCircuit.<lambda>>)"">
    Returns total number of instructions in circuit.

    **Parameters**

    **filter\_function** (*callable*) – a function to filter out some instructions. Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)). By default filters out “directives”, such as barrier or snapshot.

    **Returns**

    Total number of gate operations.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### swap

  <Function id=""qiskit.circuit.QuantumCircuit.swap"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3438-L3451"" signature=""swap(qubit1, qubit2)"">
    Apply [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **qubit1** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubits to apply the gate to.
    *   **qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubits to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### switch

  <Function id=""qiskit.circuit.QuantumCircuit.switch"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4681-L4748"" signature=""switch(target: Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int], cases: None, qubits: None, clbits: None, *, label: str | None) → SwitchContext"" extraSignatures={[""switch(target: Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int], cases: Iterable[Tuple[Any, QuantumCircuit]], qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `switch`/`case` structure on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a [`SwitchCaseOp`](qiskit.circuit.SwitchCaseOp ""qiskit.circuit.SwitchCaseOp"") with the given case structure. If `cases` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a [`SwitchCaseOp`](qiskit.circuit.SwitchCaseOp ""qiskit.circuit.SwitchCaseOp"") when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, ClassicalRegister, QuantumRegister
    qreg = QuantumRegister(3)
    creg = ClassicalRegister(3)
    qc = QuantumCircuit(qreg, creg)
    qc.h([0, 1, 2])
    qc.measure([0, 1, 2], [0, 1, 2])

    with qc.switch(creg) as case:
        with case(0):
            qc.x(0)
        with case(1, 2):
            qc.z(1)
        with case(case.DEFAULT):
            qc.cx(0, 1)
    ```

    **Parameters**Document 3:::
*   **target\_qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) targeted by the gate.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### rccx

  <Function id=""qiskit.circuit.QuantumCircuit.rccx"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3065-L3085"" signature=""rccx(control_qubit1, control_qubit2, target_qubit)"">
    Apply [`RCCXGate`](qiskit.circuit.library.RCCXGate ""qiskit.circuit.library.RCCXGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit1** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) used as the first control.
    *   **control\_qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) used as the second control.
    *   **target\_qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) targeted by the gate.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### remove\_final\_measurements

  <Function id=""qiskit.circuit.QuantumCircuit.remove_final_measurements"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2341-L2402"" signature=""remove_final_measurements(inplace=True)"">
    Removes final measurements and barriers on all qubits if they are present. Deletes the classical registers that were used to store the values from these measurements that become idle as a result of this operation, and deletes classical bits that are referenced only by removed registers, or that aren’t referenced at all but have become idle as a result of this operation.

    Measurements and barriers are considered final if they are followed by no other operations (aside from other measurements or barriers.)

    **Parameters**

    **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – All measurements removed inplace or return new circuit.

    **Returns**

    Returns the resulting circuit when `inplace=False`, else None.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### repeatDocument 4:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### cry

  <Function id=""qiskit.circuit.QuantumCircuit.cry"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3200-L3228"" signature=""cry(theta, control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CRYGate`](qiskit.circuit.library.CRYGate ""qiskit.circuit.library.CRYGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** (*ParameterValueType*) – The angle of the rotation.
    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### crz

  <Function id=""qiskit.circuit.QuantumCircuit.crz"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3265-L3293"" signature=""crz(theta, control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CRZGate`](qiskit.circuit.library.CRZGate ""qiskit.circuit.library.CRZGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **theta** (*ParameterValueType*) – The angle of the rotation.
    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### cs

  <Function id=""qiskit.circuit.QuantumCircuit.cs"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3378-L3406"" signature=""cs(control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CSGate`](qiskit.circuit.library.CSGate ""qiskit.circuit.library.CSGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.
    *   **target\_qubit** (*QubitSpecifier*) – The qubit(s) targeted by the gate.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the gate in the circuit.
    *   **ctrl\_state** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The control state in decimal, or as a bitstring (e.g. ‘1’). Defaults to controlling on the ‘1’ state.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### csdg

  <Function id=""qiskit.circuit.QuantumCircuit.csdg"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3408-L3436"" signature=""csdg(control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CSdgGate`](qiskit.circuit.library.CSdgGate ""qiskit.circuit.library.CSdgGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **control\_qubit** (*QubitSpecifier*) – The qubit(s) used as the control.""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
Write a function to perform quantum state tomography on a 1-qubit
 state. The function should create a quantum circuit that prepares a
 specific quantum state (e.g., |+⟩) and then measure the state in the
 X, Y, and Z bases. The function should simulate the circuit and return
 the measurement results for each basis.
Returns: dict: The measurement results for each tomography basis.


# Context:
""""""Document 0:::
**Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### measure

  <Function id=""qiskit.circuit.QuantumCircuit.measure"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2189-L2264"" signature=""measure(qubit, cbit)"">
    Measure a quantum bit (`qubit`) in the Z basis into a classical bit (`cbit`).

    When a quantum state is measured, a qubit is projected in the computational (Pauli Z) basis to either $\lvert 0 \rangle$ or $\lvert 1 \rangle$. The classical bit `cbit` indicates the result of that projection as a `0` or a `1` respectively. This operation is non-reversible.

    **Parameters**

    *   **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – qubit(s) to measure.
    *   **cbit** ([*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.classicalregister.Clbit"")  *|*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.classicalregister.ClassicalRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.classicalregister.Clbit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – classical bit(s) to place the measurement result(s) in.

    **Returns**

    handle to the added instructions.

    **Return type**

    [qiskit.circuit.InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if arguments have bad format.

    **Examples**

    In this example, a qubit is measured and the result of that measurement is stored in the classical bit (usually expressed in diagrams as a double line):

    ```python
    from qiskit import QuantumCircuit
    circuit = QuantumCircuit(1, 1)
    circuit.h(0)
    circuit.measure(0, 0)
    circuit.draw()
    ```

    ```python
         ┌───┐┌─┐
      q: ┤ H ├┤M├
         └───┘└╥┘
    c: 1/══════╩═
               0
    ```

    It is possible to call `measure` with lists of `qubits` and `cbits` as a shortcut for one-to-one measurement. These two forms produce identical results:

    ```python
    circuit = QuantumCircuit(2, 2)
    circuit.measure([0,1], [0,1])
    ```

    ```python
    circuit = QuantumCircuit(2, 2)
    circuit.measure(0, 0)
    circuit.measure(1, 1)
    ```

    Instead of lists, you can use [`QuantumRegister`](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"") and [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") under the same logic.

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    qreg = QuantumRegister(2, ""qreg"")
    creg = ClassicalRegister(2, ""creg"")
    circuit = QuantumCircuit(qreg, creg)
    circuit.measure(qreg, creg)
    ```

    This is equivalent to:

    ```python
    circuit = QuantumCircuit(qreg, creg)
    circuit.measure(qreg[0], creg[0])
    circuit.measure(qreg[1], creg[1])
    ```
  </Function>

  ### measure\_active

  <Function id=""qiskit.circuit.QuantumCircuit.measure_active"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2266-L2294"" signature=""measure_active(inplace=True)"">
    Adds measurement to all non-idle qubits. Creates a new ClassicalRegister with a size equal to the number of non-idle qubits being measured.

    Returns a new circuit with measurements if inplace=False.

    **Parameters**

    **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – All measurements inplace or return new circuit.

    **Returns**

    Returns circuit with measurements when inplace = False.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### measure\_allDocument 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
The statevector is initialized in the state $|{0,\ldots,0}\rangle$ of the same number of qubits as the input instruction or circuit, evolved by the input instruction, and the output statevector returned.

    **Parameters**

    **instruction** ([*qiskit.circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")  *or*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – instruction or circuit

    **Returns**

    the final density matrix.

    **Return type**

    [DensityMatrix](#qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the instruction contains invalid instructions for density matrix simulation.
  </Function>

  ### from\_int

  <Function id=""qiskit.quantum_info.DensityMatrix.from_int"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/densitymatrix.py#L574-L600"" signature=""from_int(i, dims)"" modifiers=""static"">
    Return a computational basis state density matrix.

    **Parameters**

    *   **i** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – the basis state element.
    *   **dims** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *or*[*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")  *or*[*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")) – The subsystem dimensions of the statevector (See additional information).

    **Returns**

    The computational basis state $|i\rangle\!\langle i|$.

    **Return type**

    [DensityMatrix](#qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")

    **Additional Information:**

    The `dims` kwarg can be an integer or an iterable of integers.

    *   `Iterable` – the subsystem dimensions are the values in the list with the total number of subsystems given by the length of the list.
    *   `Int` – the integer specifies the total dimension of the state. If it is a power of two the state will be initialized as an N-qubit state. If it is not a power of two the state will have a single d-dimensional subsystem.
  </Function>

  ### from\_label

  <Function id=""qiskit.quantum_info.DensityMatrix.from_label"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/densitymatrix.py#L538-L572"" signature=""from_label(label)"" modifiers=""classmethod"">
    Return a tensor product of Pauli X,Y,Z eigenstates.

    | Label | Statevector                                                 |
    | ----- | ----------------------------------------------------------- |
    | `""0""` | $\begin{pmatrix} 1 & 0 \\ 0 & 0 \end{pmatrix}$              |
    | `""1""` | $\begin{pmatrix} 0 & 0 \\ 0 & 1 \end{pmatrix}$              |
    | `""+""` | $\frac{1}{2}\begin{pmatrix} 1 & 1 \\ 1 & 1 \end{pmatrix}$   |
    | `""-""` | $\frac{1}{2}\begin{pmatrix} 1 & -1 \\ -1 & 1 \end{pmatrix}$ |
    | `""r""` | $\frac{1}{2}\begin{pmatrix} 1 & -i \\ i & 1 \end{pmatrix}$  |
    | `""l""` | $\frac{1}{2}\begin{pmatrix} 1 & i \\ -i & 1 \end{pmatrix}$  |

    **Parameters**

    **label** (*string*) – a eigenstate string ket label (see table for allowed values).

    **Returns**

    The N-qubit basis state density matrix.

    **Return type**

    [DensityMatrix](#qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the label contains invalid characters, or the length of the label is larger than an explicitly specified num\_qubits.
  </Function>

  ### is\_valid

  <Function id=""qiskit.quantum_info.DensityMatrix.is_valid"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/densitymatrix.py#L194-L207"" signature=""is_valid(atol=None, rtol=None)"">
    Return True if trace 1 and positive semidefinite.
  </Function>

  ### measure

  <Function id=""qiskit.quantum_info.DensityMatrix.measure"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/quantum_state.py#L306-L341"" signature=""measure(qargs=None)"">
    Measure subsystems and return outcome and post-measure state.

    Note that this function uses the QuantumStates internal random number generator for sampling the measurement outcome. The RNG seed can be set using the [`seed()`](#qiskit.quantum_info.DensityMatrix.seed ""qiskit.quantum_info.DensityMatrix.seed"") method.

    **Parameters**Document 3:::
**Returns**

  the circuit representing the input dag.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.dagcircuit import DAGCircuit
  from qiskit.converters import circuit_to_dag
  from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
  from qiskit.converters import dag_to_circuit

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  dag = circuit_to_dag(circ)
  circuit = dag_to_circuit(dag)
  circuit.draw('mpl')
  ```

  ![../\_images/converters-1.png](/images/api/qiskit/1.0/converters-1.png)
</Function>

### circuit\_to\_instruction

<Function id=""qiskit.converters.circuit_to_instruction"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_instruction.py#L21-L145"" signature=""qiskit.converters.circuit_to_instruction(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build an [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the instruction. If None, existing circuit parameters will also parameterize the instruction.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted instruction will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional instruction label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if parameter\_map is not compatible with circuit

  **Returns**

  an instruction equivalent to the action of the input circuit. Upon decomposition, this instruction will yield the components comprising the original circuit.

  **Return type**

  [qiskit.circuit.Instruction](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.converters import circuit_to_instruction

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  circuit_to_instruction(circ)
  ```
</Function>

### circuit\_to\_gate

<Function id=""qiskit.converters.circuit_to_gate"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_gate.py#L30-L109"" signature=""qiskit.converters.circuit_to_gate(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The gate is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The gate will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the gate. If None, existing circuit parameters will also parameterize the Gate.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted gate will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional gate label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if circuit is non-unitary or if parameter\_map is not compatible with circuit

  **Returns**

  a Gate equivalent to the action of the input circuit. Upon decomposition, this gate will yield the components comprising the original circuit.

  **Return type**

  [Gate](qiskit.circuit.Gate ""qiskit.circuit.Gate"")Document 4:::
*   `Int` – the integer specifies the total dimension of the state. If it is a power of two the state will be initialized as an N-qubit state. If it is not a power of two the state will have a single d-dimensional subsystem.
  </Function>

  ### from\_label

  <Function id=""qiskit.quantum_info.Statevector.from_label"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/statevector.py#L646-L713"" signature=""from_label(label)"" modifiers=""classmethod"">
    Return a tensor product of Pauli X,Y,Z eigenstates.

    | Label | Statevector                     |
    | ----- | ------------------------------- |
    | `""0""` | $[1, 0]$                        |
    | `""1""` | $[0, 1]$                        |
    | `""+""` | $[1 / \sqrt{2}, 1 / \sqrt{2}]$  |
    | `""-""` | $[1 / \sqrt{2}, -1 / \sqrt{2}]$ |
    | `""r""` | $[1 / \sqrt{2}, i / \sqrt{2}]$  |
    | `""l""` | $[1 / \sqrt{2}, -i / \sqrt{2}]$ |

    **Parameters**

    **label** (*string*) – a eigenstate string ket label (see table for allowed values).

    **Returns**

    The N-qubit basis state density matrix.

    **Return type**

    [Statevector](#qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the label contains invalid characters, or the length of the label is larger than an explicitly specified num\_qubits.
  </Function>

  ### inner

  <Function id=""qiskit.quantum_info.Statevector.inner"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/statevector.py#L284-L304"" signature=""inner(other)"">
    Return the inner product of self and other as $\langle self| other \rangle$.

    **Parameters**

    **other** ([*Statevector*](#qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"")) – a quantum state object.

    **Returns**

    the inner product of self and other, $\langle self| other \rangle$.

    **Return type**

    np.complex128

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if other is not a quantum state or has different dimension.
  </Function>

  ### is\_valid

  <Function id=""qiskit.quantum_info.Statevector.is_valid"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/statevector.py#L235-L242"" signature=""is_valid(atol=None, rtol=None)"">
    Return True if a Statevector has norm 1.

    **Return type**

    [bool](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")
  </Function>

  ### measure

  <Function id=""qiskit.quantum_info.Statevector.measure"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/quantum_state.py#L306-L341"" signature=""measure(qargs=None)"">
    Measure subsystems and return outcome and post-measure state.

    Note that this function uses the QuantumStates internal random number generator for sampling the measurement outcome. The RNG seed can be set using the [`seed()`](#qiskit.quantum_info.Statevector.seed ""qiskit.quantum_info.Statevector.seed"") method.

    **Parameters**

    **qargs** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"") *or None*) – subsystems to sample measurements for, if None sample measurement of all subsystems (Default: None).

    **Returns**

    **the pair `(outcome, state)` where `outcome` is the**

    measurement outcome string label, and `state` is the collapsed post-measurement state for the corresponding outcome.

    **Return type**

    [tuple](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")
  </Function>

  ### probabilities

  <Function id=""qiskit.quantum_info.Statevector.probabilities"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/statevector.py#L518-L598"" signature=""probabilities(qargs=None, decimals=None)"">
    Return the subsystem measurement probability vector.

    Measurement probabilities are with respect to measurement in the computation (diagonal) basis.

    **Parameters**

    *   **qargs** (*None or* [*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")) – subsystems to return probabilities for, if None return for all subsystems (Default: None).
    *   **decimals** (*None or* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – the number of decimal places to round values. If None no rounding is done (Default: None).

    **Returns**

    The Numpy vector array of probabilities.

    **Return type**

    np.array

    **Examples**""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function to create a quantum circuit that simulates the
 Bernstein-Vazirani algorithm. The function should generate a hidden
 binary string `s` of length `n_qubits` and create a quantum circuit to
 find this string using a single query to the oracle.
Parameters: s (str): The hidden binary string that the Bernstein-Vazirani
 algorithm will uncover. 
Returns: QuantumCircuit: The quantum circuit implementing
 the Bernstein-Vazirani algorithm.


# Context:
""""""Document 0:::
---
title: HiddenLinearFunction
description: API reference for qiskit.circuit.library.HiddenLinearFunction
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.HiddenLinearFunction
---

# HiddenLinearFunction

<Class id=""qiskit.circuit.library.HiddenLinearFunction"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/hidden_linear_function.py#L22-L98"" signature=""qiskit.circuit.library.HiddenLinearFunction(adjacency_matrix)"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  Circuit to solve the hidden linear function problem.

  The 2D Hidden Linear Function problem is determined by a 2D adjacency matrix A, where only elements that are nearest-neighbor on a grid have non-zero entries. Each row/column corresponds to one binary variable $x_i$.

  The hidden linear function problem is as follows:

  Consider the quadratic form

$$
q(x) = \sum_{i,j=1}^{n}{x_i x_j} ~(\mathrm{mod}~ 4)
$$

  and restrict $q(x)$ onto the nullspace of A. This results in a linear function.

$$
2 \sum_{i=1}^{n}{z_i x_i} ~(\mathrm{mod}~ 4)  \forall  x \in \mathrm{Ker}(A)
$$

  and the goal is to recover this linear function (equivalently a vector $[z_0, ..., z_{n-1}]$). There can be multiple solutions.

  In \[1] it is shown that the present circuit solves this problem on a quantum computer in constant depth, whereas any corresponding solution on a classical computer would require circuits that grow logarithmically with $n$. Thus this circuit is an example of quantum advantage with shallow circuits.

  **Reference Circuit:**

  > ![../\_images/qiskit-circuit-library-HiddenLinearFunction-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-HiddenLinearFunction-1.png)

  **Reference:**

  \[1] S. Bravyi, D. Gosset, R. Koenig, Quantum Advantage with Shallow Circuits, 2017. [arXiv:1704.00690](https://arxiv.org/abs/1704.00690)

  Create new HLF circuit.

  **Parameters**

  **adjacency\_matrix** ([*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]] |* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")) – a symmetric n-by-n list of 0-1 lists. n will be the number of qubits.

  **Raises**

  [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If A is not symmetric.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.data"">
    Return the circuit data (instructions and context).

    **Returns**

    a list-like object containing the [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")s for each instruction.

    **Return type**

    QuantumCircuitData
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### instances

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.instances"" attributeValue=""176"" />

  ### layout

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.layout"">
    Return any associated layout information about the circuit

    This attribute contains an optional [`TranspileLayout`](qiskit.transpiler.TranspileLayout ""qiskit.transpiler.TranspileLayout"") object. This is typically set on the output from [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") or [`PassManager.run()`](qiskit.transpiler.PassManager#run ""qiskit.transpiler.PassManager.run"") to retain information about the permutations caused on the input circuit by transpilation.

    There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.
  </Attribute>Document 1:::
*   **clbits** (*Optional\[Sequence\[ClbitSpecifier]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.

    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    depending on the call signature, either a context manager for creating the for loop (it will automatically be added to the circuit at the end of the block), or an [`InstructionSet`](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") handle to the appended loop operation.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or ForLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### from\_instructions

  <Function id=""qiskit.circuit.QuantumCircuit.from_instructions"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L283-L334"" signature=""from_instructions(instructions, *, qubits=(), clbits=(), name=None, global_phase=0, metadata=None)"" modifiers=""static"">
    Construct a circuit from an iterable of CircuitInstructions.

    **Parameters**

    *   **instructions** (*Iterable\[*[*CircuitInstruction*](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")  *|*[*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*qiskit.circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")*] |* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*qiskit.circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")*, Iterable\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]] |* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*qiskit.circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")*, Iterable\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*], Iterable\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]]*) – The instructions to add to the circuit.
    *   **qubits** (*Iterable\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]*) – Any qubits to add to the circuit. This argument can be used, for example, to enforce a particular ordering of qubits.
    *   **clbits** (*Iterable\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]*) – Any classical bits to add to the circuit. This argument can be used, for example, to enforce a particular ordering of classical bits.
    *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The name of the circuit.
    *   **global\_phase** (*ParameterValueType*) – The global phase of the circuit in radians.
    *   **metadata** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"") *| None*) – Arbitrary key value metadata to associate with the circuit.

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### from\_qasm\_file

  <Function id=""qiskit.circuit.QuantumCircuit.from_qasm_file"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2404-L2427"" signature=""from_qasm_file(path)"" modifiers=""static"">
    Read an OpenQASM 2.0 program from a file and convert to an instance of [`QuantumCircuit`](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

    **Parameters**

    **path** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Path to the file for an OpenQASM 2 program

    **Returns**

    The QuantumCircuit object for the input OpenQASM 2.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    <Admonition title=""See also"" type=""note"">
      [`qasm2.load()`](qasm2#qiskit.qasm2.load ""qiskit.qasm2.load""): the complete interface to the OpenQASM 2 importer.
    </Admonition>
  </Function>

  ### from\_qasm\_str

  <Function id=""qiskit.circuit.QuantumCircuit.from_qasm_str"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2429-L2450"" signature=""from_qasm_str(qasm_str)"" modifiers=""static"">
    Convert a string containing an OpenQASM 2.0 program to a [`QuantumCircuit`](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

    **Parameters**Document 2:::
*   **true\_body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The circuit body to be run if `condition` is true.
    *   **qubits** (*Optional\[Sequence\[QubitSpecifier]]*) – The circuit qubits over which the if/else should be run.
    *   **clbits** (*Optional\[Sequence\[ClbitSpecifier]]*) – The circuit clbits over which the if/else should be run.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    depending on the call signature, either a context manager for creating the `if` block (it will automatically be added to the circuit at the end of the block), or an [`InstructionSet`](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") handle to the appended conditional operation.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or IfContext

    **Raises**

    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the provided condition references Clbits outside the enclosing circuit.
    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.

    **Returns**

    A handle to the instruction created.
  </Function>

  ### initialize

  <Function id=""qiskit.circuit.QuantumCircuit.initialize"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4069-L4178"" signature=""initialize(params, qubits=None, normalize=False)"">
    Initialize qubits in a specific state.

    Qubit initialization is done by first resetting the qubits to $|0\rangle$ followed by calling [`StatePreparation`](qiskit.circuit.library.StatePreparation ""qiskit.circuit.library.StatePreparation"") class to prepare the qubits in a specified state. Both these steps are included in the [`Initialize`](qiskit.circuit.library.Initialize ""qiskit.circuit.library.Initialize"") instruction.

    **Parameters**

    *   **params** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"") *| Sequence\[*[*complex*](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")*] |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –

        The state to initialize to, can be either of the following.

        *   Statevector or vector of complex amplitudes to initialize to.
        *   Labels of basis states of the Pauli eigenstates Z, X, Y. See [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label""). Notice the order of the labels is reversed with respect to the qubit index to be applied to. Example label ‘01’ initializes the qubit zero to $|1\rangle$ and the qubit one to $|0\rangle$.
        *   An integer that is used as a bitmap indicating which qubits to initialize to $|1\rangle$. Example: setting params to 5 would initialize qubit 0 and qubit 2 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    *   **qubits** (*Sequence\[QubitSpecifier] | None*) – Qubits to initialize. If `None` the initialization is applied to all qubits in the circuit.

    *   **normalize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to normalize an input array to a unit vector.

    **Returns**

    A handle to the instructions created.

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.initialize([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────────────────┐
    q_0: ┤ Initialize(0.70711,-0.70711) ├
         └──────────────────────────────┘
    ```

    Initialize from a string two qubits in the state $|10\rangle$. The order of the labels is reversed with respect to qubit index. More information about labels for basis states are in [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label"").

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────┐
    q_0: ┤0                 ├
         │  Initialize(0,1) │
    q_1: ┤1                 ├
         └──────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌────────────────────────────────────┐
    q_0: ┤0                                   ├
         │  Initialize(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                   ├Document 3:::
---
title: QuantumCircuit
description: API reference for qiskit.circuit.QuantumCircuit
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.QuantumCircuit
---

# QuantumCircuit

<Class id=""qiskit.circuit.QuantumCircuit"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L106-L4951"" signature=""qiskit.circuit.QuantumCircuit(*regs, name=None, global_phase=0, metadata=None)"" modifiers=""class"">
  Bases: [`object`](https://docs.python.org/3/library/functions.html#object ""(in Python v3.12)"")

  Create a new circuit.

  A circuit is a list of instructions bound to some registers.

  **Parameters**

  *   **regs** (list([`Register`](qiskit.circuit.Register ""qiskit.circuit.Register"")) or list(`int`) or list(list([`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"")))) –

      The registers to be included in the circuit.

      *   If a list of [`Register`](qiskit.circuit.Register ""qiskit.circuit.Register"") objects, represents the [`QuantumRegister`](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"") and/or [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") objects to include in the circuit.

          For example:

          > *   `QuantumCircuit(QuantumRegister(4))`
          > *   `QuantumCircuit(QuantumRegister(4), ClassicalRegister(3))`
          > *   `QuantumCircuit(QuantumRegister(4, 'qr0'), QuantumRegister(2, 'qr1'))`

      *   If a list of `int`, the amount of qubits and/or classical bits to include in the circuit. It can either be a single int for just the number of quantum bits, or 2 ints for the number of quantum bits and classical bits, respectively.

          For example:

          > *   `QuantumCircuit(4) # A QuantumCircuit with 4 qubits`
          > *   `QuantumCircuit(4, 3) # A QuantumCircuit with 4 qubits and 3 classical bits`

      *   If a list of python lists containing [`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"") objects, a collection of [`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"") s to be added to the circuit.

  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – the name of the quantum circuit. If not set, an automatically generated string will be assigned.

  *   **global\_phase** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *or*[*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.ParameterExpression"")) – The global phase of the circuit in radians.

  *   **metadata** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – Arbitrary key value metadata to associate with the circuit. This gets stored as free-form data in a dict in the [`metadata`](#qiskit.circuit.QuantumCircuit.metadata ""qiskit.circuit.QuantumCircuit.metadata"") attribute. It will not be directly used in the circuit.

  **Raises**

  [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if the circuit name, if given, is not valid.

  **Examples**

  Construct a simple Bell state circuit.

  ```python
  from qiskit import QuantumCircuit

  qc = QuantumCircuit(2, 2)
  qc.h(0)
  qc.cx(0, 1)
  qc.measure([0, 1], [0, 1])
  qc.draw('mpl')
  ```

  ![../\_images/qiskit-circuit-QuantumCircuit-1.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-1.png)

  Construct a 5-qubit GHZ circuit.

  ```python
  from qiskit import QuantumCircuit

  qc = QuantumCircuit(5)
  qc.h(0)
  qc.cx(0, range(1, 5))
  qc.measure_all()
  ```

  Construct a 4-qubit Bernstein-Vazirani circuit using registers.

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

  qr = QuantumRegister(3, 'q')
  anc = QuantumRegister(1, 'ancilla')
  cr = ClassicalRegister(3, 'c')
  qc = QuantumCircuit(qr, anc, cr)

  qc.x(anc[0])
  qc.h(anc[0])
  qc.h(qr[0:3])
  qc.cx(qr[0:3], anc[0])
  qc.h(qr[0:3])
  qc.barrier(qr)
  qc.measure(qr, cr)

  qc.draw('mpl')
  ```

  ![../\_images/qiskit-circuit-QuantumCircuit-2.png](/images/api/qiskit/1.0/qiskit-circuit-QuantumCircuit-2.png)

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.QuantumCircuit.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.QuantumCircuit.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>Document 4:::
### from\_qasm\_str

  <Function id=""qiskit.circuit.QuantumCircuit.from_qasm_str"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2429-L2450"" signature=""from_qasm_str(qasm_str)"" modifiers=""static"">
    Convert a string containing an OpenQASM 2.0 program to a [`QuantumCircuit`](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

    **Parameters**

    **qasm\_str** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – A string containing an OpenQASM 2.0 program.

    **Returns**

    The QuantumCircuit object for the input OpenQASM 2

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    <Admonition title=""See also"" type=""note"">
      [`qasm2.loads()`](qasm2#qiskit.qasm2.loads ""qiskit.qasm2.loads""): the complete interface to the OpenQASM 2 importer.
    </Admonition>
  </Function>

  ### get\_instructions

  <Function id=""qiskit.circuit.QuantumCircuit.get_instructions"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1966-L1975"" signature=""get_instructions(name)"">
    Get instructions matching name.

    **Parameters**

    **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – The name of instruction to.

    **Returns**

    list of (instruction, qargs, cargs).

    **Return type**

    [list](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")([tuple](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)""))
  </Function>

  ### get\_parameter

  <Function id=""qiskit.circuit.QuantumCircuit.get_parameter"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1380-L1420"" signature=""get_parameter(name: str, default: T) → Parameter | T"" extraSignatures={[""get_parameter(name: str, default: ellipsis = Ellipsis) → Parameter""]}>
    Retrieve a compile-time parameter that is accessible in this circuit scope by name.

    **Parameters**

    *   **name** – the name of the parameter to retrieve.
    *   **default** – if given, this value will be returned if the parameter is not present. If it is not given, a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError ""(in Python v3.12)"") is raised instead.

    **Returns**

    The corresponding parameter.

    **Raises**

    [**KeyError**](https://docs.python.org/3/library/exceptions.html#KeyError ""(in Python v3.12)"") – if no default is given, but the parameter does not exist in the circuit.

    **Examples**

    Retrieve a parameter by name from a circuit:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter

    my_param = Parameter(""my_param"")

    # Create a parametrised circuit.
    qc = QuantumCircuit(1)
    qc.rx(my_param, 0)

    # We can use 'my_param' as a parameter, but let's say we've lost the Python object
    # and need to retrieve it.
    my_param_again = qc.get_parameter(""my_param"")

    assert my_param is my_param_again
    ```

    Get a variable from a circuit by name, returning some default if it is not present:

    ```python
    assert qc.get_parameter(""my_param"", None) is my_param
    assert qc.get_parameter(""unknown_param"", None) is None
    ```
  </Function>

  ### h

  <Function id=""qiskit.circuit.QuantumCircuit.h"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2873-L2886"" signature=""h(qubit)"">
    Apply [`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubit(s) to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function that constructs a quantum circuit to implement a
 2-design. The function should generate a quantum circuit with
 `n_qubits` that creates a 2-design using a series of random single-qubit
 rotations and entangling gates.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
depth (int): The depth of the 2-design (number of layers).
Returns: QuantumCircuit: The quantum circuit implementing the
 2-design.


# Context:
""""""Document 0:::
**Returns**

  The synthesized quantum circuit.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **References**

  1.  Samuel A. Kutin, David Petrie Moulton and Lawren M. Smithline. *Computation at a distance.*, [arXiv:quant-ph/0701194v1](https://arxiv.org/abs/quant-ph/0701194)
</Function>

### synth\_permutation\_basic

<Function id=""qiskit.synthesis.synth_permutation_basic"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/permutation/permutation_full.py#L27-L57"" signature=""qiskit.synthesis.synth_permutation_basic(pattern)"">
  Synthesize a permutation circuit for a fully-connected architecture using sorting.

  More precisely, if the input permutation is a cycle of length `m`, then this creates a quantum circuit with `m-1` SWAPs (and of depth `m-1`); if the input permutation consists of several disjoint cycles, then each cycle is essentially treated independently.

  **Parameters**

  **pattern** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*] | np.ndarray\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – Permutation pattern, describing which qubits occupy the positions 0, 1, 2, etc. after applying the permutation. That is, `pattern[k] = m` when the permutation maps qubit `m` to position `k`. As an example, the pattern `[2, 4, 3, 0, 1]` means that qubit `2` goes to position `0`, qubit `4` goes to position `1`, etc.

  **Returns**

  The synthesized quantum circuit.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
</Function>

### synth\_permutation\_acg

<Function id=""qiskit.synthesis.synth_permutation_acg"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/permutation/permutation_full.py#L60-L102"" signature=""qiskit.synthesis.synth_permutation_acg(pattern)"">
  Synthesize a permutation circuit for a fully-connected architecture using the Alon, Chung, Graham method.

  This produces a quantum circuit of depth 2 (measured in the number of SWAPs).

  This implementation is based on the Proposition 4.1 in reference \[1] with the detailed proof given in Theorem 2 in reference \[2]

  **Parameters**

  **pattern** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*] | np.ndarray\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – Permutation pattern, describing which qubits occupy the positions 0, 1, 2, etc. after applying the permutation. That is, `pattern[k] = m` when the permutation maps qubit `m` to position `k`. As an example, the pattern `[2, 4, 3, 0, 1]` means that qubit `2` goes to position `0`, qubit `4` goes to position `1`, etc.

  **Returns**

  The synthesized quantum circuit.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **References**

  1.  N. Alon, F. R. K. Chung, and R. L. Graham. *Routing Permutations on Graphs Via Matchings.*, Proceedings of the Twenty-Fifth Annual ACM Symposium on Theory of Computing(1993). Pages 583–591. [(Extended abstract) 10.1145/167088.167239](https://doi.org/10.1145/167088.167239)
  2.  N. Alon, F. R. K. Chung, and R. L. Graham. *Routing Permutations on Graphs Via Matchings.*, [(Full paper)](https://www.cs.tau.ac.il/~nogaa/PDFS/r.pdf)
</Function>

## Clifford Synthesis

### synth\_clifford\_full

<Function id=""qiskit.synthesis.synth_clifford_full"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/synthesis/clifford/clifford_decompose_full.py#L24-L64"" signature=""qiskit.synthesis.synth_clifford_full(clifford, method=None)"">
  Decompose a [`Clifford`](qiskit.quantum_info.Clifford ""qiskit.quantum_info.Clifford"") operator into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  For $N \leq 3$ qubits this is based on optimal CX-cost decomposition from reference \[1]. For $N > 3$ qubits this is done using the general non-optimal greedy compilation routine from reference \[3], which typically yields better CX cost compared to the AG method in \[2].

  **Parameters**

  *   **clifford** ([*Clifford*](qiskit.quantum_info.Clifford ""qiskit.quantum_info.Clifford"")) – A Clifford operator.
  *   **method** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Optional, a synthesis method (`'AG'` or `'greedy'`). If set this overrides optimal decomposition for $N \leq 3$ qubits.

  **Returns**

  A circuit implementation of the Clifford.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **References**Document 1:::
Generate random circuit of arbitrary size and form.

  This function will generate a random circuit by randomly selecting gates from the set of standard gates in `qiskit.circuit.library.standard_gates`. For example:

  ```python
  from qiskit.circuit.random import random_circuit

  circ = random_circuit(2, 2, measure=True)
  circ.draw(output='mpl')
  ```

  ![../\_images/circuit-5.png](/images/api/qiskit/1.0/circuit-5.png)

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – number of quantum wires
  *   **depth** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – layers of operations (i.e. critical path length)
  *   **max\_operands** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – maximum qubit operands of each gate (between 1 and 4)
  *   **measure** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, measure all qubits at the end
  *   **conditional** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle measurements and conditionals
  *   **reset** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle resets
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – sets random seed (optional)

  **Returns**

  constructed circuit

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**CircuitError**](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – when invalid options given
</Function>

### Exceptions

Almost all circuit functions and methods will raise a [`CircuitError`](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") when encountering an error that is particular to usage of Qiskit (as opposed to regular typing or indexing problems, which will typically raise the corresponding standard Python error).

#### CircuitError

<Class id=""qiskit.circuit.CircuitError"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/exceptions.py#L18-L19"" signature=""qiskit.circuit.CircuitError(*message)"" modifiers=""exception"">
  Base class for errors raised while processing a circuit.

  Set the error message.
</Class>Document 2:::
---
title: PauliTwoDesign
description: API reference for qiskit.circuit.library.PauliTwoDesign
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.PauliTwoDesign
---

# PauliTwoDesign

<Class id=""qiskit.circuit.library.PauliTwoDesign"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/n_local/pauli_two_design.py#L24-L141"" signature=""qiskit.circuit.library.PauliTwoDesign(num_qubits=None, reps=3, seed=None, insert_barriers=False, name='PauliTwoDesign')"" modifiers=""class"">
  Bases: [`TwoLocal`](qiskit.circuit.library.TwoLocal ""qiskit.circuit.library.n_local.two_local.TwoLocal"")

  The Pauli Two-Design ansatz.

  This class implements a particular form of a 2-design circuit \[1], which is frequently studied in quantum machine learning literature, such as e.g. the investigating of Barren plateaus in variational algorithms \[2].

  The circuit consists of alternating rotation and entanglement layers with an initial layer of $\sqrt{H} = RY(\pi/4)$ gates. The rotation layers contain single qubit Pauli rotations, where the axis is chosen uniformly at random to be X, Y or Z. The entanglement layers is compromised of pairwise CZ gates with a total depth of 2.

  For instance, the circuit could look like this (but note that choosing a different seed yields different Pauli rotations).

  ```python
       ┌─────────┐┌──────────┐       ░ ┌──────────┐       ░  ┌──────────┐
  q_0: ┤ RY(π/4) ├┤ RZ(θ[0]) ├─■─────░─┤ RY(θ[4]) ├─■─────░──┤ RZ(θ[8]) ├
       ├─────────┤├──────────┤ │     ░ ├──────────┤ │     ░  ├──────────┤
  q_1: ┤ RY(π/4) ├┤ RZ(θ[1]) ├─■──■──░─┤ RY(θ[5]) ├─■──■──░──┤ RX(θ[9]) ├
       ├─────────┤├──────────┤    │  ░ ├──────────┤    │  ░ ┌┴──────────┤
  q_2: ┤ RY(π/4) ├┤ RX(θ[2]) ├─■──■──░─┤ RY(θ[6]) ├─■──■──░─┤ RX(θ[10]) ├
       ├─────────┤├──────────┤ │     ░ ├──────────┤ │     ░ ├───────────┤
  q_3: ┤ RY(π/4) ├┤ RZ(θ[3]) ├─■─────░─┤ RX(θ[7]) ├─■─────░─┤ RY(θ[11]) ├
       └─────────┘└──────────┘       ░ └──────────┘       ░ └───────────┘
  ```

  **Examples**

  ```python
  from qiskit.circuit.library import PauliTwoDesign
  circuit = PauliTwoDesign(4, reps=2, seed=5, insert_barriers=True)
  circuit.draw('mpl')
  ```

  ![../\_images/qiskit-circuit-library-PauliTwoDesign-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-PauliTwoDesign-1.png)

  **References**

  **\[1]: Nakata et al., Unitary 2-designs from random X- and Z-diagonal unitaries.**

  [arXiv:1502.07514](https://arxiv.org/pdf/1502.07514.pdf)

  **\[2]: McClean et al., Barren plateaus in quantum neural network training landscapes.**

  [arXiv:1803.11173](https://arxiv.org/pdf/1803.11173.pdf)

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The number of qubits of the Pauli Two-Design circuit.
  *   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Specifies how often a block consisting of a rotation layer and entanglement layer is repeated.
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The seed for randomly choosing the axes of the Pauli rotations.
  *   **insert\_barriers** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True`, barriers are inserted in between each layer. If `False`, no barriers are inserted. Defaults to `False`.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.PauliTwoDesign.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.PauliTwoDesign.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.PauliTwoDesign.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.PauliTwoDesign.data"" />

  ### entanglement

  <Attribute id=""qiskit.circuit.library.PauliTwoDesign.entanglement"">
    Get the entanglement strategy.

    **Returns**

    The entanglement strategy, see `get_entangler_map()` for more detail on how the format is interpreted.
  </Attribute>

  ### entanglement\_blocks

  <Attribute id=""qiskit.circuit.library.PauliTwoDesign.entanglement_blocks"">
    The blocks in the entanglement layers.

    **Returns**

    The blocks in the entanglement layers.
  </Attribute>

  ### flatten

  <Attribute id=""qiskit.circuit.library.PauliTwoDesign.flatten"">
    Returns whether the circuit is wrapped in nested gates/instructions or flattened.
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.PauliTwoDesign.global_phase"">
    Return the global phase of the current circuit scope in radians.Document 3:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 4:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevectorr
Write a function to generate a random pure quantum state and create
 a quantum circuit that initializes a qubit to this state.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
Returns: QuantumCircuit: The quantum circuit that initializes the qubits
 to the random state.


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
The statevector is initialized in the state $|{0,\ldots,0}\rangle$ of the same number of qubits as the input instruction or circuit, evolved by the input instruction, and the output statevector returned.

    **Parameters**

    **instruction** ([*qiskit.circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")  *or*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – instruction or circuit

    **Returns**

    the final density matrix.

    **Return type**

    [DensityMatrix](#qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the instruction contains invalid instructions for density matrix simulation.
  </Function>

  ### from\_int

  <Function id=""qiskit.quantum_info.DensityMatrix.from_int"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/densitymatrix.py#L574-L600"" signature=""from_int(i, dims)"" modifiers=""static"">
    Return a computational basis state density matrix.

    **Parameters**

    *   **i** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – the basis state element.
    *   **dims** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *or*[*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")  *or*[*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")) – The subsystem dimensions of the statevector (See additional information).

    **Returns**

    The computational basis state $|i\rangle\!\langle i|$.

    **Return type**

    [DensityMatrix](#qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")

    **Additional Information:**

    The `dims` kwarg can be an integer or an iterable of integers.

    *   `Iterable` – the subsystem dimensions are the values in the list with the total number of subsystems given by the length of the list.
    *   `Int` – the integer specifies the total dimension of the state. If it is a power of two the state will be initialized as an N-qubit state. If it is not a power of two the state will have a single d-dimensional subsystem.
  </Function>

  ### from\_label

  <Function id=""qiskit.quantum_info.DensityMatrix.from_label"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/densitymatrix.py#L538-L572"" signature=""from_label(label)"" modifiers=""classmethod"">
    Return a tensor product of Pauli X,Y,Z eigenstates.

    | Label | Statevector                                                 |
    | ----- | ----------------------------------------------------------- |
    | `""0""` | $\begin{pmatrix} 1 & 0 \\ 0 & 0 \end{pmatrix}$              |
    | `""1""` | $\begin{pmatrix} 0 & 0 \\ 0 & 1 \end{pmatrix}$              |
    | `""+""` | $\frac{1}{2}\begin{pmatrix} 1 & 1 \\ 1 & 1 \end{pmatrix}$   |
    | `""-""` | $\frac{1}{2}\begin{pmatrix} 1 & -1 \\ -1 & 1 \end{pmatrix}$ |
    | `""r""` | $\frac{1}{2}\begin{pmatrix} 1 & -i \\ i & 1 \end{pmatrix}$  |
    | `""l""` | $\frac{1}{2}\begin{pmatrix} 1 & i \\ -i & 1 \end{pmatrix}$  |

    **Parameters**

    **label** (*string*) – a eigenstate string ket label (see table for allowed values).

    **Returns**

    The N-qubit basis state density matrix.

    **Return type**

    [DensityMatrix](#qiskit.quantum_info.DensityMatrix ""qiskit.quantum_info.DensityMatrix"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the label contains invalid characters, or the length of the label is larger than an explicitly specified num\_qubits.
  </Function>

  ### is\_valid

  <Function id=""qiskit.quantum_info.DensityMatrix.is_valid"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/densitymatrix.py#L194-L207"" signature=""is_valid(atol=None, rtol=None)"">
    Return True if trace 1 and positive semidefinite.
  </Function>

  ### measure

  <Function id=""qiskit.quantum_info.DensityMatrix.measure"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/states/quantum_state.py#L306-L341"" signature=""measure(qargs=None)"">
    Measure subsystems and return outcome and post-measure state.

    Note that this function uses the QuantumStates internal random number generator for sampling the measurement outcome. The RNG seed can be set using the [`seed()`](#qiskit.quantum_info.DensityMatrix.seed ""qiskit.quantum_info.DensityMatrix.seed"") method.

    **Parameters**Document 2:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 3:::
Generate random circuit of arbitrary size and form.

  This function will generate a random circuit by randomly selecting gates from the set of standard gates in `qiskit.circuit.library.standard_gates`. For example:

  ```python
  from qiskit.circuit.random import random_circuit

  circ = random_circuit(2, 2, measure=True)
  circ.draw(output='mpl')
  ```

  ![../\_images/circuit-5.png](/images/api/qiskit/1.0/circuit-5.png)

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – number of quantum wires
  *   **depth** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – layers of operations (i.e. critical path length)
  *   **max\_operands** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – maximum qubit operands of each gate (between 1 and 4)
  *   **measure** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, measure all qubits at the end
  *   **conditional** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle measurements and conditionals
  *   **reset** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle resets
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – sets random seed (optional)

  **Returns**

  constructed circuit

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**CircuitError**](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – when invalid options given
</Function>

### Exceptions

Almost all circuit functions and methods will raise a [`CircuitError`](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") when encountering an error that is particular to usage of Qiskit (as opposed to regular typing or indexing problems, which will typically raise the corresponding standard Python error).

#### CircuitError

<Class id=""qiskit.circuit.CircuitError"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/exceptions.py#L18-L19"" signature=""qiskit.circuit.CircuitError(*message)"" modifiers=""exception"">
  Base class for errors raised while processing a circuit.

  Set the error message.
</Class>Document 4:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter
    >>> angles = [Parameter(""angle_1""), Parameter(""angle_2""), Parameter(""angle_10"")]
    >>> circuit = QuantumCircuit(1)
    >>> circuit.u(*angles, 0)
    >>> circuit.draw()
       ┌─────────────────────────────┐
    q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.QuadraticForm.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.QuadraticForm.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### required\_result\_qubits

  <Function id=""qiskit.circuit.library.QuadraticForm.required_result_qubits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/arithmetic/quadratic_form.py#L165-L197"" signature=""required_result_qubits(quadratic, linear, offset)"" modifiers=""static"">
    Get the number of required result qubits.

    **Parameters**

    *   **quadratic** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]]*) – A matrix containing the quadratic coefficients.
    *   **linear** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – An array containing the linear coefficients.
    *   **offset** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – A constant offset.

    **Returns**

    The number of qubits needed to represent the value of the quadratic form in twos complement.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
Write a function that creates a quantum circuit to implement the
 Variational Quantum Classifier (VQC). The function should create a
 variational quantum circuit with `n_qubits`, parameterized by a set of
 angles, and simulate the circuit to classify a given input state. 
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
params (list): A list of angles used as parameters for the 
variational circuit.
Returns: dict: The result counts from simulating the VQC
 on a quantum simulator.


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
Generate random circuit of arbitrary size and form.

  This function will generate a random circuit by randomly selecting gates from the set of standard gates in `qiskit.circuit.library.standard_gates`. For example:

  ```python
  from qiskit.circuit.random import random_circuit

  circ = random_circuit(2, 2, measure=True)
  circ.draw(output='mpl')
  ```

  ![../\_images/circuit-5.png](/images/api/qiskit/1.0/circuit-5.png)

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – number of quantum wires
  *   **depth** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – layers of operations (i.e. critical path length)
  *   **max\_operands** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – maximum qubit operands of each gate (between 1 and 4)
  *   **measure** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, measure all qubits at the end
  *   **conditional** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle measurements and conditionals
  *   **reset** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle resets
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – sets random seed (optional)

  **Returns**

  constructed circuit

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**CircuitError**](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – when invalid options given
</Function>

### Exceptions

Almost all circuit functions and methods will raise a [`CircuitError`](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") when encountering an error that is particular to usage of Qiskit (as opposed to regular typing or indexing problems, which will typically raise the corresponding standard Python error).

#### CircuitError

<Class id=""qiskit.circuit.CircuitError"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/exceptions.py#L18-L19"" signature=""qiskit.circuit.CircuitError(*message)"" modifiers=""exception"">
  Base class for errors raised while processing a circuit.

  Set the error message.
</Class>Document 2:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter
    >>> angles = [Parameter(""angle_1""), Parameter(""angle_2""), Parameter(""angle_10"")]
    >>> circuit = QuantumCircuit(1)
    >>> circuit.u(*angles, 0)
    >>> circuit.draw()
       ┌─────────────────────────────┐
    q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.QuadraticForm.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.QuadraticForm.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### required\_result\_qubits

  <Function id=""qiskit.circuit.library.QuadraticForm.required_result_qubits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/arithmetic/quadratic_form.py#L165-L197"" signature=""required_result_qubits(quadratic, linear, offset)"" modifiers=""static"">
    Get the number of required result qubits.

    **Parameters**

    *   **quadratic** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]]*) – A matrix containing the quadratic coefficients.
    *   **linear** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – An array containing the linear coefficients.
    *   **offset** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – A constant offset.

    **Returns**

    The number of qubits needed to represent the value of the quadratic form in twos complement.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>
</Class>Document 4:::
---
title: BaseSamplerV1
description: API reference for qiskit.primitives.BaseSamplerV1
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.primitives.BaseSamplerV1
---

# BaseSamplerV1

<Class id=""qiskit.primitives.BaseSamplerV1"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/primitives/base/base_sampler.py#L35-L150"" signature=""qiskit.primitives.BaseSamplerV1(*, options=None)"" modifiers=""class"">
  Bases: `BasePrimitive`, [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic ""(in Python v3.12)"")\[`T`]

  Sampler V1 base class

  Base class of Sampler that calculates quasi-probabilities of bitstrings from quantum circuits.

  A sampler is initialized with an empty parameter set. The sampler is used to create a [`JobV1`](qiskit.providers.JobV1 ""qiskit.providers.JobV1""), via the [`qiskit.primitives.Sampler.run()`](qiskit.primitives.Sampler#run ""qiskit.primitives.Sampler.run"") method. This method is called with the following parameters

  *   quantum circuits ($\psi_i(\theta)$): list of (parameterized) quantum circuits. (a list of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") objects)
  *   parameter values ($\theta_k$): list of sets of parameter values to be bound to the parameters of the quantum circuits. (list of list of float)

  The method returns a [`JobV1`](qiskit.providers.JobV1 ""qiskit.providers.JobV1"") object, calling [`qiskit.providers.JobV1.result()`](qiskit.providers.JobV1#result ""qiskit.providers.JobV1.result"") yields a [`SamplerResult`](qiskit.primitives.SamplerResult ""qiskit.primitives.SamplerResult"") object, which contains probabilities or quasi-probabilities of bitstrings, plus optional metadata like error bars in the samples.

  Here is an example of how sampler is used.

  ```python
  from qiskit.primitives import Sampler
  from qiskit import QuantumCircuit
  from qiskit.circuit.library import RealAmplitudes

  # a Bell circuit
  bell = QuantumCircuit(2)
  bell.h(0)
  bell.cx(0, 1)
  bell.measure_all()

  # two parameterized circuits
  pqc = RealAmplitudes(num_qubits=2, reps=2)
  pqc.measure_all()
  pqc2 = RealAmplitudes(num_qubits=2, reps=3)
  pqc2.measure_all()

  theta1 = [0, 1, 1, 2, 3, 5]
  theta2 = [0, 1, 2, 3, 4, 5, 6, 7]

  # initialization of the sampler
  sampler = Sampler()

  # Sampler runs a job on the Bell circuit
  job = sampler.run(circuits=[bell], parameter_values=[[]], parameters=[[]])
  job_result = job.result()
  print([q.binary_probabilities() for q in job_result.quasi_dists])

  # Sampler runs a job on the parameterized circuits
  job2 = sampler.run(
      circuits=[pqc, pqc2],
      parameter_values=[theta1, theta2],
      parameters=[pqc.parameters, pqc2.parameters])
  job_result = job2.result()
  print([q.binary_probabilities() for q in job_result.quasi_dists])
  ```

  **Parameters**

  **options** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"") *| None*) – Default options.

  ## Attributes

  ### options

  <Attribute id=""qiskit.primitives.BaseSamplerV1.options"">
    Return options values for the estimator.

    **Returns**

    options
  </Attribute>

  ## Methods

  ### run

  <Function id=""qiskit.primitives.BaseSamplerV1.run"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/primitives/base/base_sampler.py#L110-L141"" signature=""run(circuits, parameter_values=None, **run_options)"">
    Run the job of the sampling of bitstrings.

    **Parameters**

    *   **circuits** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") *| Sequence\[*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – One of more circuit objects.
    *   **parameter\_values** (*Sequence\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*] | Sequence\[Sequence\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]] | None*) – Parameters to be bound to the circuit.
    *   **run\_options** – Backend runtime options used for circuit execution.

    **Returns**

    The job object of the result of the sampler. The i-th result corresponds to `circuits[i]` evaluated with parameters bound as `parameter_values[i]`.

    **Raises**

    [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError ""(in Python v3.12)"") – Invalid arguments are given.

    **Return type**

    T
  </Function>

  ### set\_options""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit.circuit.library import HGate, XGate
Write a function that creates a quantum circuit to implement a
 simple quantum key distribution (QKD) protocol like BB84. The circui
t should prepare qubits in random bases (X or Z) and measure them
 in corresponding bases.
Returns: QuantumCircuit: The quantum circuit implementing the
 BB84 protocol.


# Context:
""""""Document 0:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 1:::
**Returns**

  the circuit representing the input dag.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.dagcircuit import DAGCircuit
  from qiskit.converters import circuit_to_dag
  from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
  from qiskit.converters import dag_to_circuit

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  dag = circuit_to_dag(circ)
  circuit = dag_to_circuit(dag)
  circuit.draw('mpl')
  ```

  ![../\_images/converters-1.png](/images/api/qiskit/1.0/converters-1.png)
</Function>

### circuit\_to\_instruction

<Function id=""qiskit.converters.circuit_to_instruction"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_instruction.py#L21-L145"" signature=""qiskit.converters.circuit_to_instruction(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build an [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the instruction. If None, existing circuit parameters will also parameterize the instruction.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted instruction will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional instruction label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if parameter\_map is not compatible with circuit

  **Returns**

  an instruction equivalent to the action of the input circuit. Upon decomposition, this instruction will yield the components comprising the original circuit.

  **Return type**

  [qiskit.circuit.Instruction](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")

  **Example**

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
  from qiskit.converters import circuit_to_instruction

  q = QuantumRegister(3, 'q')
  c = ClassicalRegister(3, 'c')
  circ = QuantumCircuit(q, c)
  circ.h(q[0])
  circ.cx(q[0], q[1])
  circ.measure(q[0], c[0])
  circ.rz(0.5, q[1]).c_if(c, 2)
  circuit_to_instruction(circ)
  ```
</Function>

### circuit\_to\_gate

<Function id=""qiskit.converters.circuit_to_gate"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/converters/circuit_to_gate.py#L30-L109"" signature=""qiskit.converters.circuit_to_gate(circuit, parameter_map=None, equivalence_library=None, label=None)"">
  Build a [`Gate`](qiskit.circuit.Gate ""qiskit.circuit.Gate"") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

  The gate is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The gate will have the same string name as the circuit.

  **Parameters**

  *   **circuit** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – the input circuit.
  *   **parameter\_map** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"")) – For parameterized circuits, a mapping from parameters in the circuit to parameters to be used in the gate. If None, existing circuit parameters will also parameterize the Gate.
  *   **equivalence\_library** ([*EquivalenceLibrary*](qiskit.circuit.EquivalenceLibrary ""qiskit.circuit.EquivalenceLibrary"")) – Optional equivalence library where the converted gate will be registered.
  *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Optional gate label.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if circuit is non-unitary or if parameter\_map is not compatible with circuit

  **Returns**

  a Gate equivalent to the action of the input circuit. Upon decomposition, this gate will yield the components comprising the original circuit.

  **Return type**

  [Gate](qiskit.circuit.Gate ""qiskit.circuit.Gate"")Document 2:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 3:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 4:::
Generate random circuit of arbitrary size and form.

  This function will generate a random circuit by randomly selecting gates from the set of standard gates in `qiskit.circuit.library.standard_gates`. For example:

  ```python
  from qiskit.circuit.random import random_circuit

  circ = random_circuit(2, 2, measure=True)
  circ.draw(output='mpl')
  ```

  ![../\_images/circuit-5.png](/images/api/qiskit/1.0/circuit-5.png)

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – number of quantum wires
  *   **depth** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – layers of operations (i.e. critical path length)
  *   **max\_operands** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – maximum qubit operands of each gate (between 1 and 4)
  *   **measure** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, measure all qubits at the end
  *   **conditional** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle measurements and conditionals
  *   **reset** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – if True, insert middle resets
  *   **seed** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – sets random seed (optional)

  **Returns**

  constructed circuit

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**CircuitError**](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – when invalid options given
</Function>

### Exceptions

Almost all circuit functions and methods will raise a [`CircuitError`](#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") when encountering an error that is particular to usage of Qiskit (as opposed to regular typing or indexing problems, which will typically raise the corresponding standard Python error).

#### CircuitError

<Class id=""qiskit.circuit.CircuitError"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/exceptions.py#L18-L19"" signature=""qiskit.circuit.CircuitError(*message)"" modifiers=""exception"">
  Base class for errors raised while processing a circuit.

  Set the error message.
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
Write a function to implement a quantum circuit that performs 
amplitude damping on a single qubit. The function should apply a 
Kraus operator corresponding to amplitude damping noise with a
 given probability `p`.
Parameters: p (float): The probability of amplitude damping.
Returns: QuantumCircuit: The quantum circuit implementing amplitude
 damping noise.


# Context:
""""""Document 0:::
---
title: LinearAmplitudeFunction
description: API reference for qiskit.circuit.library.LinearAmplitudeFunction
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.LinearAmplitudeFunction
---

# LinearAmplitudeFunction

<Class id=""qiskit.circuit.library.LinearAmplitudeFunction"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/arithmetic/linear_amplitude_function.py#L22-L173"" signature=""qiskit.circuit.library.LinearAmplitudeFunction(num_state_qubits, slope, offset, domain, image, rescaling_factor=1, breakpoints=None, name='F')"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  A circuit implementing a (piecewise) linear function on qubit amplitudes.

  An amplitude function $F$ of a function $f$ is a mapping

$$
F|x\rangle|0\rangle = \sqrt{1 - \hat{f}(x)} |x\rangle|0\rangle + \sqrt{\hat{f}(x)}
|x\rangle|1\rangle.
$$

  for a function $\hat{f}: \{ 0, ..., 2^n - 1 \} \rightarrow [0, 1]$, where $|x\rangle$ is a $n$ qubit state.

  This circuit implements $F$ for piecewise linear functions $\hat{f}$. In this case, the mapping $F$ can be approximately implemented using a Taylor expansion and linearly controlled Pauli-Y rotations, see \[1, 2] for more detail. This approximation uses a `rescaling_factor` to determine the accuracy of the Taylor expansion.

  In general, the function of interest $f$ is defined from some interval $[a,b]$, the `domain` to $[c,d]$, the `image`, instead of $\{ 1, ..., N \}$ to $[0, 1]$. Using an affine transformation we can rescale $f$ to $\hat{f}$:

$$
\hat{f}(x) = \frac{f(\phi(x)) - c}{d - c}
$$

  with

$$
\phi(x) = a + \frac{b - a}{2^n - 1} x.
$$

  If $f$ is a piecewise linear function on $m$ intervals $[p_{i-1}, p_i], i \in \{1, ..., m\}$ with slopes $\alpha_i$ and offsets $\beta_i$ it can be written as

$$
f(x) = \sum_{i=1}^m 1_{[p_{i-1}, p_i]}(x) (\alpha_i x + \beta_i)
$$

  where $1_{[a, b]}$ is an indication function that is 1 if the argument is in the interval $[a, b]$ and otherwise 0. The breakpoints $p_i$ can be specified by the `breakpoints` argument.

  **References**

  **\[1]: Woerner, S., & Egger, D. J. (2018).**

  Quantum Risk Analysis. [arXiv:1806.06893](http://arxiv.org/abs/1806.06893)

  **\[2]: Gacon, J., Zoufal, C., & Woerner, S. (2020).**

  Quantum-Enhanced Simulation-Based Optimization. [arXiv:2005.10780](http://arxiv.org/abs/2005.10780)

  **Parameters**

  *   **num\_state\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The number of qubits used to encode the variable $x$.
  *   **slope** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *|*[*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – The slope of the linear function. Can be a list of slopes if it is a piecewise linear function.
  *   **offset** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *|*[*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – The offset of the linear function. Can be a list of offsets if it is a piecewise linear function.
  *   **domain** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*,* [*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – The domain of the function as tuple $(x_\min{}, x_\max{})$.
  *   **image** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*,* [*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – The image of the function as tuple $(f_\min{}, f_\max{})$.
  *   **rescaling\_factor** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The rescaling factor to adjust the accuracy in the Taylor approximation.Document 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")Document 3:::
*   **final\_layout** ([*Layout*](qiskit.transpiler.Layout ""qiskit.transpiler.Layout"")) – If specified this kwarg can be used to represent the output permutation caused by swap insertions during the routing stage of the transpiler.

    **Returns**

    An operator representing the input circuit

    **Return type**

    [Operator](#qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"")
  </Function>

  ### from\_label

  <Function id=""qiskit.quantum_info.Operator.from_label"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/operator.py#L220-L275"" signature=""from_label(label)"" modifiers=""classmethod"">
    Return a tensor product of single-qubit operators.

    **Parameters**

    **label** (*string*) – single-qubit operator string.

    **Returns**

    The N-qubit operator.

    **Return type**

    [Operator](#qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the label contains invalid characters, or the length of the label is larger than an explicitly specified num\_qubits.

    **Additional Information:**

    The labels correspond to the single-qubit matrices: ‘I’: \[\[1, 0], \[0, 1]] ‘X’: \[\[0, 1], \[1, 0]] ‘Y’: \[\[0, -1j], \[1j, 0]] ‘Z’: \[\[1, 0], \[0, -1]] ‘H’: \[\[1, 1], \[1, -1]] / sqrt(2) ‘S’: \[\[1, 0], \[0 , 1j]] ‘T’: \[\[1, 0], \[0, (1+1j) / sqrt(2)]] ‘0’: \[\[1, 0], \[0, 0]] ‘1’: \[\[0, 0], \[0, 1]] ‘+’: \[\[0.5, 0.5], \[0.5 , 0.5]] ‘-’: \[\[0.5, -0.5], \[-0.5 , 0.5]] ‘r’: \[\[0.5, -0.5j], \[0.5j , 0.5]] ‘l’: \[\[0.5, 0.5j], \[-0.5j , 0.5]]
  </Function>

  ### input\_dims

  <Function id=""qiskit.quantum_info.Operator.input_dims"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/base_operator.py#L135-L137"" signature=""input_dims(qargs=None)"">
    Return tuple of input dimension for specified subsystems.
  </Function>

  ### is\_unitary

  <Function id=""qiskit.quantum_info.Operator.is_unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/operator.py#L429-L435"" signature=""is_unitary(atol=None, rtol=None)"">
    Return True if operator is a unitary matrix.
  </Function>

  ### output\_dims

  <Function id=""qiskit.quantum_info.Operator.output_dims"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/base_operator.py#L139-L141"" signature=""output_dims(qargs=None)"">
    Return tuple of output dimension for specified subsystems.
  </Function>

  ### power

  <Function id=""qiskit.quantum_info.Operator.power"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/operator.py#L511-L539"" signature=""power(n)"">
    Return the matrix power of the operator.

    **Parameters**

    **n** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – the power to raise the matrix to.

    **Returns**

    the resulting operator `O ** n`.

    **Return type**

    [Operator](#qiskit.quantum_info.Operator ""qiskit.quantum_info.Operator"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if the input and output dimensions of the operator are not equal.
  </Function>

  ### reshape

  <Function id=""qiskit.quantum_info.Operator.reshape"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/base_operator.py#L106-L133"" signature=""reshape(input_dims=None, output_dims=None, num_qubits=None)"">
    Return a shallow copy with reshaped input and output subsystem dimensions.

    **Parameters**

    *   **input\_dims** (*None or* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")) – new subsystem input dimensions. If None the original input dims will be preserved \[Default: None].
    *   **output\_dims** (*None or* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")) – new subsystem output dimensions. If None the original output dims will be preserved \[Default: None].
    *   **num\_qubits** (*None or* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – reshape to an N-qubit operator \[Default: None].

    **Returns**Document 4:::
*   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Optional number of times the circuit should be decomposed. For instance, `reps=2` equals calling `circuit.decompose().decompose()`. can decompose specific gates specific time

    **Returns**

    a circuit one level decomposed

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### delay

  <Function id=""qiskit.circuit.QuantumCircuit.delay"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2847-L2871"" signature=""delay(duration, qarg=None, unit='dt')"">
    Apply [`Delay`](qiskit.circuit.Delay ""qiskit.circuit.Delay""). If qarg is `None`, applies to all qubits. When applying to multiple qubits, delays with the same duration will be created.

    **Parameters**

    *   **duration** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *or*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *or*[*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.ParameterExpression"")) – duration of the delay.
    *   **qarg** (*Object*) – qubit argument to apply this delay.
    *   **unit** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – unit of the duration. Supported units: `'s'`, `'ms'`, `'us'`, `'ns'`, `'ps'`, and `'dt'`. Default is `'dt'`, i.e. integer time unit depending on the target backend.

    **Returns**

    handle to the added instructions.

    **Return type**

    [qiskit.circuit.InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if arguments have bad format.
  </Function>

  ### depth

  <Function id=""qiskit.circuit.QuantumCircuit.depth"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1839-L1913"" signature=""depth(filter_function=<function QuantumCircuit.<lambda>>)"">
    Return circuit depth (i.e., length of critical path).

    **Parameters**

    **filter\_function** (*callable*) – A function to filter instructions. Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)). Instructions for which the function returns False are ignored in the computation of the circuit depth. By default filters out “directives”, such as barrier or snapshot.

    **Returns**

    Depth of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")

    **Notes**

    The circuit depth and the DAG depth need not be the same.
  </Function>

  ### draw

  <Function id=""qiskit.circuit.QuantumCircuit.draw"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1655-L1819"" signature=""draw(output=None, scale=None, filename=None, style=None, interactive=False, plot_barriers=True, reverse_bits=None, justify=None, vertical_compression='medium', idle_wires=True, with_layout=True, fold=None, ax=None, initial_state=False, cregbundle=None, wire_order=None, expr_len=30)"">
    Draw the quantum circuit. Use the output parameter to choose the drawing format:

    **text**: ASCII art TextDrawing that can be printed in the console.

    **mpl**: images with color rendered purely in Python using matplotlib.

    **latex**: high-quality images compiled via latex.

    **latex\_source**: raw uncompiled latex output.

    <Admonition title=""Warning"" type=""caution"">
      Support for [`Expr`](circuit_classical#qiskit.circuit.classical.expr.Expr ""qiskit.circuit.classical.expr.Expr"") nodes in conditions and `SwitchCaseOp.target` fields is preliminary and incomplete. The `text` and `mpl` drawers will make a best-effort attempt to show data dependencies, but the LaTeX-based drawers will skip these completely.
    </Admonition>

    **Parameters**

    *   **output** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Select the output method to use for drawing the circuit. Valid choices are `text`, `mpl`, `latex`, `latex_source`. By default the text drawer is used unless the user config file (usually `~/.qiskit/settings.conf`) has an alternative backend set as the default. For example, `circuit_drawer = latex`. If the output kwarg is set, that backend will always be used over the default in the user config file.

    *   **scale** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"") *| None*) – Scale of image to draw (shrink if `< 1.0`). Only used by the `mpl`, `latex` and `latex_source` outputs. Defaults to `1.0`.

    *   **filename** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – File path to save image to. Defaults to `None` (result not saved in a file).""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator

Write a function to create and simulate a quantum circuit that
 implements the SWAP test to determine the overlap between two
 quantum states. The function should prepare two quantum states
 on separate qubits, apply the SWAP test, and return the measurement
 results.
Returns: dict: The measurement results of the SWAP test.


# Context:
""""""Document 0:::
---
title: UnitaryOverlap
description: API reference for qiskit.circuit.library.UnitaryOverlap
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.UnitaryOverlap
---

# UnitaryOverlap

<Class id=""qiskit.circuit.library.UnitaryOverlap"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/overlap.py#L21-L98"" signature=""qiskit.circuit.library.UnitaryOverlap(unitary1, unitary2, prefix1='p1', prefix2='p2')"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  Circuit that returns the overlap between two unitaries $U_2^{\dag} U_1$.

  The input quantum circuits must represent unitary operations, since they must be invertible. If the inputs will have parameters, they are replaced by [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"")s with names “p1” (for circuit `unitary1`) and “p2” (for circuit `unitary_2`) in the output circuit.

  This circuit is usually employed in computing the fidelity:

  ```python
  .. math::

      \left|\langle 0| U_2^{\dag} U_1|0\rangle\right|^{2}
  ```

  by computing the probability of being in the all-zeros bit-string, or equivalently, the expectation value of projector $|0\rangle\langle 0|$.

  Example:

  ```python
  import numpy as np
  from qiskit.circuit.library import EfficientSU2, UnitaryOverlap
  from qiskit.primitives import Sampler

  # get two circuit to prepare states of which we comput the overlap
  circuit = EfficientSU2(2, reps=1)
  unitary1 = circuit.assign_parameters(np.random.random(circuit.num_parameters))
  unitary2 = circuit.assign_parameters(np.random.random(circuit.num_parameters))

  # create the overlap circuit
  overlap = UnitaryOverap(unitary1, unitary2)

  # sample from the overlap
  sampler = Sampler(options={""shots"": 100})
  result = sampler.run(overlap).result()

  # the fidelity is the probability to measure 0
  fidelity = result.quasi_dists[0].get(0, 0)
  ```

  **Parameters**

  *   **unitary1** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")) – Unitary acting on the ket vector.
  *   **unitary2** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")) – Unitary whose inverse operates on the bra vector.
  *   **prefix1** – The name of the parameter vector associated to `unitary1`, if it is parameterized. Defaults to `""p1""`.
  *   **prefix2** – The name of the parameter vector associated to `unitary2`, if it is parameterized. Defaults to `""p2""`.

  **Raises**

  *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – Number of qubits in `unitary1` and `unitary2` does not match.
  *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – Inputs contain measurements and/or resets.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.UnitaryOverlap.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.UnitaryOverlap.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.UnitaryOverlap.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.UnitaryOverlap.data"">
    Return the circuit data (instructions and context).

    **Returns**

    a list-like object containing the [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")s for each instruction.

    **Return type**

    QuantumCircuitData
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.UnitaryOverlap.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### instances

  <Attribute id=""qiskit.circuit.library.UnitaryOverlap.instances"" attributeValue=""158"" />

  ### layout

  <Attribute id=""qiskit.circuit.library.UnitaryOverlap.layout"">
    Return any associated layout information about the circuit

    This attribute contains an optional [`TranspileLayout`](qiskit.transpiler.TranspileLayout ""qiskit.transpiler.TranspileLayout"") object. This is typically set on the output from [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") or [`PassManager.run()`](qiskit.transpiler.PassManager#run ""qiskit.transpiler.PassManager.run"") to retain information about the permutations caused on the input circuit by transpilation.Document 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### size

  <Function id=""qiskit.circuit.QuantumCircuit.size"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1821-L1837"" signature=""size(filter_function=<function QuantumCircuit.<lambda>>)"">
    Returns total number of instructions in circuit.

    **Parameters**

    **filter\_function** (*callable*) – a function to filter out some instructions. Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)). By default filters out “directives”, such as barrier or snapshot.

    **Returns**

    Total number of gate operations.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>

  ### swap

  <Function id=""qiskit.circuit.QuantumCircuit.swap"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3438-L3451"" signature=""swap(qubit1, qubit2)"">
    Apply [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**

    *   **qubit1** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubits to apply the gate to.
    *   **qubit2** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – The qubits to apply the gate to.

    **Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### switch

  <Function id=""qiskit.circuit.QuantumCircuit.switch"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4681-L4748"" signature=""switch(target: Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int], cases: None, qubits: None, clbits: None, *, label: str | None) → SwitchContext"" extraSignatures={[""switch(target: Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int], cases: Iterable[Tuple[Any, QuantumCircuit]], qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `switch`/`case` structure on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a [`SwitchCaseOp`](qiskit.circuit.SwitchCaseOp ""qiskit.circuit.SwitchCaseOp"") with the given case structure. If `cases` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a [`SwitchCaseOp`](qiskit.circuit.SwitchCaseOp ""qiskit.circuit.SwitchCaseOp"") when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, ClassicalRegister, QuantumRegister
    qreg = QuantumRegister(3)
    creg = ClassicalRegister(3)
    qc = QuantumCircuit(qreg, creg)
    qc.h([0, 1, 2])
    qc.measure([0, 1, 2], [0, 1, 2])

    with qc.switch(creg) as case:
        with case(0):
            qc.x(0)
        with case(1, 2):
            qc.z(1)
        with case(case.DEFAULT):
            qc.cx(0, 1)
    ```

    **Parameters**Document 3:::
```python
      from qiskit.circuit import QuantumCircuit, Qubit, Clbit
      bits = [Qubit(), Qubit(), Clbit()]
      qc = QuantumCircuit(bits)
      qc.h(0)
      qc.cx(0, 1)
      qc.measure(0, 0)
      with qc.if_test((bits[2], 0)) as else_:
          qc.h(0)
      with else_:
          qc.x(0)
      ```
    </Admonition>

    **Parameters**

    *   **condition** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*] |* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*,* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*] |* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*,* [*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")*]*) – A condition to be evaluated at circuit runtime which, if true, will trigger the evaluation of `true_body`. Can be specified as either a tuple of a `ClassicalRegister` to be tested for equality with a given `int`, or as a tuple of a `Clbit` to be compared to either a `bool` or an `int`.
    *   **true\_body** ([*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – The circuit body to be run if `condition` is true.
    *   **false\_body** ([*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")) – The circuit to be run if `condition` is false.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits over which the if/else should be run.
    *   **clbits** (*Sequence\[ClbitSpecifier]*) – The circuit clbits over which the if/else should be run.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The string label of the instruction in the circuit.

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the provided condition references Clbits outside the enclosing circuit.

    **Returns**

    A handle to the instruction created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### if\_test

  <Function id=""qiskit.circuit.QuantumCircuit.if_test"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4516-L4602"" signature=""if_test(condition: tuple[ClassicalRegister | Clbit, int], true_body: None, qubits: None, clbits: None, *, label: str | None) → IfContext"" extraSignatures={[""if_test(condition: tuple[ClassicalRegister | Clbit, int], true_body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None = None) → InstructionSet""]}>
    Create an `if` statement on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a [`IfElseOp`](qiskit.circuit.IfElseOp ""qiskit.circuit.IfElseOp"") with the given `true_body`, and there will be no branch for the `false` condition (see also the [`if_else()`](#qiskit.circuit.QuantumCircuit.if_else ""qiskit.circuit.QuantumCircuit.if_else"") method). However, if `true_body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which can be used to build `if` statements. The return value of the `with` statement is a chainable context manager, which can be used to create subsequent `else` blocks. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    For example:

    ```python
    from qiskit.circuit import QuantumCircuit, Qubit, Clbit
    bits = [Qubit(), Qubit(), Qubit(), Clbit(), Clbit()]
    qc = QuantumCircuit(bits)

    qc.h(0)
    qc.cx(0, 1)
    qc.measure(0, 0)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure(0, 1)

    with qc.if_test((bits[3], 0)) as else_:
        qc.x(2)
    with else_:
        qc.h(2)
        qc.z(2)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – A condition to be evaluated at circuit runtime which, if true, will trigger the evaluation of `true_body`. Can be specified as either a tuple of a `ClassicalRegister` to be tested for equality with a given `int`, or as a tuple of a `Clbit` to be compared to either a `bool` or an `int`.Document 4:::
---
title: QFT
description: API reference for qiskit.circuit.library.QFT
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.QFT
---

# QFT

<Class id=""qiskit.circuit.library.QFT"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/basis_change/qft.py#L24-L295"" signature=""qiskit.circuit.library.QFT(num_qubits=None, approximation_degree=0, do_swaps=True, inverse=False, insert_barriers=False, name=None)"" modifiers=""class"">
  Bases: `BlueprintCircuit`

  Quantum Fourier Transform Circuit.

  The Quantum Fourier Transform (QFT) on $n$ qubits is the operation

$$
|j\rangle \mapsto \frac{1}{2^{n/2}} \sum_{k=0}^{2^n - 1} e^{2\pi ijk / 2^n} |k\rangle
$$

  The circuit that implements this transformation can be implemented using Hadamard gates on each qubit, a series of controlled-U1 (or Z, depending on the phase) gates and a layer of Swap gates. The layer of Swap gates can in principle be dropped if the QFT appears at the end of the circuit, since then the re-ordering can be done classically. They can be turned off using the `do_swaps` attribute.

  For 4 qubits, the circuit that implements this transformation is:

  ![../\_images/qiskit-circuit-library-QFT-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-1.png)

  The inverse QFT can be obtained by calling the `inverse` method on this class. The respective circuit diagram is:

  ![../\_images/qiskit-circuit-library-QFT-2.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-2.png)

  One method to reduce circuit depth is to implement the QFT approximately by ignoring controlled-phase rotations where the angle is beneath a threshold. This is discussed in more detail in [https://arxiv.org/abs/quant-ph/9601018](https://arxiv.org/abs/quant-ph/9601018) or [https://arxiv.org/abs/quant-ph/0403071](https://arxiv.org/abs/quant-ph/0403071).

  Here, this can be adjusted using the `approximation_degree` attribute: the smallest `approximation_degree` rotation angles are dropped from the QFT. For instance, a QFT on 5 qubits with approximation degree 2 yields (the barriers are dropped in this example):

  ![../\_images/qiskit-circuit-library-QFT-3.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-3.png)

  Construct a new QFT circuit.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The number of qubits on which the QFT acts.
  *   **approximation\_degree** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The degree of approximation (0 for no approximation).
  *   **do\_swaps** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to include the final swaps in the QFT.
  *   **inverse** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, the inverse Fourier transform is constructed.
  *   **insert\_barriers** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, barriers are inserted as visualization improvement.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The name of the circuit.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.QFT.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### approximation\_degree

  <Attribute id=""qiskit.circuit.library.QFT.approximation_degree"">
    The approximation degree of the QFT.

    **Returns**

    The currently set approximation degree.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.QFT.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.QFT.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.QFT.data"" />

  ### do\_swaps

  <Attribute id=""qiskit.circuit.library.QFT.do_swaps"">
    Whether the final swaps of the QFT are applied or not.

    **Returns**

    True, if the final swaps are applied, False if not.
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.QFT.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### insert\_barriers

  <Attribute id=""qiskit.circuit.library.QFT.insert_barriers"">
    Whether barriers are inserted for better visualization or not.

    **Returns**

    True, if barriers are inserted, False if not.
  </Attribute>

  ### instances""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit.circuit.library import EfficientSU2
Write a function that constructs a quantum circuit using the
 EfficientSU2 ansatz for a specified number of qubits. The function
 should allow for a variable number of layers in the ansatz and return
 the resulting circuit.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
layers (int): Number of layers in the EfficientSU2 ansatz.
Returns: QuantumCircuit: The quantum circuit using the EfficientSU2
 ansatz.


# Context:
""""""Document 0:::
---
title: EfficientSU2
description: API reference for qiskit.circuit.library.EfficientSU2
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.EfficientSU2
---

# EfficientSU2

<Class id=""qiskit.circuit.library.EfficientSU2"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/n_local/efficient_su2.py#L29-L164"" signature=""qiskit.circuit.library.EfficientSU2(num_qubits=None, su2_gates=None, entanglement='reverse_linear', reps=3, skip_unentangled_qubits=False, skip_final_rotation_layer=False, parameter_prefix='θ', insert_barriers=False, initial_state=None, name='EfficientSU2', flatten=None)"" modifiers=""class"">
  Bases: [`TwoLocal`](qiskit.circuit.library.TwoLocal ""qiskit.circuit.library.n_local.two_local.TwoLocal"")

  The hardware efficient SU(2) 2-local circuit.

  The `EfficientSU2` circuit consists of layers of single qubit operations spanned by SU(2) and $CX$ entanglements. This is a heuristic pattern that can be used to prepare trial wave functions for variational quantum algorithms or classification circuit for machine learning.

  SU(2) stands for special unitary group of degree 2, its elements are $2 \times 2$ unitary matrices with determinant 1, such as the Pauli rotation gates.

  On 3 qubits and using the Pauli $Y$ and $Z$ su2\_gates as single qubit gates, the hardware efficient SU(2) circuit is represented by:

  ```python
  ┌──────────┐┌──────────┐ ░            ░       ░ ┌───────────┐┌───────────┐
  ┤ RY(θ[0]) ├┤ RZ(θ[3]) ├─░────────■───░─ ... ─░─┤ RY(θ[12]) ├┤ RZ(θ[15]) ├
  ├──────────┤├──────────┤ ░      ┌─┴─┐ ░       ░ ├───────────┤├───────────┤
  ┤ RY(θ[1]) ├┤ RZ(θ[4]) ├─░───■──┤ X ├─░─ ... ─░─┤ RY(θ[13]) ├┤ RZ(θ[16]) ├
  ├──────────┤├──────────┤ ░ ┌─┴─┐└───┘ ░       ░ ├───────────┤├───────────┤
  ┤ RY(θ[2]) ├┤ RZ(θ[5]) ├─░─┤ X ├──────░─ ... ─░─┤ RY(θ[14]) ├┤ RZ(θ[17]) ├
  └──────────┘└──────────┘ ░ └───┘      ░       ░ └───────────┘└───────────┘
  ```

  See [`RealAmplitudes`](qiskit.circuit.library.RealAmplitudes ""qiskit.circuit.library.RealAmplitudes"") for more detail on the possible arguments and options such as skipping unentanglement qubits, which apply here too.

  **Examples**

  ```python
  >>> circuit = EfficientSU2(3, reps=1)
  >>> print(circuit)
       ┌──────────┐┌──────────┐          ┌──────────┐┌──────────┐
  q_0: ┤ RY(θ[0]) ├┤ RZ(θ[3]) ├──■────■──┤ RY(θ[6]) ├┤ RZ(θ[9]) ├─────────────
       ├──────────┤├──────────┤┌─┴─┐  │  └──────────┘├──────────┤┌───────────┐
  q_1: ┤ RY(θ[1]) ├┤ RZ(θ[4]) ├┤ X ├──┼───────■──────┤ RY(θ[7]) ├┤ RZ(θ[10]) ├
       ├──────────┤├──────────┤└───┘┌─┴─┐   ┌─┴─┐    ├──────────┤├───────────┤
  q_2: ┤ RY(θ[2]) ├┤ RZ(θ[5]) ├─────┤ X ├───┤ X ├────┤ RY(θ[8]) ├┤ RZ(θ[11]) ├
       └──────────┘└──────────┘     └───┘   └───┘    └──────────┘└───────────┘
  ```

  ```python
  >>> ansatz = EfficientSU2(4, su2_gates=['rx', 'y'], entanglement='circular', reps=1)
  >>> qc = QuantumCircuit(4)  # create a circuit and append the RY variational form
  >>> qc.compose(ansatz, inplace=True)
  >>> qc.draw()
       ┌──────────┐┌───┐┌───┐     ┌──────────┐   ┌───┐
  q_0: ┤ RX(θ[0]) ├┤ Y ├┤ X ├──■──┤ RX(θ[4]) ├───┤ Y ├─────────────────────
       ├──────────┤├───┤└─┬─┘┌─┴─┐└──────────┘┌──┴───┴───┐   ┌───┐
  q_1: ┤ RX(θ[1]) ├┤ Y ├──┼──┤ X ├─────■──────┤ RX(θ[5]) ├───┤ Y ├─────────
       ├──────────┤├───┤  │  └───┘   ┌─┴─┐    └──────────┘┌──┴───┴───┐┌───┐
  q_2: ┤ RX(θ[2]) ├┤ Y ├──┼──────────┤ X ├─────────■──────┤ RX(θ[6]) ├┤ Y ├
       ├──────────┤├───┤  │          └───┘       ┌─┴─┐    ├──────────┤├───┤
  q_3: ┤ RX(θ[3]) ├┤ Y ├──■──────────────────────┤ X ├────┤ RX(θ[7]) ├┤ Y ├
       └──────────┘└───┘                         └───┘    └──────────┘└───┘
  ```

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The number of qubits of the EfficientSU2 circuit.
  *   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Specifies how often the structure of a rotation layer followed by an entanglement layer is repeated.
  *   **su2\_gates** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*type*](https://docs.python.org/3/library/functions.html#type ""(in Python v3.12)"")  *|*[*qiskit.circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")  *|*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")  *|*[*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")*\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*type*](https://docs.python.org/3/library/functions.html#type ""(in Python v3.12)"")  *|*[*qiskit.circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")  *|*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*] | None*) – The SU(2) single qubit gates to apply in single qubit gate layers. If only one gate is provided, the same gate is applied to each qubit. If a list of gates is provided, all gates are applied to each qubit in the provided order.Document 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 3:::
ParameterView([Parameter(a), Parameter(b), Parameter(elephant)])
    ```

    Bear in mind that alphabetical sorting might be unintuitive when it comes to numbers. The literal “10” comes before “2” in strict alphabetical sorting.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter
    >>> angles = [Parameter(""angle_1""), Parameter(""angle_2""), Parameter(""angle_10"")]
    >>> circuit = QuantumCircuit(1)
    >>> circuit.u(*angles, 0)
    >>> circuit.draw()
       ┌─────────────────────────────┐
    q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.QuantumCircuit.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.QuantumCircuit.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### add\_bits

  <Function id=""qiskit.circuit.QuantumCircuit.add_bits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1512-L1533"" signature=""add_bits(bits)"">
    Add Bits to the circuit.
  </Function>

  ### add\_calibration

  <Function id=""qiskit.circuit.QuantumCircuit.add_calibration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4806-L4854"" signature=""add_calibration(gate, qubits, schedule, params=None)"">
    Register a low-level, custom pulse definition for the given gate.

    **Parameters**

    *   **gate** (*Union\[*[*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – Gate information.
    *   **qubits** (*Union\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*, Tuple\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]]*) – List of qubits to be measured.
    *   **schedule** ([*Schedule*](qiskit.pulse.Schedule ""qiskit.pulse.Schedule"")) – Schedule information.
    *   **params** (*Optional\[List\[Union\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*,* [*Parameter*](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"")*]]]*) – A list of parameters.

    **Raises**

    [**Exception**](https://docs.python.org/3/library/exceptions.html#Exception ""(in Python v3.12)"") – if the gate is of type string and params is None.
  </Function>

  ### add\_register

  <Function id=""qiskit.circuit.QuantumCircuit.add_register"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1441-L1510"" signature=""add_register(*regs)"">
    Add registers.
  </Function>

  ### append

  <Function id=""qiskit.circuit.QuantumCircuit.append"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1204-L1285"" signature=""append(instruction, qargs=None, cargs=None)"">
    Append one or more instructions to the end of the circuit, modifying the circuit in place.

    The `qargs` and `cargs` will be expanded and broadcast according to the rules of the given [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction""), and any non-[`Bit`](qiskit.circuit.Bit ""qiskit.circuit.Bit"") specifiers (such as integer indices) will be resolved into the relevant instances.

    If a [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"") is given, it will be unwrapped, verified in the context of this circuit, and a new object will be appended to the circuit. In this case, you may not pass `qargs` or `cargs` separately.

    **Parameters**

    *   **instruction** ([*Operation*](qiskit.circuit.Operation ""qiskit.circuit.Operation"")  *|*[*CircuitInstruction*](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")) – [`Instruction`](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"") instance to append, or a [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"") with all its context.Document 4:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter
    >>> angles = [Parameter(""angle_1""), Parameter(""angle_2""), Parameter(""angle_10"")]
    >>> circuit = QuantumCircuit(1)
    >>> circuit.u(*angles, 0)
    >>> circuit.draw()
       ┌─────────────────────────────┐
    q: ┤ U(angle_1,angle_2,angle_10) ├
       └─────────────────────────────┘
    >>> circuit.parameters
    ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])
    ```

    To respect numerical sorting, a [`ParameterVector`](qiskit.circuit.ParameterVector ""qiskit.circuit.ParameterVector"") can be used.

    ```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.QuadraticForm.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.QuadraticForm.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### required\_result\_qubits

  <Function id=""qiskit.circuit.library.QuadraticForm.required_result_qubits"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/arithmetic/quadratic_form.py#L165-L197"" signature=""required_result_qubits(quadratic, linear, offset)"" modifiers=""static"">
    Get the number of required result qubits.

    **Parameters**

    *   **quadratic** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]]*) – A matrix containing the quadratic coefficients.
    *   **linear** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")  *|*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")*]*) – An array containing the linear coefficients.
    *   **offset** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – A constant offset.

    **Returns**

    The number of qubits needed to represent the value of the quadratic form in twos complement.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")
  </Function>
</Class>""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator

Write a function that creates a quantum circuit to implement the
 Hidden Subgroup Problem (HSP) for a specific function. The circuit
 should include a function that maps group elements to a hidden
 subgroup and perform the necessary quantum operations to identify
 the subgroup.
 Parameters: n_qubits (int): Number of qubits in the quantum circuit.
Returns: QuantumCircuit: The quantum circuit implementing the
 Hidden Subgroup Problem.


# Context:
""""""Document 0:::
---
title: HiddenLinearFunction
description: API reference for qiskit.circuit.library.HiddenLinearFunction
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.HiddenLinearFunction
---

# HiddenLinearFunction

<Class id=""qiskit.circuit.library.HiddenLinearFunction"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/hidden_linear_function.py#L22-L98"" signature=""qiskit.circuit.library.HiddenLinearFunction(adjacency_matrix)"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  Circuit to solve the hidden linear function problem.

  The 2D Hidden Linear Function problem is determined by a 2D adjacency matrix A, where only elements that are nearest-neighbor on a grid have non-zero entries. Each row/column corresponds to one binary variable $x_i$.

  The hidden linear function problem is as follows:

  Consider the quadratic form

$$
q(x) = \sum_{i,j=1}^{n}{x_i x_j} ~(\mathrm{mod}~ 4)
$$

  and restrict $q(x)$ onto the nullspace of A. This results in a linear function.

$$
2 \sum_{i=1}^{n}{z_i x_i} ~(\mathrm{mod}~ 4)  \forall  x \in \mathrm{Ker}(A)
$$

  and the goal is to recover this linear function (equivalently a vector $[z_0, ..., z_{n-1}]$). There can be multiple solutions.

  In \[1] it is shown that the present circuit solves this problem on a quantum computer in constant depth, whereas any corresponding solution on a classical computer would require circuits that grow logarithmically with $n$. Thus this circuit is an example of quantum advantage with shallow circuits.

  **Reference Circuit:**

  > ![../\_images/qiskit-circuit-library-HiddenLinearFunction-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-HiddenLinearFunction-1.png)

  **Reference:**

  \[1] S. Bravyi, D. Gosset, R. Koenig, Quantum Advantage with Shallow Circuits, 2017. [arXiv:1704.00690](https://arxiv.org/abs/1704.00690)

  Create new HLF circuit.

  **Parameters**

  **adjacency\_matrix** ([*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*List*](https://docs.python.org/3/library/typing.html#typing.List ""(in Python v3.12)"")*\[*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]] |* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray ""(in NumPy v1.26)"")) – a symmetric n-by-n list of 0-1 lists. n will be the number of qubits.

  **Raises**

  [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If A is not symmetric.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.data"">
    Return the circuit data (instructions and context).

    **Returns**

    a list-like object containing the [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")s for each instruction.

    **Return type**

    QuantumCircuitData
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### instances

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.instances"" attributeValue=""176"" />

  ### layout

  <Attribute id=""qiskit.circuit.library.HiddenLinearFunction.layout"">
    Return any associated layout information about the circuit

    This attribute contains an optional [`TranspileLayout`](qiskit.transpiler.TranspileLayout ""qiskit.transpiler.TranspileLayout"") object. This is typically set on the output from [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") or [`PassManager.run()`](qiskit.transpiler.PassManager#run ""qiskit.transpiler.PassManager.run"") to retain information about the permutations caused on the input circuit by transpilation.

    There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.
  </Attribute>Document 1:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 2:::
```python
    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector
    >>> x = ParameterVector(""x"", 12)
    >>> circuit = QuantumCircuit(1)
    >>> for x_i in x:
    ...     circuit.rx(x_i, 0)
    >>> circuit.parameters
    ParameterView([
        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),
        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),
        ..., ParameterVectorElement(x[11])
    ])
    ```

    **Returns**

    The sorted [`Parameter`](qiskit.circuit.Parameter ""qiskit.circuit.Parameter"") objects in the circuit.
  </Attribute>

  ### prefix

  <Attribute id=""qiskit.circuit.library.MCMTVChain.prefix"" attributeValue=""'circuit'"" />

  ### qubits

  <Attribute id=""qiskit.circuit.library.MCMTVChain.qubits"">
    Returns a list of quantum bits in the order that the registers were added.
  </Attribute>

  ## Methods

  ### inverse

  <Function id=""qiskit.circuit.library.MCMTVChain.inverse"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/mcmt.py#L255-L256"" signature=""inverse(annotated=False)"">
    Return the inverse MCMT circuit, which is itself.
  </Function>
</Class>Document 3:::
*   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Optional number of times the circuit should be decomposed. For instance, `reps=2` equals calling `circuit.decompose().decompose()`. can decompose specific gates specific time

    **Returns**

    a circuit one level decomposed

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### delay

  <Function id=""qiskit.circuit.QuantumCircuit.delay"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2847-L2871"" signature=""delay(duration, qarg=None, unit='dt')"">
    Apply [`Delay`](qiskit.circuit.Delay ""qiskit.circuit.Delay""). If qarg is `None`, applies to all qubits. When applying to multiple qubits, delays with the same duration will be created.

    **Parameters**

    *   **duration** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *or*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *or*[*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.ParameterExpression"")) – duration of the delay.
    *   **qarg** (*Object*) – qubit argument to apply this delay.
    *   **unit** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – unit of the duration. Supported units: `'s'`, `'ms'`, `'us'`, `'ns'`, `'ps'`, and `'dt'`. Default is `'dt'`, i.e. integer time unit depending on the target backend.

    **Returns**

    handle to the added instructions.

    **Return type**

    [qiskit.circuit.InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if arguments have bad format.
  </Function>

  ### depth

  <Function id=""qiskit.circuit.QuantumCircuit.depth"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1839-L1913"" signature=""depth(filter_function=<function QuantumCircuit.<lambda>>)"">
    Return circuit depth (i.e., length of critical path).

    **Parameters**

    **filter\_function** (*callable*) – A function to filter instructions. Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)). Instructions for which the function returns False are ignored in the computation of the circuit depth. By default filters out “directives”, such as barrier or snapshot.

    **Returns**

    Depth of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")

    **Notes**

    The circuit depth and the DAG depth need not be the same.
  </Function>

  ### draw

  <Function id=""qiskit.circuit.QuantumCircuit.draw"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1655-L1819"" signature=""draw(output=None, scale=None, filename=None, style=None, interactive=False, plot_barriers=True, reverse_bits=None, justify=None, vertical_compression='medium', idle_wires=True, with_layout=True, fold=None, ax=None, initial_state=False, cregbundle=None, wire_order=None, expr_len=30)"">
    Draw the quantum circuit. Use the output parameter to choose the drawing format:

    **text**: ASCII art TextDrawing that can be printed in the console.

    **mpl**: images with color rendered purely in Python using matplotlib.

    **latex**: high-quality images compiled via latex.

    **latex\_source**: raw uncompiled latex output.

    <Admonition title=""Warning"" type=""caution"">
      Support for [`Expr`](circuit_classical#qiskit.circuit.classical.expr.Expr ""qiskit.circuit.classical.expr.Expr"") nodes in conditions and `SwitchCaseOp.target` fields is preliminary and incomplete. The `text` and `mpl` drawers will make a best-effort attempt to show data dependencies, but the LaTeX-based drawers will skip these completely.
    </Admonition>

    **Parameters**

    *   **output** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Select the output method to use for drawing the circuit. Valid choices are `text`, `mpl`, `latex`, `latex_source`. By default the text drawer is used unless the user config file (usually `~/.qiskit/settings.conf`) has an alternative backend set as the default. For example, `circuit_drawer = latex`. If the output kwarg is set, that backend will always be used over the default in the user config file.

    *   **scale** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"") *| None*) – Scale of image to draw (shrink if `< 1.0`). Only used by the `mpl`, `latex` and `latex_source` outputs. Defaults to `1.0`.

    *   **filename** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – File path to save image to. Defaults to `None` (result not saved in a file).Document 4:::
*   **true\_body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The circuit body to be run if `condition` is true.
    *   **qubits** (*Optional\[Sequence\[QubitSpecifier]]*) – The circuit qubits over which the if/else should be run.
    *   **clbits** (*Optional\[Sequence\[ClbitSpecifier]]*) – The circuit clbits over which the if/else should be run.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    depending on the call signature, either a context manager for creating the `if` block (it will automatically be added to the circuit at the end of the block), or an [`InstructionSet`](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") handle to the appended conditional operation.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or IfContext

    **Raises**

    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the provided condition references Clbits outside the enclosing circuit.
    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.

    **Returns**

    A handle to the instruction created.
  </Function>

  ### initialize

  <Function id=""qiskit.circuit.QuantumCircuit.initialize"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4069-L4178"" signature=""initialize(params, qubits=None, normalize=False)"">
    Initialize qubits in a specific state.

    Qubit initialization is done by first resetting the qubits to $|0\rangle$ followed by calling [`StatePreparation`](qiskit.circuit.library.StatePreparation ""qiskit.circuit.library.StatePreparation"") class to prepare the qubits in a specified state. Both these steps are included in the [`Initialize`](qiskit.circuit.library.Initialize ""qiskit.circuit.library.Initialize"") instruction.

    **Parameters**

    *   **params** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"") *| Sequence\[*[*complex*](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")*] |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –

        The state to initialize to, can be either of the following.

        *   Statevector or vector of complex amplitudes to initialize to.
        *   Labels of basis states of the Pauli eigenstates Z, X, Y. See [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label""). Notice the order of the labels is reversed with respect to the qubit index to be applied to. Example label ‘01’ initializes the qubit zero to $|1\rangle$ and the qubit one to $|0\rangle$.
        *   An integer that is used as a bitmap indicating which qubits to initialize to $|1\rangle$. Example: setting params to 5 would initialize qubit 0 and qubit 2 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    *   **qubits** (*Sequence\[QubitSpecifier] | None*) – Qubits to initialize. If `None` the initialization is applied to all qubits in the circuit.

    *   **normalize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to normalize an input array to a unit vector.

    **Returns**

    A handle to the instructions created.

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.initialize([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────────────────┐
    q_0: ┤ Initialize(0.70711,-0.70711) ├
         └──────────────────────────────┘
    ```

    Initialize from a string two qubits in the state $|10\rangle$. The order of the labels is reversed with respect to qubit index. More information about labels for basis states are in [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label"").

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────┐
    q_0: ┤0                 ├
         │  Initialize(0,1) │
    q_1: ┤1                 ├
         └──────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌────────────────────────────────────┐
    q_0: ┤0                                   ├
         │  Initialize(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                   ├""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit
from qiskit.circuit.library import U3Gate

Write a function to create a quantum circuit that performs quantum
 metrology to estimate a small phase shift. The circuit should prepare
 an entangled state, apply a small phase shift to one qubit, and perform
 measurements to estimate the phase.
Parameters: phase (float): The small phase shift to be estimated.
Returns: QuantumCircuit: The quantum circuit implementing quantum
 metrology.


# Context:
""""""Document 0:::
---
title: PhaseEstimation
description: API reference for qiskit.circuit.library.PhaseEstimation
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.PhaseEstimation
---

# PhaseEstimation

<Class id=""qiskit.circuit.library.PhaseEstimation"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/phase_estimation.py#L22-L99"" signature=""qiskit.circuit.library.PhaseEstimation(num_evaluation_qubits, unitary, iqft=None, name='QPE')"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  Phase Estimation circuit.

  In the Quantum Phase Estimation (QPE) algorithm \[1, 2, 3], the Phase Estimation circuit is used to estimate the phase $\phi$ of an eigenvalue $e^{2\pi i\phi}$ of a unitary operator $U$, provided with the corresponding eigenstate $|\psi\rangle$. That is

$$
U|\psi\rangle = e^{2\pi i\phi} |\psi\rangle
$$

  This estimation (and thereby this circuit) is a central routine to several well-known algorithms, such as Shor’s algorithm or Quantum Amplitude Estimation.

  **References:**

  **\[1]: Kitaev, A. Y. (1995). Quantum measurements and the Abelian Stabilizer Problem. 1–22.**

  [quant-ph/9511026](http://arxiv.org/abs/quant-ph/9511026)

  **\[2]: Michael A. Nielsen and Isaac L. Chuang. 2011.**

  Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.). Cambridge University Press, New York, NY, USA.

  **\[3]: Qiskit**

  [textbook](https://github.com/Qiskit/textbook/blob/main/notebooks/ch-algorithms/quantum-phase-estimation.ipynb)

  **Parameters**

  *   **num\_evaluation\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The number of evaluation qubits.
  *   **unitary** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")) – The unitary operation $U$ which will be repeated and controlled.
  *   **iqft** ([*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"") *| None*) – A inverse Quantum Fourier Transform, per default the inverse of [`QFT`](qiskit.circuit.library.QFT ""qiskit.circuit.library.QFT"") is used. Note that the QFT should not include the usual swaps!
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – The name of the circuit.

  <Admonition title=""Note"" type=""note"">
    The inverse QFT should not include a swap of the qubit order.
  </Admonition>

  **Reference Circuit:**

  ![../\_images/qiskit-circuit-library-PhaseEstimation-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-PhaseEstimation-1.png)

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.data"">
    Return the circuit data (instructions and context).

    **Returns**

    a list-like object containing the [`CircuitInstruction`](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")s for each instruction.

    **Return type**

    QuantumCircuitData
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### instances

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.instances"" attributeValue=""202"" />

  ### layout

  <Attribute id=""qiskit.circuit.library.PhaseEstimation.layout"">
    Return any associated layout information about the circuit

    This attribute contains an optional [`TranspileLayout`](qiskit.transpiler.TranspileLayout ""qiskit.transpiler.TranspileLayout"") object. This is typically set on the output from [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") or [`PassManager.run()`](qiskit.transpiler.PassManager#run ""qiskit.transpiler.PassManager.run"") to retain information about the permutations caused on the input circuit by transpilation.

    There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.Document 1:::
---
title: circuit
description: API reference for qiskit.circuit
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.circuit
---

<span id=""module-qiskit.circuit"" />

<span id=""qiskit-circuit"" />

<span id=""quantum-circuits-qiskit-circuit"" />

# Quantum Circuits

<span id=""module-qiskit.circuit"" />

`qiskit.circuit`

## Overview

The fundamental element of quantum computing is the **quantum circuit**. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.

In Qiskit, this core element is represented by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") class. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:

$$
|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}
$$

```python
from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')
```

![../\_images/circuit-1.png](/images/api/qiskit/1.0/circuit-1.png)

## Supplementary Information

### Quantum Circuit with conditionals

When building a quantum circuit, there can be interest in applying a certain gate only if a classical register has a specific value. This can be done with the [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if ""qiskit.circuit.InstructionSet.c_if"") method.

In the following example, we start with a single-qubit circuit formed by only a Hadamard gate ([`HGate`](qiskit.circuit.library.HGate ""qiskit.circuit.library.HGate"")), in which we expect to get $|0\rangle$ and $|1\rangle$ with equal probability.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')
```

![../\_images/circuit-2.png](/images/api/qiskit/1.0/circuit-2.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'0': 524, '1': 500}
```

Now, we add an [`XGate`](qiskit.circuit.library.XGate ""qiskit.circuit.library.XGate"") only if the value of the [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") is 0. That way, if the state is $|0\rangle$, it will be changed to $|1\rangle$ and if the state is $|1\rangle$, it will not be changed at all, so the final state will always be $|1\rangle$.

```python
from qiskit import transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')
```

![../\_images/circuit-3.png](/images/api/qiskit/1.0/circuit-3.png)

```python
from qiskit.providers.basic_provider import BasicSimulator
backend = BasicSimulator()
tqc = transpile(qc, backend)
counts = backend.run(tqc).result().get_counts()

print(counts)
```

```python
{'1': 1024}
```

### Quantum Circuit Properties

When constructing quantum circuits, there are several properties that help quantify the “size” of the circuits, and their ability to be run on a noisy quantum device. Some of these, like number of qubits, are straightforward to understand, while others like depth and number of tensor components require a bit more explanation. Here we will explain all of these properties, and, in preparation for understanding how circuits change when run on actual devices, highlight the conditions under which they change.

Consider the following circuit:

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')
```Document 2:::
---
title: QFT
description: API reference for qiskit.circuit.library.QFT
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.QFT
---

# QFT

<Class id=""qiskit.circuit.library.QFT"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/basis_change/qft.py#L24-L295"" signature=""qiskit.circuit.library.QFT(num_qubits=None, approximation_degree=0, do_swaps=True, inverse=False, insert_barriers=False, name=None)"" modifiers=""class"">
  Bases: `BlueprintCircuit`

  Quantum Fourier Transform Circuit.

  The Quantum Fourier Transform (QFT) on $n$ qubits is the operation

$$
|j\rangle \mapsto \frac{1}{2^{n/2}} \sum_{k=0}^{2^n - 1} e^{2\pi ijk / 2^n} |k\rangle
$$

  The circuit that implements this transformation can be implemented using Hadamard gates on each qubit, a series of controlled-U1 (or Z, depending on the phase) gates and a layer of Swap gates. The layer of Swap gates can in principle be dropped if the QFT appears at the end of the circuit, since then the re-ordering can be done classically. They can be turned off using the `do_swaps` attribute.

  For 4 qubits, the circuit that implements this transformation is:

  ![../\_images/qiskit-circuit-library-QFT-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-1.png)

  The inverse QFT can be obtained by calling the `inverse` method on this class. The respective circuit diagram is:

  ![../\_images/qiskit-circuit-library-QFT-2.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-2.png)

  One method to reduce circuit depth is to implement the QFT approximately by ignoring controlled-phase rotations where the angle is beneath a threshold. This is discussed in more detail in [https://arxiv.org/abs/quant-ph/9601018](https://arxiv.org/abs/quant-ph/9601018) or [https://arxiv.org/abs/quant-ph/0403071](https://arxiv.org/abs/quant-ph/0403071).

  Here, this can be adjusted using the `approximation_degree` attribute: the smallest `approximation_degree` rotation angles are dropped from the QFT. For instance, a QFT on 5 qubits with approximation degree 2 yields (the barriers are dropped in this example):

  ![../\_images/qiskit-circuit-library-QFT-3.png](/images/api/qiskit/1.0/qiskit-circuit-library-QFT-3.png)

  Construct a new QFT circuit.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The number of qubits on which the QFT acts.
  *   **approximation\_degree** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The degree of approximation (0 for no approximation).
  *   **do\_swaps** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to include the final swaps in the QFT.
  *   **inverse** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, the inverse Fourier transform is constructed.
  *   **insert\_barriers** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, barriers are inserted as visualization improvement.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The name of the circuit.

  ## Attributes

  ### ancillas

  <Attribute id=""qiskit.circuit.library.QFT.ancillas"">
    Returns a list of ancilla bits in the order that the registers were added.
  </Attribute>

  ### approximation\_degree

  <Attribute id=""qiskit.circuit.library.QFT.approximation_degree"">
    The approximation degree of the QFT.

    **Returns**

    The currently set approximation degree.
  </Attribute>

  ### calibrations

  <Attribute id=""qiskit.circuit.library.QFT.calibrations"">
    Return calibration dictionary.

    The custom pulse definition of a given gate is of the form `{'gate_name': {(qubits, params): schedule}}`
  </Attribute>

  ### clbits

  <Attribute id=""qiskit.circuit.library.QFT.clbits"">
    Returns a list of classical bits in the order that the registers were added.
  </Attribute>

  ### data

  <Attribute id=""qiskit.circuit.library.QFT.data"" />

  ### do\_swaps

  <Attribute id=""qiskit.circuit.library.QFT.do_swaps"">
    Whether the final swaps of the QFT are applied or not.

    **Returns**

    True, if the final swaps are applied, False if not.
  </Attribute>

  ### global\_phase

  <Attribute id=""qiskit.circuit.library.QFT.global_phase"">
    Return the global phase of the current circuit scope in radians.
  </Attribute>

  ### insert\_barriers

  <Attribute id=""qiskit.circuit.library.QFT.insert_barriers"">
    Whether barriers are inserted for better visualization or not.

    **Returns**

    True, if barriers are inserted, False if not.
  </Attribute>

  ### instancesDocument 3:::
**Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### measure

  <Function id=""qiskit.circuit.QuantumCircuit.measure"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2189-L2264"" signature=""measure(qubit, cbit)"">
    Measure a quantum bit (`qubit`) in the Z basis into a classical bit (`cbit`).

    When a quantum state is measured, a qubit is projected in the computational (Pauli Z) basis to either $\lvert 0 \rangle$ or $\lvert 1 \rangle$. The classical bit `cbit` indicates the result of that projection as a `0` or a `1` respectively. This operation is non-reversible.

    **Parameters**

    *   **qubit** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.quantumregister.QuantumRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – qubit(s) to measure.
    *   **cbit** ([*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.classicalregister.Clbit"")  *|*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.classicalregister.ClassicalRegister"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *|*[*slice*](https://docs.python.org/3/library/functions.html#slice ""(in Python v3.12)"")  *|*[*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence ""(in Python v3.12)"")*\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.classicalregister.Clbit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – classical bit(s) to place the measurement result(s) in.

    **Returns**

    handle to the added instructions.

    **Return type**

    [qiskit.circuit.InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if arguments have bad format.

    **Examples**

    In this example, a qubit is measured and the result of that measurement is stored in the classical bit (usually expressed in diagrams as a double line):

    ```python
    from qiskit import QuantumCircuit
    circuit = QuantumCircuit(1, 1)
    circuit.h(0)
    circuit.measure(0, 0)
    circuit.draw()
    ```

    ```python
         ┌───┐┌─┐
      q: ┤ H ├┤M├
         └───┘└╥┘
    c: 1/══════╩═
               0
    ```

    It is possible to call `measure` with lists of `qubits` and `cbits` as a shortcut for one-to-one measurement. These two forms produce identical results:

    ```python
    circuit = QuantumCircuit(2, 2)
    circuit.measure([0,1], [0,1])
    ```

    ```python
    circuit = QuantumCircuit(2, 2)
    circuit.measure(0, 0)
    circuit.measure(1, 1)
    ```

    Instead of lists, you can use [`QuantumRegister`](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"") and [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") under the same logic.

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    qreg = QuantumRegister(2, ""qreg"")
    creg = ClassicalRegister(2, ""creg"")
    circuit = QuantumCircuit(qreg, creg)
    circuit.measure(qreg, creg)
    ```

    This is equivalent to:

    ```python
    circuit = QuantumCircuit(qreg, creg)
    circuit.measure(qreg[0], creg[0])
    circuit.measure(qreg[1], creg[1])
    ```
  </Function>

  ### measure\_active

  <Function id=""qiskit.circuit.QuantumCircuit.measure_active"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2266-L2294"" signature=""measure_active(inplace=True)"">
    Adds measurement to all non-idle qubits. Creates a new ClassicalRegister with a size equal to the number of non-idle qubits being measured.

    Returns a new circuit with measurements if inplace=False.

    **Parameters**

    **inplace** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – All measurements inplace or return new circuit.

    **Returns**

    Returns circuit with measurements when inplace = False.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### measure\_allDocument 4:::
*   **clbits** (*Optional\[Sequence\[ClbitSpecifier]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.

    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    depending on the call signature, either a context manager for creating the for loop (it will automatically be added to the circuit at the end of the block), or an [`InstructionSet`](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") handle to the appended loop operation.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or ForLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### from\_instructions

  <Function id=""qiskit.circuit.QuantumCircuit.from_instructions"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L283-L334"" signature=""from_instructions(instructions, *, qubits=(), clbits=(), name=None, global_phase=0, metadata=None)"" modifiers=""static"">
    Construct a circuit from an iterable of CircuitInstructions.

    **Parameters**

    *   **instructions** (*Iterable\[*[*CircuitInstruction*](qiskit.circuit.CircuitInstruction ""qiskit.circuit.CircuitInstruction"")  *|*[*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*qiskit.circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")*] |* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*qiskit.circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")*, Iterable\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]] |* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple ""(in Python v3.12)"")*\[*[*qiskit.circuit.Instruction*](qiskit.circuit.Instruction ""qiskit.circuit.Instruction"")*, Iterable\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*], Iterable\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]]*) – The instructions to add to the circuit.
    *   **qubits** (*Iterable\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]*) – Any qubits to add to the circuit. This argument can be used, for example, to enforce a particular ordering of qubits.
    *   **clbits** (*Iterable\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]*) – Any classical bits to add to the circuit. This argument can be used, for example, to enforce a particular ordering of classical bits.
    *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – The name of the circuit.
    *   **global\_phase** (*ParameterValueType*) – The global phase of the circuit in radians.
    *   **metadata** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict ""(in Python v3.12)"") *| None*) – Arbitrary key value metadata to associate with the circuit.

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### from\_qasm\_file

  <Function id=""qiskit.circuit.QuantumCircuit.from_qasm_file"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2404-L2427"" signature=""from_qasm_file(path)"" modifiers=""static"">
    Read an OpenQASM 2.0 program from a file and convert to an instance of [`QuantumCircuit`](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

    **Parameters**

    **path** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – Path to the file for an OpenQASM 2 program

    **Returns**

    The QuantumCircuit object for the input OpenQASM 2.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    <Admonition title=""See also"" type=""note"">
      [`qasm2.load()`](qasm2#qiskit.qasm2.load ""qiskit.qasm2.load""): the complete interface to the OpenQASM 2 importer.
    </Admonition>
  </Function>

  ### from\_qasm\_str

  <Function id=""qiskit.circuit.QuantumCircuit.from_qasm_str"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2429-L2450"" signature=""from_qasm_str(qasm_str)"" modifiers=""static"">
    Convert a string containing an OpenQASM 2.0 program to a [`QuantumCircuit`](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"").

    **Parameters**""""""
# Generate Code here:
"
"# Prompt:

""from qiskit import QuantumCircuit

Write a function to create a quantum circuit that simulates the
 behavior of a quantum particle in a potential well. The function should
 use a finite number of qubits to represent the position and momentum
 of the particle and apply the appropriate unitary operations.
Parameters: n_qubits (int): Number of qubits representing the particle's
 state.
Returns: QuantumCircuit: The quantum circuit simulating the quantum
 particle in a potential well.


# Context:
""""""Document 0:::
circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘
    ```
  </Function>

  ### qbit\_argument\_conversion

  <Function id=""qiskit.circuit.QuantumCircuit.qbit_argument_conversion"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1174-L1187"" signature=""qbit_argument_conversion(qubit_representation)"">
    Converts several qubit representations (such as indexes, range, etc.) into a list of qubits.

    **Parameters**

    **qubit\_representation** (*Object*) – representation to expand

    **Returns**

    the resolved instances of the qubits.

    **Return type**

    List([Qubit](qiskit.circuit.Qubit ""qiskit.circuit.Qubit""))
  </Function>

  ### qubit\_duration

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_duration"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4857-L4867"" signature=""qubit_duration(*qubits)"">
    Return the duration between the start and stop time of the first and last instructions, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    **Parameters**

    **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include.

    **Returns**

    Return the duration between the first start and last stop time of non-delay instructions

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_start\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_start_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4869-L4909"" signature=""qubit_start_time(*qubits)"">
    Return the start time of the first instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the start time of the first instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### qubit\_stop\_time

  <Function id=""qiskit.circuit.QuantumCircuit.qubit_stop_time"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4911-L4951"" signature=""qubit_stop_time(*qubits)"">
    Return the stop time of the last instruction, excluding delays, over the supplied qubits. Its time unit is `self.unit`.

    Return 0 if there are no instructions over qubits

    **Parameters**

    *   **\*qubits** ([*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.quantumregister.Qubit"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Qubits within `self` to include. Integers are allowed for qubits, indicating
    *   **self.qubits.** (*indices of*) –

    **Returns**

    Return the stop time of the last instruction, excluding delays, over the qubits

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if `self` is a not-yet scheduled circuit.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")
  </Function>

  ### rDocument 1:::
### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Example**

    Apply a gate specified by a unitary matrix to a quantum circuit

    ```python
    from qiskit import QuantumCircuit
    matrix = [[0, 0, 0, 1],
            [0, 0, 1, 0],
            [1, 0, 0, 0],
            [0, 1, 0, 0]]
    circuit = QuantumCircuit(2)
    circuit.unitary(matrix, [0, 1])
    ```
  </Function>

  ### while\_loop

  <Function id=""qiskit.circuit.QuantumCircuit.while_loop"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4342-L4403"" signature=""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: None, qubits: None, clbits: None, *, label: str | None) → WhileLoopContext"" extraSignatures={[""while_loop(condition: tuple[ClassicalRegister | Clbit, int] | expr.Expr, body: QuantumCircuit, qubits: Sequence[Qubit | QuantumRegister | int | slice | Sequence[Qubit | int]], clbits: Sequence[Clbit | ClassicalRegister | int | slice | Sequence[Clbit | int]], *, label: str | None) → InstructionSet""]}>
    Create a `while` loop on this circuit.

    There are two forms for calling this function. If called with all its arguments (with the possible exception of `label`), it will create a `WhileLoopOp` with the given `body`. If `body` (and `qubits` and `clbits`) are *not* passed, then this acts as a context manager, which will automatically build a `WhileLoopOp` when the scope finishes. In this form, you do not need to keep track of the qubits or clbits you are using, because the scope will handle it for you.

    Example usage:

    ```python
    from qiskit.circuit import QuantumCircuit, Clbit, Qubit
    bits = [Qubit(), Qubit(), Clbit()]
    qc = QuantumCircuit(bits)

    with qc.while_loop((bits[2], 0)):
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(0, 0)
    ```

    **Parameters**

    *   **condition** (*Tuple\[Union\[*[*ClassicalRegister*](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")*,* [*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*],* [*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")*]*) – An equality condition to be checked prior to executing `body`. The left-hand side of the condition must be a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"") or a [`Clbit`](qiskit.circuit.Clbit ""qiskit.circuit.Clbit""), and the right-hand side must be an integer or boolean.
    *   **body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The loop body to be repeatedly executed. Omit this to use the context-manager mode.
    *   **qubits** (*Optional\[Sequence\[*[*Qubit*](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")*]]*) – The circuit qubits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **clbits** (*Optional\[Sequence\[*[*Clbit*](qiskit.circuit.Clbit ""qiskit.circuit.Clbit"")*]]*) – The circuit clbits over which the loop body should be run. Omit this to use the context-manager mode.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    If used in context-manager mode, then this should be used as a `with` resource, which will infer the block content and operands on exit. If the full form is used, then this returns a handle to the instructions created.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or WhileLoopContext

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.
  </Function>

  ### width

  <Function id=""qiskit.circuit.QuantumCircuit.width"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1915-L1922"" signature=""width()"">
    Return number of qubits plus clbits in circuit.

    **Returns**

    Width of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")Document 2:::
*   **true\_body** (*Optional\[*[*QuantumCircuit*](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")*]*) – The circuit body to be run if `condition` is true.
    *   **qubits** (*Optional\[Sequence\[QubitSpecifier]]*) – The circuit qubits over which the if/else should be run.
    *   **clbits** (*Optional\[Sequence\[ClbitSpecifier]]*) – The circuit clbits over which the if/else should be run.
    *   **label** (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")*]*) – The string label of the instruction in the circuit.

    **Returns**

    depending on the call signature, either a context manager for creating the `if` block (it will automatically be added to the circuit at the end of the block), or an [`InstructionSet`](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") handle to the appended conditional operation.

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"") or IfContext

    **Raises**

    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the provided condition references Clbits outside the enclosing circuit.
    *   [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if an incorrect calling convention is used.

    **Returns**

    A handle to the instruction created.
  </Function>

  ### initialize

  <Function id=""qiskit.circuit.QuantumCircuit.initialize"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4069-L4178"" signature=""initialize(params, qubits=None, normalize=False)"">
    Initialize qubits in a specific state.

    Qubit initialization is done by first resetting the qubits to $|0\rangle$ followed by calling [`StatePreparation`](qiskit.circuit.library.StatePreparation ""qiskit.circuit.library.StatePreparation"") class to prepare the qubits in a specified state. Both these steps are included in the [`Initialize`](qiskit.circuit.library.Initialize ""qiskit.circuit.library.Initialize"") instruction.

    **Parameters**

    *   **params** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"") *| Sequence\[*[*complex*](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")*] |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –

        The state to initialize to, can be either of the following.

        *   Statevector or vector of complex amplitudes to initialize to.
        *   Labels of basis states of the Pauli eigenstates Z, X, Y. See [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label""). Notice the order of the labels is reversed with respect to the qubit index to be applied to. Example label ‘01’ initializes the qubit zero to $|1\rangle$ and the qubit one to $|0\rangle$.
        *   An integer that is used as a bitmap indicating which qubits to initialize to $|1\rangle$. Example: setting params to 5 would initialize qubit 0 and qubit 2 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    *   **qubits** (*Sequence\[QubitSpecifier] | None*) – Qubits to initialize. If `None` the initialization is applied to all qubits in the circuit.

    *   **normalize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to normalize an input array to a unit vector.

    **Returns**

    A handle to the instructions created.

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.initialize([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────────────────┐
    q_0: ┤ Initialize(0.70711,-0.70711) ├
         └──────────────────────────────┘
    ```

    Initialize from a string two qubits in the state $|10\rangle$. The order of the labels is reversed with respect to qubit index. More information about labels for basis states are in [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label"").

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────┐
    q_0: ┤0                 ├
         │  Initialize(0,1) │
    q_1: ┤1                 ├
         └──────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌────────────────────────────────────┐
    q_0: ┤0                                   ├
         │  Initialize(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                   ├Document 3:::
A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### power

  <Function id=""qiskit.circuit.QuantumCircuit.power"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L742-L783"" signature=""power(power, matrix_power=False)"">
    Raise this circuit to the power of `power`.

    If `power` is a positive integer and `matrix_power` is `False`, this implementation defaults to calling `repeat`. Otherwise, if the circuit is unitary, the matrix is computed to calculate the matrix power.

    **Parameters**

    *   **power** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")) – The power to raise this circuit to.
    *   **matrix\_power** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If True, the circuit is converted to a matrix and then the matrix power is computed. If False, and `power` is a positive integer, the implementation defaults to `repeat`.

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – If the circuit needs to be converted to a gate but it is not unitary.

    **Returns**

    A circuit implementing this circuit raised to the power of `power`.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### prepare\_state

  <Function id=""qiskit.circuit.QuantumCircuit.prepare_state"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3957-L4067"" signature=""prepare_state(state, qubits=None, label=None, normalize=False)"">
    Prepare qubits in a specific state.

    This class implements a state preparing unitary. Unlike [`initialize()`](#qiskit.circuit.QuantumCircuit.initialize ""qiskit.circuit.QuantumCircuit.initialize"") it does not reset the qubits first.

    **Parameters**

    *   **state** ([*Statevector*](qiskit.quantum_info.Statevector ""qiskit.quantum_info.Statevector"") *| Sequence\[*[*complex*](https://docs.python.org/3/library/functions.html#complex ""(in Python v3.12)"")*] |* [*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")  *|*[*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) –

        The state to initialize to, can be either of the following.

        *   Statevector or vector of complex amplitudes to initialize to.
        *   Labels of basis states of the Pauli eigenstates Z, X, Y. See [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label""). Notice the order of the labels is reversed with respect to the qubit index to be applied to. Example label ‘01’ initializes the qubit zero to $|1\rangle$ and the qubit one to $|0\rangle$.
        *   An integer that is used as a bitmap indicating which qubits to initialize to $|1\rangle$. Example: setting params to 5 would initialize qubit 0 and qubit 2 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    *   **qubits** (*Sequence\[QubitSpecifier] | None*) – Qubits to initialize. If `None` the initialization is applied to all qubits in the circuit.

    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – An optional label for the gate

    *   **normalize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to normalize an input array to a unit vector.

    **Returns**

    A handle to the instruction that was just initialized

    **Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.prepare_state([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────────────────┐
    q_0: ┤ State Preparation(0.70711,-0.70711) ├
         └─────────────────────────────────────┘
    ```

    Prepare from a string two qubits in the state $|10\rangle$. The order of the labels is reversed with respect to qubit index. More information about labels for basis states are in [`Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label ""qiskit.quantum_info.Statevector.from_label"").

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────┐
    q_0: ┤0                        ├
         │  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)Document 4:::
*   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Optional number of times the circuit should be decomposed. For instance, `reps=2` equals calling `circuit.decompose().decompose()`. can decompose specific gates specific time

    **Returns**

    a circuit one level decomposed

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### delay

  <Function id=""qiskit.circuit.QuantumCircuit.delay"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L2847-L2871"" signature=""delay(duration, qarg=None, unit='dt')"">
    Apply [`Delay`](qiskit.circuit.Delay ""qiskit.circuit.Delay""). If qarg is `None`, applies to all qubits. When applying to multiple qubits, delays with the same duration will be created.

    **Parameters**

    *   **duration** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")  *or*[*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"")  *or*[*ParameterExpression*](qiskit.circuit.ParameterExpression ""qiskit.circuit.ParameterExpression"")) – duration of the delay.
    *   **qarg** (*Object*) – qubit argument to apply this delay.
    *   **unit** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"")) – unit of the duration. Supported units: `'s'`, `'ms'`, `'us'`, `'ns'`, `'ps'`, and `'dt'`. Default is `'dt'`, i.e. integer time unit depending on the target backend.

    **Returns**

    handle to the added instructions.

    **Return type**

    [qiskit.circuit.InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Raises**

    [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if arguments have bad format.
  </Function>

  ### depth

  <Function id=""qiskit.circuit.QuantumCircuit.depth"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1839-L1913"" signature=""depth(filter_function=<function QuantumCircuit.<lambda>>)"">
    Return circuit depth (i.e., length of critical path).

    **Parameters**

    **filter\_function** (*callable*) – A function to filter instructions. Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)). Instructions for which the function returns False are ignored in the computation of the circuit depth. By default filters out “directives”, such as barrier or snapshot.

    **Returns**

    Depth of circuit.

    **Return type**

    [int](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")

    **Notes**

    The circuit depth and the DAG depth need not be the same.
  </Function>

  ### draw

  <Function id=""qiskit.circuit.QuantumCircuit.draw"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L1655-L1819"" signature=""draw(output=None, scale=None, filename=None, style=None, interactive=False, plot_barriers=True, reverse_bits=None, justify=None, vertical_compression='medium', idle_wires=True, with_layout=True, fold=None, ax=None, initial_state=False, cregbundle=None, wire_order=None, expr_len=30)"">
    Draw the quantum circuit. Use the output parameter to choose the drawing format:

    **text**: ASCII art TextDrawing that can be printed in the console.

    **mpl**: images with color rendered purely in Python using matplotlib.

    **latex**: high-quality images compiled via latex.

    **latex\_source**: raw uncompiled latex output.

    <Admonition title=""Warning"" type=""caution"">
      Support for [`Expr`](circuit_classical#qiskit.circuit.classical.expr.Expr ""qiskit.circuit.classical.expr.Expr"") nodes in conditions and `SwitchCaseOp.target` fields is preliminary and incomplete. The `text` and `mpl` drawers will make a best-effort attempt to show data dependencies, but the LaTeX-based drawers will skip these completely.
    </Admonition>

    **Parameters**

    *   **output** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Select the output method to use for drawing the circuit. Valid choices are `text`, `mpl`, `latex`, `latex_source`. By default the text drawer is used unless the user config file (usually `~/.qiskit/settings.conf`) has an alternative backend set as the default. For example, `circuit_drawer = latex`. If the output kwarg is set, that backend will always be used over the default in the user config file.

    *   **scale** ([*float*](https://docs.python.org/3/library/functions.html#float ""(in Python v3.12)"") *| None*) – Scale of image to draw (shrink if `< 1.0`). Only used by the `mpl`, `latex` and `latex_source` outputs. Defaults to `1.0`.

    *   **filename** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – File path to save image to. Defaults to `None` (result not saved in a file).""""""
# Generate Code here:
"
