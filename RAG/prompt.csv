"# Context: Use the following context to inform your code generation.
Document 0:::
Return a QuantumCircuit implementing the Clifford.

    For N \<= 3 qubits this is based on optimal CX cost decomposition from reference \[1]. For N > 3 qubits this is done using the general non-optimal compilation routine from reference \[2].

    **Returns**

    a circuit implementation of the Clifford.

    **Return type**

    [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **References**

    1.  S. Bravyi, D. Maslov, *Hadamard-free circuits expose the structure of the Clifford group*, [arXiv:2003.09412 \[quant-ph\]](https://arxiv.org/abs/2003.09412)Document 1:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### pauli

  <Function id=""qiskit.circuit.QuantumCircuit.pauli"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3939-L3955"" signature=""pauli(pauli_string, qubits)"">
    Apply [`PauliGate`](qiskit.circuit.library.PauliGate ""qiskit.circuit.library.PauliGate"").

    **Parameters**Document 2:::
*   **method** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Optional, a synthesis method (`'AG'` or `'greedy'`). If set this overrides optimal decomposition for $N \leq 3$ qubits.

  **Returns**

  A circuit implementation of the Clifford.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **References**""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that implements the Quantum Walk algorithm
 on a cycle graph with `n_qubits` qubits. The function should create 
and return a quantum circuit that simulates one step of the quantum
 walk.
Parameters: n_qubits (int): Number of qubits in the cycle graph.
Returns: QuantumCircuit: The quantum circuit implementing the 
quantum walk. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
### apply\_permutation

  <Function id=""qiskit.quantum_info.Operator.apply_permutation"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/quantum_info/operators/operator.py#L277-L354"" signature=""apply_permutation(perm, front=False)"">
    Modifies operator’s data by composing it with a permutation.

    **Parameters**

    *   **perm** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")) – permutation pattern, describing which qubits occupy the positions 0, 1, 2, etc. after applying the permutation.Document 1:::
Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  An n\_qubit circuit that permutes qubits.

  Return an n\_qubit permutation circuit implemented using SWAPs.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – circuit width.Document 2:::
There are two types of permutations caused by the [`transpile()`](compiler#qiskit.compiler.transpile ""qiskit.compiler.transpile"") function, an initial layout which permutes the qubits based on the selected physical qubits on the [`Target`](qiskit.transpiler.Target ""qiskit.transpiler.Target""), and a final layout which is an output permutation caused by [`SwapGate`](qiskit.circuit.library.SwapGate ""qiskit.circuit.library.SwapGate"")s inserted during routing.
  </Attribute>

  ### metadata

  <Attribute id=""qiskit.circuit.QuantumCircuit.metadata"">
    The user provided metadata associated with the circuit.""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that applies a permutation operation on `n_qubits`
 using Qiskit's Permutation gate. The function should return a quantum
 circuit that applies a specific permutation, such as a swap, on the
 qubits.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
pattern (list): A list specifying the permutation pattern (e.g., [2, 1, 0]
 for reversing a 3-qubit order). Returns: QuantumCircuit: The quantum
 circuit with the permutation operation applied. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
│  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘Document 1:::
**Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.prepare_state([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    output:

    ```python
         ┌─────────────────────────────────────┐
    q_0: ┤ State Preparation(0.70711,-0.70711) ├
         └─────────────────────────────────────┘Document 2:::
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
  pw_approximation._build()
  qc = QuantumCircuit(pw_approximation.num_qubits)
  qc.h(list(range(num_state_qubits)))
  qc.append(pw_approximation.to_instruction(), qc.qubits)
  qc.draw(output='mpl')
  ```

  ![../\_images/qiskit-circuit-library-PiecewiseChebyshev-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-PiecewiseChebyshev-1.png)

  **References**""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that constructs a quantum circuit to prepare a W
 state for `n_qubits`. The function should return the quantum circuit
 that generates the W state.
Parameters: n_qubits (int): Number of qubits in the W state.
Returns: QuantumCircuit: The quantum circuit that prepares the
 W state. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of each section, used in the Patel–Markov–Hayes algorithm \[1]. `section_size` must be a factor of the number of qubits.

  **Returns**

  a CX-only circuit implementing the linear transformation.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when variable `state` isn’t of type `numpy.ndarray`Document 1:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of every section in the Patel–Markov–Hayes algorithm. `section_size` must be a factor of the number of qubits.

  **Returns**

  The decomposed quantum circuit.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when dimensions of `cnots` and `angles` don’t align.

  **Return type**

  [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")Document 2:::
Implement a quantum bit.

  Creates a qubit.

  **Parameters**

  *   **register** ([*QuantumRegister*](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"")) – Optional. A quantum register containing the bit.
  *   **index** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Optional. The index of the bit in its containing register.

  **Raises**

  [**CircuitError**](circuit#qiskit.circuit.CircuitError ""qiskit.circuit.CircuitError"") – if the provided register is not a valid [`QuantumRegister`](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"")""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that implements the Quantum Counting algorithm.
 The function should create a quantum circuit that estimates the number
 of solutions to a given oracle function using `n_qubits`.
Parameters: n_qubits (int): Number of qubits in the counting register.
Returns: QuantumCircuit: The quantum circuit implementing
 quantum counting. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of each section, used in the Patel–Markov–Hayes algorithm \[1]. `section_size` must be a factor of the number of qubits.

  **Returns**

  a CX-only circuit implementing the linear transformation.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when variable `state` isn’t of type `numpy.ndarray`Document 1:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of every section in the Patel–Markov–Hayes algorithm. `section_size` must be a factor of the number of qubits.

  **Returns**

  The decomposed quantum circuit.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when dimensions of `cnots` and `angles` don’t align.

  **Return type**

  [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")Document 2:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function to construct a quantum circuit that simulates a 
quantum annealing process. The function should return a circuit that
 implements a simple Ising model Hamiltonian on `n_qubits`.
Parameters: n_qubits (int): Number of qubits in the quantum annealing
 simulation.
Returns: QuantumCircuit: The quantum circuit simulating quantum
 annealing. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
**Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")Document 1:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**Document 2:::
| [`LinearFunction`](qiskit.circuit.library.LinearFunction ""qiskit.circuit.library.LinearFunction"")(linear\[, validate\_input])   | A linear reversible circuit on n qubits.                                                                 |
| [`Isometry`](qiskit.circuit.library.Isometry ""qiskit.circuit.library.Isometry"")(isometry, num\_ancillas\_zero, ...\[, ...])     | Decomposition of arbitrary isometries from $m$ to $n$ qubits.                                            |
| [`UnitaryGate`](qiskit.circuit.library.UnitaryGate ""qiskit.circuit.library.UnitaryGate"")(data\[, label, check\_input])          | Class quantum gates specified by a unitary matrix.                                                       |""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that applies a random unitary operation to a quantum
 circuit using `n_qubits`. The function should generate a random unitary
 matrix and apply it to all qubits in the circuit. 
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
Returns: QuantumCircuit: The quantum circuit with the random
 unitary operation applied. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of each section, used in the Patel–Markov–Hayes algorithm \[1]. `section_size` must be a factor of the number of qubits.

  **Returns**

  a CX-only circuit implementing the linear transformation.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when variable `state` isn’t of type `numpy.ndarray`Document 1:::
A sampler is initialized with an empty parameter set. The sampler is used to create a [`JobV1`](qiskit.providers.JobV1 ""qiskit.providers.JobV1""), via the [`qiskit.primitives.Sampler.run()`](qiskit.primitives.Sampler#run ""qiskit.primitives.Sampler.run"") method. This method is called with the following parameters

*   quantum circuits ($\psi_i(\theta)$): list of (parameterized) quantum circuits. (a list of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"") objects)
*   parameter values ($\theta_k$): list of sets of parameter values to be bound to the parameters of the quantum circuits. (list of list of float)Document 2:::
```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.initialize('01', circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌──────────────────┐
    q_0: ┤0                 ├
         │  Initialize(0,1) │
    q_1: ┤1                 ├
         └──────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that constructs a quantum circuit to simulate
 a boson sampling problem. The function should generate the circuit
 based on `n_qubits` corresponding to the number of photons and
 modes.
Parameters: n_qubits (int): Number of qubits, representing the number
 of photons and modes in the boson sampling.
Returns: QuantumCircuit: The quantum circuit that simulates the
 boson sampling. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
Class for representing evolution by a Hamiltonian operator as a gate.

  This gate resolves to a [`UnitaryGate`](qiskit.circuit.library.UnitaryGate ""qiskit.circuit.library.UnitaryGate"") as $U(t) = \exp(-i t H)$, which can be decomposed into basis gates if it is 2 qubits or less, or simulated directly in Aer for more qubits.

  **Parameters**

  *   **data** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – A hermitian operator.Document 1:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of each section, used in the Patel–Markov–Hayes algorithm \[1]. `section_size` must be a factor of the number of qubits.

  **Returns**

  a CX-only circuit implementing the linear transformation.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when variable `state` isn’t of type `numpy.ndarray`Document 2:::
**Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that implements time evolution under
 a given Hamiltonian for a quantum system. The function should
 create a quantum circuit with `n_qubits` and apply the Hamiltonian
 evolution for a specified time `t`.
Parameters: hamiltonian (array): The Hamiltonian matrix for the
 quantum system.
n_qubits (int): Number of qubits in the quantum circuit.
t (float): Time for which the system evolves.
Returns: QuantumCircuit: The quantum circuit that implements
 the time evolution. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of each section, used in the Patel–Markov–Hayes algorithm \[1]. `section_size` must be a factor of the number of qubits.

  **Returns**

  a CX-only circuit implementing the linear transformation.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when variable `state` isn’t of type `numpy.ndarray`Document 1:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of every section in the Patel–Markov–Hayes algorithm. `section_size` must be a factor of the number of qubits.

  **Returns**

  The decomposed quantum circuit.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when dimensions of `cnots` and `angles` don’t align.

  **Return type**

  [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")Document 2:::
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
  pw_approximation._build()
  qc = QuantumCircuit(pw_approximation.num_qubits)
  qc.h(list(range(num_state_qubits)))
  qc.append(pw_approximation.to_instruction(), qc.qubits)
  qc.draw(output='mpl')
  ```

  ![../\_images/qiskit-circuit-library-PiecewiseChebyshev-1.png](/images/api/qiskit/1.0/qiskit-circuit-library-PiecewiseChebyshev-1.png)

  **References**""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that implements the Quantum Metropolis algorithm
 for simulating thermal states. The function should return a quantum
 circuit that approximates the thermal state of a quantum system with
 `n_qubits`.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
beta (float): Inverse temperature (1/kT) for the thermal state simulation.
Returns: QuantumCircuit: The quantum circuit implementing the
 Quantum Metropolis algorithm. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
*   **qubits** (*Sequence\[QubitSpecifier] | None*) – Qubits to initialize. If `None` the initialization is applied to all qubits in the circuit.

    *   **normalize** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – Whether to normalize an input array to a unit vector.

    **Returns**

    A handle to the instructions created.

    **Examples**

    Prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$.

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)Document 1:::
Set the error message.
</Class>

For example, we can define a quantum program using OpenQASM 3, and use [`loads()`](#qiskit.qasm3.loads ""qiskit.qasm3.loads"") to directly convert it into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit""):

```python
import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];Document 2:::
│  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that creates a quantum circuit to simulate a
 simple quantum error correction code. The function should initialize
 three qubits, apply an encoding step to protect a single qubit, and then
 simulate an error by applying an X gate to one of the qubits. Finally,
 it should perform a decoding step and measure all qubits.
Returns: QuantumCircuit: The quantum circuit implementing the error
 correction code. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl', style=""iqp"")

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl', style=""iqp"")

# Run the transpiled circuit using the simulated fake backend
sampler = SamplerV2(backend)
job = sampler.run([transpiled_circuit])Document 1:::
Runs the pass on circuit.

    **Parameters**

    *   **circuit** (*QuantumCircuit*) – The dag on which the pass is run.
    *   **property\_set** (*PropertySet | dict | None*) – Input/output property set. An analysis pass might change the property set in-place.

    **Return type**

    QuantumCircuit

    **Returns**

    If on transformation pass, the resulting QuantumCircuit. If analysis pass, the input circuit.
  </Function>

  ### execute

  <Function id=""qiskit_ibm_provider.transpiler.passes.scheduling.PadDynamicalDecoupling.execute"" signature=""execute(passmanager_ir, state, callback=None)"">Document 2:::
</Function>

  ### synthesize

  <Function id=""qiskit.circuit.library.LinearFunction.synthesize"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/generalized_gates/linear_function.py#L225-L233"" signature=""synthesize()"">
    Synthesizes the linear function into a quantum circuit.

    **Returns**

    A circuit implementing the evolution.

    **Return type**

    [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>

  ### validate\_parameter""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that transpiles a quantum circuit for a specific
 backend. The function should create a quantum circuit, apply a series
 of gates, and then transpile it for the AerSimulator backend with
 optimization level 3.
Parameters: qc (QuantumCircuit): The input quantum circuit to
 be transpiled.
Returns: QuantumCircuit: The transpiled quantum circuit. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
Bases: [`TwoLocal`](qiskit.circuit.library.TwoLocal ""qiskit.circuit.library.n_local.two_local.TwoLocal"")

  The real-amplitudes 2-local circuit.

  The `RealAmplitudes` circuit is a heuristic trial wave function used as Ansatz in chemistry applications or classification circuits in machine learning. The circuit consists of alternating layers of $Y$ rotations and $CX$ entanglements. The entanglement pattern can be user-defined or selected from a predefined set. It is called `RealAmplitudes` since the prepared quantum states will only have real amplitudes, the complex part is always 0.

  For example a `RealAmplitudes` circuit with 2 repetitions on 3 qubits with `'reverse_linear'` entanglement is

  ```python
  ┌──────────┐ ░            ░ ┌──────────┐ ░            ░ ┌──────────┐Document 1:::
├──────────┤┌─┴─┐┌──┴───┴───┐└──────────┘┌─┴─┐┌──┴───┴───┐└──────────┘
  q_3: ┤ RY(θ[2]) ├┤ X ├┤ RY(θ[5]) ├────────────┤ X ├┤ RY(θ[8]) ├────────────
       └──────────┘└───┘└──────────┘            └───┘└──────────┘
  ```

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The number of qubits of the RealAmplitudes circuit.
  *   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – Specifies how often the structure of a rotation layer followed by an entanglement layer is repeated.Document 2:::
```

  ```python
  >>> ansatz = RealAmplitudes(3, entanglement='linear', reps=2, insert_barriers=True)
  >>> qc = QuantumCircuit(3)  # create a circuit and append the RY variational form
  >>> qc.compose(ansatz, inplace=True)
  >>> qc.draw()
       ┌──────────┐ ░            ░ ┌──────────┐ ░            ░ ┌──────────┐
  q_0: ┤ RY(θ[0]) ├─░───■────────░─┤ RY(θ[3]) ├─░───■────────░─┤ RY(θ[6]) ├
       ├──────────┤ ░ ┌─┴─┐      ░ ├──────────┤ ░ ┌─┴─┐      ░ ├──────────┤
  q_1: ┤ RY(θ[1]) ├─░─┤ X ├──■───░─┤ RY(θ[4]) ├─░─┤ X ├──■───░─┤ RY(θ[7]) ├
       ├──────────┤ ░ └───┘┌─┴─┐ ░ ├──────────┤ ░ └───┘┌─┴─┐ ░ ├──────────┤""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that creates a variational quantum circuit using the
 RealAmplitudes ansatz with entanglement 'full'. The circuit should
 include `reps` repetitions of the circuit block. 
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
reps (int): Number of repetitions of the circuit block.
Returns: QuantumCircuit: The variational quantum circuit 
using RealAmplitudes ansatz. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
print(backend.operation_names)
    ```

    ```python
    ['id', 'rz', 'sx', 'x', 'cx', 'measure', 'delay']
    ```

    As a product of three CNOT gates, swap gates are expensive operations to perform on noisy quantum devices. However, such operations are usually necessary for embedding a circuit into the limited gate connectivities of many devices. Thus, minimizing the number of swap gates in a circuit is a primary goal in the transpilation process.

2.  A Toffoli, or controlled-controlled-not gate (`ccx`), is a three-qubit gate. Given that our basis gate set includes only single- and two-qubit gates, it is obvious that this gate must be decomposed. This decomposition is quite costly:

    ```python
    from qiskit.circuit import QuantumCircuitDocument 1:::
**Return type**

    [InstructionSet](qiskit.circuit.InstructionSet ""qiskit.circuit.InstructionSet"")
  </Function>

  ### cx

  <Function id=""qiskit.circuit.QuantumCircuit.cx"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3668-L3695"" signature=""cx(control_qubit, target_qubit, label=None, ctrl_state=None)"">
    Apply [`CXGate`](qiskit.circuit.library.CXGate ""qiskit.circuit.library.CXGate"").

    For the full matrix form of this gate, see the underlying gate documentation.

    **Parameters**Document 2:::
qr = QuantumRegister(3)
  qc = QuantumCircuit(qr)
  c3h_gate = HGate().control(2)
  qc.append(c3h_gate, qr)
  qc.draw('mpl')
  ```

  ![../\_images/qiskit-circuit-ControlledGate-1.png](/images/api/qiskit/1.0/qiskit-circuit-ControlledGate-1.png)

  Create a controlled custom gate and apply it to a circuit.

  ```python
  from qiskit import QuantumCircuit, QuantumRegister
  from qiskit.circuit.library.standard_gates import HGate

  qc1 = QuantumCircuit(2)
  qc1.x(0)
  qc1.h(1)""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function to create a quantum circuit that implements the 
Toffoli (CCX) gate using only basic gates like CX, H, T, and T-dagger. 
The function should take three qubits as input and construct the Toffoli 
gate step by step.
Parameters: control1 (int): The first control qubit index.
control2 (int): The second control qubit index.
target (int): The target qubit index.
Returns: QuantumCircuit: The quantum circuit implementing the 
Toffoli gate. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
│  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘Document 1:::
*   **\_num\_basis\_uses** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – force a particular approximation by passing a number in \[0, 3].

    **Returns**

    Synthesized quantum circuit.

    **Return type**

    [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **Raises**

    [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – if `pulse_optimize` is True but we don’t know how to do it.
  </Function>

  ## MethodsDocument 2:::
*   **check\_input** ([*bool*](https://docs.python.org/3/library/functions.html#bool ""(in Python v3.12)"")) – If `True` check that the input matrix is valid for the decomposition.

    **Returns**

    A one-qubit circuit approximating the `gate_matrix` in the specified discrete basis.

    **Return type**

    QuantumCircuit’ | ‘DAGCircuit
  </Function>
</Class>""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function to perform quantum state tomography on a 1-qubit
 state. The function should create a quantum circuit that prepares a
 specific quantum state (e.g., |+⟩) and then measure the state in the
 X, Y, and Z bases. The function should simulate the circuit and return
 the measurement results for each basis.
Returns: dict: The measurement results for each tomography basis. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
qc.cx(0, range(1, 5))
  qc.measure_all()
  ```

  Construct a 4-qubit Bernstein-Vazirani circuit using registers.

  ```python
  from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

  qr = QuantumRegister(3, 'q')
  anc = QuantumRegister(1, 'ancilla')
  cr = ClassicalRegister(3, 'c')
  qc = QuantumCircuit(qr, anc, cr)

  qc.x(anc[0])
  qc.h(anc[0])
  qc.h(qr[0:3])
  qc.cx(qr[0:3], anc[0])Document 1:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of every section in the Patel–Markov–Hayes algorithm. `section_size` must be a factor of the number of qubits.

  **Returns**

  The decomposed quantum circuit.

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when dimensions of `cnots` and `angles` don’t align.

  **Return type**

  [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")Document 2:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of each section, used in the Patel–Markov–Hayes algorithm \[1]. `section_size` must be a factor of the number of qubits.

  **Returns**

  a CX-only circuit implementing the linear transformation.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when variable `state` isn’t of type `numpy.ndarray`""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function to create a quantum circuit that simulates the
 Bernstein-Vazirani algorithm. The function should generate a hidden
 binary string `s` of length `n_qubits` and create a quantum circuit to
 find this string using a single query to the oracle.
Parameters: s (str): The hidden binary string that the Bernstein-Vazirani
 algorithm will uncover. 
Returns: QuantumCircuit: The quantum circuit implementing
 the Bernstein-Vazirani algorithm. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
The Pauli Two-Design ansatz.

  This class implements a particular form of a 2-design circuit \[1], which is frequently studied in quantum machine learning literature, such as e.g. the investigating of Barren plateaus in variational algorithms \[2].

  The circuit consists of alternating rotation and entanglement layers with an initial layer of $\sqrt{H} = RY(\pi/4)$ gates. The rotation layers contain single qubit Pauli rotations, where the axis is chosen uniformly at random to be X, Y or Z. The entanglement layers is compromised of pairwise CZ gates with a total depth of 2.

  For instance, the circuit could look like this (but note that choosing a different seed yields different Pauli rotations).

  ```python
       ┌─────────┐┌──────────┐       ░ ┌──────────┐       ░  ┌──────────┐Document 1:::
**Return type**

  [*QuantumCircuit*](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  **References**

  1.  Shelly Garion and Andrew W. Cross, *Synthesis of CNOT-Dihedral circuits with optimal number of two qubit gates*, [Quantum 4(369), 2020](https://quantum-journal.org/papers/q-2020-12-07-369/)
  2.  Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta, *Scalable randomised benchmarking of non-Clifford gates*, npj Quantum Inf 2, 16012 (2016).
</Function>

### synth\_cnotdihedral\_two\_qubitsDocument 2:::
Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  An n\_qubit circuit that permutes qubits.

  Return an n\_qubit permutation circuit implemented using SWAPs.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – circuit width.""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that constructs a quantum circuit to implement a
 2-design. The function should generate a quantum circuit with
 `n_qubits` that creates a 2-design using a series of random single-qubit
 rotations and entangling gates.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
depth (int): The depth of the 2-design (number of layers).
Returns: QuantumCircuit: The quantum circuit implementing the
 2-design. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
│  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘Document 1:::
Generate random circuit of arbitrary size and form.

  This function will generate a random circuit by randomly selecting gates from the set of standard gates in `qiskit.circuit.library.standard_gates`. For example:

  ```python
  from qiskit.circuit.random import random_circuit

  circ = random_circuit(2, 2, measure=True)
  circ.draw(output='mpl')
  ```

  ![../\_images/circuit-5.png](/images/api/qiskit/1.0/circuit-5.png)

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – number of quantum wiresDocument 2:::
</Function>

  ### prepare\_state

  <Function id=""qiskit.circuit.QuantumCircuit.prepare_state"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3957-L4067"" signature=""prepare_state(state, qubits=None, label=None, normalize=False)"">
    Prepare qubits in a specific state.

    This class implements a state preparing unitary. Unlike [`initialize()`](#qiskit.circuit.QuantumCircuit.initialize ""qiskit.circuit.QuantumCircuit.initialize"") it does not reset the qubits first.

    **Parameters**""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function to generate a random pure quantum state and create
 a quantum circuit that initializes a qubit to this state.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
Returns: QuantumCircuit: The quantum circuit that initializes the qubits
 to the random state. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of each section, used in the Patel–Markov–Hayes algorithm \[1]. `section_size` must be a factor of the number of qubits.

  **Returns**

  a CX-only circuit implementing the linear transformation.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when variable `state` isn’t of type `numpy.ndarray`Document 1:::
*   **qubits** ([*list*](https://docs.python.org/3/library/stdtypes.html#list ""(in Python v3.12)"")) – List of qubits over which the operation is defined in case synthesis is done on a physical circuit.
    *   **options** – Additional method-specific optional kwargs.

    **Returns**

    **The quantum circuit representation of the Operation**

    when successful, and `None` otherwise.

    **Return type**

    [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")
  </Function>
</Class>Document 2:::
**Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that creates a quantum circuit to implement the
 Variational Quantum Classifier (VQC). The function should create a
 variational quantum circuit with `n_qubits`, parameterized by a set of
 angles, and simulate the circuit to classify a given input state. 
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
params (list): A list of angles used as parameters for the 
variational circuit.
Returns: dict: The result counts from simulating the VQC
 on a quantum simulator. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
│  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘Document 1:::
Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  An n\_qubit circuit for bitwise xor-ing the input with some integer `amount`.

  The `amount` is xor-ed in bitstring form with the input.

  This circuit can also represent addition by `amount` over the finite field GF(2).

  Return a circuit implementing bitwise xor.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – the width of circuit.Document 2:::
Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  An n\_qubit circuit that permutes qubits.

  Return an n\_qubit permutation circuit implemented using SWAPs.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – circuit width.""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that creates a quantum circuit to implement a
 simple quantum key distribution (QKD) protocol like BB84. The circui
t should prepare qubits in random bases (X or Z) and measure them
 in corresponding bases.
Returns: QuantumCircuit: The quantum circuit implementing the
 BB84 protocol. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
---

# LinearAmplitudeFunction

<Class id=""qiskit.circuit.library.LinearAmplitudeFunction"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/arithmetic/linear_amplitude_function.py#L22-L173"" signature=""qiskit.circuit.library.LinearAmplitudeFunction(num_state_qubits, slope, offset, domain, image, rescaling_factor=1, breakpoints=None, name='F')"" modifiers=""class"">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  A circuit implementing a (piecewise) linear function on qubit amplitudes.Document 1:::
│  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘Document 2:::
A circuit implementing a (piecewise) linear function on qubit amplitudes.

  An amplitude function $F$ of a function $f$ is a mapping

$$
F|x\rangle|0\rangle = \sqrt{1 - \hat{f}(x)} |x\rangle|0\rangle + \sqrt{\hat{f}(x)}
|x\rangle|1\rangle.
$$

  for a function $\hat{f}: \{ 0, ..., 2^n - 1 \} \rightarrow [0, 1]$, where $|x\rangle$ is a $n$ qubit state.""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function to implement a quantum circuit that performs 
amplitude damping on a single qubit. The function should apply a 
Kraus operator corresponding to amplitude damping noise with a
 given probability `p`.
Parameters: p (float): The probability of amplitude damping.
Returns: QuantumCircuit: The quantum circuit implementing amplitude
 damping noise. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  An n\_qubit circuit that permutes qubits.

  Return an n\_qubit permutation circuit implemented using SWAPs.

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – circuit width.Document 1:::
│  State Preparation(0,1) │
    q_1: ┤1                        ├
         └─────────────────────────┘
    ```

    Initialize two qubits from an array of complex amplitudes .. code-block:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)
    circuit.draw()
    ```

    output:

    ```python
         ┌───────────────────────────────────────────┐
    q_0: ┤0                                          ├
         │  State Preparation(0,0.70711,-0.70711j,0) │
    q_1: ┤1                                          ├
         └───────────────────────────────────────────┘Document 2:::
This produces a quantum circuit of depth 2 (measured in the number of SWAPs).

  This implementation is based on the Proposition 4.1 in reference \[1] with the detailed proof given in Theorem 2 in reference \[2]

  **Parameters**""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function to create and simulate a quantum circuit that
 implements the SWAP test to determine the overlap between two
 quantum states. The function should prepare two quantum states
 on separate qubits, apply the SWAP test, and return the measurement
 results.
Returns: QuantumCircuit: The circuit implementing the SWAP test """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
├───┤ ░ ┌─┴─┐  │   ░ ├───┤ ░       ░ ├───┤
  q_1: ┤ X ├─░─┤ X ├──┼───░─┤ X ├─░───■───░─┤ X ├
       ├───┤ ░ └───┘┌─┴─┐ ░ ├───┤ ░ ┌─┴─┐ ░ ├───┤
  q_2: ┤ X ├─░──────┤ X ├─░─┤ X ├─░─┤ X ├─░─┤ X ├
       └───┘ ░      └───┘ ░ └───┘ ░ └───┘ ░ └───┘
  ```

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The number of qubits of the two-local circuit.Document 1:::
├──────────┤├───┤└─┬─┘┌─┴─┐└──────────┘┌──┴───┴───┐   ┌───┐
  q_1: ┤ RX(θ[1]) ├┤ Y ├──┼──┤ X ├─────■──────┤ RX(θ[5]) ├───┤ Y ├─────────
       ├──────────┤├───┤  │  └───┘   ┌─┴─┐    └──────────┘┌──┴───┴───┐┌───┐
  q_2: ┤ RX(θ[2]) ├┤ Y ├──┼──────────┤ X ├─────────■──────┤ RX(θ[6]) ├┤ Y ├
       ├──────────┤├───┤  │          └───┘       ┌─┴─┐    ├──────────┤├───┤
  q_3: ┤ RX(θ[3]) ├┤ Y ├──■──────────────────────┤ X ├────┤ RX(θ[7]) ├┤ Y ├
       └──────────┘└───┘                         └───┘    └──────────┘└───┘
  ```

  **Parameters**

  *   **num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"") *| None*) – The number of qubits of the EfficientSU2 circuit.Document 2:::
---

# EfficientSU2

<Class id=""qiskit.circuit.library.EfficientSU2"" isDedicatedPage={true} github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/library/n_local/efficient_su2.py#L29-L164"" signature=""qiskit.circuit.library.EfficientSU2(num_qubits=None, su2_gates=None, entanglement='reverse_linear', reps=3, skip_unentangled_qubits=False, skip_final_rotation_layer=False, parameter_prefix='θ', insert_barriers=False, initial_state=None, name='EfficientSU2', flatten=None)"" modifiers=""class"">""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that constructs a quantum circuit using the
 EfficientSU2 ansatz for a specified number of qubits. The function
 should allow for a variable number of layers in the ansatz and return
 the resulting circuit.
Parameters: n_qubits (int): Number of qubits in the quantum circuit.
layers (int): Number of layers in the EfficientSU2 ansatz.
Returns: QuantumCircuit: The quantum circuit using the EfficientSU2
 ansatz. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
*   **section\_size** ([*int*](https://docs.python.org/3/library/functions.html#int ""(in Python v3.12)"")) – The size of each section, used in the Patel–Markov–Hayes algorithm \[1]. `section_size` must be a factor of the number of qubits.

  **Returns**

  a CX-only circuit implementing the linear transformation.

  **Return type**

  [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

  **Raises**

  [**QiskitError**](exceptions#qiskit.exceptions.QiskitError ""qiskit.exceptions.QiskitError"") – when variable `state` isn’t of type `numpy.ndarray`Document 1:::
Return a QuantumCircuit implementing the Clifford.

    For N \<= 3 qubits this is based on optimal CX cost decomposition from reference \[1]. For N > 3 qubits this is done using the general non-optimal compilation routine from reference \[2].

    **Returns**

    a circuit implementation of the Clifford.

    **Return type**

    [QuantumCircuit](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")

    **References**

    1.  S. Bravyi, D. Maslov, *Hadamard-free circuits expose the structure of the Clifford group*, [arXiv:2003.09412 \[quant-ph\]](https://arxiv.org/abs/2003.09412)Document 2:::
Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  Circuit to solve the hidden linear function problem.

  The 2D Hidden Linear Function problem is determined by a 2D adjacency matrix A, where only elements that are nearest-neighbor on a grid have non-zero entries. Each row/column corresponds to one binary variable $x_i$.

  The hidden linear function problem is as follows:

  Consider the quadratic form

$$
q(x) = \sum_{i,j=1}^{n}{x_i x_j} ~(\mathrm{mod}~ 4)
$$

  and restrict $q(x)$ onto the nullspace of A. This results in a linear function.

$$""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function that creates a quantum circuit to implement the
 Hidden Subgroup Problem (HSP) for a specific function. The circuit
 should include a function that maps group elements to a hidden
 subgroup and perform the necessary quantum operations to identify
 the subgroup.
 Parameters: n_qubits (int): Number of qubits in the quantum circuit.
Returns: QuantumCircuit: The quantum circuit implementing the
 Hidden Subgroup Problem. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.quantumcircuit.QuantumCircuit"")

  Phase Estimation circuit.

  In the Quantum Phase Estimation (QPE) algorithm \[1, 2, 3], the Phase Estimation circuit is used to estimate the phase $\phi$ of an eigenvalue $e^{2\pi i\phi}$ of a unitary operator $U$, provided with the corresponding eigenstate $|\psi\rangle$. That is

$$
U|\psi\rangle = e^{2\pi i\phi} |\psi\rangle
$$

  This estimation (and thereby this circuit) is a central routine to several well-known algorithms, such as Shor’s algorithm or Quantum Amplitude Estimation.

  **References:**Document 1:::
| [`QuantumCircuit`](qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")(\*regs\[, name, global\_phase, ...]) | Create a new circuit.                                                                                                                                           |
| [`QuantumRegister`](qiskit.circuit.QuantumRegister ""qiskit.circuit.QuantumRegister"")(\[size, name, bits])              | Implement a quantum register.                                                                                                                                   |
| [`Qubit`](qiskit.circuit.Qubit ""qiskit.circuit.Qubit"")(\[register, index])                                             | Implement a quantum bit.                                                                                                                                        |
| [`ClassicalRegister`](qiskit.circuit.ClassicalRegister ""qiskit.circuit.ClassicalRegister"")(\[size, name, bits])        | Implement a classical register.                                                                                                                                 |Document 2:::
| [`QuantumVolume`](qiskit.circuit.library.QuantumVolume ""qiskit.circuit.library.QuantumVolume"")(num\_qubits\[, depth, seed, ...])             | A quantum volume model circuit.                                          |
| [`PhaseEstimation`](qiskit.circuit.library.PhaseEstimation ""qiskit.circuit.library.PhaseEstimation"")(num\_evaluation\_qubits, unitary)       | Phase Estimation circuit.                                                |
| [`GroverOperator`](qiskit.circuit.library.GroverOperator ""qiskit.circuit.library.GroverOperator"")(oracle\[, state\_preparation, ...])        | The Grover operator.                                                     |
| [`PhaseOracle`](qiskit.circuit.library.PhaseOracle ""qiskit.circuit.library.PhaseOracle"")(expression\[, synthesizer, var\_order])             | Phase Oracle.                                                            |""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function to create a quantum circuit that performs quantum
 metrology to estimate a small phase shift. The circuit should prepare
 an entangled state, apply a small phase shift to one qubit, and perform
 measurements to estimate the phase.
Parameters: phase (float): The small phase shift to be estimated.
Returns: QuantumCircuit: The quantum circuit implementing quantum
 metrology. """"""

# Task: Generate the code here based on the provided context and prompt:
"
"# Context: Use the following context to inform your code generation.
Document 0:::
**Parameters**

    *   **obj** (*np.ndarray |* [*Gate*](qiskit.circuit.Gate ""qiskit.circuit.Gate"") *| BaseOperator*) – Unitary operator.
    *   **qubits** (*Sequence\[QubitSpecifier]*) – The circuit qubits to apply the transformation to.
    *   **label** ([*str*](https://docs.python.org/3/library/stdtypes.html#str ""(in Python v3.12)"") *| None*) – Unitary name for backend \[Default: None].

    **Returns**

    The quantum circuit.

    **Return type**

    [QuantumCircuit](#qiskit.circuit.QuantumCircuit ""qiskit.circuit.QuantumCircuit"")Document 1:::
**Returns**

    A handle to the instructions created.

    **Return type**

    [*InstructionSet*](qiskit.circuit.InstructionSet ""qiskit.circuit.instructionset.InstructionSet"")
  </Function>

  ### unitary

  <Function id=""qiskit.circuit.QuantumCircuit.unitary"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L4180-L4221"" signature=""unitary(obj, qubits, label=None)"">
    Apply unitary gate specified by `obj` to `qubits`.

    **Parameters**Document 2:::
</Function>

  ### prepare\_state

  <Function id=""qiskit.circuit.QuantumCircuit.prepare_state"" github=""https://github.com/Qiskit/qiskit/tree/stable/1.0/qiskit/circuit/quantumcircuit.py#L3957-L4067"" signature=""prepare_state(state, qubits=None, label=None, normalize=False)"">
    Prepare qubits in a specific state.

    This class implements a state preparing unitary. Unlike [`initialize()`](#qiskit.circuit.QuantumCircuit.initialize ""qiskit.circuit.QuantumCircuit.initialize"") it does not reset the qubits first.

    **Parameters**""""""
# Prompt: Generate code based on the prompt below. Consider the context provided.
 
"""""" Write a function to create a quantum circuit that simulates the
 behavior of a quantum particle in a potential well. The function should
 use a finite number of qubits to represent the position and momentum
 of the particle and apply the appropriate unitary operations.
Parameters: n_qubits (int): Number of qubits representing the particle's
 state.
Returns: QuantumCircuit: The quantum circuit simulating the quantum
 particle in a potential well. """"""

# Task: Generate the code here based on the provided context and prompt:
"
