https://github.com/Qiskit-Extensions/circuit-knitting-toolbox,Qiskit-Extensions,"# This code is a Qiskit project.

# (C) Copyright IBM 2024.

# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Helper functions that are used in the code.""""""

from __future__ import annotations

from qiskit import QuantumCircuit
from qiskit.circuit import Instruction, Gate
from .optimization_settings import OptimizationSettings
from typing import TYPE_CHECKING, cast, Callable

if TYPE_CHECKING:
    from .cut_optimization import CutOptimizationFuncArgs  # pragma: no cover
from .disjoint_subcircuits_state import DisjointSubcircuitsState
from .search_space_generator import SearchFunctions
from .best_first_search import BestFirstSearch
from .circuit_interface import CircuitElement, SimpleGateList
from ..qpd import QPDBasis


def qc_to_cco_circuit(circuit: QuantumCircuit) -> list[str | CircuitElement]:
    """"""Convert a :class:`qiskit.QuantumCircuit` instance into a circuit list that is compatible with the :class:`SimpleGateList`.

    To conform with the uniformity of the design, single qubit gates are assigned :math:`gamma=None`.
    In the converted list, a barrier across the entire circuit is represented by the string ""barrier.""
    Everything else is represented by an instance of :class:`CircuitElement`.

    Args:
    circuit: an instance of :class:`qiskit.QuantumCircuit` .

    Returns:
    circuit_list_rep: list of circuit instructions represented in a form that is compatible with
    :class:`SimpleGateList` and can therefore be ingested by the cut finder.

    TODO: Extend this function to allow for circuits with (mid-circuit or other)
    measurements, as needed.
    """"""
    circuit_list_rep = []
    for inst in circuit.data:
        if inst.operation.name == ""barrier"" and len(inst.qubits) == circuit.num_qubits:
            circuit_element: CircuitElement | str = ""barrier""
        else:
            gamma = None
            if isinstance(inst.operation, Gate) and len(inst.qubits) == 2:
                gamma = QPDBasis.from_instruction(inst.operation).kappa
            name = inst.operation.name
            params = inst.operation.params
            circuit_element = CircuitElement(
                name=name,
                params=params,
                qubits=list(circuit.find_bit(q).index for q in inst.qubits),
                gamma=gamma,
            )
        circuit_list_rep.append(circuit_element)

    return circuit_list_rep


# currently not in use, written up for future use.
def cco_to_qc_circuit(interface: SimpleGateList) -> QuantumCircuit:
    """"""Convert the cut circuit outputted by the cut finder into a :class:`qiskit.QuantumCircuit` instance.

    Args:
    interface: An instance of :class:`SimpleGateList` whose attributes carry information about the cut circuit.

    Returns:
    qc_cut: The SimpleGateList converted into a :class:`qiskit.QuantumCircuit` instance.

    TODO: This function only works for instances of LO gate cutting.
    Expand to cover the wire cutting case if or when needed.
    """"""
    cut_circuit_list = interface.export_cut_circuit(name_mapping=None)
    num_qubits = interface.get_num_wires()
    cut_types = interface.cut_type
    qc_cut = QuantumCircuit(num_qubits)
    for k, op in enumerate([cut_circuit for cut_circuit in cut_circuit_list]):
        if cut_types[k] is None:  # only append gates that are not cut.
            op_name = op.name
            op_qubits = op.qubits
            op_params = op.params
            inst = Instruction(op_name, len(op_qubits), 0, op_params)
            qc_cut.append(inst, op_qubits)
    return qc_cut


def select_search_engine(
    stage_of_optimization: str,
    optimization_settings: OptimizationSettings,
    search_space_funcs: SearchFunctions,
    stop_at_first_min: bool = False,
) -> BestFirstSearch:
    """"""Select the search algorithm to use.

    In this release, the main search engine is always Dijkstra's
    best first search algorithm. Note however that there is also
    :func:``greedy_best_first_search``, which is used to warm start
    the search algorithm. It can also provide a solution should the
    main search engine fail to find a solution given the constraints
    on the computation it is allowed to perform.
    """"""
    engine = optimization_settings.get_engine_selection(stage_of_optimization)

    if engine == ""BestFirst"":
        return BestFirstSearch(
            optimization_settings,
            search_space_funcs,
            stop_at_first_min=stop_at_first_min,
        )

    else:
        raise ValueError(f""Search engine {engine} is not supported."")


def greedy_best_first_search(
    state: DisjointSubcircuitsState,
    search_space_funcs: SearchFunctions,
    *args: CutOptimizationFuncArgs,
) -> None | DisjointSubcircuitsState:
    """"""Perform greedy best-first search using the input starting state and the input search-space functions.

    The resulting goal state is returned, or None if a deadend is reached. Any additional input argumnets
    are passed as additional arguments to the search-space functions.
    """"""
    search_space_funcs.goal_state_func = cast(
        Callable, search_space_funcs.goal_state_func
    )
    search_space_funcs.cost_func = cast(Callable, search_space_funcs.cost_func)
    search_space_funcs.next_state_func = cast(
        Callable, search_space_funcs.next_state_func
    )

    while not search_space_funcs.goal_state_func(state, *args):
        best = min(
            [
                (search_space_funcs.cost_func(next_state, *args), k, next_state)
                for k, next_state in enumerate(
                    search_space_funcs.next_state_func(state, *args)
                )
            ],
            default=(None, None, None),
        )
        if best[-1] is None:  # pragma: no cover
            # This covers a rare edge case.
            # We have so far found no circuit that triggers it.
            # Excluding from test coverage for now.
            return None
        state = best[-1]
    return state
"
https://github.com/Qiskit-Extensions/circuit-knitting-toolbox,Qiskit-Extensions,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Two-qubit instruction representing a swap + single-qubit reset.""""""
from __future__ import annotations

from qiskit.circuit import QuantumCircuit, Instruction


class Move(Instruction):
    """"""A two-qubit instruction representing a reset of the second qubit followed by a swap.

    **Circuit Symbol:**

    .. parsed-literal::

            ┌───────┐
       q_0: ┤0      ├       q_0: ──────X─
            │  Move │   =              │
       q_1: ┤1      ├       q_1: ─|0>──X─
            └───────┘

    The desired effect of this instruction, typically, is to move the state of
    the first qubit to the second qubit.  For this to work as expected, the
    second incoming qubit must share no entanglement with the remainder of the
    system.  If this qubit *is* entangled, then performing the reset operation
    will in turn implement a quantum channel on the other qubit(s) with which
    it is entangled, resulting in the partial collapse of those qubits.

    The simplest way to ensure that the second (i.e., destination) qubit shares
    no entanglement with the remainder of the system is to use a fresh qubit
    which has not been used since initialization.

    Another valid way is to use, as a desination qubit, a qubit whose immediate
    prior use was as the source (i.e., first) qubit of a preceding
    :class:`Move` operation.

    The following circuit contains two :class:`Move` operations, corresponding
    to each of the aforementioned cases:

    .. plot::
       :include-source:

       import numpy as np
       from qiskit import QuantumCircuit
       from circuit_knitting.cutting.instructions import Move

       qc = QuantumCircuit(4)
       qc.ryy(np.pi / 4, 0, 1)
       qc.rx(np.pi / 4, 3)
       qc.append(Move(), [1, 2])
       qc.rz(np.pi / 4, 0)
       qc.ryy(np.pi / 4, 2, 3)
       qc.append(Move(), [2, 1])
       qc.ryy(np.pi / 4, 0, 1)
       qc.rx(np.pi / 4, 3)
       qc.draw(""mpl"")

    A full demonstration of the :class:`Move` instruction is available in `the
    introductory tutorial on wire cutting
    <../circuit_cutting/tutorials/03_wire_cutting_via_move_instruction.ipynb>`__.
    """"""

    def __init__(self, label: str | None = None):
        """"""Create a :class:`Move` instruction.""""""
        super().__init__(""move"", 2, 0, [], label=label)

    def _define(self):
        """"""Set definition to equivalent circuit.""""""
        qc = QuantumCircuit(2, name=self.name)
        qc.reset(1)
        qc.swap(0, 1)
        self.definition = qc
"
https://github.com/Qiskit-Extensions/circuit-knitting-toolbox,Qiskit-Extensions,"# This code is a Qiskit project.

# (C) Copyright IBM 2023.

# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Tests for cutting_decomposition module.""""""

import unittest

import pytest
import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit import CircuitInstruction, Barrier, Clbit
from qiskit.circuit.library import EfficientSU2, RXXGate
from qiskit.circuit.library.standard_gates import CXGate
from qiskit.quantum_info import PauliList

from circuit_knitting.cutting import (
    partition_circuit_qubits,
    partition_problem,
    cut_gates,
)
from circuit_knitting.cutting.instructions import Move
from circuit_knitting.cutting.qpd import (
    QPDBasis,
    TwoQubitQPDGate,
    BaseQPDGate,
)


class TestCuttingDecomposition(unittest.TestCase):
    def setUp(self):
        # Use HWEA for simplicity and easy visualization
        circuit = EfficientSU2(4, entanglement=""linear"", reps=2).decompose()
        qpd_circuit = EfficientSU2(4, entanglement=""linear"", reps=2).decompose()

        # We will instantiate 2 QPDBasis objects using from_instruction
        rxx_gate = RXXGate(np.pi / 3)
        rxx_decomp = QPDBasis.from_instruction(rxx_gate)

        # Create two QPDGates and specify each of their bases
        # Labels are only used for visualizations
        qpd_gate1 = TwoQubitQPDGate(rxx_decomp, label=f""cut_{rxx_gate.name}"")
        qpd_gate2 = TwoQubitQPDGate(rxx_decomp, label=f""cut_{rxx_gate.name}"")
        qpd_gate1.basis_id = 0
        qpd_gate2.basis_id = 0

        # Create the circuit instructions
        qpd_inst1 = CircuitInstruction(qpd_gate1, qubits=[1, 2])
        qpd_inst2 = CircuitInstruction(qpd_gate2, qubits=[1, 2])
        inst1 = CircuitInstruction(rxx_gate, qubits=[1, 2])
        inst2 = CircuitInstruction(rxx_gate, qubits=[1, 2])

        # Hard-coded overwrite of the two CNOTS with our decomposed RXX gates
        qpd_circuit.data[9] = qpd_inst1
        qpd_circuit.data[20] = qpd_inst2
        circuit.data[9] = inst1
        circuit.data[20] = inst2

        self.qpd_circuit = qpd_circuit
        self.circuit = circuit

    def test_partition_circuit_qubits(self):
        with self.subTest(""Empty circuit""):
            compare_circuit = QuantumCircuit()
            partitioned_circuit = partition_circuit_qubits(compare_circuit, [])
            self.assertEqual(partitioned_circuit, compare_circuit)
        with self.subTest(""Circuit with parameters""):
            # Split 4q HWEA in middle of qubits
            partition_labels = [0, 0, 1, 1]

            # Get a QPD circuit based on partitions, and set the basis for each gate
            # to match the basis_ids of self.qpd_circuit's QPDGates
            circuit = partition_circuit_qubits(self.circuit, partition_labels)
            for inst in circuit.data:
                if isinstance(inst.operation, TwoQubitQPDGate):
                    inst.operation.basis_id = 0

            # Terra doesn't consider params with same name to be equivalent, so
            # we need to copy the comparison circuit and bind parameters to test
            # equivalence.
            compare_circuit = self.qpd_circuit.copy()
            compare_qpd_circuit = partition_circuit_qubits(
                compare_circuit, partition_labels
            )
            parameter_vals = [np.pi / 4] * len(circuit.parameters)
            circuit.assign_parameters(parameter_vals, inplace=True)
            compare_qpd_circuit.assign_parameters(parameter_vals, inplace=True)
            self.assertEqual(circuit, compare_qpd_circuit)
        with self.subTest(""Circuit with barriers""):
            # Split 4q HWEA in middle of qubits
            partition_labels = [0, 0, 1, 1]

            bar1 = CircuitInstruction(Barrier(4), qubits=[0, 1, 2, 3])
            bar2 = CircuitInstruction(Barrier(4), qubits=[0, 1, 2, 3])

            bar_circuit = self.circuit.copy()
            bar_circuit.data.insert(10, bar1)
            bar_circuit.data.insert(22, bar2)

            # Get a QPD circuit based on partitions, and set the basis for each gate
            # to match the basis_ids of self.qpd_circuit's QPDGates
            circuit = partition_circuit_qubits(bar_circuit, partition_labels)
            for inst in circuit.data:
                if isinstance(inst.operation, TwoQubitQPDGate):
                    inst.operation.basis_id = 0

            # Terra doesn't consider params with same name to be equivalent, so
            # we need to copy the comparison circuit and bind parameters to test
            # equivalence.
            compare_circuit = self.qpd_circuit.copy()
            compare_qpd_circuit = partition_circuit_qubits(
                compare_circuit, partition_labels
            )
            bar1 = CircuitInstruction(Barrier(4), qubits=[0, 1, 2, 3])
            bar2 = CircuitInstruction(Barrier(4), qubits=[0, 1, 2, 3])

            compare_qpd_circuit.data.insert(10, bar1)
            compare_qpd_circuit.data.insert(22, bar2)
            parameter_vals = [np.pi / 4] * len(circuit.parameters)
            circuit.assign_parameters(parameter_vals, inplace=True)
            compare_qpd_circuit.assign_parameters(parameter_vals, inplace=True)
            self.assertEqual(circuit, compare_qpd_circuit)
        with self.subTest(""Partition IDs the wrong size""):
            compare_circuit = QuantumCircuit()
            with pytest.raises(ValueError) as e_info:
                partition_circuit_qubits(compare_circuit, [0])
            assert (
                e_info.value.args[0]
                == ""Length of partition_labels (1) does not equal the number of qubits in the input circuit (0).""
            )
        with self.subTest(""Unsupported gate""):
            compare_circuit = QuantumCircuit(3)
            compare_circuit.ccx(0, 1, 2)
            partitions = [0, 1, 1]
            with pytest.raises(ValueError) as e_info:
                partition_circuit_qubits(compare_circuit, partitions)
            assert (
                e_info.value.args[0]
                == ""Decomposition is only supported for two-qubit gates. Cannot decompose (ccx).""
            )
        with self.subTest(""Toffoli gate in a single partition""):
            circuit = QuantumCircuit(4)
            circuit.ccx(0, 1, 2)
            circuit.rzz(np.pi / 7, 2, 3)
            partition_circuit_qubits(circuit, ""AAAB"")

    def test_partition_problem(self):
        with self.subTest(""simple circuit and observable""):
            # Split 4q HWEA in middle of qubits
            partition_labels = ""AABB""

            observable = PauliList([""ZZXX""])

            subcircuits, _, subobservables = partition_problem(
                self.circuit, partition_labels, observables=observable
            )
            for subcircuit in subcircuits.values():
                parameter_vals = [np.pi / 4] * len(subcircuit.parameters)
                subcircuit.assign_parameters(parameter_vals, inplace=True)
                for inst in subcircuit.data:
                    if isinstance(inst.operation, BaseQPDGate):
                        inst.operation.basis_id = 0

            compare_obs = {""A"": PauliList([""XX""]), ""B"": PauliList([""ZZ""])}

            self.assertEqual(subobservables, compare_obs)

        with self.subTest(""test mismatching inputs""):
            # Split 4q HWEA in middle of qubits
            partition_labels = ""AB""

            with pytest.raises(ValueError) as e_info:
                subcircuits, _, subobservables = partition_problem(
                    self.circuit, partition_labels
                )
            assert (
                e_info.value.args[0]
                == ""The number of partition labels (2) must equal the number of qubits in the circuit (4).""
            )

            partition_labels = ""AABB""
            observable = PauliList([""ZZ""])

            with pytest.raises(ValueError) as e_info:
                subcircuits, _, subobservables = partition_problem(
                    self.circuit, partition_labels, observable
                )
            assert (
                e_info.value.args[0]
                == ""An input observable acts on a different number of qubits than the input circuit.""
            )
        with self.subTest(""Classical bit on input""):
            # Split 4q HWEA in middle of qubits
            partition_labels = ""AABB""

            observable = PauliList([""ZZXX""])

            # Add a clbit
            circuit = self.circuit.copy()
            circuit.add_bits([Clbit()])

            with pytest.raises(ValueError) as e_info:
                partition_problem(circuit, partition_labels, observables=observable)
            assert (
                e_info.value.args[0]
                == ""Circuits input to partition_problem should contain no classical registers or bits.""
            )
        with self.subTest(""Unsupported phase""):
            # Split 4q HWEA in middle of qubits
            partition_labels = ""AABB""

            observable = PauliList([""-ZZXX""])

            with pytest.raises(ValueError) as e_info:
                partition_problem(
                    self.circuit, partition_labels, observables=observable
                )
            assert (
                e_info.value.args[0]
                == ""An input observable has a phase not equal to 1.""
            )
        with self.subTest(""Unlabeled TwoQubitQPDGates (smoke test)""):
            qc = QuantumCircuit(4)
            qc.rx(np.pi / 4, 0)
            qc.rx(np.pi / 4, 1)
            qc.rx(np.pi / 4, 3)
            qc.cx(0, 1)
            qc.append(TwoQubitQPDGate(QPDBasis.from_instruction(Move())), [1, 2])
            qc.cx(2, 3)
            qc.append(TwoQubitQPDGate(QPDBasis.from_instruction(Move())), [2, 1])
            qc.cx(0, 1)
            subcircuits, bases, subobservables = partition_problem(
                qc, ""AABB"", observables=PauliList([""IZIZ""])
            )
            assert len(subcircuits) == len(bases) == len(subobservables) == 2
        with self.subTest(""Automatic partition_labels""):
            qc = QuantumCircuit(4)
            qc.h(0)
            qc.cx(0, 2)
            qc.cx(0, 1)
            qc.s(3)
            # Add a TwoQubitQPDGate that, when cut, allows the circuit to
            # separate
            qc.append(TwoQubitQPDGate.from_instruction(CXGate()), [1, 3])
            # Add a TwoQubitQPDGate that, when cut, does *not* allow the
            # circuit to separate
            qc.append(TwoQubitQPDGate.from_instruction(CXGate()), [2, 0])
            subcircuit, *_ = partition_problem(qc)
            assert subcircuit.keys() == {0, 1}
            assert subcircuit[0].num_qubits == 3
            assert subcircuit[1].num_qubits == 1

    def test_cut_gates(self):
        with self.subTest(""simple circuit""):
            compare_qc = QuantumCircuit(2)
            compare_qc.append(TwoQubitQPDGate.from_instruction(CXGate()), [0, 1])

            qc = QuantumCircuit(2)
            qc.cx(0, 1)
            qpd_qc, _ = cut_gates(qc, [0])
            self.assertEqual(qpd_qc, compare_qc)
        with self.subTest(""classical bit on input""):
            qc = QuantumCircuit(2, 1)
            qc.cx(0, 1)
            with pytest.raises(ValueError) as e_info:
                cut_gates(qc, [0])
            assert (
                e_info.value.args[0]
                == ""Circuits input to cut_gates should contain no classical registers or bits.""
            )

    def test_unused_qubits(self):
        """"""Issue #218""""""
        qc = QuantumCircuit(2)
        subcircuits, _, subobservables = partition_problem(
            circuit=qc, partition_labels=""AB"", observables=PauliList([""XX""])
        )
        assert subcircuits.keys() == {""A"", ""B""}
        assert subobservables.keys() == {""A"", ""B""}
"
https://github.com/Qiskit-Extensions/circuit-knitting-toolbox,Qiskit-Extensions,"# This code is a Qiskit project.

# (C) Copyright IBM 2023.

# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
from __future__ import annotations

import pytest

import logging

import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library import UnitaryGate
from qiskit.circuit.library.standard_gates import (
    RXXGate,
    RYYGate,
    RZZGate,
    RZXGate,
    XXPlusYYGate,
    XXMinusYYGate,
    CHGate,
    CXGate,
    CYGate,
    CZGate,
    CSGate,
    CSdgGate,
    CSXGate,
    CRXGate,
    CRYGate,
    CRZGate,
    CPhaseGate,
    ECRGate,
    SwapGate,
    iSwapGate,
    DCXGate,
)
from qiskit.quantum_info import PauliList, random_unitary
from qiskit.primitives import Estimator
from qiskit_ibm_runtime import SamplerV2
from qiskit_aer import AerSimulator
from qiskit_aer.primitives import Sampler

from circuit_knitting.utils.simulation import ExactSampler
from circuit_knitting.cutting import (
    partition_problem,
    generate_cutting_experiments,
    reconstruct_expectation_values,
)
from circuit_knitting.cutting.instructions import Move

logger = logging.getLogger(__name__)


def append_random_unitary(circuit: QuantumCircuit, qubits):
    circuit.unitary(random_unitary(2 ** len(qubits)), qubits)


@pytest.fixture(
    params=[
        [SwapGate()],
        [iSwapGate()],
        [DCXGate()],
        [CXGate()],
        [CYGate()],
        [CZGate()],
        [CHGate()],
        [ECRGate()],
        [CSXGate()],
        [CSXGate().inverse()],
        [CSGate()],
        [CSdgGate()],
        [RYYGate(0.0)],
        [RZZGate(np.pi)],
        [RXXGate(np.pi / 3)],
        [RYYGate(np.pi / 7)],
        [RZZGate(np.pi / 11)],
        [CRXGate(0.0)],
        [CRYGate(np.pi)],
        [CRZGate(np.pi / 2)],
        [CRXGate(np.pi / 3)],
        [CRYGate(np.pi / 7)],
        [CRZGate(np.pi / 11)],
        [RXXGate(np.pi / 3), CRYGate(np.pi / 7)],
        [CPhaseGate(np.pi / 3)],
        [RXXGate(np.pi / 3), CPhaseGate(np.pi / 7)],
        [UnitaryGate(random_unitary(2**2))],
        [RZXGate(np.pi / 5)],
        # XXPlusYYGate, XXMinusYYGate, with some combinations:
        #     beta == 0 or not; and
        #     within |theta| < pi or not
        [XXPlusYYGate(7 * np.pi / 11)],
        [XXPlusYYGate(17 * np.pi / 11, beta=0.4)],
        [XXPlusYYGate(-19 * np.pi / 11, beta=0.3)],
        [XXMinusYYGate(11 * np.pi / 17)],
        [Move()],
        [Move(), Move()],
    ]
)
def example_circuit(request) -> QuantumCircuit:
    """"""Fixture for an example circuit.

    Except for the parametrized gates, the system can be separated according to
    the partition labels ""AAB"".

    """"""
    qc = QuantumCircuit(3)
    cut_indices = []
    for instruction in request.param:
        if instruction.name == ""move"" and len(cut_indices) % 2 == 1:
            # We should not entangle qubit 1 with the remainder of the system.
            # In fact, we're also assuming that the previous operation here was
            # a move.
            append_random_unitary(qc, [0])
            append_random_unitary(qc, [1])
        else:
            append_random_unitary(qc, [0, 1])
        append_random_unitary(qc, [2])
        cut_indices.append(len(qc.data))
        qubits = [1, 2]
        if len(cut_indices) % 2 == 0:
            qubits.reverse()
        qc.append(instruction, qubits)
    qc.barrier()
    append_random_unitary(qc, [0, 1])
    qc.barrier()
    append_random_unitary(qc, [2])

    return qc


def test_cutting_exact_reconstruction(example_circuit):
    """"""Test gate-cut circuit vs original circuit on statevector simulator""""""
    qc = example_circuit

    observables = PauliList([""III"", ""IIY"", ""XII"", ""XYZ"", ""iZZZ"", ""-XZI""])
    phases = np.array([(-1j) ** obs.phase for obs in observables])
    observables_nophase = PauliList([""III"", ""IIY"", ""XII"", ""XYZ"", ""ZZZ"", ""XZI""])

    estimator = Estimator()
    exact_expvals = (
        estimator.run([qc] * len(observables), list(observables)).result().values
    )
    subcircuits, bases, subobservables = partition_problem(
        qc, ""AAB"", observables=observables_nophase
    )
    subexperiments, coefficients = generate_cutting_experiments(
        subcircuits, subobservables, num_samples=np.inf
    )
    if np.random.randint(2):
        # Re-use a single sampler
        sampler = ExactSampler()
        samplers = {label: sampler for label in subcircuits.keys()}
    else:
        # One sampler per partition
        samplers = {label: ExactSampler() for label in subcircuits.keys()}
    results = {
        label: sampler.run(subexperiments[label]).result()
        for label, sampler in samplers.items()
    }
    reconstructed_expvals = reconstruct_expectation_values(
        results, coefficients, subobservables
    )
    reconstructed_expvals *= phases

    logger.info(""Max error: %f"", np.max(np.abs(exact_expvals - reconstructed_expvals)))

    assert np.allclose(exact_expvals, reconstructed_expvals, atol=1e-8)


@pytest.mark.parametrize(
    ""sampler,is_exact_sampler"",
    [(Sampler(), False), (SamplerV2(AerSimulator()), False), (ExactSampler(), True)],
)
def test_sampler_with_identity_subobservable(sampler, is_exact_sampler):
    """"""This test ensures that the sampler works for a subcircuit with no observable measurements.

    Specifically, that

    - ``Sampler`` does not blow up (Issue #422); and
    - ``ExactSampler`` returns correct results

    This is related to https://github.com/Qiskit-Extensions/circuit-knitting-toolbox/issues/422.
    """"""
    # Create a circuit to cut
    qc = QuantumCircuit(3)
    append_random_unitary(qc, [0, 1])
    append_random_unitary(qc, [2])
    qc.rxx(np.pi / 3, 1, 2)
    append_random_unitary(qc, [0, 1])
    append_random_unitary(qc, [2])

    # Determine expectation value using cutting
    observables = PauliList(
        [""IIZ""]
    )  # Without the workaround to Issue #422, this observable causes a Sampler error.
    subcircuits, bases, subobservables = partition_problem(
        qc, ""AAB"", observables=observables
    )
    subexperiments, coefficients = generate_cutting_experiments(
        subcircuits, subobservables, num_samples=np.inf
    )
    samplers = {label: sampler for label in subexperiments.keys()}
    results = {
        label: sampler.run(subexperiments[label]).result()
        for label, sampler in samplers.items()
    }
    reconstructed_expvals = reconstruct_expectation_values(
        results, coefficients, subobservables
    )

    if is_exact_sampler:
        # Determine exact expectation values
        estimator = Estimator()
        exact_expvals = (
            estimator.run([qc] * len(observables), list(observables)).result().values
        )

        logger.info(
            ""Max error: %f"", np.max(np.abs(exact_expvals - reconstructed_expvals))
        )

        # Ensure both methods yielded equivalent expectation values
        assert np.allclose(exact_expvals, reconstructed_expvals, atol=1e-8)
"
https://github.com/Qiskit-Extensions/circuit-knitting-toolbox,Qiskit-Extensions,"# This code is a Qiskit project.

# (C) Copyright IBM 2024.

# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Tests for find_cuts module.""""""

import unittest

import pytest
import os
import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library import EfficientSU2

from circuit_knitting.cutting.automated_cut_finding import (
    find_cuts,
    OptimizationParameters,
    DeviceConstraints,
)


class TestCuttingDecomposition(unittest.TestCase):
    def test_find_cuts(self):
        with self.subTest(""simple circuit""):
            path_to_circuit = os.path.join(
                os.path.dirname(__file__),
                "".."",
                ""qasm_circuits"",
                ""circuit_find_cuts_test.qasm"",
            )
            circuit = QuantumCircuit.from_qasm_file(path_to_circuit)
            optimization = OptimizationParameters(seed=111)
            constraints = DeviceConstraints(qubits_per_subcircuit=4)

            _, metadata = find_cuts(
                circuit, optimization=optimization, constraints=constraints
            )
            cut_types = {cut[0] for cut in metadata[""cuts""]}

            assert len(metadata[""cuts""]) == 2
            assert {""Wire Cut"", ""Gate Cut""} == cut_types
            assert np.isclose(127.06026169, metadata[""sampling_overhead""], atol=1e-8)
            assert metadata[""minimum_reached""] is True

        with self.subTest(""Cut both wires instance""):
            qc = EfficientSU2(4, entanglement=""linear"", reps=2).decompose()
            qc.assign_parameters([0.4] * len(qc.parameters), inplace=True)
            optimization = OptimizationParameters(
                seed=12345, gate_lo=False, wire_lo=True
            )
            constraints = DeviceConstraints(qubits_per_subcircuit=2)

            _, metadata = find_cuts(
                qc, optimization=optimization, constraints=constraints
            )
            cut_types = {cut[0] for cut in metadata[""cuts""]}

            assert len(metadata[""cuts""]) == 8
            assert {""Wire Cut""} == cut_types
            assert np.isclose(65536.0**2, metadata[""sampling_overhead""], atol=1e-8)

        with self.subTest(""3-qubit gate""):
            circuit = QuantumCircuit(3)
            circuit.cswap(2, 1, 0)
            circuit.crx(3.57, 1, 0)
            circuit.z(2)
            with pytest.raises(ValueError) as e_info:
                _, metadata = find_cuts(
                    circuit, optimization=optimization, constraints=constraints
                )
            assert e_info.value.args[0] == (
                ""The input circuit must contain only single and two-qubits gates. ""
                ""Found 3-qubit gate: (cswap).""
            )
        with self.subTest(
            ""right-wire-cut""
        ):  # tests resolution of https://github.com/Qiskit-Extensions/circuit-knitting-toolbox/issues/508

            circuit = QuantumCircuit(5)
            circuit.cx(0, 3)
            circuit.cx(1, 3)
            circuit.cx(2, 3)
            circuit.h(4)
            circuit.cx(3, 4)
            constraints = DeviceConstraints(qubits_per_subcircuit=3)
            _, metadata = find_cuts(
                circuit, optimization=optimization, constraints=constraints
            )
            cut_types = {cut[0] for cut in metadata[""cuts""]}

            assert len(metadata[""cuts""]) == 1
            assert {""Wire Cut""} == cut_types
            assert metadata[""sampling_overhead""] == 16


@pytest.mark.parametrize(""qubits_per_subcircuit"", [-1, 0])
def test_device_constraints(qubits_per_subcircuit: int):
    """"""Test device constraints for being valid data types.""""""

    with pytest.raises(ValueError):
        _ = DeviceConstraints(qubits_per_subcircuit)


@pytest.mark.parametrize(""qubits_per_subcircuit"", [2, 1])
def test_get_qpu_width(qubits_per_subcircuit: int):
    """"""Test that get_qpu_width returns number of qubits per qpu.""""""

    assert (
        DeviceConstraints(qubits_per_subcircuit).get_qpu_width()
        == qubits_per_subcircuit
    )
"
https://github.com/Qiskit-Extensions/circuit-knitting-toolbox,Qiskit-Extensions,"# This code is a Qiskit project.

# (C) Copyright IBM 2024.

# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Tests for cco_utils module.""""""

from __future__ import annotations
from typing import Callable

import pytest
from pytest import fixture
from qiskit.circuit.library import EfficientSU2
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit import Qubit, Instruction, CircuitInstruction
from circuit_knitting.cutting.cut_finding.cco_utils import (
    qc_to_cco_circuit,
    cco_to_qc_circuit,
)
from circuit_knitting.cutting.cut_finding.circuit_interface import (
    SimpleGateList,
    CircuitElement,
)


def create_test_circuit_1():
    tc_1 = QuantumCircuit(2)
    tc_1.h(1)
    tc_1.barrier(1)
    tc_1.s(0)
    tc_1.barrier()
    tc_1.cx(1, 0)
    return tc_1


def create_test_circuit_2():
    tc_2 = EfficientSU2(2, entanglement=""linear"", reps=2).decompose()
    tc_2.assign_parameters([0.4] * len(tc_2.parameters), inplace=True)
    return tc_2


# test circuit 3
@fixture
def internal_test_circuit():
    circuit = [
        CircuitElement(name=""cx"", params=[], qubits=[0, 1], gamma=3),
        CircuitElement(name=""cx"", params=[], qubits=[2, 3], gamma=3),
        CircuitElement(name=""cx"", params=[], qubits=[1, 2], gamma=3),
        CircuitElement(name=""cx"", params=[], qubits=[0, 1], gamma=3),
        CircuitElement(name=""cx"", params=[], qubits=[2, 3], gamma=3),
        CircuitElement(name=""h"", params=[], qubits=[0], gamma=None),
        CircuitElement(name=""rx"", params=[0.4], qubits=[0], gamma=None),
    ]
    interface = SimpleGateList(circuit)
    interface.insert_gate_cut(2, ""LO"")
    interface.define_subcircuits([[0, 1], [2, 3]])
    return interface


@pytest.mark.parametrize(
    ""create_test_circuit, known_output"",
    [
        (
            create_test_circuit_1,
            [
                CircuitElement(""h"", [], [1], None),
                CircuitElement(""barrier"", [], [1], None),
                CircuitElement(""s"", [], [0], None),
                ""barrier"",
                CircuitElement(""cx"", [], [1, 0], 3),
            ],
        ),
        (
            create_test_circuit_2,
            [
                CircuitElement(""ry"", [0.4], [0], None),
                CircuitElement(""rz"", [0.4], [0], None),
                CircuitElement(""ry"", [0.4], [1], None),
                CircuitElement(""rz"", [0.4], [1], None),
                CircuitElement(""cx"", [], [0, 1], 3),
                CircuitElement(""ry"", [0.4], [0], None),
                CircuitElement(""rz"", [0.4], [0], None),
                CircuitElement(""ry"", [0.4], [1], None),
                CircuitElement(""rz"", [0.4], [1], None),
                CircuitElement(""cx"", [], [0, 1], 3),
                CircuitElement(""ry"", [0.4], [0], None),
                CircuitElement(""rz"", [0.4], [0], None),
                CircuitElement(""ry"", [0.4], [1], None),
                CircuitElement(""rz"", [0.4], [1], None),
            ],
        ),
    ],
)
def test_qc_to_cco_circuit(
    create_test_circuit: Callable[[], QuantumCircuit],
    known_output: list[CircuitElement, str],
):
    test_circuit = create_test_circuit()
    test_circuit_internal = qc_to_cco_circuit(test_circuit)
    assert test_circuit_internal == known_output


def test_cco_to_qc_circuit(internal_test_circuit: SimpleGateList):
    qc_cut = cco_to_qc_circuit(internal_test_circuit)
    assert qc_cut.data == [
        CircuitInstruction(
            operation=Instruction(name=""cx"", num_qubits=2, num_clbits=0, params=[]),
            qubits=(
                Qubit(QuantumRegister(4, ""q""), 0),
                Qubit(QuantumRegister(4, ""q""), 1),
            ),
            clbits=(),
        ),
        CircuitInstruction(
            operation=Instruction(name=""cx"", num_qubits=2, num_clbits=0, params=[]),
            qubits=(
                Qubit(QuantumRegister(4, ""q""), 2),
                Qubit(QuantumRegister(4, ""q""), 3),
            ),
            clbits=(),
        ),
        CircuitInstruction(
            operation=Instruction(name=""cx"", num_qubits=2, num_clbits=0, params=[]),
            qubits=(
                Qubit(QuantumRegister(4, ""q""), 0),
                Qubit(QuantumRegister(4, ""q""), 1),
            ),
            clbits=(),
        ),
        CircuitInstruction(
            operation=Instruction(name=""cx"", num_qubits=2, num_clbits=0, params=[]),
            qubits=(
                Qubit(QuantumRegister(4, ""q""), 2),
                Qubit(QuantumRegister(4, ""q""), 3),
            ),
            clbits=(),
        ),
        CircuitInstruction(
            operation=Instruction(name=""h"", num_qubits=1, num_clbits=0, params=[]),
            qubits=(Qubit(QuantumRegister(4, ""q""), 0),),
            clbits=(),
        ),
        CircuitInstruction(
            operation=Instruction(name=""rx"", num_qubits=1, num_clbits=0, params=[0.4]),
            qubits=(Qubit(QuantumRegister(4, ""q""), 0),),
            clbits=(),
        ),
    ]
"
https://github.com/Qiskit-Extensions/circuit-knitting-toolbox,Qiskit-Extensions,"# This code is a Qiskit project.

# (C) Copyright IBM 2024.

# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""End to end tests for the cut finder workflow.""""""

from __future__ import annotations

import numpy as np
import unittest
from pytest import raises
from qiskit import QuantumCircuit
from qiskit.circuit.library import EfficientSU2
from circuit_knitting.cutting.cut_finding.cco_utils import qc_to_cco_circuit
from circuit_knitting.cutting.cut_finding.circuit_interface import (
    SimpleGateList,
)
from circuit_knitting.cutting.cut_finding.optimization_settings import (
    OptimizationSettings,
)
from circuit_knitting.cutting.automated_cut_finding import DeviceConstraints
from circuit_knitting.cutting.cut_finding.disjoint_subcircuits_state import (
    get_actions_list,
    SingleWireCutIdentifier,
    WireCutLocation,
    CutIdentifier,
    CutLocation,
)
from circuit_knitting.cutting.cut_finding.lo_cuts_optimizer import (
    LOCutsOptimizer,
)
from circuit_knitting.cutting.cut_finding.cut_optimization import CutOptimization


class TestCuttingFourQubitCircuit(unittest.TestCase):
    def setUp(self):
        qc = EfficientSU2(4, entanglement=""linear"", reps=2).decompose()
        qc.assign_parameters([0.4] * len(qc.parameters), inplace=True)
        self.circuit_internal = qc_to_cco_circuit(qc)

    def test_four_qubit_cutting_workflow(self):

        with self.subTest(""No cuts needed""):

            qubits_per_subcircuit = 4

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=True, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

            output = optimization_pass.optimize(interface, settings, constraint_obj)

            assert get_actions_list(output.actions) == []  # no cutting.

            assert (
                interface.export_subcircuits_as_string(name_mapping=""default"") == ""AAAA""
            )

        with self.subTest(""No cuts found when all flags set to False""):

            qubits_per_subcircuit = 3

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=False, wire_lo=False)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

            with raises(ValueError) as e_info:
                optimization_pass.optimize(interface, settings, constraint_obj)
            assert (
                e_info.value.args[0]
                == ""None state encountered: no cut state satisfying the specified constraints and settings could be found.""
            )

        with self.subTest(
            ""No separating cuts possible if one qubit per qpu and only wire cuts allowed""
        ):

            settings = OptimizationSettings(seed=12345, gate_lo=False, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            interface = SimpleGateList(self.circuit_internal)

            qubits_per_subcircuit = 1
            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

            with raises(ValueError) as e_info:
                optimization_pass.optimize(interface, settings, constraint_obj)
            assert (
                e_info.value.args[0]
                == ""None state encountered: no cut state satisfying the specified constraints and settings could be found.""
            )

        with self.subTest(""Gate cuts to get three qubits per subcircuit""):
            # QPU with 3 qubits for a 4 qubit circuit enforces cutting.
            qubits_per_subcircuit = 3

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=True, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

            output = optimization_pass.optimize()

            cut_actions_list = output.cut_actions_sublist()

            assert cut_actions_list == [
                CutIdentifier(
                    cut_action=""CutTwoQubitGate"",
                    cut_location=CutLocation(
                        instruction_id=17, gate_name=""cx"", qubits=[2, 3]
                    ),
                ),
                CutIdentifier(
                    cut_action=""CutTwoQubitGate"",
                    cut_location=CutLocation(
                        instruction_id=25, gate_name=""cx"", qubits=[2, 3]
                    ),
                ),
            ]
            best_result = optimization_pass.get_results()

            assert (
                output.upper_bound_gamma() == best_result.gamma_UB == 9
            )  # 2 LO cnot cuts.

            assert (
                optimization_pass.minimum_reached() is True
            )  # matches optimal solution.

            assert (
                interface.export_subcircuits_as_string(name_mapping=""default"") == ""AAAB""
            )  # circuit separated into 2 subcircuits.

        with self.subTest(""Gate cuts to get two qubits per subcircuit""):

            qubits_per_subcircuit = 2

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=True, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

            output = optimization_pass.optimize()

            cut_actions_list = output.cut_actions_sublist()

            assert cut_actions_list == [
                CutIdentifier(
                    cut_action=""CutTwoQubitGate"",
                    cut_location=CutLocation(
                        instruction_id=9, gate_name=""cx"", qubits=[1, 2]
                    ),
                ),
                CutIdentifier(
                    cut_action=""CutTwoQubitGate"",
                    cut_location=CutLocation(
                        instruction_id=20, gate_name=""cx"", qubits=[1, 2]
                    ),
                ),
            ]

        best_result = optimization_pass.get_results()

        assert (
            output.upper_bound_gamma() == best_result.gamma_UB == 9
        )  # 2 LO cnot cuts.

        assert optimization_pass.minimum_reached() is True  # matches optimal solution.

        assert (
            interface.export_subcircuits_as_string(name_mapping=""default"") == ""AABB""
        )  # circuit separated into 2 subcircuits.

        assert (
            optimization_pass.get_stats()[""CutOptimization""].backjumps
            <= settings.max_backjumps
        )

        with self.subTest(""Cut both wires instance""):

            qubits_per_subcircuit = 2

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=False, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

            output = optimization_pass.optimize()

            cut_actions_list = output.cut_actions_sublist()

            assert cut_actions_list == [
                SingleWireCutIdentifier(
                    cut_action=""CutLeftWire"",
                    wire_cut_location=WireCutLocation(
                        instruction_id=9, gate_name=""cx"", qubits=[1, 2], input=1
                    ),
                ),
                CutIdentifier(
                    cut_action=""CutBothWires"",
                    cut_location=CutLocation(
                        instruction_id=12, gate_name=""cx"", qubits=[0, 1]
                    ),
                ),
                SingleWireCutIdentifier(
                    cut_action=""CutLeftWire"",
                    wire_cut_location=WireCutLocation(
                        instruction_id=17, gate_name=""cx"", qubits=[2, 3], input=1
                    ),
                ),
                CutIdentifier(
                    cut_action=""CutBothWires"",
                    cut_location=CutLocation(
                        instruction_id=20, gate_name=""cx"", qubits=[1, 2]
                    ),
                ),
                CutIdentifier(
                    cut_action=""CutBothWires"",
                    cut_location=CutLocation(
                        instruction_id=25, gate_name=""cx"", qubits=[2, 3]
                    ),
                ),
            ]

        best_result = optimization_pass.get_results()

        assert output.upper_bound_gamma() == best_result.gamma_UB == 65536

        assert (
            interface.export_subcircuits_as_string(name_mapping=""default"")
            == ""ADABDEBCEFCF""
        )

        with self.subTest(""Wire cuts to get to 3 qubits per subcircuit""):

            qubits_per_subcircuit = 3

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=False, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

            output = optimization_pass.optimize()

            cut_actions_list = output.cut_actions_sublist()

            assert cut_actions_list == [
                SingleWireCutIdentifier(
                    cut_action=""CutLeftWire"",
                    wire_cut_location=WireCutLocation(
                        instruction_id=17, gate_name=""cx"", qubits=[2, 3], input=1
                    ),
                ),
                SingleWireCutIdentifier(
                    cut_action=""CutLeftWire"",
                    wire_cut_location=WireCutLocation(
                        instruction_id=20, gate_name=""cx"", qubits=[1, 2], input=1
                    ),
                ),
            ]

        best_result = optimization_pass.get_results()

        assert (
            output.upper_bound_gamma() == best_result.gamma_UB == 16
        )  # 2 LO wire cuts.

        assert (
            interface.export_subcircuits_as_string(name_mapping=""default"") == ""AABABB""
        )  # circuit separated into 2 subcircuits.

        with self.subTest(""Search engine not supported""):
            # Check if unspported search engine is flagged

            qubits_per_subcircuit = 4

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=True, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BeamSearch"")

            search_engine = settings.get_engine_selection(""CutOptimization"")

        constraint_obj = DeviceConstraints(qubits_per_subcircuit)

        optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

        with raises(ValueError) as e_info:
            _ = optimization_pass.optimize()
        assert (
            e_info.value.args[0] == f""Search engine {search_engine} is not supported.""
        )

        with self.subTest(""Greedy search gate cut warm start test""):
            # Even if the input cost bounds are too stringent, greedy_cut_optimization
            # is able to return a solution.

            qubits_per_subcircuit = 3

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=True, wire_lo=False)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            # Impose a stringent cost upper bound, insist gamma <=2.
            cut_opt = CutOptimization(interface, settings, constraint_obj)
            cut_opt.update_upperbound_cost((2, 4))
            state, cost = cut_opt.optimization_pass()

            # 2 cnot cuts are still found
            assert state is not None
            assert cost[0] == 9

        with self.subTest(""Greedy search wire cut warm start test""):
            # Even if the input cost bounds are too stringent, greedy_cut_optimization
            # is able to return a solution.

            qubits_per_subcircuit = 3

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=False, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            # Impose a stringent cost upper bound, insist gamma <=2.
            cut_opt = CutOptimization(interface, settings, constraint_obj)
            cut_opt.update_upperbound_cost((2, 4))
            state, cost = cut_opt.optimization_pass()

            # 2 LO wire cuts are still found
            assert state is not None
            assert cost[0] == 16


class TestCuttingSevenQubitCircuit(unittest.TestCase):
    def setUp(self):
        qc = QuantumCircuit(7)
        for i in range(7):
            qc.rx(np.pi / 4, i)
        qc.cx(0, 3)
        qc.cx(1, 3)
        qc.cx(2, 3)
        qc.cx(3, 4)
        qc.cx(3, 5)
        qc.cx(3, 6)
        self.circuit_internal = qc_to_cco_circuit(qc)

    def test_seven_qubit_workflow(self):
        with self.subTest(""Two qubits per subcircuit""):

            qubits_per_subcircuit = 2

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=True, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

            output = optimization_pass.optimize()

            cut_actions_list = output.cut_actions_sublist()

            assert cut_actions_list == [
                CutIdentifier(
                    cut_action=""CutTwoQubitGate"",
                    cut_location=CutLocation(
                        instruction_id=7, gate_name=""cx"", qubits=[0, 3]
                    ),
                ),
                CutIdentifier(
                    cut_action=""CutTwoQubitGate"",
                    cut_location=CutLocation(
                        instruction_id=8, gate_name=""cx"", qubits=[1, 3]
                    ),
                ),
                CutIdentifier(
                    cut_action=""CutTwoQubitGate"",
                    cut_location=CutLocation(
                        instruction_id=9, gate_name=""cx"", qubits=[2, 3]
                    ),
                ),
                CutIdentifier(
                    cut_action=""CutTwoQubitGate"",
                    cut_location=CutLocation(
                        instruction_id=11, gate_name=""cx"", qubits=[3, 5]
                    ),
                ),
                CutIdentifier(
                    cut_action=""CutTwoQubitGate"",
                    cut_location=CutLocation(
                        instruction_id=12, gate_name=""cx"", qubits=[3, 6]
                    ),
                ),
            ]

            best_result = optimization_pass.get_results()

            assert (
                output.upper_bound_gamma() == best_result.gamma_UB == 243
            )  # 5 LO cnot cuts.

            assert (
                optimization_pass.minimum_reached() is True
            )  # matches optimal solution.

            assert (
                interface.export_subcircuits_as_string(name_mapping=""default"")
                == ""ABCDDEF""
            )  # circuit separated into 2 subcircuits.

        with self.subTest(""Single wire cut""):

            qubits_per_subcircuit = 4

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=True, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

            output = optimization_pass.optimize()

            cut_actions_list = output.cut_actions_sublist()

            assert cut_actions_list == [
                SingleWireCutIdentifier(
                    cut_action=""CutLeftWire"",
                    wire_cut_location=WireCutLocation(
                        instruction_id=10, gate_name=""cx"", qubits=[3, 4], input=1
                    ),
                )
            ]

            assert (
                interface.export_subcircuits_as_string(name_mapping=""default"")
                == ""AAAABBBB""
            )  # extra wires because of wire cuts
            # and no qubit reuse.

            best_result = optimization_pass.get_results()

            assert (
                output.upper_bound_gamma() == best_result.gamma_UB == 4
            )  # One LO wire cut.

            assert (
                optimization_pass.minimum_reached() is True
            )  # matches optimal solution

        with self.subTest(""Two single wire cuts""):

            qubits_per_subcircuit = 3

            interface = SimpleGateList(self.circuit_internal)

            settings = OptimizationSettings(seed=12345, gate_lo=True, wire_lo=True)

            settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

            constraint_obj = DeviceConstraints(qubits_per_subcircuit)

            optimization_pass = LOCutsOptimizer(interface, settings, constraint_obj)

            output = optimization_pass.optimize()

            cut_actions_list = output.cut_actions_sublist()

            assert cut_actions_list == [
                SingleWireCutIdentifier(
                    cut_action=""CutRightWire"",
                    wire_cut_location=WireCutLocation(
                        instruction_id=9, gate_name=""cx"", qubits=[2, 3], input=2
                    ),
                ),
                SingleWireCutIdentifier(
                    cut_action=""CutLeftWire"",
                    wire_cut_location=WireCutLocation(
                        instruction_id=11, gate_name=""cx"", qubits=[3, 5], input=1
                    ),
                ),
            ]

            assert (
                interface.export_subcircuits_as_string(name_mapping=""default"")
                == ""AABABCBCC""
            )  # extra wires because of wire cuts
        # and no qubit reuse. In the string above,
        # {A: wire 0, A:wire 1, B:wire 2, A: wire 3,
        # B: first cut on wire 3, C: second cut on wire 3,
        # B: wire 4, C: wire 5, C: wire 6}.

        best_result = optimization_pass.get_results()

        assert (
            output.upper_bound_gamma() == best_result.gamma_UB == 16
        )  # Two LO wire cuts.

        assert optimization_pass.minimum_reached() is True  # matches optimal solution


class TestCuttingMultiQubitGates(unittest.TestCase):
    def setUp(self):
        qc = QuantumCircuit(3)
        qc.ccx(0, 1, 2)
        circuit_internal = qc_to_cco_circuit(qc)
        self.interface = SimpleGateList(circuit_internal)
        self.settings = OptimizationSettings(seed=12345)
        self.settings.set_engine_selection(""CutOptimization"", ""BestFirst"")

    def no_cutting_multiqubit_gates(self):

        # The cutting of multiqubit gates is not supported at present.
        qubits_per_subcircuit = 2

        constraint_obj = DeviceConstraints(qubits_per_subcircuit)

        optimization_pass = LOCutsOptimizer(
            self.interface, self.settings, constraint_obj
        )

        with raises(ValueError) as e_info:
            _ = optimization_pass.optimize()
        assert e_info.value.args[0] == (
            ""The input circuit must contain only single and two-qubits gates. ""
            ""Found 3-qubit gate: (ccx).""
        )
"
https://github.com/Qiskit-Extensions/circuit-knitting-toolbox,Qiskit-Extensions,"# This code is a Qiskit project.

# (C) Copyright IBM 2023.

# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Tests for QPDGate classes.""""""

import unittest
import copy
import io

import pytest
from qiskit import QuantumCircuit, qpy
from qiskit.circuit.library.standard_gates import CXGate, XGate, YGate, ZGate

from circuit_knitting.cutting.qpd import (
    QPDBasis,
    TwoQubitQPDGate,
    SingleQubitQPDGate,
)


class TestTwoQubitQPDGate(unittest.TestCase):
    def test_qpd_gate_empty(self):
        empty_maps = [([], [])]
        empty_basis = QPDBasis(empty_maps, [1.0])
        empty_gate = TwoQubitQPDGate(empty_basis)
        self.assertEqual(None, empty_gate.basis_id)

    def test_qpd_gate_bad_idx(self):
        empty_maps = [([], [])]
        empty_basis = QPDBasis(empty_maps, [1.0])
        empty_gate = TwoQubitQPDGate(empty_basis)
        with pytest.raises(ValueError) as e_info:
            empty_gate.basis_id = 1
        self.assertEqual(""Basis ID out of range"", e_info.value.args[0])

    def test_qpd_gate_select_basis(self):
        qpd_maps = [
            ([XGate()], [XGate()]),
            ([YGate()], [YGate()]),
            ([ZGate()], [ZGate()]),
        ]
        qpd_basis = QPDBasis(qpd_maps, [0.5, 0.25, 0.25])
        qpd_gate = TwoQubitQPDGate(qpd_basis)
        qpd_gate.basis_id = 1
        qpd_gate_copy1 = copy.copy(qpd_gate)
        qpd_gate_copy2 = copy.copy(qpd_gate)

        # These will be random if the basis_id isn't working correctly
        self.assertEqual(
            qpd_gate.definition.decompose(),
            qpd_gate_copy1.definition.decompose(),
            qpd_gate_copy2.definition.decompose(),
        )

    def test_qpd_gate_mismatching_basis(self):
        single_qubit_map = [
            ([XGate()],),
        ]
        single_qubit_basis = QPDBasis(single_qubit_map, [1.0])
        with pytest.raises(ValueError) as e_info:
            TwoQubitQPDGate(single_qubit_basis)
        self.assertEqual(
            ""TwoQubitQPDGate only supports QPDBasis which act on two qubits."",
            e_info.value.args[0],
        )


class TestSingleQubitQPDGate(unittest.TestCase):
    def test_qpd_gate_empty(self):
        empty_maps = [([],)]
        empty_basis = QPDBasis(empty_maps, [1.0])
        empty_gate = SingleQubitQPDGate(empty_basis, qubit_id=0)
        self.assertEqual(None, empty_gate.basis_id)
        self.assertEqual(0, empty_gate.qubit_id)

    def test_qubit_id_out_of_range(self):
        maps = [([XGate()], [YGate()])]
        basis = QPDBasis(maps, [1.0])
        with pytest.raises(ValueError) as e_info:
            SingleQubitQPDGate(basis, qubit_id=2)
        self.assertEqual(
            ""'qubit_id' out of range. 'basis' acts on 2 qubits, but 'qubit_id' is 2."",
            e_info.value.args[0],
        )

    def test_missing_basis_id(self):
        maps = [([XGate()], [YGate()])]
        basis = QPDBasis(maps, [1.0])
        assert SingleQubitQPDGate(basis=basis, qubit_id=0).definition is None

    def test_compare_1q_and_2q(self):
        maps = [([XGate()], [YGate()])]
        basis = QPDBasis(maps, [1.0])
        inst_2q = TwoQubitQPDGate(basis=basis)
        inst_1q = SingleQubitQPDGate(basis=basis, qubit_id=0)
        # Call both eq methods, since single qubit implements a slightly different equivalence
        self.assertFalse(inst_2q == inst_1q)
        self.assertFalse(inst_1q == inst_2q)

    def test_qpy_serialization(self):
        qc = QuantumCircuit(2)
        qc.append(TwoQubitQPDGate.from_instruction(CXGate()), [0, 1])

        f = io.BytesIO()
        qpy.dump(qc, f)
"
https://github.com/Qiskit-Extensions/circuit-knitting-toolbox,Qiskit-Extensions,"# This code is a Qiskit project.

# (C) Copyright IBM 2023.

# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import unittest
import pytest

import numpy as np
from qiskit import QuantumCircuit

from circuit_knitting.utils.simulation import (
    simulate_statevector_outcomes,
    ExactSampler,
)


class TestSimulationFunctions(unittest.TestCase):
    def test_simulate_statevector_outcomes(self):
        with self.subTest(""Normal circuit""):
            qc = QuantumCircuit(2, 1)
            qc.h(0)
            qc.t(0)
            qc.h(0)
            qc.cx(0, 1)
            qc.measure(0, 0)
            qc.h(0)
            r = simulate_statevector_outcomes(qc)
            assert r.keys() == {0, 1}
            assert r[0] == pytest.approx(np.cos(np.pi / 8) ** 2)
            assert r[1] == pytest.approx(1 - np.cos(np.pi / 8) ** 2)

        with self.subTest(""Circuit without measurement""):
            qc = QuantumCircuit(2)
            qc.h(0)
            qc.t(0)
            qc.h(0)
            qc.cx(0, 1)
            qc.h(0)
            r = simulate_statevector_outcomes(qc)
            assert r.keys() == {0}
            assert r[0] == pytest.approx(1.0)

        with self.subTest(""Overwriting clbits""):
            qc = QuantumCircuit(2, 1)
            qc.h(0)
            qc.measure(0, 0)
            qc.measure(1, 0)
            r = simulate_statevector_outcomes(qc)
            assert r.keys() == {0}
            assert r[0] == pytest.approx(1.0)

        with self.subTest(""Bit has probability 1 of being set""):
            qc = QuantumCircuit(1, 1)
            qc.x(0)
            qc.measure(0, 0)
            r = simulate_statevector_outcomes(qc)
            assert r.keys() == {1}

        with self.subTest(""Circuit with reset operation""):
            qc = QuantumCircuit(1, 2)
            qc.h(0)
            qc.measure(0, 0)
            qc.reset(0)
            qc.measure(0, 1)
            r = simulate_statevector_outcomes(qc)
            assert r.keys() == {0, 1}
            assert r[0] == pytest.approx(0.5)
            assert r[1] == pytest.approx(0.5)

        with self.subTest(""Circuit with control flow""):
            qc = QuantumCircuit(2, 1)
            with qc.for_loop(range(5)):
                qc.h(0)
                qc.cx(0, 1)
                qc.measure(0, 0)
                qc.break_loop().c_if(0, True)
            with pytest.raises(ValueError) as e_info:
                simulate_statevector_outcomes(qc)
            assert (
                e_info.value.args[0]
                == ""Circuit cannot contain a non-measurement operation on classical bit(s).""
            )

        with self.subTest(""Circuit with condition bits""):
            qc = QuantumCircuit(2, 1)
            qc.h(0)
            qc.measure(0, 0)
            qc.x(1).c_if(0, True)
            with pytest.raises(ValueError) as e_info:
                simulate_statevector_outcomes(qc)
            assert (
                e_info.value.args[0]
                == ""Operations conditioned on classical bits are currently not supported.""
            )

    def test_exact_sampler(self):
        with self.subTest(""Mid-circuit measurement, etc.""):
            qc = QuantumCircuit(2, 2)
            qc.h(0)
            qc.cx(0, 1)
            qc.measure(0, 0)
            qc.reset(0)
            qc.measure(0, 1)
            quasi_dists = ExactSampler().run(qc).result().quasi_dists
            assert len(quasi_dists) == 1
            r = quasi_dists[0]
            assert r.keys() == {0, 1}
            assert r[0] == pytest.approx(0.5)
            assert r[0] == pytest.approx(0.5)

        with self.subTest(""Circuit with reset""):
            qc = QuantumCircuit(2, 2)
            qc.h(0)
            qc.cx(0, 1)
            qc.reset(0)
            qc.measure([0, 1], [0, 1])
            quasi_dists = ExactSampler().run(qc).result().quasi_dists
            assert len(quasi_dists) == 1
            r = quasi_dists[0]
            assert r.keys() == {0, 2}
            assert r[0] == pytest.approx(0.5)
            assert r[2] == pytest.approx(0.5)
"
https://github.com/Qiskit-Extensions/circuit-knitting-toolbox,Qiskit-Extensions,"# This code is a Qiskit project.

# (C) Copyright IBM 2023.

# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Tests for CKT transpilation passes.""""""

import unittest

from qiskit import QuantumRegister, QuantumCircuit
from qiskit.transpiler import PassManager
from qiskit.transpiler.passes import DAGFixedPoint
from qiskit.passmanager.flow_controllers import DoWhileController
from qiskit.converters import circuit_to_dag

from circuit_knitting.utils.transpiler_passes import RemoveFinalReset, ConsolidateResets


class TestRemoveFinalReset(unittest.TestCase):
    """"""Test remove-reset-in-zero-state optimizations.""""""

    def test_optimize_single_reset(self):
        """"""Remove a single final reset
        qr0:--[H]--|0>--   ==>    qr0:--[H]--
        """"""
        qr = QuantumRegister(1, ""qr"")
        circuit = QuantumCircuit(qr)
        circuit.h(0)
        circuit.reset(qr)
        dag = circuit_to_dag(circuit)

        expected = QuantumCircuit(qr)
        expected.h(0)

        pass_ = RemoveFinalReset()
        after = pass_.run(dag)

        self.assertEqual(circuit_to_dag(expected), after)

    def test_dont_optimize_non_final_reset(self):
        """"""Do not remove reset if not final instruction
        qr0:--|0>--[H]--   ==>    qr0:--|0>--[H]--
        """"""
        qr = QuantumRegister(1, ""qr"")
        circuit = QuantumCircuit(qr)
        circuit.reset(qr)
        circuit.h(qr)
        dag = circuit_to_dag(circuit)

        expected = QuantumCircuit(qr)
        expected.reset(qr)
        expected.h(qr)

        pass_ = RemoveFinalReset()
        after = pass_.run(dag)

        self.assertEqual(circuit_to_dag(expected), after)

    def test_optimize_single_reset_in_diff_qubits(self):
        """"""Remove a single final reset in different qubits
        qr0:--[H]--|0>--          qr0:--[H]--
                      ==>
        qr1:--[X]--|0>--          qr1:--[X]----
        """"""
        qr = QuantumRegister(2, ""qr"")
        circuit = QuantumCircuit(qr)
        circuit.h(0)
        circuit.x(1)
        circuit.reset(qr)
        dag = circuit_to_dag(circuit)

        expected = QuantumCircuit(qr)
        expected.h(0)
        expected.x(1)

        pass_ = RemoveFinalReset()
        after = pass_.run(dag)

        self.assertEqual(circuit_to_dag(expected), after)


class TestRemoveFinalResetFixedPoint(unittest.TestCase):
    """"""Test RemoveFinalReset in a transpiler, using fixed point.""""""

    def test_two_resets(self):
        """"""Remove two final resets
        qr0:--[H]-|0>-|0>--   ==>    qr0:--[H]--
        """"""
        qr = QuantumRegister(1, ""qr"")
        circuit = QuantumCircuit(qr)
        circuit.h(qr[0])
        circuit.reset(qr[0])
        circuit.reset(qr[0])

        expected = QuantumCircuit(qr)
        expected.h(qr[0])

        pass_manager = PassManager()
        passes = [RemoveFinalReset(), DAGFixedPoint()]
        pass_manager.append(
            DoWhileController(
                passes,
                do_while=lambda property_set: not property_set[""dag_fixed_point""],
            )
        )
        after = pass_manager.run(circuit)

        self.assertEqual(expected, after)


class TestConsolidateResets(unittest.TestCase):
    """"""Test consolidate-resets optimization.""""""

    def test_consolidate_double_reset(self):
        """"""Consolidate a pair of resets.
        qr0:--|0>--|0>--   ==>    qr0:--|0>--
        """"""
        qr = QuantumRegister(1, ""qr"")
        circuit = QuantumCircuit(qr)
        circuit.reset(qr)
        circuit.reset(qr)
        dag = circuit_to_dag(circuit)

        expected = QuantumCircuit(qr)
        expected.reset(qr)

        pass_ = ConsolidateResets()
        after = pass_.run(dag)

        self.assertEqual(circuit_to_dag(expected), after)
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Basic example with the Qiskit AQT provider. Creates a 4-qubit GHZ state.""""""

import qiskit
from qiskit import QuantumCircuit

from qiskit_aqt_provider.aqt_provider import AQTProvider

if __name__ == ""__main__"":
    # Ways to specify an access token (in precedence order):
    # - as argument to the AQTProvider initializer
    # - in the AQT_TOKEN environment variable
    # - if none of the above exists, default to an empty string, which restricts access
    #   to the default workspace only.
    provider = AQTProvider(""token"")

    # The backends() method lists all available computing backends. Printing it
    # renders it as a table that shows each backend's containing workspace.
    print(provider.backends())

    # Retrieve a backend by providing search criteria. The search must have a single
    # match. For example:
    backend = provider.get_backend(""offline_simulator_no_noise"", workspace=""default"")

    # Define a quantum circuit that produces a 4-qubit GHZ state.
    qc = QuantumCircuit(4)
    qc.h(0)
    qc.cx(0, 1)
    qc.cx(0, 2)
    qc.cx(0, 3)
    qc.measure_all()

    # Transpile for the target backend.
    qc = qiskit.transpile(qc, backend)

    # Execute on the target backend.
    result = backend.run(qc, shots=200).result()

    if result.success:
        print(result.get_counts())
    else:  # pragma: no cover
        print(result.to_dict()[""error""])
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Basic example with the Qiskit AQT provider and the noisy offline simulator.

Creates a 2-qubit GHZ state.
""""""

import qiskit
from qiskit import QuantumCircuit

from qiskit_aqt_provider.aqt_provider import AQTProvider

if __name__ == ""__main__"":
    # Ways to specify an access token (in precedence order):
    # - as argument to the AQTProvider initializer
    # - in the AQT_TOKEN environment variable
    # - if none of the above exists, default to an empty string, which restricts access
    #   to the default workspace only.
    provider = AQTProvider(""token"")

    # The backends() method lists all available computing backends. Printing it
    # renders it as a table that shows each backend's containing workspace.
    print(provider.backends())

    # Retrieve a backend by providing search criteria. The search must have a single
    # match. For example:
    backend = provider.get_backend(""offline_simulator_noise"", workspace=""default"")

    # Define a quantum circuit that produces a 2-qubit GHZ state.
    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    # Transpile for the target backend.
    qc = qiskit.transpile(qc, backend)

    # Execute on the target backend.
    result = backend.run(qc, shots=200).result()

    if result.success:
        # due to the noise, also the states '01' and '10' may be populated!
        print(result.get_counts())
    else:  # pragma: no cover
        print(result.to_dict()[""error""])
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Simple number partition problem solving.

This example shows how to solve problems covered by the application
domains in the qiskit_optimization package.

Number partition: given a set of positive integers, determine whether
it can be split into two non-overlapping sets that have the same sum.
""""""

from dataclasses import dataclass
from typing import Final, Union

import qiskit_algorithms
from qiskit_algorithms.minimum_eigensolvers import QAOA
from qiskit_algorithms.optimizers import COBYLA
from qiskit_optimization.algorithms import MinimumEigenOptimizer, OptimizationResultStatus
from qiskit_optimization.applications import NumberPartition

from qiskit_aqt_provider import AQTProvider
from qiskit_aqt_provider.primitives import AQTSampler

RANDOM_SEED: Final = 0


@dataclass(frozen=True)
class Success:
    """"""Solution of a partition problem.""""""

    # type would be better as tuple[set[int], set[int]] but
    # NumberPartition.interpret returns list[list[int]].
    partition: list[list[int]]

    def is_valid(self) -> bool:
        """"""Evaluate whether the stored partition is valid.

        A partition is valid if both sets have the same sum.
        """"""
        a, b = self.partition
        return sum(a) == sum(b)


class Infeasible:
    """"""Marker for unsolvable partition problems.""""""


def solve_partition_problem(num_set: set[int]) -> Union[Success, Infeasible]:
    """"""Solve a partition problem.

    Args:
        num_set: set of positive integers to partition into two distinct subsets
        with the same sum.

    Returns:
        Success: solutions to the problem exist and are returned
        Infeasible: the given set cannot be partitioned.
    """"""
    problem = NumberPartition(list(num_set))
    qp = problem.to_quadratic_program()

    meo = MinimumEigenOptimizer(
        min_eigen_solver=QAOA(sampler=AQTSampler(backend), optimizer=COBYLA())
    )
    result = meo.solve(qp)

    if result.status is OptimizationResultStatus.SUCCESS:
        return Success(partition=problem.interpret(result))

    if result.status is OptimizationResultStatus.INFEASIBLE:
        return Infeasible()

    raise RuntimeError(""Unexpected optimizer status"")  # pragma: no cover


if __name__ == ""__main__"":
    backend = AQTProvider(""token"").get_backend(""offline_simulator_no_noise"")

    # fix the random seeds such that the example is reproducible
    qiskit_algorithms.utils.algorithm_globals.random_seed = RANDOM_SEED
    backend.simulator.options.seed_simulator = RANDOM_SEED

    num_set = {1, 3, 4}
    result = solve_partition_problem(num_set)
    assert isinstance(result, Success)  # noqa: S101
    assert result.is_valid()  # noqa: S101
    print(f""Partition for {num_set}:"", result.partition)

    num_set = {1, 2}
    result = solve_partition_problem(num_set)
    assert isinstance(result, Infeasible)  # noqa: S101
    print(f""No partition possible for {num_set}."")
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Trivial minimization example using a quantum approximate optimization algorithm (QAOA).

This is the same example as in vqe.py, but uses QAOA instead of VQE as solver.
""""""

from typing import Final

import qiskit_algorithms
from qiskit.quantum_info import SparsePauliOp
from qiskit_algorithms.minimum_eigensolvers import QAOA
from qiskit_algorithms.optimizers import COBYLA

from qiskit_aqt_provider import AQTProvider
from qiskit_aqt_provider.primitives import AQTSampler

RANDOM_SEED: Final = 0

if __name__ == ""__main__"":
    backend = AQTProvider(""token"").get_backend(""offline_simulator_no_noise"")
    sampler = AQTSampler(backend)

    # fix the random seeds such that the example is reproducible
    qiskit_algorithms.utils.algorithm_globals.random_seed = RANDOM_SEED
    backend.simulator.options.seed_simulator = RANDOM_SEED

    # Hamiltonian: Ising model on two spin 1/2 without external field
    J = 1.23456789
    hamiltonian = SparsePauliOp.from_list([(""ZZ"", 3 * J)])

    # Find the ground-state energy with QAOA
    optimizer = COBYLA(maxiter=100, tol=0.01)
    qaoa = QAOA(sampler, optimizer)
    result = qaoa.compute_minimum_eigenvalue(operator=hamiltonian)
    assert result.eigenvalue is not None  # noqa: S101

    print(f""Optimizer run time: {result.optimizer_time:.2f} s"")
    print(""Cost function evaluations:"", result.cost_function_evals)
    print(""Deviation from expected ground-state energy:"", abs(result.eigenvalue - (-3 * J)))
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# mypy: disable-error-code=""no-untyped-def""

""""""Quickstart example on using the Estimator primitive.

This examples uses a variational quantum eigensolver (VQE) to find
the ground state energy of a Hamiltonian.
""""""

from collections.abc import Sequence

from qiskit import QuantumCircuit
from qiskit.circuit.library import TwoLocal
from qiskit.primitives import BaseEstimator
from qiskit.quantum_info import SparsePauliOp
from qiskit.quantum_info.operators.base_operator import BaseOperator
from scipy.optimize import minimize

from qiskit_aqt_provider import AQTProvider
from qiskit_aqt_provider.primitives import AQTEstimator

# Select an execution backend
provider = AQTProvider(""ACCESS_TOKEN"")
backend = provider.get_backend(""offline_simulator_no_noise"")

# Instantiate an estimator on the execution backend
estimator = AQTEstimator(backend)

# Set the transpiler's optimization level
estimator.set_transpile_options(optimization_level=3)

# Specify the problem Hamiltonian
hamiltonian = SparsePauliOp.from_list(
    [
        (""II"", -1.052373245772859),
        (""IZ"", 0.39793742484318045),
        (""ZI"", -0.39793742484318045),
        (""ZZ"", -0.01128010425623538),
        (""XX"", 0.18093119978423156),
    ]
)

# Define the VQE Ansatz, initial point, and cost function
ansatz = TwoLocal(num_qubits=2, rotation_blocks=""ry"", entanglement_blocks=""cz"")
initial_point = [0] * 8


def cost_function(
    params: Sequence[float],
    ansatz: QuantumCircuit,
    hamiltonian: BaseOperator,
    estimator: BaseEstimator,
) -> float:
    """"""Cost function for the VQE.

    Return the estimated expectation value of the Hamiltonian
    on the state prepared by the Ansatz circuit.
    """"""
    return float(estimator.run(ansatz, hamiltonian, parameter_values=params).result().values[0])


# Run the VQE using the SciPy minimizer routine
result = minimize(
    cost_function, initial_point, args=(ansatz, hamiltonian, estimator), method=""cobyla""
)

# Print the found minimum eigenvalue
print(result.fun)
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Quickstart example on using the Sampler primitive.

This example samples a 2-qubit Bell state.
""""""

from qiskit import QuantumCircuit

from qiskit_aqt_provider import AQTProvider
from qiskit_aqt_provider.primitives import AQTSampler

# Define a circuit
circuit = QuantumCircuit(2)
circuit.h(0)
circuit.cx(0, 1)
circuit.measure_all()

# Select an execution backend
provider = AQTProvider(""ACCESS_TOKEN"")
backend = provider.get_backend(""offline_simulator_no_noise"")

# Instantiate a sampler on the execution backend
sampler = AQTSampler(backend)

# Set the transpiler's optimization level
sampler.set_transpile_options(optimization_level=3)

# Sample the circuit on the execution backend
result = sampler.run(circuit).result()

quasi_dist = result.quasi_dists[0]
print(quasi_dist)
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Quickstart example on transpiling and executing circuits.""""""

import qiskit
from qiskit.circuit.library import QuantumVolume

from qiskit_aqt_provider import AQTProvider

# Define a circuit
circuit = QuantumVolume(5)
circuit.measure_all()

# Select an execution backend
provider = AQTProvider(""ACCESS_TOKEN"")
backend = provider.get_backend(""offline_simulator_no_noise"")

# Transpile the circuit to target the selected AQT backend
transpiled_circuit = qiskit.transpile(circuit, backend, optimization_level=2)
print(transpiled_circuit)

# Execute the circuit on the selected AQT backend
result = backend.run(transpiled_circuit, shots=50).result()

if result.success:
    print(result.get_counts())
else:  # pragma: no cover
    raise RuntimeError
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Trivial minimization example using a variational quantum eigensolver.""""""

from typing import Final

import qiskit_algorithms
from qiskit.circuit.library import TwoLocal
from qiskit.quantum_info import SparsePauliOp
from qiskit_algorithms.minimum_eigensolvers import VQE
from qiskit_algorithms.optimizers import COBYLA

from qiskit_aqt_provider import AQTProvider
from qiskit_aqt_provider.aqt_resource import OfflineSimulatorResource
from qiskit_aqt_provider.primitives import AQTEstimator

RANDOM_SEED: Final = 0

if __name__ == ""__main__"":
    backend = AQTProvider(""token"").get_backend(""offline_simulator_no_noise"")
    assert isinstance(backend, OfflineSimulatorResource)  # noqa: S101
    estimator = AQTEstimator(backend)

    # fix the random seeds such that the example is reproducible
    qiskit_algorithms.utils.algorithm_globals.random_seed = RANDOM_SEED
    backend.simulator.options.seed_simulator = RANDOM_SEED

    # Hamiltonian: Ising model on two spin 1/2 without external field
    J = 1.2
    hamiltonian = SparsePauliOp.from_list([(""XX"", J)])

    # Find the ground-state energy with VQE
    ansatz = TwoLocal(num_qubits=2, rotation_blocks=""ry"", entanglement_blocks=""rxx"", reps=1)
    optimizer = COBYLA(maxiter=100, tol=0.01)
    vqe = VQE(estimator, ansatz, optimizer)
    result = vqe.compute_minimum_eigenvalue(operator=hamiltonian)
    assert result.eigenvalue is not None  # noqa: S101

    print(f""Optimizer run time: {result.optimizer_time:.2f} s"")
    print(""Cost function evaluations:"", result.cost_function_evals)
    print(""Deviation from expected ground-state energy:"", abs(result.eigenvalue - (-J)))
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2019, Alpine Quantum Technologies GmbH 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import uuid
from collections import Counter, defaultdict
from dataclasses import dataclass
from pathlib import Path
from types import TracebackType
from typing import (
    TYPE_CHECKING,
    Any,
    ClassVar,
    NoReturn,
    Optional,
    Union,
)

import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers import JobV1
from qiskit.providers.jobstatus import JobStatus
from qiskit.result.result import Result
from qiskit.utils.lazy_tester import contextlib
from tqdm import tqdm
from typing_extensions import Self, TypeAlias, assert_never

from qiskit_aqt_provider import api_models_generated, persistence
from qiskit_aqt_provider.api_models_direct import JobResultError
from qiskit_aqt_provider.aqt_options import AQTOptions
from qiskit_aqt_provider.circuit_to_aqt import circuits_to_aqt_job

if TYPE_CHECKING:  # pragma: no cover
    from qiskit_aqt_provider.aqt_resource import AQTDirectAccessResource, AQTResource


# Tags for the status of AQT API jobs


@dataclass
class JobFinished:
    """"""The job finished successfully.""""""

    status: ClassVar = JobStatus.DONE
    results: dict[int, list[list[int]]]


@dataclass
class JobFailed:
    """"""An error occurred during the job execution.""""""

    status: ClassVar = JobStatus.ERROR
    error: str


class JobQueued:
    """"""The job is queued.""""""

    status: ClassVar = JobStatus.QUEUED


@dataclass
class JobOngoing:
    """"""The job is running.""""""

    status: ClassVar = JobStatus.RUNNING
    finished_count: int


class JobCancelled:
    """"""The job was cancelled.""""""

    status = ClassVar = JobStatus.CANCELLED


JobStatusPayload: TypeAlias = Union[JobQueued, JobOngoing, JobFinished, JobFailed, JobCancelled]


@dataclass(frozen=True)
class Progress:
    """"""Progress information of a job.""""""

    finished_count: int
    """"""Number of completed circuits.""""""

    total_count: int
    """"""Total number of circuits in the job.""""""


@dataclass
class _MockProgressBar:
    """"""Minimal tqdm-compatible progress bar mock.""""""

    total: int
    """"""Total number of items in the job.""""""

    n: int = 0
    """"""Number of processed items.""""""

    def update(self, n: int = 1) -> None:
        """"""Update the number of processed items by `n`.""""""
        self.n += n

    def __enter__(self) -> Self:
        return self

    def __exit__(
        self,
        exc_type: Optional[type[BaseException]],
        exc_value: Optional[BaseException],
        traceback: Optional[TracebackType],
        /,
    ) -> None: ...


class AQTJob(JobV1):
    """"""Handle for quantum circuits jobs running on AQT cloud backends.

    Jobs contain one or more quantum circuits that are executed with a common
    set of options (see :class:`AQTOptions <qiskit_aqt_provider.aqt_options.AQTOptions>`).

    Job handles should be retrieved from calls
    to :meth:`AQTResource.run <qiskit_aqt_provider.aqt_resource.AQTResource.run>`, which immediately
    returns after submitting the job. The :meth:`result` method allows blocking until a job
    completes:

    >>> import qiskit
    >>> from qiskit.providers import JobStatus
    >>> from qiskit_aqt_provider import AQTProvider
    >>>
    >>> backend = AQTProvider("""").get_backend(""offline_simulator_no_noise"")
    >>>
    >>> qc = qiskit.QuantumCircuit(1)
    >>> _ = qc.rx(3.14, 0)
    >>> _ = qc.measure_all()
    >>> qc = qiskit.transpile(qc, backend)
    >>>
    >>> job = backend.run(qc, shots=100)
    >>> result = job.result()
    >>> job.status() is JobStatus.DONE
    True
    >>> result.success
    True
    >>> result.get_counts()
    {'1': 100}
    """"""

    _backend: ""AQTResource""

    def __init__(
        self,
        backend: ""AQTResource"",
        circuits: list[QuantumCircuit],
        options: AQTOptions,
    ) -> None:
        """"""Initialize an :class:`AQTJob` instance.

        .. tip:: :class:`AQTJob` instances should not be created directly. Use
          :meth:`AQTResource.run <qiskit_aqt_provider.aqt_resource.AQTResource.run>`
          to submit circuits for execution and retrieve a job handle.

        Args:
            backend: backend to run the job on.
            circuits: list of circuits to execute.
            options: overridden resource options for this job.
        """"""
        super().__init__(backend, """")

        self.circuits = circuits
        self.options = options
        self.api_submit_payload = circuits_to_aqt_job(circuits, options.shots)

        self.status_payload: JobStatusPayload = JobQueued()

    @classmethod
    def restore(
        cls,
        job_id: str,
        *,
        access_token: Optional[str] = None,
        store_path: Optional[Path] = None,
        remove_from_store: bool = True,
    ) -> Self:
        """"""Restore a job handle from local persistent storage.

        .. warning:: The default local storage path depends on the `qiskit_aqt_provider`
            package version. Job persisted with a different package version will therefore
            **not** be found!

        .. hint:: If the job's execution backend is an offline simulator, the
            job is re-submitted to the simulation backend and the new job ID differs
            from the one passed to this function.

        Args:
            job_id: identifier of the job to retrieve.
            access_token: access token for the AQT cloud.
              See :class:`AQTProvider <qiskit_aqt_provider.aqt_provider.AQTProvider>`.
            store_path: local persistent storage directory.
              By default, use a standard cache directory.
            remove_from_store: if :data:`True`, remove the retrieved job's data from persistent
              storage after a successful load.

        Returns:
            A job handle for the passed `job_id`.

        Raises:
            JobNotFoundError: the target job was not found in persistent storage.
        """"""
        from qiskit_aqt_provider.aqt_provider import AQTProvider
        from qiskit_aqt_provider.aqt_resource import AQTResource, OfflineSimulatorResource

        store_path = persistence.get_store_path(store_path)
        data = persistence.Job.restore(job_id, store_path)

        # TODO: forward .env loading args?
        provider = AQTProvider(access_token)
        if data.resource.resource_type == ""offline_simulator"":
            # FIXME: persist with_noise_model and restore it
            resource = OfflineSimulatorResource(provider, data.resource, with_noise_model=False)
        else:
            resource = AQTResource(provider, data.resource)

        obj = cls(backend=resource, circuits=data.circuits.circuits, options=data.options)

        if data.resource.resource_type == ""offline_simulator"":
            # re-submit the job because we can't restore the backend state
            obj.submit()
        else:
            obj._job_id = job_id

        if remove_from_store:
            persistence.Job.remove_from_store(job_id, store_path)

        return obj

    def persist(self, *, store_path: Optional[Path] = None) -> Path:
        """"""Save this job to local persistent storage.

        .. warning:: Only jobs that have been submitted for execution
          can be persisted (a valid `job_id` is required).

        Args:
            store_path: local persistent storage directory.
              By default, use a standard cache directory.

        Returns:
            The path to the job data in local persistent storage.

        Raises:
            RuntimeError: the job was never submitted for execution.
        """"""
        if not self.job_id():
            raise RuntimeError(""Can only persist submitted jobs."")

        store_path = persistence.get_store_path(store_path)
        data = persistence.Job(
            resource=self._backend.resource_id,
            circuits=persistence.Circuits(self.circuits),
            options=self.options,
        )

        return data.persist(self.job_id(), store_path)

    def submit(self) -> None:
        """"""Submit this job for execution.

        This operation is not blocking. Use :meth:`result()` to block until
        the job completes.

        Raises:
            RuntimeError: this job was already submitted.
        """"""
        if self.job_id():
            raise RuntimeError(f""Job already submitted (ID: {self.job_id()})"")

        job_id = self._backend.submit(self)
        self._job_id = str(job_id)

    def status(self) -> JobStatus:
        """"""Query the job's status.

        Returns:
            Aggregated job status for all the circuits in this job.
        """"""
        payload = self._backend.result(uuid.UUID(self.job_id()))

        if isinstance(payload, api_models_generated.JobResponseRRQueued):
            self.status_payload = JobQueued()
        elif isinstance(payload, api_models_generated.JobResponseRROngoing):
            self.status_payload = JobOngoing(finished_count=payload.response.finished_count)
        elif isinstance(payload, api_models_generated.JobResponseRRFinished):
            self.status_payload = JobFinished(
                results={
                    int(circuit_index): [[sample.root for sample in shot] for shot in shots]
                    for circuit_index, shots in payload.response.result.items()
                }
            )
        elif isinstance(payload, api_models_generated.JobResponseRRError):
            self.status_payload = JobFailed(error=payload.response.message)
        elif isinstance(payload, api_models_generated.JobResponseRRCancelled):
            self.status_payload = JobCancelled()
        else:  # pragma: no cover
            assert_never(payload)

        return self.status_payload.status

    def progress(self) -> Progress:
        """"""Progress information for this job.""""""
        num_circuits = len(self.circuits)

        if isinstance(self.status_payload, JobQueued):
            return Progress(finished_count=0, total_count=num_circuits)

        if isinstance(self.status_payload, JobOngoing):
            return Progress(
                finished_count=self.status_payload.finished_count, total_count=num_circuits
            )

        # if the circuit is finished, failed, or cancelled, it is completed
        return Progress(finished_count=num_circuits, total_count=num_circuits)

    @property
    def error_message(self) -> Optional[str]:
        """"""Error message for this job (if any).""""""
        if isinstance(self.status_payload, JobFailed):
            return self.status_payload.error

        return None

    def result(self) -> Result:
        """"""Block until all circuits have been evaluated and return the combined result.

        Success or error is signalled by the `success` field in the returned Result instance.

        Returns:
            The combined result of all circuit evaluations.
        """"""
        if self.options.with_progress_bar:
            context: Union[tqdm[NoReturn], _MockProgressBar] = tqdm(total=len(self.circuits))
        else:
            context = _MockProgressBar(total=len(self.circuits))

        with context as progress_bar:

            def callback(
                job_id: str,  # noqa: ARG001
                status: JobStatus,  # noqa: ARG001
                job: AQTJob,
            ) -> None:
                progress = job.progress()
                progress_bar.update(progress.finished_count - progress_bar.n)

            # one of DONE, CANCELLED, ERROR
            self.wait_for_final_state(
                timeout=self.options.query_timeout_seconds,
                wait=self.options.query_period_seconds,
                callback=callback,
            )

            # make sure the progress bar completes
            progress_bar.update(self.progress().finished_count - progress_bar.n)

        results = []

        if isinstance(self.status_payload, JobFinished):
            for circuit_index, circuit in enumerate(self.circuits):
                samples = self.status_payload.results[circuit_index]
                results.append(
                    _partial_qiskit_result_dict(
                        samples, circuit, shots=self.options.shots, memory=self.options.memory
                    )
                )

        return Result.from_dict(
            {
                ""backend_name"": self._backend.name,
                ""backend_version"": self._backend.version,
                ""qobj_id"": id(self.circuits),
                ""job_id"": self.job_id(),
                ""success"": self.status_payload.status is JobStatus.DONE,
                ""results"": results,
                # Pass error message as metadata
                ""error"": self.error_message,
            }
        )


class AQTDirectAccessJob(JobV1):
    """"""Handle for quantum circuits jobs running on direct-access AQT backends.

    Use
    :meth:`AQTDirectAccessResource.run
    <qiskit_aqt_provider.aqt_resource.AQTDirectAccessResource.run>`
    to get a handle and evaluate circuits on a direct-access backend.
    """"""

    _backend: ""AQTDirectAccessResource""

    def __init__(
        self,
        backend: ""AQTDirectAccessResource"",
        circuits: list[QuantumCircuit],
        options: AQTOptions,
    ) -> None:
        """"""Initialize the :class:`AQTDirectAccessJob` instance.

        Args:
            backend: backend to run the job on.
            circuits: list of circuits to execute.
            options: overridden resource options for this job.
        """"""
        super().__init__(backend, """")

        self.circuits = circuits
        self.options = options
        self.api_submit_payload = circuits_to_aqt_job(circuits, options.shots)

        self._job_id = uuid.uuid4()
        self._status = JobStatus.INITIALIZING

    def submit(self) -> None:
        """"""No-op on direct-access backends.""""""

    def result(self) -> Result:
        """"""Iteratively submit all circuits and block until full completion.

        If an error occurs, the remaining circuits are not executed and the whole
        job is marked as failed.

        Returns:
            The combined result of all circuit evaluations.
        """"""
        if self.options.with_progress_bar:
            context: Union[tqdm[NoReturn], _MockProgressBar] = tqdm(total=len(self.circuits))
        else:
            context = _MockProgressBar(total=len(self.circuits))

        result = {
            ""backend_name"": self._backend.name,
            ""backend_version"": self._backend.version,
            ""qobj_id"": id(self.circuits),
            ""job_id"": self.job_id(),
            ""success"": True,
            ""results"": [],
        }

        with context as progress_bar:
            for circuit_index, circuit in enumerate(self.circuits):
                api_circuit = self.api_submit_payload.payload.circuits[circuit_index]
                job_id = self._backend.submit(api_circuit)
                api_result = self._backend.result(
                    job_id, timeout=self.options.query_timeout_seconds
                )

                if isinstance(api_result.payload, JobResultError):
                    break

                result[""results""].append(
                    _partial_qiskit_result_dict(
                        api_result.payload.result,
                        circuit,
                        shots=self.options.shots,
                        memory=self.options.memory,
                    )
                )

                progress_bar.update(1)
            else:  # no circuits in the job, or all executed successfully
                self._status = JobStatus.DONE
                return Result.from_dict(result)

        self._status = JobStatus.ERROR
        result[""success""] = False
        return Result.from_dict(result)

    def status(self) -> JobStatus:
        """"""Query the job's status.

        Returns:
            Aggregated job status for all the circuits in this job.
        """"""
        return self._status


def _partial_qiskit_result_dict(
    samples: list[list[int]], circuit: QuantumCircuit, *, shots: int, memory: bool
) -> dict[str, Any]:
    """"""Build the Qiskit result dict for a single circuit evaluation.

    Args:
        samples: measurement outcome of the circuit evaluation.
        circuit: the evaluated circuit.
        shots: number of repetitions of the circuit evaluation.
        memory: whether to fill the classical memory dump field with the measurement results.

    Returns:
        Dict, suitable for Qiskit's `Result.from_dict` factory.
    """"""
    meas_map = _build_memory_mapping(circuit)

    data: dict[str, Any] = {""counts"": _format_counts(samples, meas_map)}

    if memory:
        data[""memory""] = ["""".join(str(x) for x in reversed(states)) for states in samples]

    return {
        ""shots"": shots,
        ""success"": True,
        ""status"": JobStatus.DONE,
        ""data"": data,
        ""header"": {
            ""memory_slots"": circuit.num_clbits,
            ""creg_sizes"": [[reg.name, reg.size] for reg in circuit.cregs],
            ""qreg_sizes"": [[reg.name, reg.size] for reg in circuit.qregs],
            ""name"": circuit.name,
            ""metadata"": circuit.metadata or {},
        },
    }


def _build_memory_mapping(circuit: QuantumCircuit) -> dict[int, set[int]]:
    """"""Scan the circuit for measurement instructions and collect qubit to classical bits mappings.

    Qubits can be mapped to multiple classical bits, possibly in different classical registers.
    The returned map only maps qubits referenced in a `measure` operation in the passed circuit.
    Qubits not targeted by a `measure` operation will not appear in the returned result.

    Parameters:
        circuit: the `QuantumCircuit` to analyze.

    Returns:
        the translation map for all measurement operations in the circuit.

    Examples:
        >>> qc = QuantumCircuit(2)
        >>> qc.measure_all()
        >>> _build_memory_mapping(qc)
        {0: {0}, 1: {1}}

        >>> qc = QuantumCircuit(2, 2)
        >>> _ = qc.measure([0, 1], [1, 0])
        >>> _build_memory_mapping(qc)
        {0: {1}, 1: {0}}

        >>> qc = QuantumCircuit(3, 2)
        >>> _ = qc.measure([0, 1], [0, 1])
        >>> _build_memory_mapping(qc)
        {0: {0}, 1: {1}}

        >>> qc = QuantumCircuit(4, 6)
        >>> _ = qc.measure([0, 1, 2, 3], [2, 3, 4, 5])
        >>> _build_memory_mapping(qc)
        {0: {2}, 1: {3}, 2: {4}, 3: {5}}

        >>> qc = QuantumCircuit(3, 4)
        >>> qc.measure_all(add_bits=False)
        >>> _build_memory_mapping(qc)
        {0: {0}, 1: {1}, 2: {2}}

        >>> qc = QuantumCircuit(3, 3)
        >>> _ = qc.x(0)
        >>> _ = qc.measure([0], [2])
        >>> _ = qc.y(1)
        >>> _ = qc.measure([1], [1])
        >>> _ = qc.x(2)
        >>> _ = qc.measure([2], [0])
        >>> _build_memory_mapping(qc)
        {0: {2}, 1: {1}, 2: {0}}

        5 qubits in two registers:

        >>> from qiskit import QuantumRegister, ClassicalRegister
        >>> qr0 = QuantumRegister(2)
        >>> qr1 = QuantumRegister(3)
        >>> cr = ClassicalRegister(2)
        >>> qc = QuantumCircuit(qr0, qr1, cr)
        >>> _ = qc.measure(qr0, cr)
        >>> _build_memory_mapping(qc)
        {0: {0}, 1: {1}}

        Multiple mapping of a qubit:

        >>> qc = QuantumCircuit(3, 3)
        >>> _ = qc.measure([0, 1], [0, 1])
        >>> _ = qc.measure([0], [2])
        >>> _build_memory_mapping(qc)
        {0: {0, 2}, 1: {1}}
    """"""
    qu2cl: defaultdict[int, set[int]] = defaultdict(set)

    for instruction in circuit.data:
        if instruction.operation.name == ""measure"":
            for qubit, clbit in zip(instruction.qubits, instruction.clbits):
                qu2cl[circuit.find_bit(qubit).index].add(circuit.find_bit(clbit).index)

    return dict(qu2cl)


def _shot_to_int(
    fluorescence_states: list[int], qubit_to_bit: Optional[dict[int, set[int]]] = None
) -> int:
    """"""Format the detected fluorescence states from a single shot as an integer.

    This follows the Qiskit ordering convention, where bit 0 in the classical register is mapped
    to bit 0 in the returned integer. The first classical register in the original circuit
    represents the least-significant bits in the integer representation.

    An optional translation map from the quantum to the classical register can be applied.
    If given, only the qubits registered in the translation map are present in the return value,
    at the index given by the translation map.

    Parameters:
        fluorescence_states: detected fluorescence states for this shot
        qubit_to_bit: optional translation map from quantum register to classical register positions

    Returns:
        integral representation of the shot result, with the translation map applied.

    Examples:
       Without a translation map, the natural mapping is used (n -> n):

        >>> _shot_to_int([1])
        1

        >>> _shot_to_int([0, 0, 1])
        4

        >>> _shot_to_int([0, 1, 1])
        6

        Swap qubits 1 and 2 in the classical register:

        >>> _shot_to_int([1, 0, 1], {0: {0}, 1: {2}, 2: {1}})
        3

        If the map is partial, only the mapped qubits are present in the output:

        >>> _shot_to_int([1, 0, 1], {1: {2}, 2: {1}})
        2

        One can translate into a classical register larger than the
        qubit register.

        Warning: the classical register is always initialized to 0.

        >>> _shot_to_int([1], {0: {1}})
        2

        >>> _shot_to_int([0, 1, 1], {0: {3}, 1: {4}, 2: {5}}) == (0b110 << 3)
        True

        or with a map larger than the qubit space:

        >>> _shot_to_int([1], {0: {0}, 1: {1}})
        1

        Consider the typical example of two quantum registers (the second one contains
        ancilla qubits) and one classical register:

        >>> from qiskit import QuantumRegister, ClassicalRegister
        >>> qr_meas = QuantumRegister(2)
        >>> qr_ancilla = QuantumRegister(3)
        >>> cr = ClassicalRegister(2)
        >>> qc = QuantumCircuit(qr_meas, qr_ancilla, cr)
        >>> _ = qc.measure(qr_meas, cr)
        >>> tr_map = _build_memory_mapping(qc)

        We assume that a single shot gave the result:

        >>> ancillas = [1, 1, 0]
        >>> meas = [1, 0]

        Then the corresponding output is 0b01 (measurement qubits mapped straight
        to the classical register of length 2):

        >>> _shot_to_int(meas + ancillas, tr_map) == 0b01
        True

        One can overwrite qr_meas[1] with qr_ancilla[0]:

        >>> _ = qc.measure(qr_ancilla[0], cr[1])
        >>> tr_map = _build_memory_mapping(qc)
        >>> _shot_to_int(meas + ancillas, tr_map) == 0b11
        True
    """"""
    tr_map = qubit_to_bit or {}

    if tr_map:
        # allocate a zero-initialized classical register
        # TODO: support pre-initialized classical registers
        clbits = max(max(d) for d in tr_map.values()) + 1
        creg = [0] * clbits

        for src_index, dest_indices in tr_map.items():
            # the translation map could map more than just the measured qubits
            with contextlib.suppress(IndexError):
                for dest_index in dest_indices:
                    creg[dest_index] = fluorescence_states[src_index]
    else:
        creg = fluorescence_states.copy()

    return int((np.left_shift(1, np.arange(len(creg))) * creg).sum())


def _format_counts(
    samples: list[list[int]], qubit_to_bit: Optional[dict[int, set[int]]] = None
) -> dict[str, int]:
    """"""Format all shots results from a circuit evaluation.

    The returned dictionary is compatible with Qiskit's `ExperimentResultData`
    `counts` field.

    Keys are hexadecimal string representations of the detected states, with the
    optional `QuantumRegister` to `ClassicalRegister` applied. Values are the occurrences
    of the keys.

    Parameters:
        samples: detected qubit fluorescence states for all shots
        qubit_to_bit: optional quantum to classical register translation map

    Returns:
        collected counts, for `ExperimentResultData`.

    Examples:
        >>> _format_counts([[1, 0, 0], [0, 1, 0], [1, 0, 0]])
        {'0x1': 2, '0x2': 1}

        >>> _format_counts([[1, 0, 0], [0, 1, 0], [1, 0, 0]], {0: {2}, 1: {1}, 2: {0}})
        {'0x4': 2, '0x2': 1}
    """"""
    return dict(Counter(hex(_shot_to_int(shot, qubit_to_bit)) for shot in samples))
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

from collections.abc import Iterator, Mapping
from typing import Any, Optional

import annotated_types
import pydantic as pdt
from typing_extensions import Self, override


class AQTOptions(pdt.BaseModel, Mapping[str, Any]):
    """"""Options for AQT resources.

    This is a typed drop-in replacement for :class:`qiskit.providers.Options`.

    Options can be set on a backend globally or on a per-job basis. To update an option
    globally, set the corresponding attribute in the backend's
    :attr:`options <qiskit_aqt_provider.aqt_resource._ResourceBase.options>` attribute:

    >>> import qiskit
    >>> from qiskit_aqt_provider import AQTProvider
    >>>
    >>> backend = AQTProvider("""").get_backend(""offline_simulator_no_noise"")
    >>>
    >>> qc = qiskit.QuantumCircuit(1)
    >>> _ = qc.rx(3.14, 0)
    >>> _ = qc.measure_all()
    >>> qc = qiskit.transpile(qc, backend)
    >>>
    >>> backend.options.shots = 50
    >>> result = backend.run(qc).result()
    >>> sum(result.get_counts().values())
    50

    Option overrides can also be applied on a per-job basis, as keyword arguments to
    :meth:`AQTResource.run <qiskit_aqt_provider.aqt_resource.AQTResource.run>` or
    :meth:`AQTDirectAccessResource.run
    <qiskit_aqt_provider.aqt_resource.AQTDirectAccessResource.run>`:

    >>> backend.options.shots
    50
    >>> result = backend.run(qc, shots=100).result()
    >>> sum(result.get_counts().values())
    100
    """"""

    model_config = pdt.ConfigDict(extra=""forbid"", validate_assignment=True)

    # Qiskit generic:

    shots: int = pdt.Field(ge=1, le=2000, default=100)
    """"""Number of repetitions per circuit.""""""

    memory: bool = False
    """"""Whether to return the sequence of memory states (readout) for each shot.

    See :meth:`qiskit.result.Result.get_memory` for details.""""""

    # AQT-specific:

    query_period_seconds: float = pdt.Field(ge=0.1, default=1.0)
    """"""Elapsed time between queries to the cloud portal when waiting for results, in seconds.""""""

    query_timeout_seconds: Optional[float] = None
    """"""Maximum time to wait for results of a single job, in seconds.""""""

    with_progress_bar: bool = True
    """"""Whether to display a progress bar when waiting for results from a single job.

    When enabled, the progress bar is written to :data:`sys.stderr`.
    """"""

    @pdt.field_validator(""query_timeout_seconds"")
    @classmethod
    def validate_timeout(cls, value: Optional[float], info: pdt.ValidationInfo) -> Optional[float]:
        """"""Enforce that the timeout, if set, is strictly positive.""""""
        if value is not None and value <= 0.0:
            raise ValueError(f""{info.field_name} must be None or > 0."")

        return value

    def update_options(self, **kwargs: Any) -> Self:
        """"""Update options by name.

        .. tip::
          This is exposed for compatibility with :class:`qiskit.providers.Options`.
          The preferred way of updating options is by direct (validated)
          assignment.
        """"""
        update = self.model_dump()
        update.update(kwargs)

        for key, value in self.model_validate(update).model_dump().items():
            setattr(self, key, value)

        return self

    # Mapping[str, Any] implementation, for compatibility with qiskit.providers.Options

    @override
    def __len__(self) -> int:
        """"""Number of options.""""""
        return len(self.model_fields)

    @override
    def __iter__(self) -> Iterator[Any]:  # type: ignore[override]
        """"""Iterate over option names.""""""
        return iter(self.model_fields)

    @override
    def __getitem__(self, name: str) -> Any:
        """"""Get the value for a given option.""""""
        return self.__dict__[name]

    # Convenience methods

    @classmethod
    def max_shots(cls) -> int:
        """"""Maximum number of repetitions per circuit.""""""
        for metadata in cls.model_fields[""shots""].metadata:
            if isinstance(metadata, annotated_types.Le):
                return int(str(metadata.le))

            if isinstance(metadata, annotated_types.Lt):  # pragma: no cover
                return int(str(metadata.lt)) - 1

        raise ValueError(""No upper bound found for 'shots'."")  # pragma: no cover


class AQTDirectAccessOptions(AQTOptions):
    """"""Options for AQT direct-access resources.""""""

    shots: int = pdt.Field(ge=1, le=200, default=100)
    """"""Number of repetitions per circuit.""""""
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2019, Alpine Quantum Technologies GmbH 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import typing
import warnings
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Any,
    Generic,
    Optional,
    TypeVar,
    Union,
)
from uuid import UUID

import httpx
from qiskit import QuantumCircuit
from qiskit.circuit.library import RXGate, RXXGate, RZGate
from qiskit.circuit.measure import Measure
from qiskit.circuit.parameter import Parameter
from qiskit.providers import BackendV2 as Backend
from qiskit.providers import Options as QiskitOptions
from qiskit.providers.models import BackendConfiguration
from qiskit.transpiler import Target
from qiskit_aer import AerJob, AerSimulator, noise
from typing_extensions import override

from qiskit_aqt_provider import api_models, api_models_direct
from qiskit_aqt_provider.aqt_job import AQTDirectAccessJob, AQTJob
from qiskit_aqt_provider.aqt_options import AQTDirectAccessOptions, AQTOptions
from qiskit_aqt_provider.circuit_to_aqt import aqt_to_qiskit_circuit

if TYPE_CHECKING:  # pragma: no cover
    from qiskit_aqt_provider.aqt_provider import AQTProvider


TargetT = TypeVar(""TargetT"", bound=Target)


class UnknownOptionWarning(UserWarning):
    """"""An unknown option was passed to a backend's :meth:`run <AQTResource.run>` method.""""""


def make_transpiler_target(target_cls: type[TargetT], num_qubits: int) -> TargetT:
    """"""Factory for transpilation targets of AQT resources.

    Args:
        target_cls: base class to use for the returned instance.
        num_qubits: maximum number of qubits supported by the resource.

    Returns:
        A Qiskit transpilation target for an AQT resource.
    """"""
    target: TargetT = target_cls(num_qubits=num_qubits)

    theta = Parameter(""θ"")
    lam = Parameter(""λ"")

    # configure the transpiler to use RX/RZ/RXX
    # the custom scheduling pass rewrites RX to R to comply to the Arnica API format.
    target.add_instruction(RZGate(lam))
    target.add_instruction(RXGate(theta))
    target.add_instruction(RXXGate(theta))
    target.add_instruction(Measure())

    return target


_JobType = TypeVar(""_JobType"", AQTJob, AQTDirectAccessJob)

_OptionsType = TypeVar(""_OptionsType"", bound=AQTOptions)
""""""Resource options model.""""""


class _ResourceBase(Generic[_OptionsType], Backend):
    """"""Common setup for AQT backends.""""""

    def __init__(
        self, provider: ""AQTProvider"", name: str, options_type: type[_OptionsType]
    ) -> None:
        """"""Initialize the Qiskit backend.

        Args:
            provider: Qiskit provider that owns this backend.
            name: name of the backend.
            options_type: options model. Must be default-initializable.
        """"""
        super().__init__(name=name, provider=provider)

        num_qubits = 20
        self._target = make_transpiler_target(Target, num_qubits)
        self._options = options_type()

        self._configuration = BackendConfiguration.from_dict(
            {
                ""backend_name"": name,
                ""backend_version"": 2,
                ""url"": provider.portal_url,
                ""simulator"": True,
                ""local"": False,
                ""coupling_map"": None,
                ""description"": ""AQT trapped-ion device simulator"",
                ""basis_gates"": [""r"", ""rz"", ""rxx""],  # the actual basis gates
                ""memory"": True,
                ""n_qubits"": num_qubits,
                ""conditional"": False,
                ""max_shots"": self._options.max_shots(),
                ""max_experiments"": 1,
                ""open_pulse"": False,
                ""gates"": [
                    {""name"": ""rz"", ""parameters"": [""theta""], ""qasm_def"": ""TODO""},
                    {""name"": ""r"", ""parameters"": [""theta"", ""phi""], ""qasm_def"": ""TODO""},
                    {""name"": ""rxx"", ""parameters"": [""theta""], ""qasm_def"": ""TODO""},
                ],
            }
        )

    def configuration(self) -> BackendConfiguration:
        """"""Legacy Qiskit backend configuration.""""""
        return self._configuration

    @property
    def max_circuits(self) -> int:
        """"""Maximum number of circuits per batch.""""""
        return 2000

    @property
    def target(self) -> Target:
        """"""Transpilation target for this backend.""""""
        return self._target

    @classmethod
    def _default_options(cls) -> QiskitOptions:
        """"""Default backend options, in Qiskit format.""""""
        options_type = typing.get_args(cls.__orig_bases__[0])[0]
        return QiskitOptions(**options_type())

    @property
    def options(self) -> _OptionsType:
        """"""Configured backend options.""""""
        return self._options

    def get_scheduling_stage_plugin(self) -> str:
        """"""Name of the custom scheduling stage plugin for the Qiskit transpiler.""""""
        return ""aqt""

    def get_translation_stage_plugin(self) -> str:
        """"""Name of the custom translation stage plugin for the Qiskit transpiler.""""""
        return ""aqt""

    def _create_job(
        self,
        job_type: type[_JobType],
        circuits: Union[QuantumCircuit, list[QuantumCircuit]],
        **options: Any,
    ) -> _JobType:
        """"""Initialize a job handle of a given type.

        Helper function for the ``run()`` method implementations.

        Args:
            job_type: type of the job handle to initialize.
            circuits: circuits to execute when the job is submitted.
            options: backend options overrides.
        """"""
        if not isinstance(circuits, list):
            circuits = [circuits]

        valid_options = {key: value for key, value in options.items() if key in self.options}
        unknown_options = set(options) - set(valid_options)

        if unknown_options:
            for unknown_option in unknown_options:
                warnings.warn(
                    f""Option {unknown_option} is not used by this backend"",
                    UnknownOptionWarning,
                    stacklevel=2,
                )

        options_copy = self.options.model_copy()
        options_copy.update_options(**valid_options)

        return job_type(
            self,
            circuits,
            options_copy,
        )


class AQTResource(_ResourceBase[AQTOptions]):
    """"""Qiskit backend for AQT cloud quantum computing resources.

    Use :meth:`AQTProvider.get_backend <qiskit_aqt_provider.aqt_provider.AQTProvider.get_backend>`
    to retrieve backend instances.
    """"""

    def __init__(
        self,
        provider: ""AQTProvider"",
        resource_id: api_models.ResourceId,
    ) -> None:
        """"""Initialize the backend.

        Args:
            provider: Qiskit provider that owns this backend.
            resource_id: description of resource to target.
        """"""
        super().__init__(
            name=resource_id.resource_id,
            provider=provider,
            options_type=AQTOptions,
        )

        self._http_client: httpx.Client = provider._http_client
        self.resource_id = resource_id

    def run(self, circuits: Union[QuantumCircuit, list[QuantumCircuit]], **options: Any) -> AQTJob:
        """"""Submit circuits for execution on this resource.

        Args:
            circuits: circuits to execute
            options: overrides for this resource's options. Elements should be valid fields
              of the :class:`AQTOptions <qiskit_aqt_provider.aqt_options.AQTOptions>` model.
              Unknown fields are ignored with a :class:`UnknownOptionWarning`.

        Returns:
            A handle to the submitted job.
        """"""
        job = self._create_job(AQTJob, circuits, **options)
        job.submit()
        return job

    def submit(self, job: AQTJob) -> UUID:
        """"""Submit a quantum circuits job to the AQT resource.

        .. tip:: This is a low-level method. Use the :meth:`run` method to submit
            a job and retrieve a :class:`AQTJob <qiskit_aqt_provider.aqt_job.AQTJob>`
            handle.

        Args:
            job: the quantum circuits job to submit to the resource for execution.

        Returns:
            The unique identifier of the submitted job.
        """"""
        resp = self._http_client.post(
            f""/submit/{self.resource_id.workspace_id}/{self.resource_id.resource_id}"",
            json=job.api_submit_payload.model_dump(),
        )

        resp.raise_for_status()
        return api_models.Response.model_validate(resp.json()).job.job_id

    def result(self, job_id: UUID) -> api_models.JobResponse:
        """"""Query the result for a specific job.

        .. tip:: This is a low-level method. Use the
            :meth:`AQTJob.result <qiskit_aqt_provider.aqt_job.AQTJob.result>`
            method to retrieve the result of a job described by a
            :class:`AQTJob <qiskit_aqt_provider.aqt_job.AQTJob>` handle.

        Parameters:
            job_id: The unique identifier for the target job.

        Returns:
            AQT API payload with the job results.
        """"""
        resp = self._http_client.get(f""/result/{job_id}"")
        resp.raise_for_status()
        return api_models.Response.model_validate(resp.json())


class AQTDirectAccessResource(_ResourceBase[AQTDirectAccessOptions]):
    """"""Qiskit backend for AQT direct-access quantum computing resources.

    Use
    :meth:`AQTProvider.get_direct_access_backend
    <qiskit_aqt_provider.aqt_provider.AQTProvider.get_direct_access_backend>`
    to retrieve backend instances.
    """"""

    def __init__(
        self,
        provider: ""AQTProvider"",
        base_url: str,
    ) -> None:
        """"""Initialize the backend.

        Args:
            provider: Qiskit provider that owns the backend.
            base_url: URL of the direct-access interface.
        """"""
        super().__init__(
            provider=provider,
            name=""direct-access"",
            options_type=AQTDirectAccessOptions,
        )

        self._http_client = api_models.http_client(base_url=base_url, token=provider.access_token)

    def run(
        self, circuits: Union[QuantumCircuit, list[QuantumCircuit]], **options: Any
    ) -> AQTDirectAccessJob:
        """"""Prepare circuits for execution on this resource.

        .. warning:: The circuits are only evaluated during
          the :meth:`AQTDirectAccessJob.result
          <qiskit_aqt_provider.aqt_job.AQTDirectAccessJob.result>`
          call.

        Args:
            circuits: circuits to execute
            options: overrides for this resource's options. Elements should be valid fields
              of the :class:`AQTOptions <qiskit_aqt_provider.aqt_options.AQTOptions>` model.
              Unknown fields are ignored with a :class:`UnknownOptionWarning`.

        Returns:
            A handle to the prepared job.
        """"""
        return self._create_job(AQTDirectAccessJob, circuits, **options)

    def submit(self, circuit: api_models.QuantumCircuit) -> UUID:
        """"""Submit a quantum circuit job to the AQT resource.

        Args:
            circuit: circuit to evaluate, in API format.

        Returns:
            The unique identifier of the submitted job.
        """"""
        resp = self._http_client.put(""/circuit"", json=circuit.model_dump())
        resp.raise_for_status()
        return UUID(resp.json())

    def result(self, job_id: UUID, *, timeout: Optional[float]) -> api_models_direct.JobResult:
        """"""Query the result of a specific job.

        Block until a result (success or error) is available.

        Args:
            job_id: unique identifier of the target job.
            timeout: query timeout, in seconds. Disabled if `None`.

        Returns:
            Job result, as API payload.
        """"""
        resp = self._http_client.get(f""/circuit/result/{job_id}"", timeout=timeout)
        resp.raise_for_status()
        return api_models_direct.JobResult.model_validate(resp.json())


def qubit_states_from_int(state: int, num_qubits: int) -> list[int]:
    """"""Convert the Qiskit state representation to the AQT states samples one.

    Args:
        state: Qiskit quantum register state representation
        num_qubits: number of qubits in the register.

    Returns:
        AQT qubit states representation.

    Raises:
        ValueError: the passed state is too large for the passed register size.

    Examples:
        >>> qubit_states_from_int(0, 3)
        [0, 0, 0]

        >>> qubit_states_from_int(0b11, 3)
        [1, 1, 0]

        >>> qubit_states_from_int(0b01, 3)
        [1, 0, 0]

        >>> qubit_states_from_int(123, 7)
        [1, 1, 0, 1, 1, 1, 1]

        >>> qubit_states_from_int(123, 3)  # doctest: +ELLIPSIS
        Traceback (most recent call last):
        ...
        ValueError: Cannot represent state=123 on num_qubits=3.
    """"""
    if state.bit_length() > num_qubits:
        raise ValueError(f""Cannot represent {state=} on {num_qubits=}."")
    return [(state >> qubit) & 1 for qubit in range(num_qubits)]


@dataclass(frozen=True)
class SimulatorJob:
    """"""Data for a job running on a local simulator.""""""

    job: AerJob
    """"""Simulation backend job handle.""""""

    circuits: list[QuantumCircuit]
    """"""Quantum circuits to evaluate.""""""

    shots: int
    """"""Number of repetitions of each circuit.""""""

    @property
    def job_id(self) -> UUID:
        """"""The job's unique identifier.""""""
        return UUID(hex=self.job.job_id())


class OfflineSimulatorResource(AQTResource):
    """"""AQT-compatible offline simulator resource.

    Offline simulators expose the same interface and restrictions as hardware backends. If
    `with_noise_model` is true, a noise model approximating that of AQT hardware backends is used.

    .. tip::
      The simulator backend is provided by
      `Qiskit Aer <https://qiskit.github.io/qiskit-aer/>`_.
      The Qiskit Aer resource is exposed for detailed detuning as the
      ``OfflineSimulatorResource.simulator`` attribute.
    """"""

    def __init__(
        self,
        provider: ""AQTProvider"",
        resource_id: api_models.ResourceId,
        with_noise_model: bool,
    ) -> None:
        """"""Initialize an offline simulator resource.

        Args:
            provider: Qiskit provider that owns this backend.
            resource_id: identification of the offline simulator resource.
            with_noise_model: whether to configure a noise model in the simulator backend.
        """"""
        assert resource_id.resource_type == ""offline_simulator""  # noqa: S101

        super().__init__(
            provider,
            resource_id=resource_id,
        )

        self.job: Optional[SimulatorJob] = None

        if not with_noise_model:
            noise_model = None
        else:
            # the transpiler lowers all operations to the gate set supported by the AQT API,
            # not to the resource target's one.
            noise_model = noise.NoiseModel(basis_gates=[""r"", ""rz"", ""rxx""])
            noise_model.add_all_qubit_quantum_error(noise.depolarizing_error(0.003, 1), [""r""])
            noise_model.add_all_qubit_quantum_error(noise.depolarizing_error(0.01, 2), [""rxx""])

        self.simulator = AerSimulator(method=""statevector"", noise_model=noise_model)

    @property
    def with_noise_model(self) -> bool:
        """"""Whether the simulator includes a noise model.""""""
        return self.simulator.options.noise_model is not None

    @override
    def submit(self, job: AQTJob) -> UUID:
        """"""Submit a job for execution on the simulator.

        .. tip:: This is a low-level method. Use the :meth:`AQTResource.run()` method
            to submit a job and retrieve a :class:`AQTJob <qiskit_aqt_provider.aqt_job.AQTJob>`
            handle.

        Args:
            job: quantum circuits job to submit to the simulator.

        Returns:
            Unique identifier of the simulator job.
        """"""
        # Use the API payload such that the memory map is the same as that
        # of the remote devices.
        circuits = [
            aqt_to_qiskit_circuit(circuit.quantum_circuit, circuit.number_of_qubits)
            for circuit in job.api_submit_payload.payload.circuits
        ]

        self.job = SimulatorJob(
            job=self.simulator.run(circuits, shots=job.options.shots),
            circuits=job.circuits,
            shots=job.options.shots,
        )
        return self.job.job_id

    @override
    def result(self, job_id: UUID) -> api_models.JobResponse:
        """"""Query results for a simulator job.

        .. tip:: This is a low-level method. Use
            :meth:`AQTJob.result() <qiskit_aqt_provider.aqt_job.AQTJob.result>` instead.

        Args:
            job_id: identifier of the job to retrieve results for.

        Returns:
            AQT API payload with the job results.

        Raises:
            UnknownJobError: ``job_id`` doesn't correspond to a simulator job on this resource.
        """"""
        if self.job is None or job_id != self.job.job_id:
            raise api_models.UnknownJobError(str(job_id))

        qiskit_result = self.job.job.result()

        results: dict[str, list[list[int]]] = {}
        for circuit_index, circuit in enumerate(self.job.circuits):
            samples: list[list[int]] = []

            # Use data()[""counts""] instead of get_counts() to access the raw counts
            # in hexadecimal format.
            counts: dict[str, int] = qiskit_result.data(circuit_index)[""counts""]

            for hex_state, occurrences in counts.items():
                samples.extend(
                    [
                        qubit_states_from_int(int(hex_state, 16), circuit.num_qubits)
                        for _ in range(occurrences)
                    ]
                )

            results[str(circuit_index)] = samples

        return api_models.Response.finished(
            job_id=job_id,
            workspace_id=self.resource_id.workspace_id,
            resource_id=self.resource_id.resource_id,
            results=results,
        )
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2019, Alpine Quantum Technologies GmbH 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.


from numpy import pi
from qiskit import QuantumCircuit
from typing_extensions import assert_never

from qiskit_aqt_provider import api_models, api_models_generated


def qiskit_to_aqt_circuit(circuit: QuantumCircuit) -> api_models.Circuit:
    """"""Convert a Qiskit `QuantumCircuit` into a payload for AQT's quantum_circuit job type.

    Args:
        circuit: Qiskit circuit to convert.

    Returns:
        AQT API circuit payload.
    """"""
    ops: list[api_models.OperationModel] = []
    num_measurements = 0

    for instruction in circuit.data:
        if instruction.operation.name != ""measure"" and num_measurements > 0:
            raise ValueError(
                ""Measurement operations can only be located at the end of the circuit.""
            )

        if instruction.operation.name == ""rz"":
            (phi,) = instruction.operation.params
            (qubit,) = instruction.qubits
            ops.append(
                api_models.Operation.rz(
                    phi=float(phi) / pi,
                    qubit=circuit.find_bit(qubit).index,
                )
            )
        elif instruction.operation.name == ""r"":
            theta, phi = instruction.operation.params
            (qubit,) = instruction.qubits
            ops.append(
                api_models.Operation.r(
                    phi=float(phi) / pi,
                    theta=float(theta) / pi,
                    qubit=circuit.find_bit(qubit).index,
                )
            )
        elif instruction.operation.name == ""rxx"":
            (theta,) = instruction.operation.params
            q0, q1 = instruction.qubits
            ops.append(
                api_models.Operation.rxx(
                    theta=float(theta) / pi,
                    qubits=[circuit.find_bit(q0).index, circuit.find_bit(q1).index],
                )
            )
        elif instruction.operation.name == ""measure"":
            num_measurements += 1
        elif instruction.operation.name == ""barrier"":
            continue
        else:
            raise ValueError(
                f""Operation '{instruction.operation.name}' not in basis gate set: {{rz, r, rxx}}""
            )

    if not num_measurements:
        raise ValueError(""Circuit must have at least one measurement operation."")

    ops.append(api_models.Operation.measure())
    return api_models.Circuit(root=ops)


def aqt_to_qiskit_circuit(circuit: api_models.Circuit, number_of_qubits: int) -> QuantumCircuit:
    """"""Convert an AQT API quantum circuit payload to an equivalent Qiskit representation.

    Args:
        circuit: payload to convert
        number_of_qubits: size of the quantum register to use for the converted circuit.

    Returns:
        A :class:`QuantumCircuit <qiskit.circuit.quantumcircuit.QuantumCircuit>` equivalent
        to the passed circuit payload.
    """"""
    qiskit_circuit = QuantumCircuit(number_of_qubits)

    for operation in circuit.root:
        if isinstance(operation.root, api_models_generated.GateRZ):
            qiskit_circuit.rz(operation.root.phi * pi, operation.root.qubit)
        elif isinstance(operation.root, api_models_generated.GateR):
            qiskit_circuit.r(
                operation.root.theta * pi,
                operation.root.phi * pi,
                operation.root.qubit,
            )
        elif isinstance(operation.root, api_models_generated.GateRXX):
            qiskit_circuit.rxx(
                operation.root.theta * pi, *[mod.root for mod in operation.root.qubits]
            )
        elif isinstance(operation.root, api_models_generated.Measure):
            qiskit_circuit.measure_all()
        else:
            assert_never(operation.root)  # pragma: no cover

    return qiskit_circuit


def circuits_to_aqt_job(circuits: list[QuantumCircuit], shots: int) -> api_models.SubmitJobRequest:
    """"""Convert a list of circuits to the corresponding AQT API job request payload.

    Args:
        circuits: circuits to execute
        shots: number of repetitions per circuit.

    Returns:
        JobSubmission: AQT API payload for submitting the quantum circuits job.
    """"""
    return api_models.SubmitJobRequest(
        job_type=""quantum_circuit"",
        label=""qiskit"",
        payload=api_models.QuantumCircuits(
            circuits=[
                api_models.QuantumCircuit(
                    repetitions=shots,
                    quantum_circuit=qiskit_to_aqt_circuit(circuit),
                    number_of_qubits=circuit.num_qubits,
                )
                for circuit in circuits
            ]
        ),
    )
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import base64
import io
import typing
from pathlib import Path
from typing import Any, Optional, Union

import platformdirs
import pydantic as pdt
from pydantic import ConfigDict, GetCoreSchemaHandler
from pydantic_core import CoreSchema, core_schema
from qiskit import qpy
from qiskit.circuit import QuantumCircuit
from typing_extensions import Self

from qiskit_aqt_provider.api_models import ResourceId
from qiskit_aqt_provider.aqt_options import AQTOptions
from qiskit_aqt_provider.utils import map_exceptions
from qiskit_aqt_provider.versions import QISKIT_AQT_PROVIDER_VERSION


class JobNotFoundError(Exception):
    """"""A job was not found in persistent storage.""""""


class Circuits:
    """"""Custom Pydantic type to persist and restore lists of Qiskit circuits.

    Serialization of :class:`QuantumCircuit <qiskit.circuit.QuantumCircuit>` instances is
    provided by :mod:`qiskit.qpy`.
    """"""

    def __init__(self, circuits: list[QuantumCircuit]) -> None:
        """"""Initialize a container filled with the given circuits.""""""
        self.circuits = circuits

    @classmethod
    def __get_pydantic_core_schema__(
        cls, source_type: Any, handler: GetCoreSchemaHandler
    ) -> CoreSchema:
        """"""Setup custom validator, to turn this class into a pydantic model.""""""
        return core_schema.no_info_plain_validator_function(function=cls.validate)

    @classmethod
    def validate(cls, value: Union[Self, str]) -> Self:
        """"""Parse the base64-encoded :mod:`qiskit.qpy` representation of a list of quantum circuits.

        Because initializing a Pydantic model also triggers validation, this parser accepts
        already formed instances of this class and returns them unvalidated.
        """"""
        if isinstance(value, Circuits):  # self bypass
            return typing.cast(Self, value)

        if not isinstance(value, str):
            raise ValueError(f""Expected string, received {type(value)}"")

        data = base64.b64decode(value.encode(""ascii""))
        buf = io.BytesIO(data)
        obj = qpy.load(buf)

        if not isinstance(obj, list):
            obj = [obj]

        for n, qc in enumerate(obj):
            if not isinstance(qc, QuantumCircuit):
                raise ValueError(f""Object at position {n} is not a QuantumCircuit: {type(qc)}"")

        return cls(circuits=obj)

    @classmethod
    def json_encoder(cls, value: Self) -> str:
        """"""Return a base64-encoded QPY representation of the held list of circuits.""""""
        buf = io.BytesIO()
        qpy.dump(value.circuits, buf)
        return base64.b64encode(buf.getvalue()).decode(""ascii"")


class Job(pdt.BaseModel):
    """"""Model for job persistence in local storage.""""""

    model_config = ConfigDict(frozen=True, json_encoders={Circuits: Circuits.json_encoder})

    resource: ResourceId
    circuits: Circuits
    options: AQTOptions

    @classmethod
    @map_exceptions(JobNotFoundError, source_exc=(FileNotFoundError,))
    def restore(cls, job_id: str, store_path: Path) -> Self:
        """"""Load data for a job by ID from local storage.

        Args:
            job_id: identifier of the job to restore.
            store_path: path to the local storage directory.

        Raises:
            JobNotFoundError: no job with the given identifier is stored in the local storage.
        """"""
        data = cls.filepath(job_id, store_path).read_text(""utf-8"")
        return cls.model_validate_json(data)

    def persist(self, job_id: str, store_path: Path) -> Path:
        """"""Persist the job data to the local storage.

        Args:
            job_id: storage key for this job data.
            store_path: path to the local storage directory.

        Returns:
            The path of the persisted data file.
        """"""
        filepath = self.filepath(job_id, store_path)
        filepath.write_text(self.model_dump_json(), ""utf-8"")
        return filepath

    @classmethod
    def remove_from_store(cls, job_id: str, store_path: Path) -> None:
        """"""Remove persisted job data from the local storage.

        This function also succeeds if there is no data under `job_id`.

        Args:
            job_id: storage key for the data to delete.
            store_path: path to the local storage directory.
        """"""
        cls.filepath(job_id, store_path).unlink(missing_ok=True)

    @classmethod
    def filepath(cls, job_id: str, store_path: Path) -> Path:
        """"""Path of the file to store data under a given key in local storage.

        Args:
            job_id: storage key for the data.
            store_path: path to the local storage directory.
        """"""
        return store_path / job_id


def get_store_path(override: Optional[Path] = None) -> Path:
    """"""Resolve the local persistence store path.

    By default, this is the user cache directory for this package.
    Different cache directories are used for different package versions.

    Args:
        override: if given, return this override instead of the default path.

    Returns:
       Path for the persistence store. Ensured to exist.
    """"""
    if override is not None:
        override.mkdir(parents=True, exist_ok=True)
        return override

    return Path(
        platformdirs.user_cache_dir(
            ""qiskit_aqt_provider"",
            version=QISKIT_AQT_PROVIDER_VERSION,
            ensure_exists=True,
        )
    )
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import math
from collections.abc import Sequence
from dataclasses import dataclass
from typing import Final, Optional

import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit import Gate, Instruction
from qiskit.circuit.library import RGate, RXGate, RXXGate, RZGate
from qiskit.circuit.tools import pi_check
from qiskit.dagcircuit import DAGCircuit
from qiskit.transpiler import Target
from qiskit.transpiler.basepasses import BasePass, TransformationPass
from qiskit.transpiler.exceptions import TranspilerError
from qiskit.transpiler.passes import Decompose, Optimize1qGatesDecomposition
from qiskit.transpiler.passmanager import PassManager
from qiskit.transpiler.passmanager_config import PassManagerConfig
from qiskit.transpiler.preset_passmanagers import common
from qiskit.transpiler.preset_passmanagers.plugin import PassManagerStagePlugin

from qiskit_aqt_provider.utils import map_exceptions


class UnboundParametersTarget(Target):
    """"""Marker class for transpilation targets to disable passes that require bound parameters.""""""


def bound_pass_manager(target: Target) -> PassManager:
    """"""Transpilation passes to apply on circuits after the parameters are bound.

    This assumes that a preset pass manager was applied to the unbound circuits
    (by setting the target to an instance of `UnboundParametersTarget`).

    Args:
        target: transpilation target.
    """"""
    return PassManager(
        [
            # wrap the Rxx angles
            WrapRxxAngles(),
            # decompose the substituted Rxx gates
            Decompose([f""{WrapRxxAngles.SUBSTITUTE_GATE_NAME}*""]),
            # collapse the single qubit runs as ZXZ
            Optimize1qGatesDecomposition(target=target),
            # wrap the Rx angles, rewrite as R
            RewriteRxAsR(),
        ]
    )


def rewrite_rx_as_r(theta: float) -> Instruction:
    """"""Instruction equivalent to Rx(θ) as R(θ, φ) with θ ∈ [0, π] and φ ∈ [0, 2π].""""""
    theta = math.atan2(math.sin(theta), math.cos(theta))
    phi = math.pi if theta < 0.0 else 0.0
    return RGate(abs(theta), phi)


class RewriteRxAsR(TransformationPass):
    """"""Rewrite Rx(θ) as R(θ, φ) with θ ∈ [0, π] and φ ∈ [0, 2π].""""""

    @map_exceptions(TranspilerError)
    def run(self, dag: DAGCircuit) -> DAGCircuit:
        """"""Apply the transformation pass.""""""
        for node in dag.gate_nodes():
            if node.name == ""rx"":
                (theta,) = node.op.params
                dag.substitute_node(node, rewrite_rx_as_r(float(theta)))
        return dag


class AQTSchedulingPlugin(PassManagerStagePlugin):
    """"""Scheduling stage plugin for the :mod:`qiskit.transpiler`.

    If the transpilation target is not :class:`UnboundParametersTarget`,
    register a :class:`RewriteRxAsR` pass irrespective of the optimization level.
    """"""

    def pass_manager(
        self,
        pass_manager_config: PassManagerConfig,
        optimization_level: Optional[int] = None,  # noqa: ARG002
    ) -> PassManager:
        """"""Pass manager for the scheduling phase.""""""
        if isinstance(pass_manager_config.target, UnboundParametersTarget):
            return PassManager([])

        passes: list[BasePass] = [
            # The Qiskit Target declares RX/RZ as basis gates.
            # This allows decomposing any run of rotations into the ZXZ form, taking
            # advantage of the free Z rotations.
            # Since the API expects R/RZ as single-qubit operations,
            # we rewrite all RX gates as R gates after optimizations have been performed.
            RewriteRxAsR(),
        ]

        return PassManager(passes)


@dataclass(frozen=True)
class CircuitInstruction:
    """"""Substitute for `qiskit.circuit.CircuitInstruction`.

    Contrary to its Qiskit counterpart, this type allows
    passing the qubits as integers.
    """"""

    gate: Gate
    qubits: tuple[int, ...]


def _rxx_positive_angle(theta: float) -> list[CircuitInstruction]:
    """"""List of instructions equivalent to RXX(θ) with θ >= 0.""""""
    rxx = CircuitInstruction(RXXGate(abs(theta)), qubits=(0, 1))

    if theta >= 0:
        return [rxx]

    return [
        CircuitInstruction(RZGate(math.pi), (0,)),
        rxx,
        CircuitInstruction(RZGate(math.pi), (0,)),
    ]


def _emit_rxx_instruction(theta: float, instructions: list[CircuitInstruction]) -> Instruction:
    """"""Collect the passed instructions into a single one labeled 'Rxx(θ)'.""""""
    qc = QuantumCircuit(2, name=f""{WrapRxxAngles.SUBSTITUTE_GATE_NAME}({pi_check(theta)})"")
    for instruction in instructions:
        qc.append(instruction.gate, instruction.qubits)

    return qc.to_instruction()


def wrap_rxx_angle(theta: float) -> Instruction:
    """"""Instruction equivalent to RXX(θ) with θ ∈ [0, π/2].""""""
    # fast path if -π/2 <= θ <= π/2
    if abs(theta) <= math.pi / 2:
        operations = _rxx_positive_angle(theta)
        return _emit_rxx_instruction(theta, operations)

    # exploit 2-pi periodicity of Rxx
    theta %= 2 * math.pi

    if abs(theta) <= math.pi / 2:
        operations = _rxx_positive_angle(theta)
    elif abs(theta) <= 3 * math.pi / 2:
        corrected_angle = theta - np.sign(theta) * math.pi
        operations = [
            CircuitInstruction(RXGate(math.pi), (0,)),
            CircuitInstruction(RXGate(math.pi), (1,)),
        ]
        operations.extend(_rxx_positive_angle(corrected_angle))
    else:
        corrected_angle = theta - np.sign(theta) * 2 * math.pi
        operations = _rxx_positive_angle(corrected_angle)

    return _emit_rxx_instruction(theta, operations)


class WrapRxxAngles(TransformationPass):
    """"""Wrap Rxx angles to [0, π/2].""""""

    SUBSTITUTE_GATE_NAME: Final = ""Rxx-wrapped""

    @map_exceptions(TranspilerError)
    def run(self, dag: DAGCircuit) -> DAGCircuit:
        """"""Apply the transformation pass.""""""
        for node in dag.gate_nodes():
            if node.name == ""rxx"":
                (theta,) = node.op.params

                if 0 <= float(theta) <= math.pi / 2:
                    continue

                rxx = wrap_rxx_angle(float(theta))
                dag.substitute_node(node, rxx)

        return dag


class AQTTranslationPlugin(PassManagerStagePlugin):
    """"""Translation stage plugin for the :mod:`qiskit.transpiler`.

    If the transpilation target is not :class:`UnboundParametersTarget`,
    register a :class:`WrapRxxAngles` pass after the preset pass irrespective
    of the optimization level.
    """"""

    def pass_manager(
        self,
        pass_manager_config: PassManagerConfig,
        optimization_level: Optional[int] = None,
    ) -> PassManager:
        """"""Pass manager for the translation stage.""""""
        translation_pm = common.generate_translation_passmanager(
            target=pass_manager_config.target,
            basis_gates=pass_manager_config.basis_gates,
            approximation_degree=pass_manager_config.approximation_degree,
            coupling_map=pass_manager_config.coupling_map,
            backend_props=pass_manager_config.backend_properties,
            unitary_synthesis_method=pass_manager_config.unitary_synthesis_method,
            unitary_synthesis_plugin_config=pass_manager_config.unitary_synthesis_plugin_config,
            hls_config=pass_manager_config.hls_config,
        )

        if isinstance(pass_manager_config.target, UnboundParametersTarget):
            return translation_pm

        passes: Sequence[BasePass] = [
            WrapRxxAngles(),
        ] + (
            [
                Decompose([f""{WrapRxxAngles.SUBSTITUTE_GATE_NAME}*""]),
            ]
            if optimization_level is None or optimization_level == 0
            else []
        )

        return translation_pm + PassManager(passes)
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

from copy import copy
from typing import Any, Optional

from qiskit.primitives import BackendSampler

from qiskit_aqt_provider import transpiler_plugin
from qiskit_aqt_provider.aqt_resource import AQTResource, make_transpiler_target


class AQTSampler(BackendSampler):
    """""":class:`BaseSamplerV1 <qiskit.primitives.BaseSamplerV1>` primitive for AQT backends.""""""

    _backend: AQTResource

    def __init__(
        self,
        backend: AQTResource,
        options: Optional[dict[str, Any]] = None,
        skip_transpilation: bool = False,
    ) -> None:
        """"""Initialize a ``Sampler`` primitive using an AQT backend.

        Args:
            backend: AQT resource to evaluate circuits on.
            options: options passed through to the underlying
              :class:`BackendSampler <qiskit.primitives.BackendSampler>`.
            skip_transpilation: if :data:`True`, do not transpile circuits
              before passing them to the execution backend.

        Examples:
            Initialize a :class:`Sampler <qiskit.primitives.BaseSamplerV1>` primitive
            on a AQT offline simulator:

            >>> import qiskit
            >>> from qiskit_aqt_provider import AQTProvider
            >>> from qiskit_aqt_provider.primitives import AQTSampler
            >>>
            >>> backend = AQTProvider("""").get_backend(""offline_simulator_no_noise"")
            >>> sampler = AQTSampler(backend)

            Configuring :class:`options <qiskit_aqt_provider.aqt_options.AQTOptions>`
            on the backend will affect all circuit evaluations triggered by
            the `Sampler` primitive:

            >>> qc = qiskit.QuantumCircuit(2)
            >>> _ = qc.cx(0, 1)
            >>> _ = qc.measure_all()
            >>>
            >>> sampler.run(qc).result().metadata[0][""shots""]
            100
            >>> backend.options.shots = 123
            >>> sampler.run(qc).result().metadata[0][""shots""]
            123

            The same effect is achieved by passing options to the
            :class:`AQTSampler` initializer:

            >>> sampler = AQTSampler(backend, options={""shots"": 120})
            >>> sampler.run(qc).result().metadata[0][""shots""]
            120

            Passing the option in the
            :meth:`AQTSampler.run <qiskit.primitives.BaseSamplerV1.run>` call
            restricts the effect to a single evaluation:

            >>> sampler.run(qc, shots=130).result().metadata[0][""shots""]
            130
            >>> sampler.run(qc).result().metadata[0][""shots""]
            120
        """"""
        # Signal the transpiler to disable passes that require bound
        # parameters.
        # This allows the underlying sampler to apply most of
        # the transpilation passes, and cache the results.
        mod_backend = copy(backend)
        mod_backend._target = make_transpiler_target(
            transpiler_plugin.UnboundParametersTarget, backend.num_qubits
        )

        # if `with_progress_bar` is not explicitly set in the options, disable it
        options_copy = (options or {}).copy()
        options_copy.update(with_progress_bar=options_copy.get(""with_progress_bar"", False))

        super().__init__(
            mod_backend,
            bound_pass_manager=transpiler_plugin.bound_pass_manager(mod_backend.target),
            options=options_copy,
            skip_transpilation=skip_transpilation,
        )

    @property
    def backend(self) -> AQTResource:
        """"""Computing resource used for circuit evaluation.""""""
        return self._backend
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Test helpers for quantum circuits.""""""

import math

import qiskit.circuit.random
from qiskit import QuantumCircuit
from qiskit.quantum_info.operators import Operator


def assert_circuits_equal(result: QuantumCircuit, expected: QuantumCircuit) -> None:
    """"""Assert result == expected, pretty-printing the circuits if they don't match.""""""
    msg = f""\nexpected:\n{expected}\nresult:\n{result}""
    assert result == expected, msg  # noqa: S101


def assert_circuits_equal_ignore_global_phase(
    result: QuantumCircuit, expected: QuantumCircuit
) -> None:
    """"""Assert result == expected, ignoring the value of the global phase.""""""
    result_copy = result.copy()
    result_copy.global_phase = 0.0
    expected_copy = expected.copy()
    expected_copy.global_phase = 0.0

    assert_circuits_equal(result_copy, expected_copy)


def assert_circuits_equivalent(result: QuantumCircuit, expected: QuantumCircuit) -> None:
    """"""Assert that the passed circuits are equivalent up to a global phase.""""""
    msg = f""\nexpected:\n{expected}\nresult:\n{result}""
    assert Operator(expected).equiv(Operator(result)), msg  # noqa: S101


def empty_circuit(num_qubits: int, with_final_measurement: bool = True) -> QuantumCircuit:
    """"""An empty circuit, with the given number of qubits.""""""
    qc = QuantumCircuit(num_qubits)

    if with_final_measurement:
        qc.measure_all()

    return qc


def random_circuit(
    num_qubits: int, *, seed: int = 1234, with_final_measurement: bool = True
) -> QuantumCircuit:
    """"""A random circuit, with depth equal to the number of qubits.""""""
    qc = qiskit.circuit.random.random_circuit(
        num_qubits,
        num_qubits,
        seed=seed,
    )

    if with_final_measurement:
        qc.measure_all()

    return qc


def qft_circuit(num_qubits: int) -> QuantumCircuit:
    """"""N-qubits quantum Fourier transform.

    Source: Nielsen & Chuang, Quantum Computation and Quantum Information.
    """"""
    qc = QuantumCircuit(num_qubits)
    for qubit in range(num_qubits - 1, -1, -1):
        qc.h(qubit)
        for k in range(1, qubit + 1):
            qc.cp(math.pi / 2**k, qubit - k, qubit)

    for qubit in range(num_qubits // 2):
        qc.swap(qubit, (num_qubits - 1) - qubit)

    return qc
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Dummy resources for testing purposes.""""""

import enum
import random
import time
import uuid
from dataclasses import dataclass, field
from typing import Optional

from qiskit import QuantumCircuit
from typing_extensions import assert_never, override

from qiskit_aqt_provider import api_models
from qiskit_aqt_provider.aqt_job import AQTJob
from qiskit_aqt_provider.aqt_provider import AQTProvider
from qiskit_aqt_provider.aqt_resource import AQTDirectAccessResource, AQTResource


class JobStatus(enum.Enum):
    """"""AQT job lifecycle labels.""""""

    QUEUED = enum.auto()
    ONGOING = enum.auto()
    FINISHED = enum.auto()
    ERROR = enum.auto()
    CANCELLED = enum.auto()


@dataclass
class TestJob:  # pylint: disable=too-many-instance-attributes
    """"""Job state holder for the TestResource.""""""

    circuits: list[QuantumCircuit]
    shots: int
    status: JobStatus = JobStatus.QUEUED
    job_id: uuid.UUID = field(default_factory=lambda: uuid.uuid4())
    time_queued: float = field(default_factory=time.time)
    time_submitted: float = 0.0
    time_finished: float = 0.0
    error_message: str = ""error""

    results: dict[str, list[list[int]]] = field(init=False)

    workspace: str = field(default=""test-workspace"", init=False)
    resource: str = field(default=""test-resource"", init=False)

    def __post_init__(self) -> None:
        """"""Calculate derived quantities.""""""
        self.results = {
            str(circuit_index): [
                random.choices([0, 1], k=circuit.num_clbits) for _ in range(self.shots)
            ]
            for circuit_index, circuit in enumerate(self.circuits)
        }

    def submit(self) -> None:
        """"""Submit the job for execution.""""""
        self.time_submitted = time.time()
        self.status = JobStatus.ONGOING

    def finish(self) -> None:
        """"""The job execution finished successfully.""""""
        self.time_finished = time.time()
        self.status = JobStatus.FINISHED

    def error(self) -> None:
        """"""The job execution triggered an error.""""""
        self.time_finished = time.time()
        self.status = JobStatus.ERROR

    def cancel(self) -> None:
        """"""The job execution was cancelled.""""""
        self.time_finished = time.time()
        self.status = JobStatus.CANCELLED

    def response_payload(self) -> api_models.JobResponse:
        """"""AQT API-compatible response for the current job status.""""""
        if self.status is JobStatus.QUEUED:
            return api_models.Response.queued(
                job_id=self.job_id,
                workspace_id=self.workspace,
                resource_id=self.resource,
            )

        if self.status is JobStatus.ONGOING:
            return api_models.Response.ongoing(
                job_id=self.job_id,
                workspace_id=self.workspace,
                resource_id=self.resource,
                finished_count=1,
            )

        if self.status is JobStatus.FINISHED:
            return api_models.Response.finished(
                job_id=self.job_id,
                workspace_id=self.workspace,
                resource_id=self.resource,
                results=self.results,
            )

        if self.status is JobStatus.ERROR:
            return api_models.Response.error(
                job_id=self.job_id,
                workspace_id=self.workspace,
                resource_id=self.resource,
                message=self.error_message,
            )

        if self.status is JobStatus.CANCELLED:
            return api_models.Response.cancelled(
                job_id=self.job_id, workspace_id=self.workspace, resource_id=self.resource
            )

        assert_never(self.status)  # pragma: no cover


class TestResource(AQTResource):  # pylint: disable=too-many-instance-attributes
    """"""AQT computing resource with hooks for triggering different execution scenarios.""""""

    __test__ = False  # disable pytest collection

    def __init__(  # noqa: PLR0913
        self,
        *,
        min_queued_duration: float = 0.0,
        min_running_duration: float = 0.0,
        always_cancel: bool = False,
        always_error: bool = False,
        error_message: str = """",
    ) -> None:
        """"""Initialize the testing resource.

        Args:
            min_queued_duration: minimum time in seconds spent by all jobs in the QUEUED state
            min_running_duration: minimum time in seconds spent by all jobs in the ONGOING state
            always_cancel: always cancel the jobs directly after submission
            always_error: always finish execution with an error
            error_message: the error message returned by failed jobs. Implies `always_error`.
        """"""
        super().__init__(
            AQTProvider(""""),
            resource_id=api_models.ResourceId(
                workspace_id=""test-workspace"",
                resource_id=""test"",
                resource_name=""test-resource"",
                resource_type=""simulator"",
            ),
        )

        self.job: Optional[TestJob] = None

        self.min_queued_duration = min_queued_duration
        self.min_running_duration = min_running_duration
        self.always_cancel = always_cancel
        self.always_error = always_error or error_message
        self.error_message = error_message or str(uuid.uuid4())

    @override
    def submit(self, job: AQTJob) -> uuid.UUID:
        """"""Handle an execution request for a given job.

        If the backend always cancels job, the job is immediately cancelled.
        Otherwise, register the passed job as the active one on the backend.
        """"""
        test_job = TestJob(job.circuits, job.options.shots, error_message=self.error_message)

        if self.always_cancel:
            test_job.cancel()

        self.job = test_job
        return test_job.job_id

    @override
    def result(self, job_id: uuid.UUID) -> api_models.JobResponse:
        """"""Handle a results request for a given job.

        Apply the logic configured when initializing the backend to
        build an API result payload.

        Raises:
            UnknownJobError: the given job ID doesn't correspond to the active job's ID.
        """"""
        if self.job is None or self.job.job_id != job_id:  # pragma: no cover
            raise api_models.UnknownJobError(str(job_id))

        now = time.time()

        if (
            self.job.status is JobStatus.QUEUED
            and (now - self.job.time_queued) > self.min_queued_duration
        ):
            self.job.submit()

        if (
            self.job.status is JobStatus.ONGOING
            and (now - self.job.time_submitted) > self.min_running_duration
        ):
            if self.always_error:
                self.job.error()
            else:
                self.job.finish()

        return self.job.response_payload()


class DummyResource(AQTResource):
    """"""A non-functional resource, for testing purposes.""""""

    def __init__(self, token: str) -> None:
        """"""Initialize the dummy backend.""""""
        super().__init__(
            AQTProvider(token),
            resource_id=api_models.ResourceId(
                workspace_id=""dummy"",
                resource_id=""dummy"",
                resource_name=""dummy"",
                resource_type=""simulator"",
            ),
        )


class DummyDirectAccessResource(AQTDirectAccessResource):
    """"""A non-functional direct-access resource, for testing purposes.""""""

    def __init__(self, token: str) -> None:
        """"""Initialize the dummy backend.""""""
        super().__init__(
            AQTProvider(token),
            base_url=""direct-access-example.aqt.eu:6020"",
        )
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2019, Alpine Quantum Technologies 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.


from math import pi

import pytest
import qiskit
from pydantic import ValidationError
from qiskit import QuantumCircuit

from qiskit_aqt_provider import api_models
from qiskit_aqt_provider.aqt_resource import AQTResource
from qiskit_aqt_provider.circuit_to_aqt import (
    aqt_to_qiskit_circuit,
    circuits_to_aqt_job,
    qiskit_to_aqt_circuit,
)
from qiskit_aqt_provider.test.circuits import (
    assert_circuits_equal_ignore_global_phase,
    assert_circuits_equivalent,
    empty_circuit,
    qft_circuit,
    random_circuit,
)


def test_no_circuit() -> None:
    """"""Cannot convert an empty list of circuits to an AQT job request.""""""
    with pytest.raises(ValidationError):
        circuits_to_aqt_job([], shots=1)


def test_empty_circuit() -> None:
    """"""Circuits need at least one measurement operation.""""""
    qc = QuantumCircuit(1)
    with pytest.raises(ValueError):
        circuits_to_aqt_job([qc], shots=1)


def test_just_measure_circuit() -> None:
    """"""Circuits with only measurement operations are valid.""""""
    shots = 100

    qc = QuantumCircuit(1)
    qc.measure_all()

    expected = api_models.SubmitJobRequest(
        job_type=""quantum_circuit"",
        label=""qiskit"",
        payload=api_models.QuantumCircuits(
            circuits=[
                api_models.QuantumCircuit(
                    repetitions=shots,
                    number_of_qubits=1,
                    quantum_circuit=api_models.Circuit(root=[api_models.Operation.measure()]),
                ),
            ]
        ),
    )

    result = circuits_to_aqt_job([qc], shots=shots)

    assert result == expected


def test_valid_circuit() -> None:
    """"""A valid circuit with all supported basis gates.""""""
    qc = QuantumCircuit(2)
    qc.r(pi / 2, 0, 0)
    qc.rz(pi / 5, 1)
    qc.rxx(pi / 2, 0, 1)
    qc.measure_all()

    result = circuits_to_aqt_job([qc], shots=1)

    expected = api_models.SubmitJobRequest(
        job_type=""quantum_circuit"",
        label=""qiskit"",
        payload=api_models.QuantumCircuits(
            circuits=[
                api_models.QuantumCircuit(
                    number_of_qubits=2,
                    repetitions=1,
                    quantum_circuit=api_models.Circuit(
                        root=[
                            api_models.Operation.r(theta=0.5, phi=0.0, qubit=0),
                            api_models.Operation.rz(phi=0.2, qubit=1),
                            api_models.Operation.rxx(theta=0.5, qubits=[0, 1]),
                            api_models.Operation.measure(),
                        ]
                    ),
                ),
            ]
        ),
    )

    assert result == expected


def test_invalid_gates_in_circuit() -> None:
    """"""Circuits must already be in the target basis when they are converted
    to the AQT wire format.
    """"""
    qc = QuantumCircuit(1)
    qc.h(0)  # not an AQT-resource basis gate
    qc.measure_all()

    with pytest.raises(ValueError, match=""not in basis gate set""):
        circuits_to_aqt_job([qc], shots=1)


def test_invalid_measurements() -> None:
    """"""Measurement operations can only be located at the end of the circuit.""""""
    qc_invalid = QuantumCircuit(2, 2)
    qc_invalid.r(pi / 2, 0.0, 0)
    qc_invalid.measure([0], [0])
    qc_invalid.r(pi / 2, 0.0, 1)
    qc_invalid.measure([1], [1])

    with pytest.raises(ValueError, match=""at the end of the circuit""):
        circuits_to_aqt_job([qc_invalid], shots=1)

    # same circuit as above, but with the measurements at the end is valid
    qc = QuantumCircuit(2, 2)
    qc.r(pi / 2, 0.0, 0)
    qc.r(pi / 2, 0.0, 1)
    qc.measure([0], [0])
    qc.measure([1], [1])

    result = circuits_to_aqt_job([qc], shots=1)
    expected = api_models.SubmitJobRequest(
        job_type=""quantum_circuit"",
        label=""qiskit"",
        payload=api_models.QuantumCircuits(
            circuits=[
                api_models.QuantumCircuit(
                    number_of_qubits=2,
                    repetitions=1,
                    quantum_circuit=api_models.Circuit(
                        root=[
                            api_models.Operation.r(theta=0.5, phi=0.0, qubit=0),
                            api_models.Operation.r(theta=0.5, phi=0.0, qubit=1),
                            api_models.Operation.measure(),
                        ]
                    ),
                ),
            ]
        ),
    )

    assert result == expected


def test_convert_multiple_circuits() -> None:
    """"""Convert multiple circuits. Check that the order is conserved.""""""
    qc0 = QuantumCircuit(2)
    qc0.r(pi / 2, 0.0, 0)
    qc0.rxx(pi / 2, 0, 1)
    qc0.measure_all()

    qc1 = QuantumCircuit(1)
    qc1.r(pi / 4, 0.0, 0)
    qc1.measure_all()

    result = circuits_to_aqt_job([qc0, qc1], shots=1)

    expected = api_models.SubmitJobRequest(
        job_type=""quantum_circuit"",
        label=""qiskit"",
        payload=api_models.QuantumCircuits(
            circuits=[
                api_models.QuantumCircuit(
                    number_of_qubits=2,
                    repetitions=1,
                    quantum_circuit=api_models.Circuit(
                        root=[
                            api_models.Operation.r(theta=0.5, phi=0.0, qubit=0),
                            api_models.Operation.rxx(theta=0.5, qubits=[0, 1]),
                            api_models.Operation.measure(),
                        ]
                    ),
                ),
                api_models.QuantumCircuit(
                    number_of_qubits=1,
                    repetitions=1,
                    quantum_circuit=api_models.Circuit(
                        root=[
                            api_models.Operation.r(theta=0.25, phi=0.0, qubit=0),
                            api_models.Operation.measure(),
                        ]
                    ),
                ),
            ],
        ),
    )

    assert result == expected


@pytest.mark.parametrize(
    ""circuit"",
    [
        pytest.param(empty_circuit(2, with_final_measurement=False), id=""empty-2""),
        pytest.param(random_circuit(2, with_final_measurement=False), id=""random-2""),
        pytest.param(random_circuit(3, with_final_measurement=False), id=""random-3""),
        pytest.param(random_circuit(5, with_final_measurement=False), id=""random-5""),
        pytest.param(qft_circuit(5), id=""qft-5""),
    ],
)
def test_convert_circuit_round_trip(
    circuit: QuantumCircuit, offline_simulator_no_noise: AQTResource
) -> None:
    """"""Check that transpiled qiskit circuits can be round-tripped through the API format.""""""
    trans_qc = qiskit.transpile(circuit, offline_simulator_no_noise)
    # There's no measurement in the circuit, so unitary operator equality
    # can be used to check the transpilation result.
    assert_circuits_equivalent(trans_qc, circuit)

    # Add the measurement operation to allow conversion to the AQT API format.
    trans_qc.measure_all()

    aqt_circuit = qiskit_to_aqt_circuit(trans_qc)
    trans_qc_back = aqt_to_qiskit_circuit(aqt_circuit, trans_qc.num_qubits)

    # transpiled circuits can be exactly reconstructed, up to the global
    # phase which is irrelevant for execution
    assert_circuits_equal_ignore_global_phase(trans_qc_back, trans_qc)
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Run various circuits on an offline simulator controlled by an AQTResource.

This tests whether the circuit pre-conditioning and results formatting works as
expected.
""""""

import re
import typing
from collections import Counter
from math import pi
from typing import Union

import pytest
import qiskit
from qiskit import ClassicalRegister, QiskitError, QuantumCircuit, QuantumRegister, quantum_info
from qiskit.providers import BackendV2
from qiskit.providers.jobstatus import JobStatus
from qiskit.transpiler import TranspilerError
from qiskit_aer import AerProvider, AerSimulator

from qiskit_aqt_provider import AQTProvider
from qiskit_aqt_provider.aqt_resource import AQTResource
from qiskit_aqt_provider.test.circuits import assert_circuits_equivalent
from qiskit_aqt_provider.test.fixtures import MockSimulator
from qiskit_aqt_provider.test.resources import TestResource
from qiskit_aqt_provider.test.timeout import timeout


@pytest.mark.parametrize(""shots"", [200])
def test_empty_circuit(shots: int, any_offline_simulator_no_noise: BackendV2) -> None:
    """"""Run an empty circuit.""""""
    qc = QuantumCircuit(1)
    qc.measure_all()

    job = any_offline_simulator_no_noise.run(qc, shots=shots)
    assert job.result().get_counts() == {""0"": shots}


def test_circuit_success_lifecycle() -> None:
    """"""Go through the lifecycle of a successful single-circuit job.
    Check that the job status visits the states QUEUED, RUNNING, and DONE.
    """"""
    backend = TestResource(min_queued_duration=0.5, min_running_duration=0.5)
    backend.options.update_options(query_period_seconds=0.1)

    qc = QuantumCircuit(1)
    qc.measure_all()

    job = backend.run(qc)

    assert job.status() is JobStatus.QUEUED

    with timeout(2.0):
        while job.status() is JobStatus.QUEUED:
            continue

    assert job.status() is JobStatus.RUNNING

    with timeout(2.0):
        while job.status() is JobStatus.RUNNING:
            continue

    assert job.status() is JobStatus.DONE


def test_error_circuit() -> None:
    """"""Check that errors in circuits are reported in the `errors` field of the Qiskit
    result metadata, where the keys are the circuit job ids.
    """"""
    backend = TestResource(always_error=True)
    backend.options.update_options(query_period_seconds=0.1)

    qc = QuantumCircuit(1)
    qc.measure_all()

    result = backend.run(qc).result()
    assert result.success is False
    assert backend.error_message == result._metadata[""error""]


def test_cancelled_circuit() -> None:
    """"""Check that cancelled jobs return success = false.""""""
    backend = TestResource(always_cancel=True)

    qc = QuantumCircuit(1)
    qc.measure_all()

    result = backend.run(qc).result()
    assert result.success is False


@pytest.mark.parametrize(""shots"", [1, 100, 200])
def test_simple_backend_run(shots: int, any_offline_simulator_no_noise: BackendV2) -> None:
    """"""Run a simple circuit with `backend.run`.""""""
    qc = QuantumCircuit(1)
    qc.rx(pi, 0)
    qc.measure_all()

    trans_qc = qiskit.transpile(qc, any_offline_simulator_no_noise)
    job = any_offline_simulator_no_noise.run(trans_qc, shots=shots)

    assert job.result().get_counts() == {""1"": shots}


@pytest.mark.parametrize(""resource"", [MockSimulator(noisy=False), MockSimulator(noisy=True)])
def test_simple_backend_execute_noisy(resource: MockSimulator) -> None:
    """"""Execute a simple circuit on a noisy and noiseless backend. Check that the noisy backend
    is indeed noisy.
    """"""
    qc = QuantumCircuit(1)
    qc.rx(pi, 0)
    qc.measure_all()

    # the single qubit error is around 0.1% so to see at least one error, we need to do more than
    # 1000 shots.
    total_shots = 4000  # take some margin
    shots = 200  # maximum shots per submission
    assert total_shots % shots == 0

    counts: typing.Counter[str] = Counter()
    for _ in range(total_shots // shots):
        job = resource.run(qiskit.transpile(qc, backend=resource), shots=shots)
        counts += Counter(job.result().get_counts())

    assert sum(counts.values()) == total_shots

    if resource.with_noise_model:
        assert set(counts.keys()) == {""0"", ""1""}
        assert counts[""0""] < 0.1 * counts[""1""]  # very crude
    else:
        assert set(counts.keys()) == {""1""}


@pytest.mark.parametrize(""shots"", [100])
def test_ancilla_qubits_mapping(shots: int, any_offline_simulator_no_noise: BackendV2) -> None:
    """"""Run a circuit with two quantum registers, with only one mapped to the classical memory.""""""
    qr = QuantumRegister(2)
    qr_aux = QuantumRegister(3)
    memory = ClassicalRegister(2)

    qc = QuantumCircuit(qr, qr_aux, memory)
    qc.rx(pi, qr[0])
    qc.ry(pi, qr[1])
    qc.rxx(pi / 2, qr_aux[0], qr_aux[1])
    qc.measure(qr, memory)

    trans_qc = qiskit.transpile(qc, any_offline_simulator_no_noise)
    job = any_offline_simulator_no_noise.run(trans_qc, shots=shots)
    # only two bits in the counts dict because memory has two bits width
    assert job.result().get_counts() == {""11"": shots}


@pytest.mark.parametrize(""shots"", [100])
def test_multiple_classical_registers(
    shots: int, any_offline_simulator_no_noise: BackendV2
) -> None:
    """"""Run a circuit with the final state mapped to multiple classical registers.""""""
    qr = QuantumRegister(5)
    memory_a = ClassicalRegister(2)
    memory_b = ClassicalRegister(3)

    qc = QuantumCircuit(qr, memory_a, memory_b)
    qc.rx(pi, qr[0])
    qc.rx(pi, qr[3])
    qc.measure(qr[:2], memory_a)
    qc.measure(qr[2:], memory_b)

    trans_qc = qiskit.transpile(qc, any_offline_simulator_no_noise)
    job = any_offline_simulator_no_noise.run(trans_qc, shots=shots)

    # counts are returned as ""memory_b memory_a"", msb first
    assert job.result().get_counts() == {""010 01"": shots}


@pytest.mark.parametrize(""shots"", [123])
@pytest.mark.parametrize(""memory_opt"", [True, False])
def test_get_memory_simple(
    shots: int, memory_opt: bool, any_offline_simulator_no_noise: BackendV2
) -> None:
    """"""Check that the raw bitstrings can be accessed for each shot via the
    get_memory() method in Qiskit's Result.

    The memory is only accessible if the `memory` option is set.
    """"""
    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    result = any_offline_simulator_no_noise.run(
        qiskit.transpile(qc, any_offline_simulator_no_noise), shots=shots, memory=memory_opt
    ).result()

    if memory_opt:
        memory = result.get_memory()

        assert set(memory) == {""11"", ""00""}
        assert len(memory) == shots
    else:
        with pytest.raises(QiskitError, match=re.compile(""no memory"", re.IGNORECASE)):
            result.get_memory()


@pytest.mark.parametrize(""shots"", [123])
def test_get_memory_ancilla_qubits(shots: int, any_offline_simulator_no_noise: BackendV2) -> None:
    """"""Check that the raw bistrings returned by get_memory() in Qiskit's Result only
    contain the mapped classical bits.
    """"""
    qr = QuantumRegister(2)
    qr_aux = QuantumRegister(3)
    memory = ClassicalRegister(2)

    qc = QuantumCircuit(qr, qr_aux, memory)
    qc.rx(pi, qr[0])
    qc.ry(pi, qr[1])
    qc.rxx(pi / 2, qr_aux[0], qr_aux[1])
    qc.measure(qr, memory)

    job = any_offline_simulator_no_noise.run(
        qiskit.transpile(qc, any_offline_simulator_no_noise), shots=shots, memory=True
    )
    memory = job.result().get_memory()

    assert set(memory) == {""11""}
    assert len(memory) == shots


@pytest.mark.parametrize(""shots"", [123])
def test_get_memory_bit_ordering(shots: int, any_offline_simulator_no_noise: BackendV2) -> None:
    """"""Check that the bitstrings returned by the results produced by AQT jobs have the same
    bit order as the Qiskit Aer simulators.
    """"""
    sim = AerSimulator(method=""statevector"")

    qc = QuantumCircuit(3)
    qc.rx(pi, 0)
    qc.rx(pi, 1)
    qc.measure_all()

    aqt_memory = (
        any_offline_simulator_no_noise.run(
            qiskit.transpile(qc, any_offline_simulator_no_noise), shots=shots, memory=True
        )
        .result()
        .get_memory()
    )
    sim_memory = sim.run(qiskit.transpile(qc, sim), shots=shots, memory=True).result().get_memory()

    assert set(sim_memory) == set(aqt_memory)

    # sanity check: bitstrings are no palindromes
    assert not any(bitstring == bitstring[::-1] for bitstring in sim_memory)


@pytest.mark.parametrize(
    ""backend"",
    [
        pytest.param(
            AQTProvider(""token"").get_backend(""offline_simulator_no_noise""), id=""offline-simulator""
        ),
        pytest.param(AerProvider().get_backend(""aer_simulator""), id=""aer-simulator""),
    ],
)
def test_regression_issue_85(backend: BackendV2) -> None:
    """"""Check that qubit and clbit permutations are properly handled by the offline simulators.

    This is a regression test for #85. Check that executing circuits with qubit/clbit
    permutations outputs the same bitstrings on noiseless offline simulators from this
    package and straight from Aer.
    """"""
    empty_3 = QuantumCircuit(3)
    base = QuantumCircuit(3)
    base.h(0)
    base.cx(0, 2)
    base.measure_all()

    perm_qubits = empty_3.compose(base, qubits=[0, 2, 1])
    perm_all = empty_3.compose(base, qubits=[0, 2, 1], clbits=[0, 2, 1])

    base_bitstrings = set(backend.run(qiskit.transpile(base, backend)).result().get_counts())
    assert base_bitstrings == {""000"", ""101""}

    perm_qubits_bitstrings = set(
        backend.run(qiskit.transpile(perm_qubits, backend)).result().get_counts()
    )
    assert perm_qubits_bitstrings == {""000"", ""101""}

    perm_all_bitstrings = set(
        backend.run(qiskit.transpile(perm_all, backend)).result().get_counts()
    )
    assert perm_all_bitstrings == {""000"", ""011""}


@pytest.mark.parametrize((""shots"", ""qubits""), [(100, 5), (100, 8)])
def test_bell_states(shots: int, qubits: int, any_offline_simulator_no_noise: BackendV2) -> None:
    """"""Create a N qubits Bell state.""""""
    qc = QuantumCircuit(qubits)
    qc.h(0)
    for qubit in range(1, qubits):
        qc.cx(0, qubit)
    qc.measure_all()

    job = any_offline_simulator_no_noise.run(
        qiskit.transpile(qc, any_offline_simulator_no_noise), shots=shots
    )
    counts = job.result().get_counts()

    assert set(counts.keys()) == {""0"" * qubits, ""1"" * qubits}
    assert sum(counts.values()) == shots


@pytest.mark.parametrize(
    ""target_state"",
    [
        quantum_info.Statevector.from_label(""01""),
        ""01"",
        1,
        [0, 1, 0, 0],
    ],
)
@pytest.mark.parametrize(""optimization_level"", range(4))
def test_state_preparation(
    target_state: Union[int, str, quantum_info.Statevector, list[complex]],
    optimization_level: int,
    any_offline_simulator_no_noise: BackendV2,
) -> None:
    """"""Test the state preparation unitary factory.

    Prepare the state |01> using the different formats accepted by
    `QuantumCircuit.prepare_state`.
    """"""
    qc = QuantumCircuit(2)
    qc.prepare_state(target_state)
    qc.measure_all()

    shots = 100
    job = any_offline_simulator_no_noise.run(
        qiskit.transpile(qc, any_offline_simulator_no_noise, optimization_level=optimization_level),
        shots=shots,
    )
    counts = job.result().get_counts()

    assert counts == {""01"": shots}


@pytest.mark.parametrize(""optimization_level"", range(4))
def test_state_preparation_single_qubit(
    optimization_level: int, any_offline_simulator_no_noise: BackendV2
) -> None:
    """"""Test the state preparation unitary factory, targeting a single qubit in the register.""""""
    qreg = QuantumRegister(4)
    qc = QuantumCircuit(qreg)
    qc.prepare_state(1, qreg[2])
    qc.measure_all()

    shots = 100
    job = any_offline_simulator_no_noise.run(
        qiskit.transpile(qc, any_offline_simulator_no_noise, optimization_level=optimization_level),
        shots=shots,
    )
    counts = job.result().get_counts()

    assert counts == {""0100"": shots}


def test_initialize_not_supported(offline_simulator_no_noise: AQTResource) -> None:
    """"""Verify that `QuantumCircuit.initialize` is not supported.

    #112 adds a note to the user guide indicating that `QuantumCircuit.initialize`
    is not supported. Remove the note if this test fails.
    """"""
    qc = QuantumCircuit(2)
    qc.x(0)
    qc.initialize(""01"")
    qc.measure_all()

    with pytest.raises(
        TranspilerError,
        match=re.compile(
            r""high\s?level\s?synthesis was unable to synthesize instruction"", re.IGNORECASE
        ),
    ):
        qiskit.transpile(qc, offline_simulator_no_noise)


@pytest.mark.parametrize(""optimization_level"", range(4))
def test_cswap(optimization_level: int, any_offline_simulator_no_noise: BackendV2) -> None:
    """"""Verify that CSWAP (Fredkin) gates can be transpiled and executed (in a trivial case).""""""
    qc = QuantumCircuit(3)
    qc.prepare_state(""101"")
    qc.cswap(0, 1, 2)

    trans_qc = qiskit.transpile(
        qc, any_offline_simulator_no_noise, optimization_level=optimization_level
    )
    assert_circuits_equivalent(qc, trans_qc)

    qc.measure_all()
    shots = 200
    job = any_offline_simulator_no_noise.run(
        qiskit.transpile(qc, any_offline_simulator_no_noise, optimization_level=optimization_level),
        shots=shots,
    )
    counts = job.result().get_counts()

    assert counts == {""011"": shots}
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import json
import os
import re
import uuid
from pathlib import Path
from typing import NamedTuple, Optional

import httpx
import pytest
import qiskit
from pytest_httpx import HTTPXMock
from pytest_mock import MockerFixture
from qiskit.providers import JobStatus

from qiskit_aqt_provider import api_models, api_models_generated, persistence
from qiskit_aqt_provider.aqt_job import AQTJob
from qiskit_aqt_provider.aqt_options import AQTOptions
from qiskit_aqt_provider.aqt_provider import AQTProvider
from qiskit_aqt_provider.aqt_resource import AQTResource, OfflineSimulatorResource
from qiskit_aqt_provider.test.circuits import random_circuit
from qiskit_aqt_provider.test.fixtures import MockSimulator


@pytest.mark.parametrize(
    ""backend_name"",
    [
        ""offline_simulator_no_noise"",
        pytest.param(
            ""offline_simulator_noise"",
            marks=pytest.mark.xfail(reason=""Job persistence on noisy simulator not supported.""),
        ),
    ],
)
@pytest.mark.parametrize(""remove_from_store"", [True, False])
def test_job_persistence_transaction_offline_simulator(
    backend_name: str, remove_from_store: bool, tmp_path: Path
) -> None:
    """"""Persist and restore a job on offline simulators.""""""
    token = str(uuid.uuid4())
    provider = AQTProvider(token)
    backend = provider.get_backend(backend_name)
    assert isinstance(backend, OfflineSimulatorResource)

    circuits = [random_circuit(2), random_circuit(3)]
    job = backend.run(qiskit.transpile(circuits, backend))

    path = job.persist(store_path=tmp_path)

    # sanity check
    assert str(path).startswith(str(tmp_path))

    restored_job = AQTJob.restore(
        job.job_id(), access_token=token, store_path=tmp_path, remove_from_store=remove_from_store
    )

    assert path.exists() is not remove_from_store

    assert isinstance(restored_job.backend(), OfflineSimulatorResource)
    restored_backend: OfflineSimulatorResource = restored_job.backend()

    assert restored_backend.provider.access_token == backend.provider.access_token
    assert restored_backend.with_noise_model == backend.with_noise_model

    assert restored_job.options == job.options
    assert restored_job.circuits == job.circuits
    assert restored_job.api_submit_payload == job.api_submit_payload

    # for offline simulators, the backend state is fully lost so the restored_job
    # is actually a new one
    assert restored_job.job_id()
    assert restored_job.job_id() != job.job_id()

    # we get a result for both jobs, but they in principle differ because the job was re-submitted
    assert restored_job.result().success
    assert len(restored_job.result().get_counts()) == len(circuits)
    assert job.result().success
    assert len(job.result().get_counts()) == len(circuits)


def test_job_persistence_transaction_online_backend(httpx_mock: HTTPXMock, tmp_path: Path) -> None:
    """"""Persist and restore a job on mocked online resources.""""""
    # Set up a fake online resource
    token = str(uuid.uuid4())
    provider = AQTProvider(token)
    resource_id = api_models.ResourceId(
        workspace_id=str(uuid.uuid4()),
        resource_id=str(uuid.uuid4()),
        resource_name=str(uuid.uuid4()),
        resource_type=""device"",
    )
    backend = AQTResource(provider, resource_id)

    class PortalJob(NamedTuple):
        """"""Mocked portal state: holds details of the submitted jobs.""""""

        circuits: list[api_models_generated.QuantumCircuit]
        workspace_id: str
        resource_id: str
        error_msg: str

    portal_state: dict[uuid.UUID, PortalJob] = {}

    def handle_submit(request: httpx.Request) -> httpx.Response:
        """"""Mocked circuit submission endpoint.

        Create a job ID and a unique error message for the submitted job.
        Store the details in `portal_state`.
        """"""
        assert request.headers[""authorization""] == f""Bearer {token}""

        _, workspace_id, resource_id = request.url.path.rsplit(""/"", maxsplit=2)
        data = api_models.SubmitJobRequest.model_validate_json(request.content.decode(""utf-8""))
        circuits = data.payload.circuits
        job_id = uuid.uuid4()

        assert job_id not in portal_state
        portal_state[job_id] = PortalJob(
            circuits=circuits,
            workspace_id=workspace_id,
            resource_id=resource_id,
            error_msg=str(uuid.uuid4()),
        )

        return httpx.Response(
            status_code=httpx.codes.OK,
            json=json.loads(
                api_models.Response.queued(
                    job_id=job_id, resource_id=resource_id, workspace_id=workspace_id
                ).model_dump_json()
            ),
        )

    def handle_result(request: httpx.Request) -> httpx.Response:
        """"""Mocked circuit result endpoint.

        Check that the access token is valid.
        Return an error response, with the unique error message for the
        requested job ID.
        """"""
        assert request.headers[""authorization""] == f""Bearer {token}""

        _, job_id = request.url.path.rsplit(""/"", maxsplit=1)
        job = portal_state[uuid.UUID(job_id)]

        return httpx.Response(
            status_code=httpx.codes.OK,
            json=json.loads(
                api_models.Response.error(
                    job_id=uuid.UUID(job_id),
                    workspace_id=job.workspace_id,
                    resource_id=job.resource_id,
                    message=job.error_msg,
                ).model_dump_json()
            ),
        )

    httpx_mock.add_callback(
        handle_submit, url=re.compile(r"".+/submit/[0-9a-f-]+/[0-9a-f-]+$""), method=""POST""
    )
    httpx_mock.add_callback(handle_result, url=re.compile(r"".+/result/[0-9a-f-]+$""), method=""GET"")

    # ----------

    circuits = [random_circuit(2), random_circuit(3), random_circuit(4)]
    job = backend.run(qiskit.transpile(circuits, backend), shots=123)

    # sanity checks
    assert uuid.UUID(job.job_id()) in portal_state
    assert job.options != AQTOptions()  # non-default options because shots=123

    path = job.persist(store_path=tmp_path)
    restored_job = AQTJob.restore(job.job_id(), access_token=token, store_path=tmp_path)

    assert not path.exists()  # remove_from_store is True by default

    assert restored_job.job_id() == job.job_id()
    assert restored_job.circuits == job.circuits
    assert restored_job.options == job.options

    # the mocked GET /result route always returns an error response with a unique error message
    assert job.status() is JobStatus.ERROR
    assert restored_job.status() is JobStatus.ERROR

    assert job.error_message
    assert job.error_message == restored_job.error_message

    assert job.result().success is False
    assert restored_job.result().success is False

    # both job and restored_job have already been submitted, so they can't be submitted again
    with pytest.raises(RuntimeError, match=""Job already submitted""):
        job.submit()

    with pytest.raises(RuntimeError, match=""Job already submitted""):
        restored_job.submit()


def test_can_only_persist_submitted_jobs(
    offline_simulator_no_noise: MockSimulator, tmp_path: Path
) -> None:
    """"""Check that only jobs with a valid job_id can be persisted.""""""
    circuit = qiskit.transpile(random_circuit(2), offline_simulator_no_noise)
    job = AQTJob(offline_simulator_no_noise, [circuit], AQTOptions())

    assert not job.job_id()
    with pytest.raises(RuntimeError, match=r""Can only persist submitted jobs.""):
        job.persist(store_path=tmp_path)


def test_restore_unknown_job(tmp_path: Path) -> None:
    """"""Check that an attempt at restoring an unknown job raises JobNotFoundError.""""""
    with pytest.raises(persistence.JobNotFoundError):
        AQTJob.restore(job_id=""invalid"", store_path=tmp_path)


@pytest.mark.parametrize(""override"", [None, Path(""foo/bar"")])
def test_store_path_resolver(
    override: Optional[Path], tmp_path: Path, mocker: MockerFixture
) -> None:
    """"""Test the persistence store path resolver.

    The returned path must:
    - be the override, if passed
    - exist
    - be a directory.
    """"""
    # do not pollute the test user's environment
    # this only works on unix
    mocker.patch.dict(os.environ, {""XDG_CACHE_HOME"": str(tmp_path)})

    if override is not None:
        override = tmp_path / override

    store_path = persistence.get_store_path(override)

    # sanity check: make sure the mock works
    assert str(store_path).startswith(str(tmp_path))

    assert store_path.exists()
    assert store_path.is_dir()

    if override is not None:
        assert store_path == override
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Alpine Quantum Technologies GmbH 2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

from math import isclose, pi
from typing import Callable

import pytest
import qiskit
from qiskit.circuit import Parameter, QuantumCircuit
from qiskit.primitives import (
    BackendEstimator,
    BackendSampler,
    BaseEstimatorV1,
    BaseSamplerV1,
    Sampler,
)
from qiskit.providers import Backend, BackendV2
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.exceptions import TranspilerError

from qiskit_aqt_provider.primitives import AQTSampler
from qiskit_aqt_provider.primitives.estimator import AQTEstimator
from qiskit_aqt_provider.test.circuits import assert_circuits_equal
from qiskit_aqt_provider.test.fixtures import MockSimulator


@pytest.fixture(scope=""module"")
def assert_all_responses_were_requested() -> bool:
    """"""Disable pytest-httpx check that all mocked responses are used for this module.

    Some tests in this module request the offline_simulator_no_noise_direct_access
    fixture without using it, thus not calling the mocked HTTP responses it contains.

    # TODO: use alternative HTTPXMock setup when available.
    # See: https://github.com/Colin-b/pytest_httpx/issues/137
    """"""
    return False


def test_backend_primitives_are_v1() -> None:
    """"""Check that `BackendSampler` and `BackendEstimator` have primitives V1 interfaces.

    As of 2024-02-20, there are no backend primitives that provide V2 interfaces.

    If this test fails, the `AQTSampler` and `AQTEstimator` docs as well as the user
    guide must be updated.

    An interface mismatch may be detected at other spots. This makes the detection explicit.
    """"""
    assert issubclass(BackendSampler, BaseSamplerV1)
    assert issubclass(BackendEstimator, BaseEstimatorV1)


@pytest.mark.parametrize(
    ""get_sampler"",
    [
        # Reference implementation
        lambda _: Sampler(),
        # The AQT transpilation plugin doesn't support transpiling unbound parametric circuits
        # and the BackendSampler doesn't fallback to transpiling the bound circuit if
        # transpiling the unbound circuit failed (like the opflow sampler does).
        # Sampling a parametric circuit with the generic BackendSampler is therefore not supported.
        pytest.param(
            lambda backend: BackendSampler(backend), marks=pytest.mark.xfail(raises=TranspilerError)
        ),
        # The specialized implementation of the Sampler primitive for AQT backends delays the
        # transpilation passes that require bound parameters.
        lambda backend: AQTSampler(backend),
    ],
)
def test_circuit_sampling_primitive(
    get_sampler: Callable[[Backend], BaseSamplerV1], any_offline_simulator_no_noise: BackendV2
) -> None:
    """"""Check that a `Sampler` primitive using an AQT backend can sample parametric circuits.""""""
    theta = Parameter(""θ"")

    qc = QuantumCircuit(2)
    qc.rx(theta, 0)
    qc.ry(theta, 0)
    qc.rz(theta, 0)
    qc.rxx(theta, 0, 1)
    qc.measure_all()

    assert qc.num_parameters > 0

    sampler = get_sampler(any_offline_simulator_no_noise)
    sampled = sampler.run(qc, [pi]).result().quasi_dists
    assert sampled == [{3: 1.0}]


@pytest.mark.parametrize(""theta"", [0.0, pi])
def test_operator_estimator_primitive_trivial_pauli_x(
    theta: float, offline_simulator_no_noise: MockSimulator
) -> None:
    """"""Use the Estimator primitive to verify that <0|X|0> = <1|X|1> = 0.

    Define the parametrized circuit that consists of the single gate Rx(θ) with
    θ=0,π. Applied to |0>, this creates the states |0>,|1>. The Estimator primitive
    is then used to evaluate the expectation value of the Pauli X operator on the
    state produced by the circuit.
    """"""
    offline_simulator_no_noise.simulator.options.seed_simulator = 0

    estimator = AQTEstimator(offline_simulator_no_noise, options={""shots"": 200})

    qc = QuantumCircuit(1)
    qc.rx(theta, 0)

    op = SparsePauliOp(""X"")
    result = estimator.run(qc, op).result()

    assert abs(result.values[0]) < 0.1


def test_operator_estimator_primitive_trivial_pauli_z(
    offline_simulator_no_noise: MockSimulator,
) -> None:
    """"""Use the Estimator primitive to verify that:
    <0|Z|0> = 1
    <1|Z|1> = -1
    <ψ|Z|ψ> = 0 with |ψ> = (|0> + |1>)/√2.

    The sampled circuit is always Rx(θ) with θ=0,π,π/2 respectively.

    The θ values are passed into a single call to the estimator, thus also checking
    that the AQTEstimator can deal with parametrized circuits.
    """"""
    offline_simulator_no_noise.simulator.options.seed_simulator = 0

    estimator = AQTEstimator(offline_simulator_no_noise, options={""shots"": 200})

    theta = Parameter(""θ"")
    qc = QuantumCircuit(1)
    qc.rx(theta, 0)

    op = SparsePauliOp(""Z"")
    result = estimator.run([qc] * 3, [op] * 3, [[0], [pi], [pi / 2]]).result()

    z0, z1, z01 = result.values

    assert isclose(z0, 1.0)  # <0|Z|0>
    assert isclose(z1, -1.0)  # <1|Z|1>
    assert abs(z01) < 0.1  # <ψ|Z|ψ>, |ψ> = (|0> + |1>)/√2


@pytest.mark.parametrize(
    ""theta"",
    [
        pi / 3,
        -pi / 3,
        pi / 2,
        -pi / 2,
        3 * pi / 4,
        -3 * pi / 4,
        15 * pi / 8,
        -15 * pi / 8,
        33 * pi / 16,
        -33 * pi / 16,
    ],
)
def test_aqt_sampler_transpilation(theta: float, offline_simulator_no_noise: MockSimulator) -> None:
    """"""Check that the AQTSampler passes the same circuit to the backend as a call to
    `backend.run` with the same transpiler call on the bound circuit would.
    """"""
    theta_param = Parameter(""θ"")

    # define a circuit with unbound parameters
    qc = QuantumCircuit(2)
    qc.rx(pi / 3, 0)
    qc.rxx(theta_param, 0, 1)
    qc.measure_all()

    assert qc.num_parameters > 0

    # sample the circuit, passing parameter assignments
    sampler = AQTSampler(offline_simulator_no_noise)
    sampler.run(qc, [theta]).result()

    # the sampler was only called once
    assert len(offline_simulator_no_noise.submitted_circuits) == 1
    # get the circuit passed to the backend
    ((transpiled_circuit,),) = offline_simulator_no_noise.submitted_circuits

    # compare to the circuit obtained by binding the parameters and transpiling at once
    expected = qc.assign_parameters({theta_param: theta})
    tr_expected = qiskit.transpile(expected, offline_simulator_no_noise)

    assert_circuits_equal(transpiled_circuit, tr_expected)
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2019, Alpine Quantum Technologies GmbH 2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import itertools
import json
import math
import re
import uuid
from contextlib import AbstractContextManager, nullcontext
from typing import Any
from unittest import mock

import httpx
import pydantic as pdt
import pytest
import qiskit
from polyfactory.factories.pydantic_factory import ModelFactory
from pytest_httpx import HTTPXMock
from qiskit import QuantumCircuit
from qiskit.providers import JobStatus
from qiskit.providers.exceptions import JobTimeoutError
from typing_extensions import assert_type

from qiskit_aqt_provider import api_models, api_models_direct
from qiskit_aqt_provider.aqt_job import AQTJob
from qiskit_aqt_provider.aqt_options import AQTDirectAccessOptions, AQTOptions
from qiskit_aqt_provider.aqt_resource import AQTResource
from qiskit_aqt_provider.circuit_to_aqt import circuits_to_aqt_job
from qiskit_aqt_provider.test.circuits import assert_circuits_equal, empty_circuit, random_circuit
from qiskit_aqt_provider.test.fixtures import MockSimulator
from qiskit_aqt_provider.test.resources import (
    DummyDirectAccessResource,
    DummyResource,
    TestResource,
)
from qiskit_aqt_provider.versions import USER_AGENT


class OptionsFactory(ModelFactory[AQTOptions]):
    """"""Factory of random but well-formed options data.""""""

    __model__ = AQTOptions

    query_timeout_seconds = 10.0


def test_options_set_query_timeout(offline_simulator_no_noise: AQTResource) -> None:
    """"""Set the query timeout for job status queries with different values.""""""
    backend = offline_simulator_no_noise

    # doesn't work with str
    with pytest.raises(pdt.ValidationError):
        backend.options.update_options(query_timeout_seconds=""abc"")

    # works with integers
    backend.options.update_options(query_timeout_seconds=123)
    assert backend.options.query_timeout_seconds == 123

    # works with floats
    backend.options.update_options(query_timeout_seconds=123.45)
    assert backend.options.query_timeout_seconds == 123.45

    # works with None (no timeout)
    backend.options.update_options(query_timeout_seconds=None)
    assert backend.options.query_timeout_seconds is None


def test_options_set_query_period(offline_simulator_no_noise: AQTResource) -> None:
    """"""Set the query period for job status queries with different values.""""""
    backend = offline_simulator_no_noise

    # works with integers
    backend.options.update_options(query_period_seconds=123)
    assert backend.options.query_period_seconds == 123

    # works with floats
    backend.options.update_options(query_period_seconds=123.45)
    assert backend.options.query_period_seconds == 123.45

    # doesn't work with None
    with pytest.raises(pdt.ValidationError):
        backend.options.update_options(query_period_seconds=None)

    # doesn't work with str
    with pytest.raises(pdt.ValidationError):
        backend.options.update_options(query_period_seconds=""abc"")


def test_options_types_and_constraints_cloud_resource(
    offline_simulator_no_noise: AQTResource,
) -> None:
    """"""Check that the options models and constraints are as expected for cloud backends.""""""
    assert_type(offline_simulator_no_noise.options, AQTOptions)
    assert isinstance(offline_simulator_no_noise.options, AQTOptions)
    assert offline_simulator_no_noise.options.max_shots() == 2000

    # Check that the default options in Qiskit format match the Pydantic model.
    assert offline_simulator_no_noise.options.model_dump() == {
        **offline_simulator_no_noise.__class__._default_options()
    }


def test_options_types_and_constraints_direct_access_resource() -> None:
    """"""Check that the options models and constraints are as expected for direct-access backends.""""""
    backend = DummyDirectAccessResource(""token"")

    assert_type(backend.options, AQTDirectAccessOptions)
    assert isinstance(backend.options, AQTDirectAccessOptions)
    assert backend.options.max_shots() == 200

    # Check that the default options in Qiskit format match the Pydantic model.
    assert backend.options.model_dump() == {**backend.__class__._default_options()}


def test_query_timeout_propagation() -> None:
    """"""Check that the query timeout is properly propagated from the backend options to
    the job result polling loop.

    Acquire a resource with 10s processing time, but set the job result timeout to 1s.
    Check that calling `result()` on the job handle fails with a timeout error.
    """"""
    response_delay = 10.0
    timeout = 1.0
    assert timeout < response_delay

    backend = TestResource(min_running_duration=response_delay)
    backend.options.update_options(query_timeout_seconds=timeout, query_period_seconds=0.5)

    qc = QuantumCircuit(1)
    qc.rx(3.14, 0)
    qc.measure_all()

    job = backend.run(qiskit.transpile(qc, backend))

    with pytest.raises(JobTimeoutError):
        job.result()


def test_query_period_propagation() -> None:
    """"""Check that the query wait duration is properly propagated from the backend options
    to the job result polling loop.

    Set the polling period (much) shorter than the backend's processing time. Check that
    the backend is polled the calculated number of times.
    """"""
    response_delay = 2.0
    period_seconds = 0.5
    timeout_seconds = 3.0
    assert timeout_seconds > response_delay  # won't time out

    backend = TestResource(min_running_duration=response_delay)
    backend.options.update_options(
        query_timeout_seconds=timeout_seconds, query_period_seconds=period_seconds
    )

    qc = QuantumCircuit(1)
    qc.rx(3.14, 0)
    qc.measure_all()

    job = backend.run(qiskit.transpile(qc, backend))

    with mock.patch.object(AQTJob, ""status"", wraps=job.status) as mocked_status:
        job.result()

    lower_bound = math.floor(response_delay / period_seconds)
    upper_bound = math.ceil(response_delay / period_seconds) + 1
    assert lower_bound <= mocked_status.call_count <= upper_bound


def test_run_options_propagation(offline_simulator_no_noise: MockSimulator) -> None:
    """"""Check that options passed to AQTResource.run are propagated to the corresponding job.""""""
    default = offline_simulator_no_noise.options.model_copy()

    while True:
        overrides = OptionsFactory.build()
        if overrides != default:
            break

    qc = QuantumCircuit(1)
    qc.measure_all()

    # don't submit the circuit to the simulator
    with mock.patch.object(AQTJob, ""submit"") as mocked_submit:
        job = offline_simulator_no_noise.run(qc, **overrides.model_dump())
        assert job.options == overrides

    mocked_submit.assert_called_once()


def test_run_options_unknown(offline_simulator_no_noise: MockSimulator) -> None:
    """"""Check that AQTResource.run accepts but warns about unknown options.""""""
    default = offline_simulator_no_noise.options.model_copy()
    overrides = {""shots"": 123, ""unknown_option"": True}
    assert set(overrides) - set(default) == {""unknown_option""}

    qc = QuantumCircuit(1)
    qc.measure_all()

    with mock.patch.object(AQTJob, ""submit"") as mocked_submit:
        with pytest.warns(UserWarning, match=""not used""):
            job = offline_simulator_no_noise.run(qc, **overrides)

        assert job.options.shots == 123

    mocked_submit.assert_called_once()


def test_run_options_invalid(offline_simulator_no_noise: MockSimulator) -> None:
    """"""Check that AQTResource.run reject valid option names with invalid values.""""""
    qc = QuantumCircuit(1)
    qc.measure_all()

    with pytest.raises(pdt.ValidationError, match=""shots""):
        offline_simulator_no_noise.run(qc, shots=-123)


def test_double_job_submission(offline_simulator_no_noise: MockSimulator) -> None:
    """"""Check that attempting to re-submit a job raises a RuntimeError.""""""
    qc = QuantumCircuit(1)
    qc.r(3.14, 0.0, 0)
    qc.measure_all()

    # AQTResource.run submits the job
    job = offline_simulator_no_noise.run(qc)

    with pytest.raises(RuntimeError, match=f""{job.job_id()}""):
        job.submit()

    # Check that the job was actually submitted
    ((submitted_circuit,),) = offline_simulator_no_noise.submitted_circuits
    assert_circuits_equal(submitted_circuit, qc)


def test_offline_simulator_invalid_job_id(offline_simulator_no_noise: MockSimulator) -> None:
    """"""Check that the offline simulator raises UnknownJobError if the job id passed
    to `result()` is invalid.
    """"""
    qc = QuantumCircuit(1)
    qc.measure_all()

    job = offline_simulator_no_noise.run([qc], shots=1)
    job_id = uuid.UUID(hex=job.job_id())
    invalid_job_id = uuid.uuid4()
    assert invalid_job_id != job_id

    with pytest.raises(api_models.UnknownJobError, match=str(invalid_job_id)):
        offline_simulator_no_noise.result(invalid_job_id)

    # querying the actual job is successful
    result = offline_simulator_no_noise.result(job_id)
    assert result.job.job_id == job_id


def test_submit_valid_response(httpx_mock: HTTPXMock) -> None:
    """"""Check that AQTResource.submit passes the authorization token and
    extracts the correct job_id when the response payload is valid.
    """"""
    token = str(uuid.uuid4())
    backend = DummyResource(token)
    expected_job_id = uuid.uuid4()

    def handle_submit(request: httpx.Request) -> httpx.Response:
        assert request.headers[""user-agent""] == USER_AGENT
        assert request.headers[""authorization""] == f""Bearer {token}""

        return httpx.Response(
            status_code=httpx.codes.OK,
            json=json.loads(
                api_models.Response.queued(
                    job_id=expected_job_id,
                    resource_id=backend.resource_id.resource_id,
                    workspace_id=backend.resource_id.workspace_id,
                ).model_dump_json()
            ),
        )

    httpx_mock.add_callback(handle_submit, method=""POST"")

    job = AQTJob(backend, circuits=[empty_circuit(2)], options=AQTOptions(shots=10))
    job.submit()
    assert job.job_id() == str(expected_job_id)


def test_submit_payload_matches(httpx_mock: HTTPXMock) -> None:
    """"""Check that the quantum circuits jobs payload is correctly submitted to the API endpoint.""""""
    backend = DummyResource("""")
    shots = 123
    qc = qiskit.transpile(random_circuit(2), backend)
    expected_job_payload = circuits_to_aqt_job([qc], shots=shots)
    expected_job_id = uuid.uuid4()

    def handle_submit(request: httpx.Request) -> httpx.Response:
        assert request.headers[""user-agent""] == USER_AGENT
        assert request.url.path.endswith(
            f""submit/{backend.resource_id.workspace_id}/{backend.resource_id.resource_id}""
        )

        data = api_models.SubmitJobRequest.model_validate_json(request.content.decode(""utf-8""))
        assert data == expected_job_payload

        return httpx.Response(
            status_code=httpx.codes.OK,
            json=json.loads(
                api_models.Response.queued(
                    job_id=expected_job_id,
                    resource_id=backend.resource_id.resource_id,
                    workspace_id=backend.resource_id.workspace_id,
                ).model_dump_json()
            ),
        )

    httpx_mock.add_callback(handle_submit, method=""POST"")

    qc = qiskit.transpile(random_circuit(2), backend)
    job = AQTJob(backend, circuits=[qc], options=AQTOptions(shots=shots))
    job.submit()
    assert job.job_id() == str(expected_job_id)


def test_submit_bad_request(httpx_mock: HTTPXMock) -> None:
    """"""Check that AQTResource.submit raises an HTTPError if the request
    is flagged invalid by the server.
    """"""
    backend = DummyResource("""")
    httpx_mock.add_response(status_code=httpx.codes.BAD_REQUEST)

    job = AQTJob(backend, circuits=[empty_circuit(2)], options=AQTOptions(shots=10))
    with pytest.raises(httpx.HTTPError):
        job.submit()


def test_result_valid_response(httpx_mock: HTTPXMock) -> None:
    """"""Check that AQTResource.result passes the authorization token
    and returns the raw response payload.
    """"""
    token = str(uuid.uuid4())
    backend = DummyResource(token)
    job_id = uuid.uuid4()

    payload = api_models.Response.cancelled(
        job_id=job_id,
        resource_id=backend.resource_id.resource_id,
        workspace_id=backend.resource_id.workspace_id,
    )

    def handle_result(request: httpx.Request) -> httpx.Response:
        assert request.headers[""user-agent""] == USER_AGENT
        assert request.headers[""authorization""] == f""Bearer {token}""
        assert request.url.path.endswith(f""result/{job_id}"")

        return httpx.Response(
            status_code=httpx.codes.OK, json=json.loads(payload.model_dump_json())
        )

    httpx_mock.add_callback(handle_result, method=""GET"")

    response = backend.result(job_id)
    assert response == payload


def test_result_bad_request(httpx_mock: HTTPXMock) -> None:
    """"""Check that AQTResource.result raises an HTTPError if the request
    is flagged invalid by the server.
    """"""
    backend = DummyResource("""")
    httpx_mock.add_response(status_code=httpx.codes.BAD_REQUEST)

    with pytest.raises(httpx.HTTPError):
        backend.result(uuid.uuid4())


def test_result_unknown_job(httpx_mock: HTTPXMock) -> None:
    """"""Check that AQTResource.result raises UnknownJobError if the API
    responds with an UnknownJob payload.
    """"""
    backend = DummyResource("""")
    job_id = uuid.uuid4()

    httpx_mock.add_response(
        json=json.loads(api_models.Response.unknown_job(job_id=job_id).model_dump_json())
    )

    with pytest.raises(api_models.UnknownJobError, match=str(job_id)):
        backend.result(job_id)


def test_offline_simulator_detects_invalid_circuits(
    offline_simulator_no_noise: MockSimulator,
) -> None:
    """"""Pass a circuit that cannot be converted to the AQT API to the offline simulator.
    This must fail.
    """"""
    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    with pytest.raises(ValueError, match=""^Operation 'h' not in basis gate set""):
        offline_simulator_no_noise.run(qc)


def test_offline_simulator_propagate_shots_option(
    offline_simulator_no_noise: MockSimulator,
) -> None:
    """"""Check various ways of configuring the number of repetitions.""""""
    qc = qiskit.transpile(random_circuit(2), offline_simulator_no_noise)

    default_shots = sum(offline_simulator_no_noise.run(qc).result().get_counts().values())
    assert default_shots == AQTOptions().shots

    shots = min(default_shots + 40, AQTOptions.max_shots())
    assert shots != default_shots

    # configure shots in AQTResource.run
    shots_run = sum(offline_simulator_no_noise.run(qc, shots=shots).result().get_counts().values())
    assert shots_run == shots

    # configure shots in resource options
    offline_simulator_no_noise.options.shots = shots
    shots_options = sum(offline_simulator_no_noise.run(qc).result().get_counts().values())
    assert shots_options == shots


@pytest.mark.parametrize(
    (""memory"", ""context""),
    [(True, nullcontext()), (False, pytest.raises(qiskit.QiskitError, match=""No memory""))],
)
def test_offline_simulator_run_propagate_memory_option(
    memory: bool,
    context: AbstractContextManager[Any],
    offline_simulator_no_noise: MockSimulator,
) -> None:
    """"""Check that the memory option can be set on `AQTResource.run`.""""""
    qc = qiskit.transpile(random_circuit(2), offline_simulator_no_noise)
    default_shots = AQTOptions().shots

    result = offline_simulator_no_noise.run(qc, memory=memory).result()
    with context:
        assert len(result.get_memory()) == default_shots


@pytest.mark.parametrize(
    (""memory"", ""context""),
    [(True, nullcontext()), (False, pytest.raises(qiskit.QiskitError, match=""No memory""))],
)
def test_offline_simulator_resource_propagate_memory_option(
    memory: bool, context: AbstractContextManager[Any], offline_simulator_no_noise: MockSimulator
) -> None:
    """"""Check that the memory option can be set as resource option.""""""
    qc = qiskit.transpile(random_circuit(2), offline_simulator_no_noise)
    default_shots = AQTOptions().shots

    offline_simulator_no_noise.options.memory = memory
    result = offline_simulator_no_noise.run(qc).result()
    with context:
        assert len(result.get_memory()) == default_shots


def test_direct_access_bad_request(httpx_mock: HTTPXMock) -> None:
    """"""Check that direct-access resources raise a httpx.HTTPError on bad requests.""""""
    backend = DummyDirectAccessResource(""token"")
    httpx_mock.add_response(status_code=httpx.codes.BAD_REQUEST)

    job = backend.run(empty_circuit(2))
    with pytest.raises(httpx.HTTPError):
        job.result()


@pytest.mark.parametrize(""success"", [False, True])
def test_direct_access_job_status(success: bool, httpx_mock: HTTPXMock) -> None:
    """"""Check the expected Qiskit job status on direct-access resources.

    Since the transactions are synchronous, there are only three possible statuses:
    1. initializing: the job was created but is not executing
    2. done: the job executed successfully
    3. error: the job execution failed.
    """"""
    shots = 100

    def handle_submit(request: httpx.Request) -> httpx.Response:
        assert request.headers[""user-agent""] == USER_AGENT

        return httpx.Response(status_code=httpx.codes.OK, text=f'""{uuid.uuid4()}""')

    def handle_result(request: httpx.Request) -> httpx.Response:
        assert request.headers[""user-agent""] == USER_AGENT

        _, job_id = request.url.path.rsplit(""/"", maxsplit=1)

        return httpx.Response(
            status_code=httpx.codes.OK,
            json=json.loads(
                api_models_direct.JobResult.create_finished(
                    job_id=uuid.UUID(job_id), result=[[0] for _ in range(shots)]
                ).model_dump_json()
                if success
                else api_models_direct.JobResult.create_error(
                    job_id=uuid.UUID(job_id)
                ).model_dump_json()
            ),
        )

    httpx_mock.add_callback(handle_submit, method=""PUT"", url=re.compile("".+/circuit/?$""))
    httpx_mock.add_callback(
        handle_result, method=""GET"", url=re.compile("".+/circuit/result/[0-9a-f-]+$"")
    )

    backend = DummyDirectAccessResource(""token"")
    job = backend.run(empty_circuit(1), shots=shots)

    assert job.status() is JobStatus.INITIALIZING

    result = job.result()
    assert result.success is success

    if success:
        assert job.status() is JobStatus.DONE
    else:
        assert job.status() is JobStatus.ERROR


@pytest.mark.parametrize(""token"", [str(uuid.uuid4()), """"])
def test_direct_access_mocked_successful_transaction(token: str, httpx_mock: HTTPXMock) -> None:
    """"""Mock a successful single-circuit transaction on a direct-access resource.""""""
    backend = DummyDirectAccessResource(token)
    backend.options.with_progress_bar = False

    shots = 122
    qc = empty_circuit(2)

    expected_job_id = str(uuid.uuid4())

    def assert_valid_token(headers: httpx.Headers) -> None:
        if token:
            assert headers[""authorization""] == f""Bearer {token}""
        else:
            assert ""authorization"" not in headers

    def handle_submit(request: httpx.Request) -> httpx.Response:
        assert request.headers[""user-agent""] == USER_AGENT
        assert_valid_token(request.headers)

        data = api_models.QuantumCircuit.model_validate_json(request.content.decode(""utf-8""))
        assert data.repetitions == shots

        return httpx.Response(
            status_code=httpx.codes.OK,
            text=f'""{expected_job_id}""',
        )

    def handle_result(request: httpx.Request) -> httpx.Response:
        assert request.headers[""user-agent""] == USER_AGENT
        assert_valid_token(request.headers)

        _, job_id = request.url.path.rsplit(""/"", maxsplit=1)
        assert job_id == expected_job_id

        return httpx.Response(
            status_code=httpx.codes.OK,
            json=json.loads(
                api_models_direct.JobResult.create_finished(
                    job_id=uuid.UUID(job_id),
                    result=[[0, 0] if s % 2 == 0 else [1, 0] for s in range(shots)],
                ).model_dump_json()
            ),
        )

    httpx_mock.add_callback(handle_submit, method=""PUT"", url=re.compile("".+/circuit/?$""))
    httpx_mock.add_callback(
        handle_result, method=""GET"", url=re.compile("".+/circuit/result/[0-9a-f-]+$"")
    )

    job = backend.run(qc, shots=shots)
    result = job.result()

    assert result.get_counts() == {""00"": shots // 2, ""01"": shots // 2}


def test_direct_access_mocked_failed_transaction(httpx_mock: HTTPXMock) -> None:
    """"""Mock a failed multi-circuit transaction on a direct-access resource.

    The first two circuits succeed, the third one not. The fourth circuit would succeed,
    but is never executed.
    """"""
    token = str(uuid.uuid4())
    backend = DummyDirectAccessResource(token)
    backend.options.with_progress_bar = False

    shots = 122
    qc = empty_circuit(2)

    job_ids = [str(uuid.uuid4()) for _ in range(4)]
    # produce 2 times the same id before going to the next, one value
    # for handle_submit, the other one for handle result.
    job_ids_iter = itertools.chain.from_iterable(zip(job_ids, job_ids))

    # circuit executions' planned success
    success = [True, True, False, True]
    success_iter = iter(success)

    circuit_submissions = 0

    def handle_submit(request: httpx.Request) -> httpx.Response:
        assert request.headers[""user-agent""] == USER_AGENT

        data = api_models.QuantumCircuit.model_validate_json(request.content.decode(""utf-8""))
        assert data.repetitions == shots

        nonlocal circuit_submissions
        circuit_submissions += 1

        return httpx.Response(
            status_code=httpx.codes.OK,
            text=f'""{next(job_ids_iter)}""',
        )

    def handle_result(request: httpx.Request) -> httpx.Response:
        assert request.headers[""user-agent""] == USER_AGENT

        _, job_id = request.url.path.rsplit(""/"", maxsplit=1)
        assert job_id == next(job_ids_iter)

        return httpx.Response(
            status_code=httpx.codes.OK,
            json=json.loads(
                api_models_direct.JobResult.create_finished(
                    job_id=uuid.UUID(job_id), result=[[0, 1] for _ in range(shots)]
                ).model_dump_json()
                if next(success_iter)
                else api_models_direct.JobResult.create_error(
                    job_id=uuid.UUID(job_id)
                ).model_dump_json()
            ),
        )

    httpx_mock.add_callback(handle_submit, method=""PUT"", url=re.compile("".+/circuit/?$""))
    httpx_mock.add_callback(
        handle_result, method=""GET"", url=re.compile("".+/circuit/result/[0-9a-f-]+$"")
    )

    job = backend.run([qc, qc, qc, qc], shots=shots)
    result = job.result()

    assert not result.success  # not all circuits executed successfully

    counts = result.get_counts()
    assert isinstance(counts, list)  # multiple successful circuit executions
    assert len(counts) == 2  # the first two circuits executed successfully
    assert counts == [{""10"": shots}, {""10"": shots}]

    assert circuit_submissions == 3  # the last circuit was never submitted
"
https://github.com/qiskit-community/qiskit-aqt-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Alpine Quantum Technologies GmbH 2023
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.


from math import pi
from typing import Union

import pytest
from hypothesis import assume, example, given
from hypothesis import strategies as st
from qiskit import QuantumCircuit, transpile
from qiskit.circuit.library import RXGate, RYGate

from qiskit_aqt_provider.aqt_resource import AQTResource
from qiskit_aqt_provider.test.circuits import (
    assert_circuits_equal,
    assert_circuits_equivalent,
    qft_circuit,
)
from qiskit_aqt_provider.test.fixtures import MockSimulator
from qiskit_aqt_provider.transpiler_plugin import rewrite_rx_as_r, wrap_rxx_angle


@pytest.mark.parametrize(
    (""input_theta"", ""output_theta"", ""output_phi""),
    [
        (pi / 3, pi / 3, 0.0),
        (-pi / 3, pi / 3, pi),
        (7 * pi / 5, 3 * pi / 5, pi),
        (25 * pi, pi, pi),
        (22 * pi / 3, 2 * pi / 3, pi),
    ],
)
def test_rx_rewrite_example(
    input_theta: float,
    output_theta: float,
    output_phi: float,
) -> None:
    """"""Snapshot test for the Rx(θ) → R(θ, φ) rule.""""""
    result = QuantumCircuit(1)
    result.append(rewrite_rx_as_r(input_theta), (0,))

    expected = QuantumCircuit(1)
    expected.r(output_theta, output_phi, 0)

    reference = QuantumCircuit(1)
    reference.rx(input_theta, 0)

    assert_circuits_equal(result, expected)
    assert_circuits_equivalent(result, reference)


@given(theta=st.floats(allow_nan=False, min_value=-1000 * pi, max_value=1000 * pi))
@pytest.mark.parametrize(""optimization_level"", [0, 1, 2, 3])
@pytest.mark.parametrize(""test_gate"", [RXGate, RYGate])
def test_rx_ry_rewrite_transpile(
    theta: float,
    optimization_level: int,
    test_gate: Union[RXGate, RYGate],
) -> None:
    """"""Test the rewrite rule: Rx(θ), Ry(θ) → R(θ, φ), θ ∈ [0, π], φ ∈ [0, 2π].""""""
    assume(abs(theta) > pi / 200)

    # we only need the backend's transpiler target for this test
    backend = MockSimulator(noisy=False)

    qc = QuantumCircuit(1)
    qc.append(test_gate(theta), (0,))

    trans_qc = transpile(qc, backend, optimization_level=optimization_level)
    assert isinstance(trans_qc, QuantumCircuit)

    assert_circuits_equivalent(trans_qc, qc)

    assert set(trans_qc.count_ops()) <= set(backend.configuration().basis_gates)

    num_r = trans_qc.count_ops().get(""r"")
    assume(num_r is not None)
    assert num_r == 1

    for operation in trans_qc.data:
        instruction = operation[0]
        if instruction.name == ""r"":
            theta, phi = instruction.params
            assert 0 <= float(theta) <= pi
            assert 0 <= float(phi) <= 2 * pi
            break
    else:  # pragma: no cover
        pytest.fail(""No R gates in transpiled circuit."")


def test_decompose_1q_rotations_example(offline_simulator_no_noise: AQTResource) -> None:
    """"""Snapshot test for the efficient rewrite of single-qubit rotation runs as ZXZ.""""""
    qc = QuantumCircuit(1)
    qc.rx(pi / 2, 0)
    qc.ry(pi / 2, 0)

    expected = QuantumCircuit(1)
    expected.rz(-pi / 2, 0)
    expected.r(pi / 2, 0, 0)

    result = transpile(qc, offline_simulator_no_noise, optimization_level=3)
    assert isinstance(result, QuantumCircuit)  # only got one circuit back

    assert_circuits_equal(result, expected)
    assert_circuits_equivalent(result, expected)


def test_rxx_wrap_angle_case0() -> None:
    """"""Snapshot test for Rxx(θ) rewrite with 0 <= θ <= π/2.""""""
    result = QuantumCircuit(2)
    result.append(wrap_rxx_angle(pi / 2), (0, 1))

    expected = QuantumCircuit(2)
    expected.rxx(pi / 2, 0, 1)

    assert_circuits_equal(result.decompose(), expected)
    assert_circuits_equivalent(result.decompose(), expected)


def test_rxx_wrap_angle_case0_negative() -> None:
    """"""Snapshot test for Rxx(θ) rewrite with -π/2 <= θ < 0.""""""
    result = QuantumCircuit(2)
    result.append(wrap_rxx_angle(-pi / 2), (0, 1))

    expected = QuantumCircuit(2)
    expected.rz(pi, 0)
    expected.rxx(pi / 2, 0, 1)
    expected.rz(pi, 0)

    assert_circuits_equal(result.decompose(), expected)
    assert_circuits_equivalent(result.decompose(), expected)


def test_rxx_wrap_angle_case1() -> None:
    """"""Snapshot test for Rxx(θ) rewrite with π/2 < θ <= 3π/2.""""""
    result = QuantumCircuit(2)
    result.append(wrap_rxx_angle(3 * pi / 2), (0, 1))

    expected = QuantumCircuit(2)
    expected.rx(pi, 0)
    expected.rx(pi, 1)
    expected.rxx(pi / 2, 0, 1)

    assert_circuits_equal(result.decompose(), expected)
    assert_circuits_equivalent(result.decompose(), expected)


def test_rxx_wrap_angle_case1_negative() -> None:
    """"""Snapshot test for Rxx(θ) rewrite with -3π/2 <= θ < -π/2.""""""
    result = QuantumCircuit(2)
    result.append(wrap_rxx_angle(-3 * pi / 2), (0, 1))

    expected = QuantumCircuit(2)
    expected.rxx(pi / 2, 0, 1)

    assert_circuits_equal(result.decompose(), expected)
    assert_circuits_equivalent(result.decompose(), expected)


def test_rxx_wrap_angle_case2() -> None:
    """"""Snapshot test for Rxx(θ) rewrite with θ > 3*π/2.""""""
    result = QuantumCircuit(2)
    result.append(wrap_rxx_angle(18 * pi / 10), (0, 1))  # mod 2π = 9π/5 → -π/5

    expected = QuantumCircuit(2)
    expected.rz(pi, 0)
    expected.rxx(pi / 5, 0, 1)
    expected.rz(pi, 0)

    assert_circuits_equal(result.decompose(), expected)
    assert_circuits_equivalent(result.decompose(), expected)


def test_rxx_wrap_angle_case2_negative() -> None:
    """"""Snapshot test for Rxx(θ) rewrite with θ < -3π/2.""""""
    result = QuantumCircuit(2)
    result.append(wrap_rxx_angle(-18 * pi / 10), (0, 1))  # mod 2π = π/5

    expected = QuantumCircuit(2)
    expected.rxx(pi / 5, 0, 1)

    assert_circuits_equal(result.decompose(), expected)
    assert_circuits_equivalent(result.decompose(), expected)


@given(
    angle=st.floats(
        allow_nan=False,
        allow_infinity=False,
        min_value=-1000 * pi,
        max_value=1000 * pi,
    )
)
@pytest.mark.parametrize(""qubits"", [3])
@pytest.mark.parametrize(""optimization_level"", [0, 1, 2, 3])
def test_rxx_wrap_angle_transpile(angle: float, qubits: int, optimization_level: int) -> None:
    """"""Check that Rxx angles are wrapped by the transpiler.""""""
    assume(abs(angle) > pi / 200)

    qc = QuantumCircuit(qubits)
    qc.rxx(angle, 0, 1)

    # we only need the backend's transpilation target for this test
    backend = MockSimulator(noisy=False)
    trans_qc = transpile(qc, backend, optimization_level=optimization_level)
    assert isinstance(trans_qc, QuantumCircuit)

    assert_circuits_equivalent(trans_qc, qc)

    assert set(trans_qc.count_ops()) <= set(backend.configuration().basis_gates)
    num_rxx = trans_qc.count_ops().get(""rxx"", 0)

    # Higher optimization levels can optimize e.g. Rxx(2n*π) = Identity away.
    assert num_rxx <= 1

    # check that the Rxx gate has angle in [0, π/2]
    for operation in trans_qc.data:
        instruction = operation[0]
        if instruction.name == ""rxx"":
            (theta,) = instruction.params
            assert 0 <= float(theta) <= pi / 2
            break
    else:  # pragma: no cover
        if num_rxx > 0:
            pytest.fail(""Transpiled circuit contains no Rxx gate."")


@example(angles_pi=[-582.16 / pi])
@given(
    angles_pi=st.lists(
        st.floats(min_value=-1000.0, max_value=1000.0, allow_nan=False),
        min_size=1,
        max_size=4,
    )
)
@pytest.mark.parametrize(""optimization_level"", [0, 1, 2, 3])
def test_transpilation_preserves_or_decreases_number_of_rxx_gates(
    angles_pi: list[float], optimization_level: int
) -> None:
    """"""Check that transpilation at least preserves the number of RXX gates.""""""
    if optimization_level > 1:
        # FIXME: remove once https://github.com/Qiskit/qiskit/issues/12051 is fixed.
        assume(len(angles_pi) == 1)

    qc = QuantumCircuit(2)

    for angle_pi in angles_pi:
        qc.rxx(angle_pi * pi, 0, 1)

    # we only need the backend's transpilation target for this test
    backend = MockSimulator(noisy=False)
    tr_qc = transpile(qc, backend, optimization_level=optimization_level)

    tr_qc_ops = tr_qc.count_ops()
    assert set(tr_qc_ops) <= set(backend.configuration().basis_gates)

    qc_rxx = qc.count_ops()[""rxx""]
    assert qc_rxx == len(angles_pi)
    assert tr_qc_ops.get(""rxx"", 0) <= qc_rxx


@pytest.mark.parametrize(""qubits"", [1, 5, 10])
@pytest.mark.parametrize(""optimization_level"", [0, 1, 2, 3])
def test_qft_circuit_transpilation(
    qubits: int, optimization_level: int, offline_simulator_no_noise: AQTResource
) -> None:
    """"""Transpile a N-qubit QFT circuit for an AQT backend. Check that the angles are properly
    wrapped.
    """"""
    qc = qft_circuit(qubits)
    trans_qc = transpile(qc, offline_simulator_no_noise, optimization_level=optimization_level)
    assert isinstance(trans_qc, QuantumCircuit)

    assert set(trans_qc.count_ops()) <= set(offline_simulator_no_noise.configuration().basis_gates)

    rxx_count = 0
    r_count = 0
    for operation in trans_qc.data:
        instruction = operation[0]
        if instruction.name == ""rxx"":
            (theta,) = instruction.params
            assert 0 <= float(theta) <= pi / 2
            rxx_count += 1

        if instruction.name == ""r"":
            (theta, _) = instruction.params
            assert abs(theta) <= pi
            r_count += 1

    assert r_count > 0

    if qubits > 1:
        assert rxx_count > 0

    if optimization_level < 2 and qubits < 6:
        assert_circuits_equivalent(qc, trans_qc)
"
https://github.com/Qiskit-Extensions/qiskit-ibm-experiment,Qiskit-Extensions,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021-2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Experiment integration tests.""""""

import os
import unittest
from unittest import mock, skipIf
import contextlib
from test.service.ibm_test_case import IBMTestCase
import numpy as np
from qiskit import transpile, QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.providers import JobStatus
from qiskit_experiments.framework import (
    ExperimentData,
    ExperimentDecoder,
    ExperimentEncoder,
)
from qiskit_experiments.framework.experiment_data import ExperimentStatus
from qiskit_experiments.framework import AnalysisResult
from qiskit_experiments.database_service.exceptions import ExperimentEntryNotFound
from qiskit_ibm_runtime import QiskitRuntimeService

from qiskit_ibm_experiment import IBMExperimentService
from qiskit_ibm_experiment.exceptions import IBMExperimentEntryNotFound
from qiskit_ibm_experiment.exceptions import IBMApiError


def bell():
    """"""Return a Bell circuit.""""""
    qr = QuantumRegister(2, name=""qr"")
    cr = ClassicalRegister(2, name=""qc"")
    qc = QuantumCircuit(qr, cr, name=""bell"")
    qc.h(qr[0])
    qc.cx(qr[0], qr[1])
    qc.measure(qr, cr)

    return qc


@skipIf(
    not os.environ.get(""QISKIT_IBM_USE_STAGING_CREDENTIALS"", """"), ""Only runs on staging""
)
class TestExperimentDataIntegration(IBMTestCase):
    """"""Test experiment service with experiment data.""""""

    @classmethod
    def setUpClass(cls):
        """"""Initial class level setup.""""""
        super().setUpClass()
        try:
            cls._setup_service()
            cls._setup_provider()
            cls.circuit = transpile(bell(), cls.backend)
        except Exception as err:
            cls.log.info(""Error while setting the service/provider: %s"", err)
            raise

    @classmethod
    def _setup_service(cls):
        """"""Get the service for the class.""""""
        cls.service = IBMExperimentService(
            token=os.getenv(""QISKIT_IBM_STAGING_API_TOKEN""),
            url=os.getenv(""QISKIT_IBM_STAGING_API_URL""),
        )

    @classmethod
    def _setup_provider(cls):
        """"""Get the provider for the class.""""""
        cls.provider = QiskitRuntimeService(
            channel=""ibm_quantum"",
            token=os.getenv(""QISKIT_IBM_STAGING_API_TOKEN""),
            url=os.getenv(""QISKIT_IBM_STAGING_API_URL""),
            instance=os.getenv(""QISKIT_IBM_STAGING_HGP""),
        )
        cls.backend = cls.provider.backend(os.getenv(""QISKIT_IBM_STAGING_BACKEND""))
        try:
            cls.device_components = cls.service.device_components(cls.backend.name)
        except IBMApiError:
            cls.device_components = None

    def setUp(self) -> None:
        """"""Test level setup.""""""
        super().setUp()
        self.experiments_to_delete = []
        self.results_to_delete = []
        self.jobs_to_cancel = []

    def tearDown(self):
        """"""Test level tear down.""""""
        for result_uuid in self.results_to_delete:
            try:
                with mock.patch(""builtins.input"", lambda _: ""y""):
                    self.service.delete_analysis_result(result_uuid)
            except Exception as err:  # pylint: disable=broad-except
                self.log.info(
                    ""Unable to delete analysis result %s: %s"", result_uuid, err
                )
        for expr_uuid in self.experiments_to_delete:
            try:
                with mock.patch(""builtins.input"", lambda _: ""y""):
                    self.service.delete_experiment(expr_uuid)
            except Exception as err:  # pylint: disable=broad-except
                self.log.info(""Unable to delete experiment %s: %s"", expr_uuid, err)
        for job in self.jobs_to_cancel:
            with contextlib.suppress(Exception):
                job.cancel()
        super().tearDown()

    def test_add_data_job(self):
        """"""Test add job to experiment data.""""""
        exp_data = ExperimentData(
            backend=self.backend,
            provider=self.provider,
            experiment_type=""qiskit_test"",
            service=self.service,
        )
        transpiled = transpile(bell(), self.backend)
        transpiled.metadata = {""foo"": ""bar""}
        job = self._run_circuit(transpiled)
        exp_data.add_jobs(job)
        self.assertEqual([job.job_id()], exp_data.job_ids)
        result = job.result()
        exp_data.block_for_results()
        circuit_data = exp_data.data(0)
        self.assertEqual(result.get_counts(0), circuit_data[""counts""])
        # currently the returned job_id is different; this is not a qiskit-ibm-experiment
        # problem but a known behaviour in the new provider
        # self.assertEqual(job.job_id(), circuit_data[""job_id""])
        self.assertEqual(transpiled.metadata, circuit_data[""metadata""])

    def test_new_experiment_data(self):
        """"""Test creating a new experiment data.""""""
        metadata = {""complex"": 2 + 3j, ""numpy"": np.zeros(2)}
        exp_data = ExperimentData(
            service=self.service,
            backend=self.backend,
            provider=self.provider,
            experiment_type=""qiskit_test"",
            tags=[""foo"", ""bar""],
            share_level=""hub"",
            metadata=metadata,
            notes=""some notes"",
        )

        job_ids = []
        for _ in range(2):
            job = self._run_circuit()
            exp_data.add_jobs(job)
            job_ids.append(job.job_id())

        exp_data.block_for_results().save(suppress_errors=False)
        self.experiments_to_delete.append(exp_data.experiment_id)

        hub, group, project = list(self.provider._hgps)[0].split(""/"")

        rexp = ExperimentData.load(exp_data.experiment_id, self.service)
        self._verify_experiment_data(exp_data, rexp)
        self.assertEqual(hub, rexp.hub)  # pylint: disable=no-member
        self.assertEqual(group, rexp.group)  # pylint: disable=no-member
        self.assertEqual(project, rexp.project)  # pylint: disable=no-member

    def test_update_experiment_data(self):
        """"""Test updating an experiment.""""""
        exp_data = self._create_experiment_data()

        for _ in range(2):
            job = self._run_circuit()
            exp_data.add_jobs(job)
        exp_data.tags = [""foo"", ""bar""]
        exp_data.share_level = ""hub""
        exp_data.notes = ""some notes""
        exp_data.block_for_results().save(suppress_errors=False)

        rexp = ExperimentData.load(exp_data.experiment_id, self.service)
        self._verify_experiment_data(exp_data, rexp)

    def _verify_experiment_data(self, expected, actual):
        """"""Verify the input experiment data.""""""
        self.assertEqual(expected.experiment_id, actual.experiment_id)
        self.assertEqual(expected.job_ids, actual.job_ids)
        self.assertEqual(expected.share_level, actual.share_level)
        self.assertEqual(expected.tags, actual.tags)
        self.assertEqual(expected.notes, actual.notes)
        self.assertEqual(
            expected.metadata.get(""complex"", {}), actual.metadata.get(""complex"", {})
        )
        self.assertTrue(actual.creation_datetime)
        self.assertTrue(getattr(actual, ""creation_datetime"").tzinfo)

    def test_add_analysis_results(self):
        """"""Test adding an analysis result.""""""
        exp_data = self._create_experiment_data()
        result_data = {""complex"": 2 + 3j, ""numpy"": np.zeros(2)}
        aresult = AnalysisResult(
            name=""qiskit_test"",
            value=result_data,
            device_components=self.device_components,
            experiment_id=exp_data.experiment_id,
            quality=""good"",
            tags=[""foo"", ""bar""],
            service=self.service,
        )
        exp_data.add_analysis_results(aresult)
        exp_data.save(suppress_errors=False)

        rresult = AnalysisResult.load(aresult.result_id, self.service)
        self.assertEqual(exp_data.experiment_id, rresult.experiment_id)
        self._verify_analysis_result(aresult, rresult)

    def test_update_analysis_result(self):
        """"""Test updating an analysis result.""""""
        aresult, exp_data = self._create_analysis_result()

        rdata = {""complex"": 2 + 3j, ""numpy"": np.zeros(2)}
        aresult.value = rdata
        aresult.quality = ""good""
        aresult.tags = [""foo"", ""bar""]
        aresult.save(suppress_errors=False)

        rexp = ExperimentData.load(exp_data.experiment_id, self.service)
        rresult = rexp.analysis_results(0)
        self._verify_analysis_result(aresult, rresult)

    def _verify_analysis_result(self, expected, actual):
        """"""Verify the input analysis result.""""""
        self.assertEqual(expected.result_id, actual.result_id)
        self.assertEqual(expected.name, actual.name)
        ecomp = {str(comp) for comp in expected.device_components}
        acomp = {str(comp) for comp in actual.device_components}
        self.assertEqual(ecomp, acomp)
        self.assertEqual(expected.experiment_id, actual.experiment_id)
        self.assertEqual(expected.quality, actual.quality)
        self.assertEqual(expected.tags, actual.tags)
        self.assertEqual(expected.value[""complex""], actual.value[""complex""])
        self.assertEqual(expected.value[""numpy""].all(), actual.value[""numpy""].all())

    def test_delete_analysis_result(self):
        """"""Test deleting an analysis result.""""""
        aresult, exp_data = self._create_analysis_result()
        with mock.patch(""builtins.input"", lambda _: ""y""):
            exp_data.delete_analysis_result(0)
            exp_data.save(suppress_errors=False)
        rexp = ExperimentData.load(exp_data.experiment_id, self.service)
        self.assertRaises(
            ExperimentEntryNotFound, rexp.analysis_results, aresult.result_id
        )
        self.assertRaises(
            IBMExperimentEntryNotFound, self.service.analysis_result, aresult.result_id
        )

    def test_add_figures(self):
        """"""Test adding a figure to the experiment data.""""""
        exp_data = self._create_experiment_data()
        hello_bytes = str.encode(""hello world"")

        sub_tests = [""hello.svg"", None]

        for idx, figure_name in enumerate(sub_tests):
            with self.subTest(figure_name=figure_name):
                exp_data.add_figures(
                    figures=hello_bytes, figure_names=figure_name, save_figure=True
                )
                rexp = ExperimentData.load(exp_data.experiment_id, self.service)
                self.assertEqual(rexp.figure(idx).figure, hello_bytes)

    def test_add_figures_plot(self):
        """"""Test adding a matplotlib figure.""""""
        import matplotlib.pyplot as plt

        figure, axes = plt.subplots()
        axes.plot([1, 2, 3])

        exp_data = self._create_experiment_data()
        exp_data.add_figures(figure, save_figure=True)

        rexp = ExperimentData.load(exp_data.experiment_id, self.service)
        self.assertTrue(rexp.figure(0))

    def test_add_figures_file(self):
        """"""Test adding a figure file.""""""
        exp_data = self._create_experiment_data()
        hello_bytes = str.encode(""hello world"")
        file_name = ""hello_world.svg""
        self.addCleanup(os.remove, file_name)
        with open(file_name, ""wb"") as file:
            file.write(hello_bytes)

        exp_data.add_figures(figures=file_name, save_figure=True)
        rexp = ExperimentData.load(exp_data.experiment_id, self.service)
        self.assertEqual(rexp.figure(0).figure, hello_bytes)

    def test_update_figure(self):
        """"""Test updating a figure.""""""
        exp_data = self._create_experiment_data()
        hello_bytes = str.encode(""hello world"")
        figure_name = ""hello.svg""

        exp_data.add_figures(
            figures=hello_bytes, figure_names=figure_name, save_figure=True
        )
        self.assertEqual(exp_data.figure(0).figure, hello_bytes)

        friend_bytes = str.encode(""hello friend"")
        exp_data.add_figures(
            figures=friend_bytes,
            figure_names=figure_name,
            overwrite=True,
            save_figure=True,
        )
        rexp = ExperimentData.load(exp_data.experiment_id, self.service)
        self.assertEqual(rexp.figure(0).figure, friend_bytes)
        self.assertEqual(rexp.figure(figure_name).figure, friend_bytes)

    def test_delete_figure(self):
        """"""Test deleting a figure.""""""
        exp_data = self._create_experiment_data()
        hello_bytes = str.encode(""hello world"")
        figure_name = ""hello.svg""

        exp_data.add_figures(
            figures=hello_bytes, figure_names=figure_name, save_figure=True
        )
        with mock.patch(""builtins.input"", lambda _: ""y""):
            exp_data.delete_figure(0)
            exp_data.save(suppress_errors=False)

        rexp = ExperimentData.load(exp_data.experiment_id, self.service)
        self.assertRaises(IBMExperimentEntryNotFound, rexp.figure, figure_name)
        self.assertRaises(
            IBMExperimentEntryNotFound,
            self.service.figure,
            exp_data.experiment_id,
            figure_name,
        )

    def test_save_all(self):
        """"""Test saving all.""""""
        exp_data = self._create_experiment_data()
        exp_data.tags = [""foo"", ""bar""]
        aresult = AnalysisResult(
            value={},
            name=""qiskit_test"",
            device_components=self.device_components,
            experiment_id=exp_data.experiment_id,
        )
        exp_data.add_analysis_results(aresult)
        hello_bytes = str.encode(""hello world"")
        exp_data.add_figures(hello_bytes, figure_names=""hello.svg"")
        exp_data.save(suppress_errors=False)

        rexp = ExperimentData.load(exp_data.experiment_id, self.service)
        # Experiment tag order is not necessarily preserved
        # so compare tags with a predictable sort order.
        self.assertEqual([""bar"", ""foo""], sorted(rexp.tags))
        self.assertEqual(aresult.result_id, rexp.analysis_results(0).result_id)
        self.assertEqual(hello_bytes, rexp.figure(0).figure)

        exp_data.delete_analysis_result(0)
        exp_data.delete_figure(0)
        with mock.patch(""builtins.input"", lambda _: ""y""):
            exp_data.save(suppress_errors=False)

        rexp = ExperimentData.load(exp_data.experiment_id, self.service)
        self.assertRaises(IBMExperimentEntryNotFound, rexp.figure, ""hello.svg"")
        self.assertRaises(
            ExperimentEntryNotFound, rexp.analysis_results, aresult.result_id
        )

    def test_set_service_job(self):
        """"""Test setting service with a job.""""""
        exp_data = ExperimentData(experiment_type=""qiskit_test"", service=self.service)
        job = self._run_circuit()
        exp_data.add_jobs(job)
        exp_data.save(suppress_errors=False)
        self.experiments_to_delete.append(exp_data.experiment_id)

        rexp = self.service.experiment(exp_data.experiment_id)
        self.assertEqual([job.job_id()], rexp.job_ids)

    def test_auto_save_experiment(self):
        """"""Test auto save.""""""
        exp_data = self._create_experiment_data()
        exp_data.auto_save = True

        subtests = [
            (
                setattr,
                (
                    exp_data,
                    ""tags"",
                    [""foo""],
                ),
            ),
            (setattr, (exp_data, ""notes"", ""foo"")),
            (setattr, (exp_data, ""share_level"", ""hub"")),
        ]

        for func, params in subtests:
            with self.subTest(func=func):
                with mock.patch.object(
                    IBMExperimentService,
                    ""create_or_update_experiment"",
                    wraps=exp_data.service.create_or_update_experiment,
                ) as mocked:
                    func(*params)
                    mocked.assert_called_once()
                    data = mocked.call_args[0][0]
                    self.assertEqual(exp_data.experiment_id, data.experiment_id)
                    mocked.reset_mock()

    def test_auto_save_figure(self):
        """"""Test auto saving figure.""""""
        exp_data = self._create_experiment_data()
        exp_data.auto_save = True
        figure_name = ""hello.svg""

        with mock.patch.object(
            IBMExperimentService,
            ""update_experiment"",
            wraps=exp_data.service.update_experiment,
        ) as mocked_exp:
            with mock.patch.object(
                IBMExperimentService,
                ""create_figure"",
                wraps=exp_data.service.create_figure,
            ) as mocked_fig:
                exp_data.add_figures(
                    str.encode(""hello world""), figure_names=figure_name
                )
                mocked_exp.assert_called_once()
                mocked_fig.assert_called_once()
                mocked_exp.reset_mock()

            with mock.patch.object(
                IBMExperimentService,
                ""update_figure"",
                wraps=exp_data.service.update_figure,
            ) as mocked_fig:
                exp_data.add_figures(
                    str.encode(""hello friend""), figure_names=figure_name, overwrite=True
                )
                mocked_fig.assert_called_once()
                mocked_exp.assert_called_once()
                mocked_exp.reset_mock()

            with mock.patch.object(
                IBMExperimentService,
                ""delete_figure"",
                wraps=exp_data.service.delete_figure,
            ) as mocked_fig, mock.patch(""builtins.input"", lambda _: ""y""):
                exp_data.delete_figure(figure_name)
                mocked_fig.assert_called_once()
                mocked_exp.assert_called_once()

    def test_auto_save_analysis_result(self):
        """"""Test auto saving analysis result.""""""
        exp_data = self._create_experiment_data()
        exp_data.auto_save = True
        aresult = AnalysisResult(
            value={},
            name=""qiskit_test"",
            device_components=self.device_components,
            experiment_id=exp_data.experiment_id,
            service=self.service,
        )

        with mock.patch.object(
            IBMExperimentService,
            ""update_experiment"",
            wraps=exp_data.service.update_experiment,
        ) as mocked_exp:
            with mock.patch.object(
                IBMExperimentService,
                ""create_or_update_analysis_result"",
                wraps=exp_data.service.create_or_update_analysis_result,
            ) as mocked_res:
                exp_data.add_analysis_results(aresult)
                mocked_exp.assert_called_once()
                mocked_res.assert_called_once()
                mocked_exp.reset_mock()

    def test_auto_save_analysis_result_update(self):
        """"""Test auto saving analysis result updates.""""""
        aresult, exp_data = self._create_analysis_result()
        aresult.auto_save = True

        subtests = [
            (""tags"", [""foo""]),
            (""value"", {""foo"": ""bar""}),
            (""quality"", ""GOOD""),
        ]
        for attr, value in subtests:
            with self.subTest(attr=attr):
                with mock.patch.object(
                    IBMExperimentService,
                    ""create_or_update_analysis_result"",
                    wraps=exp_data.service.create_or_update_analysis_result,
                ) as mocked:
                    setattr(aresult, attr, value)
                    mocked.assert_called_once()
                    data = mocked.call_args[0][0]
                    self.assertEqual(aresult.result_id, data.result_id)
                    mocked.reset_mock()

    def test_block_for_results(self):
        """"""Test blocking for jobs""""""
        exp_data = ExperimentData(
            backend=self.backend,
            provider=self.provider,
            experiment_type=""qiskit_test"",
            service=self.service,
        )
        jobs = []
        for _ in range(2):
            job = self._run_circuit()
            exp_data.add_jobs(job)
            jobs.append(job)
        exp_data.block_for_results()
        self.assertTrue(all(job.status() == JobStatus.DONE for job in jobs))
        self.assertEqual(ExperimentStatus.DONE, exp_data.status())

    def test_file_upload_download(self):
        """"""test upload and download of actual experiment data""""""
        exp_id = self._create_experiment_data().experiment_id
        qc = QuantumCircuit(2)
        qc.h(0)
        qc.measure_all()
        data = {""string"": ""b-string"", ""int"": 10, ""float"": 0.333, ""circuit"": qc}
        json_filename = ""data.json""

        self.service.file_upload(
            exp_id, json_filename, data, json_encoder=ExperimentEncoder
        )
        rjson_data = self.service.file_download(
            exp_id, json_filename, json_decoder=ExperimentDecoder
        )
        self.assertEqual(data, rjson_data)

    def _create_experiment_data(self):
        """"""Create an experiment data.""""""
        exp_data = ExperimentData(
            backend=self.backend,
            provider=self.provider,
            experiment_type=""qiskit_test"",
            verbose=False,
            service=self.service,
        )
        exp_data.save(suppress_errors=False)
        self.experiments_to_delete.append(exp_data.experiment_id)
        return exp_data

    def _create_analysis_result(self):
        """"""Create a simple analysis result.""""""
        exp_data = self._create_experiment_data()
        aresult = AnalysisResult(
            value={},
            name=""qiskit_test"",
            device_components=self.device_components,
            experiment_id=exp_data.experiment_id,
            service=self.service,
        )
        exp_data.add_analysis_results(aresult)
        exp_data.save(suppress_errors=False)
        self.results_to_delete.append(aresult.result_id)
        return aresult, exp_data

    def _run_circuit(self, circuit=None):
        """"""Run a circuit.""""""
        circuit = circuit or self.circuit
        job = self.backend.run(circuit, shots=1)
        self.jobs_to_cancel.append(job)
        return job


if __name__ == ""__main__"":
    unittest.main()
"
https://github.com/Qiskit-Extensions/qiskit-ibm-experiment,Qiskit-Extensions,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Templates for use with unit tests.""""""

RUNTIME_PROGRAM = """"""
import random
import time
import warnings
import logging

from qiskit import transpile
from qiskit.circuit.random import random_circuit

logger = logging.getLogger(""qiskit-test"")

def prepare_circuits(backend):
    circuit = random_circuit(num_qubits=5, depth=4, measure=True,
                             seed=random.randint(0, 1000))
    return transpile(circuit, backend)

def main(backend, user_messenger, **kwargs):
    iterations = kwargs['iterations']
    sleep_per_iteration = kwargs.pop('sleep_per_iteration', 0)
    interim_results = kwargs.pop('interim_results', {})
    final_result = kwargs.pop(""final_result"", {})
    for it in range(iterations):
        time.sleep(sleep_per_iteration)
        qc = prepare_circuits(backend)
        user_messenger.publish({""iteration"": it, ""interim_results"": interim_results})
        backend.run(qc).result()

    user_messenger.publish(final_result, final=True)
    print(""this is a stdout message"")
    warnings.warn(""this is a stderr message"")
    logger.info(""this is an info log"")
    """"""

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program"",
}
PROGRAM_PREFIX = ""qiskit-test""
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"import qiskit_qasm3_import

project = 'Qiskit OpenQASM 3 Importer'
copyright = '2022, Jake Lishman'
author = 'Jake Lishman'
version = qiskit_qasm3_import.__version__
release = qiskit_qasm3_import.__version__

extensions = [
    ""sphinx.ext.autodoc"",
    ""sphinx.ext.intersphinx"",
    ""reno.sphinxext"",
    'qiskit_sphinx_theme',
]
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']

# Document the docstring for the class and the __init__ method together.
autoclass_content = ""both""

html_theme = ""qiskit-ecosystem""
html_title = f""{project} {release}""

intersphinx_mapping = {
    ""qiskit-terra"": (""https://docs.quantum.ibm.com/api/qiskit/"", None),
}
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""A base class for circuit solvers of cold atomic quantum circuits.""""""

from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any
import warnings
import numpy as np
from scipy.sparse import csc_matrix, identity, SparseEfficiencyWarning
from scipy.sparse.linalg import expm

from qiskit import QuantumCircuit
from qiskit.circuit import Gate
from qiskit_nature.second_q.operators import SparseLabelOp
from qiskit_cold_atom.exceptions import QiskitColdAtomError


class BaseCircuitSolver(ABC):
    """"""An abstract class for circuit solvers of different cold atom types.

    By subclassing BaseCircuitSolver one can create circuit solvers for different
    types of cold atomic setups such as spin, fermionic, and bosonic setups. All
    these subclasses will simulate cold atom quantum circuits by exponentiating
    matrices. Therefore, subclasses of BaseCircuitSolver are not intended to solve
    large circuits.
    """"""

    def __init__(
        self,
        shots: Optional[int] = None,
        seed: Optional[int] = None,
        max_dimension: int = 1e6,
        ignore_barriers: bool = True,
    ):
        """"""
        Args:
            shots: amount of shots for the measurement simulation;
                   if not None, measurements are performed, otherwise no measurements are done.
            seed: seed for the RNG for the measurement simulation
            max_dimension: The maximum Hilbert space dimension (limited to keep
                computation times reasonably short)
            ignore_barriers: If true, will ignore barrier instructions
        """"""
        self.shots = shots

        self._seed = seed
        if self._seed is not None:
            np.random.seed(self._seed)

        self._max_dimension = max_dimension
        self._ignore_barriers = ignore_barriers
        self._dim = None

    @property
    def seed(self) -> int:
        """"""The seed for the random number generator of the measurement simulation.""""""
        return self._seed

    @seed.setter
    def seed(self, value: int):
        """"""Set the seed for the random number generator. This will also update numpy's seed.""""""
        np.random.seed(value)
        self._seed = value

    @property
    def max_dimension(self) -> int:
        """"""The maximal Hilbert space dimension of the simulation.""""""
        return self._max_dimension

    @max_dimension.setter
    def max_dimension(self, value: int):
        self._max_dimension = value

    @property
    def ignore_barriers(self) -> bool:
        """"""Boolean flag that defines how barrier instructions in the circuit are handled.""""""
        return self._ignore_barriers

    @property
    def dim(self) -> int:
        """"""Return the dimension set by the last quantum circuit on which the solver was called.""""""
        return self._dim

    @ignore_barriers.setter
    def ignore_barriers(self, boolean):
        self._ignore_barriers = boolean

    def __call__(self, circuit: QuantumCircuit) -> Dict[str, Any]:
        """"""
        Performs the simulation of the circuit: Each operator is converted into a sparse matrix
        over the basis and is then exponentiated to get the unitary of the gate. All these
        unitaries are multiplied to give the total unitary of the circuit. Applying this to the
        initial state yields the final state of the circuit, from which we sample a number `shots`
        of shots (if specified).

        Args:
            circuit: A quantum circuit with gates described by second quantized generators

        Returns:
            output: dict{'unitary' : np.array((dimension, dimension)),
                 'statevector': np.array((dimension, 1)),
                 'counts': dict{string: int}}

        Raises:
            QiskitColdAtomError:
                - If one of the generating Hamiltonians is not hermitian which would
                lead to non-unitary time evolution.
                - If the dimension of the Hilbert space is larger than the max. dimension.
            NotImplementedError:
                - If ignore_barriers is False.
        """"""

        self.preprocess_circuit(circuit)

        if self._dim > self.max_dimension:
            raise QiskitColdAtomError(
                f""Hilbert space dimension of the simulation ({self._dim}) exceeds the ""
                f""maximally supported value {self.max_dimension}.""
            )

        # initialize the circuit unitary as an identity matrix
        circuit_unitary = identity(self._dim, dtype=complex)

        for op in self.to_operators(circuit):
            operator_mat = self.operator_to_mat(op)

            # check that the operators are hermitian before exponentiating
            if (operator_mat.H - operator_mat).count_nonzero() != 0:
                raise QiskitColdAtomError(""generator of unitary gate is not hermitian!"")
            # with the next release of qiskit nature this can be replaced with
            # if not operator.is_hermitian():
            #     raise QiskitColdAtomError(""generator of unitary gate is not hermitian!"")

            with warnings.catch_warnings():
                warnings.filterwarnings(""ignore"", category=SparseEfficiencyWarning)
                gate_unitary = expm(-1j * operator_mat)

            circuit_unitary = gate_unitary @ circuit_unitary

        final_state = circuit_unitary @ self.get_initial_state(circuit)

        output = {
            ""unitary"": circuit_unitary.toarray(),
            ""statevector"": final_state.toarray().reshape(self._dim),
        }

        # If shots is specified, simulate measurements on the entire register!
        if self.shots is not None:
            meas_distr = np.abs(final_state.toarray().reshape(self._dim)) ** 2

            if not np.isclose(sum(meas_distr), 1.0):
                raise QiskitColdAtomError(""Final statevector is not normalized"")

            meas_results = self.draw_shots(meas_distr)
            counts_dict = {
                outcome: list(meas_results).count(outcome) for outcome in set(meas_results)
            }
            output[""memory""] = meas_results
            output[""counts""] = counts_dict

        # return empty memory and counts dictionary if no shots are specified
        else:
            output[""memory""] = []
            output[""counts""] = {}

        return output

    def to_operators(self, circuit: QuantumCircuit) -> List[SparseLabelOp]:
        """"""
        Convert a circuit to a list of second quantized operators that describe the generators of the
        gates applied to the circuit. The SparseLabelOps generating the gates are embedded in the
        larger space corresponding to the entire circuit.

        Args:
            circuit: A quantum circuit with gates described by second quantized generators

        Returns:
            operators: a list of second-quantized operators, one for each applied gate, in the order
            of the gates in the circuit

        Raises:
            QiskitColdAtomError: - If a given gate can not be converted into a second-quantized operator
                         - If a gate is applied after a measurement instruction
                         - If a circuit instruction other than a Gate, measure, load or barrier is given
            NotImplementedError: If ignore_barriers is False
        """"""
        operators = []
        measured = [False] * circuit.num_qubits

        for inst in circuit.data:
            name = inst[0].name
            qargs = [circuit.qubits.index(qubit) for qubit in inst[1]]

            if name == ""measure"":
                for idx in qargs:
                    measured[idx] = True

            elif name == ""load"":
                continue

            elif name == ""barrier"":
                if self.ignore_barriers:
                    continue
                raise NotImplementedError

            elif isinstance(inst[0], Gate):
                try:
                    second_quantized_op = inst[0].generator
                except AttributeError as attribute_error:
                    raise QiskitColdAtomError(
                        f""Gate {inst[0].name} has no defined generator""
                    ) from attribute_error

                if not isinstance(second_quantized_op, SparseLabelOp):
                    raise QiskitColdAtomError(
                        ""Gate generator needs to be initialized as qiskit_nature SparseLabelOp""
                    )
                for idx in qargs:
                    if measured[idx]:
                        raise QiskitColdAtomError(
                            f""Simulator cannot handle gate {name} after previous measure instruction.""
                        )

                if not second_quantized_op.register_length == len(qargs):
                    raise QiskitColdAtomError(
                        f""length of operator labels {second_quantized_op.register_length} must be ""
                        f""equal to length of wires {len(qargs)} the gate acts on""
                    )
                operators.append(
                    self._embed_operator(second_quantized_op, circuit.num_qubits, qargs)
                )

            else:
                raise QiskitColdAtomError(f""Unknown instruction {name} applied to circuit"")

        return operators

    @abstractmethod
    def get_initial_state(self, circuit: QuantumCircuit) -> csc_matrix:
        """"""Returns the initial state of the quantum circuit as a sparse column vector.""""""

    @abstractmethod
    def _embed_operator(
        self, operator: SparseLabelOp, num_wires: int, qargs: List[int]
    ) -> SparseLabelOp:
        """"""
        Turning an operator that acts on the wires given in qargs into an operator
        that acts on the entire state space of a circuit. The implementation of the subclasses
        depends on whether the operators use sparse labels (SpinOp) or dense labels (FermionicOp).

        Args:
            operator: SparseLabelOp describing the generating Hamiltonian of a gate
            num_wires: number of wires of the space in which to embed the operator
            qargs: The wire indices the gate acts on

        Returns: A SparseLabelOp acting on the entire quantum register of the Circuit
        """"""

    @abstractmethod
    def operator_to_mat(self, operator: SparseLabelOp) -> csc_matrix:
        """"""Turn a SparseLabelOp into a sparse matrix.""""""

    @abstractmethod
    def preprocess_circuit(self, circuit: QuantumCircuit):
        """"""Pre-process the circuit, e.g. initialize the basis and validate.
        This needs to update ``dim``, i.e. the Hilbert space dimension of the solver.""""""

    @abstractmethod
    def draw_shots(self, measurement_distribution: List[float]) -> List[str]:
        """"""
        Simulates shots by drawing from a given distribution of measurement outcomes.
        Assigning the index of each outcome to the occupations of the modes can be
        non-trivial which is why this step needs to be implemented by the subclasses.

        Args:
            measurement_distribution: A list with the probabilities of the different
                measurement outcomes that has the length of the Hilbert space dimension.

        Returns:
            A list of strings encoding the outcome of the individual shots.
        """"""
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Module to convert cold atom circuits to dictionaries that can be sent to backends.""""""

from typing import List, Union, Optional
from enum import Enum

from qiskit import QuantumCircuit
from qiskit.providers import BackendV1 as Backend
from qiskit_cold_atom.exceptions import QiskitColdAtomError


class WireOrder(str, Enum):
    """"""The possible wire orderings for cold atomic circuits.

    For example, a sequential register [0, 1, 2, 3, 4, 5] with two species implies that wires 0, 1, 2
    are of the same type while an interleaved ordering implies that wires 0, 2, and 4 are of the
    same type.
    """"""

    SEQUENTIAL = ""sequential""
    INTERLEAVED = ""interleaved""


class CircuitTools:
    """"""A class to provide tooling for cold-atomic circuits.

    Since all methods are class methods this class does not need to be instantiated. This
    class groups tools for cold atomic circuits. It also makes clear the ordering of the
    fermionic wires that qiskit works with.
    """"""

    # Qiskit for fermions works with a sequential register definition. For fermionic
    # modes with more than on species the circuits will have a corresponding number of
    # sequential registers with the same length. For example, a three site system with two
    # species will have two sequential registers with three wires each. Other packages may
    # use an ""interleaved"" wire order.
    __wire_order__ = WireOrder(""sequential"")

    @classmethod
    def validate_circuits(
        cls,
        circuits: Union[List[QuantumCircuit], QuantumCircuit],
        backend: Backend,
        shots: Optional[int] = None,
        convert_wires: bool = True,
    ) -> None:
        """"""
        Performs validity checks on circuits against the configuration of the backends. This checks
        whether all applied instructions in the circuit are accepted by the backend and whether the
        applied gates comply with their respective coupling maps.

        Args:
            circuits: The circuits that need to be run.
            backend: The backend on which the circuit should be run.
            shots: The number of shots for each circuit.
            convert_wires: If True, the circuits are converted to the wiring convention of the backend.

        Raises:
            QiskitColdAtomError: If the maximum shot number specified by the backend is exceeded.
            QiskitColdAtomError: If the backend does not support an instruction in the circuit.
            QiskitColdAtomError: If the width of the circuit is too large.
            QiskitColdAtomError: If the circuit has unbound parameters.
        """"""

        if isinstance(circuits, QuantumCircuit):
            circuits = [circuits]

        # check for number of experiments allowed by the backend
        if backend.configuration().max_experiments:
            max_circuits = backend.configuration().max_experiments
            if len(circuits) > max_circuits:
                raise QiskitColdAtomError(
                    f""{backend.name()} allows for max. {max_circuits} different circuits; ""
                    f""but {len(circuits)} circuits were given""
                )
        # check for number of individual shots allowed by the backend
        if backend.configuration().max_shots and shots:
            max_shots = backend.configuration().max_shots
            if shots > max_shots:
                raise QiskitColdAtomError(
                    f""{backend.name()} allows for max. {max_shots} shots per circuit; ""
                    f""{shots} shots were requested""
                )

        config_dict = backend.configuration().to_dict()

        for circuit in circuits:
            try:
                native_gates = {
                    gate.name: gate.coupling_map for gate in backend.configuration().gates
                }
                native_instructions = backend.configuration().supported_instructions
            except NameError as name_error:
                raise QiskitColdAtomError(
                    ""backend needs to be initialized with config file first""
                ) from name_error

            if circuit.num_qubits > backend.configuration().num_qubits:
                raise QiskitColdAtomError(
                    f""{backend.name()} supports circuits with up to ""
                    f""{backend.configuration().num_qubits} wires, but""
                    f""{circuit.num_qubits} wires were given.""
                )

            # If num_species is specified by the backend, the wires describe different atomic species
            # and the circuit's wire count must be a multiple of the number of species.
            num_species = None
            wire_order = None
            if ""num_species"" in config_dict and convert_wires:
                num_species = backend.configuration().num_species
                if ""wire_order"" in config_dict:
                    wire_order = WireOrder(backend.configuration().wire_order)
                else:
                    wire_order = cls.__wire_order__

                if num_species > 1 and circuit.num_qubits % num_species:
                    raise QiskitColdAtomError(
                        f""{backend.name()} requires circuits to be submitted with a multiple of ""
                        f""{num_species} wires, but {circuit.num_qubits} wires were given.""
                    )

            for inst in circuit.data:
                # get the correct wire indices of the instruction with respect
                # to the total index of the qubit objects in the circuit
                wires = [circuit.qubits.index(qubit) for qubit in inst[1]]

                for param in inst[0].params:
                    try:
                        float(param)
                    except TypeError as type_error:
                        raise QiskitColdAtomError(
                            ""Cannot run circuit with unbound parameters.""
                        ) from type_error

                # check if instruction is supported by the backend
                name = inst[0].name
                if name not in native_instructions:
                    raise QiskitColdAtomError(f""{backend.name()} does not support {name}"")

                # for the gates, check whether coupling map fits
                if name in native_gates:
                    couplings = native_gates[name]

                    if num_species and convert_wires:
                        wires = cls.convert_wire_order(
                            wires,
                            convention_from=cls.__wire_order__,
                            convention_to=wire_order,
                            num_species=num_species,
                            num_sites=circuit.num_qubits // num_species,
                            sort=True,
                        )

                    if wires not in couplings:
                        raise QiskitColdAtomError(
                            f""coupling {wires} not supported for gate ""
                            f""{name} on {backend.name()}; possible couplings: {couplings}""
                        )

    @classmethod
    def circuit_to_data(
        cls, circuit: QuantumCircuit, backend: Backend, convert_wires: bool = True
    ) -> List[List]:
        """"""Convert the circuit to JSON serializable instructions.

        Helper function that converts a QuantumCircuit into a list of symbolic
        instructions as required by the Json format which is sent to the backend.

        Args:
            circuit: The quantum circuit for which to extract the instructions.
            backend: The backend on which the circuit should be run.
            convert_wires: If True, the circuits are converted to the wiring convention of the backend.

        Returns:
            A list of lists describing the instructions in the circuit. Each sublist
            has three entries the name of the instruction, the wires that the instruction
            applies to and the parameter values of the instruction.
        """"""

        instructions = []

        config_dict = backend.configuration().to_dict()
        num_species = None
        wire_order = None
        if ""num_species"" in config_dict:
            num_species = backend.configuration().num_species
            if ""wire_order"" in config_dict:
                wire_order = WireOrder(backend.configuration().wire_order)
            else:
                wire_order = cls.__wire_order__

        for inst in circuit.data:
            name = inst[0].name
            wires = [circuit.qubits.index(qubit) for qubit in inst[1]]
            if num_species and convert_wires:
                wires = cls.convert_wire_order(
                    wires,
                    convention_from=cls.__wire_order__,
                    convention_to=wire_order,
                    num_species=num_species,
                    num_sites=circuit.num_qubits // num_species,
                    sort=True,
                )
            params = [float(param) for param in inst[0].params]
            instructions.append([name, wires, params])

        return instructions

    @classmethod
    def circuit_to_cold_atom(
        cls,
        circuits: Union[List[QuantumCircuit], QuantumCircuit],
        backend: Backend,
        shots: int = 60,
        convert_wires: bool = True,
    ) -> dict:
        """"""
        Converts a circuit to a JSon payload to be sent to a given backend.

        Args:
            circuits: The circuits that need to be run.
            backend: The backend on which the circuit should be run.
            shots: The number of shots for each circuit.
            convert_wires: If True, the circuits are converted to the wiring convention of the backend.

        Returns:
            A list of dicts.
        """"""
        if isinstance(circuits, QuantumCircuit):
            circuits = [circuits]

        # validate the circuits against the backend configuration
        cls.validate_circuits(
            circuits=circuits, backend=backend, shots=shots, convert_wires=convert_wires
        )

        if ""wire_order"" in backend.configuration().to_dict():
            wire_order = WireOrder(backend.configuration().wire_order)
        else:
            wire_order = cls.__wire_order__

        experiments = {}
        for idx, circuit in enumerate(circuits):
            experiments[""experiment_%i"" % idx] = {
                ""instructions"": cls.circuit_to_data(
                    circuit, backend=backend, convert_wires=convert_wires
                ),
                ""shots"": shots,
                ""num_wires"": circuit.num_qubits,
                ""wire_order"": wire_order,
            }

        return experiments

    @classmethod
    def convert_wire_order(
        cls,
        wires: List[int],
        convention_from: WireOrder,
        convention_to: WireOrder,
        num_sites: int,
        num_species: int,
        sort: Optional[bool] = False,
    ) -> List[int]:
        """"""
        Converts a list of wire indices onto which a gate acts from one convention to another.
        Possible conventions are ""sequential"", where the first num_sites wires denote the
        first species, the second num_sites wires denote the second species etc., and ""interleaved"",
        where the first num_species wires denote the first site, the second num_species wires denote
        the second site etc.

        Args:
            wires: Wires onto which a gate acts, e.g. [3, 4, 7, 8].
            convention_from: The convention in which ""wires"" is given.
            convention_to: The convention into which to convert.
            num_sites: The total number of sites.
            num_species: The number of different atomic species.
            sort: If true, the returned list of indices is sorted in ascending order.

        Raises:
            QiskitColdAtomError: If the convention to and from is not supported.

        Returns:
            A list of wire indices following the convention_to.
        """"""
        if (convention_to or convention_from) not in WireOrder:
            raise QiskitColdAtomError(
                f""Wire order conversion from {convention_from} to {convention_to}""
                f"" is not supported.""
            )

        new_wires = None

        if convention_from == convention_to:
            new_wires = wires

        if convention_from == WireOrder.SEQUENTIAL and convention_to == WireOrder.INTERLEAVED:
            new_wires = [idx % num_sites * num_species + idx // num_sites for idx in wires]

        elif convention_from == WireOrder.INTERLEAVED and convention_to == WireOrder.SEQUENTIAL:
            new_wires = [idx % num_species * num_sites + idx // num_species for idx in wires]

        if sort:
            return sorted(new_wires)
        else:
            return new_wires
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

r""""""
.. image:: ../images/qiskit_cold_atom_logo_with_text.svg
   :alt: Missing Logo

==================================================
Qiskit Cold Atom module (:mod:`qiskit_cold_atom`)
==================================================

.. currentmodule:: qiskit_cold_atom

The Qiskit Cold Atom module provides functionality to describe quantum systems of trapped cold atoms
in a gate- and circuit-based framework.

Traditionally, each wire in a quantum circuit represents one qubit as the fundamental unit of information
processing. Here, we extend this concept and allow wires to represent individual internal states of
trapped cold atoms. This currently covers two settings, one for fermionic modes and one for spin
modes.

In a fermionic setting, each wire of a quantum circuit represents an abstract fermionic mode in second
quantization which can either be occupied (1) or empty (0). Such systems are realized experimentally by
individual fermionic atoms trapped in arrays of optical tweezers. Circuit instructions and backends
to interact with and simulate such circuits are given by the :mod:`qiskit_cold_atom.fermions` module.

In a spin setting, each wire of a quantum circuit represents a quantum mechanical spin of a given length
:math:`S`. Upon measurement, each spin is measured in one of its :math:`2S+1` internal basis states
labelled :math:`0` to :math:`2S`, thus it can be thought of as a qudit with dimension :math:`d = 2S+1`.
This setting describes the collective spin of bosonic atoms trapped in a Bose-Einstein-condensate.
Circuit instructions and backends to interact with and simulate such circuits are provided by the
:mod:`qiskit_cold_atom.spins` module.

The quantum circuits that these systems can implement thus utilize a fundamentally different form of
quantum information processing compared to qubits. Therefore, the typical qubit gates can not be applied
to these circuits. Instead, the fermions and spin modules define their own gate sets which are defined
by their second-quantized Hamiltonians that generate the unitary gate. Note that loading the
:mod:`qiskit_cold_atom.fermions` or :mod:`qiskit_cold_atom.spins` module will decorate the
:class:`QuantumCircuit` class in Qiskit by adding methods to call pre-defined fermionic and spin gates,
respectively.

To enable the control of real quantum hardware, the :mod:`qiskit_cold_atom.providers`
module contains a provider which enables access to cold atomic device backends.

The top-level classes and submodules of qiskit_cold_atom are:

.. autosummary::
   :toctree: ../stubs/
   :nosignatures:

   QiskitColdAtomError

Submodules
==========

.. autosummary::
   :toctree:

   applications
   fermions
   providers
   spins

""""""
from functools import wraps
from qiskit import QuantumCircuit
from qiskit_cold_atom.exceptions import QiskitColdAtomError


def add_gate(func):
    """"""Decorator to add a gate method to the QuantumCircuit class""""""

    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)

    setattr(QuantumCircuit, func.__name__, wrapper)

    return func


__version__ = ""0.1.0""

__all__ = [""__version__"", ""QiskitColdAtomError"", ""add_gate""]
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Class that holds a fermionic time-evolution problem.""""""

from typing import List, Union

from qiskit import QuantumCircuit
from qiskit_nature.second_q.operators import FermionicOp

from qiskit_cold_atom.fermions.fermionic_state import FermionicState
from qiskit_cold_atom.fermions.fermionic_basis import FermionicBasis
from qiskit_cold_atom.fermions.fermion_gate_library import FermionicGate
from qiskit_cold_atom.exceptions import QiskitColdAtomError
from qiskit_cold_atom.applications.fermi_hubbard import FermionicLattice


class FermionicEvolutionProblem:
    """"""
    Problem class corresponding to evaluating an observable of a fermionic system after a time
    evolution under a hamiltonian from an initial state in an occupation number representation.
    """"""

    def __init__(
        self,
        system: FermionicLattice,
        initial_state: FermionicState,
        evolution_times: Union[float, List[float]],
        observable: FermionicOp,
    ):
        """"""
        Initialize a fermionic time evolution problem.

        Args:
            system: The fermionic system under which the initial state will evolve.
            initial_state: The fermionic state at time t=0.
            evolution_times: List of times (or single time) after which the observable is measured.
            observable: The observable to measure after the time evolution, given as a FermionicOp.
                        The observable must be diagonal in the fermionic occupation number basis.

        Raises:
            QiskitColdAtomError: - If the sizes of the system, initial state and the observable
                                   do not match.
                                 - If the observables is not diagonal in the fermionic occupation number
                                   basis
        """"""

        if system.size != initial_state.sites:
            raise QiskitColdAtomError(
                f""The size of the system {system.size} does not match ""
                f""the size of the initial state {initial_state.sites}.""
            )

        if 2 * system.size != observable.register_length:
            raise QiskitColdAtomError(
                f""The fermionic modes of the system {2*system.size} do not match ""
                f""the size of the observable {observable.register_length}.""
            )

        # check if matrix is diagonal
        # can later be replaced when the FermionicOp from qiskit-nature has its own .to_matrix() method
        basis = FermionicBasis.from_fermionic_op(observable)
        observable_mat = FermionicGate.operator_to_mat(observable, num_species=1, basis=basis)

        if list(observable_mat.nonzero()[0]) != list(observable_mat.nonzero()[1]):
            raise QiskitColdAtomError(
                ""The fermionic observable needs to be diagonal in the computational basis, ""
                ""as measuring general, non-diagonal observables is not yet implemented for ""
                ""fermionic backends. This requires non-trivial basis transformations that ""
                ""are in general difficult to find and depend on the backend's native gate set.""
            )

        self._system = system
        self._initial_state = initial_state
        self._evolution_times = evolution_times
        self._observable = observable

    @property
    def system(self) -> FermionicLattice:
        """"""Return the system of the problem.""""""
        return self._system

    @property
    def initial_state(self) -> FermionicState:
        """"""Return the initial state of the system.""""""
        return self._initial_state

    @property
    def evolution_times(self) -> List[float]:
        """"""Return the evolution times to simulate.""""""
        return self._evolution_times

    @property
    def observable(self) -> FermionicOp:
        """"""Return the observable as a FermionicOp.""""""
        return self._observable

    def circuits(self, initial_state: QuantumCircuit) -> List[QuantumCircuit]:
        """"""
        The problem embedded in a quantum circuit.

        Args:
            initial_state: A quantum circuit which corresponds to the initial state for the
                time-evolution problem.

        Return:
            A list of quantum circuits. Circuit :math:`i` is a single instruction which
            corresponds to :math:`exp(-i*H*t_i)` where :math:`t_i` is the time of the
            the ith evolution time.
        """"""
        circuits = []

        for time in self.evolution_times:
            circ = QuantumCircuit(initial_state.num_qubits)
            circ.compose(initial_state, inplace=True)
            circ.compose(self.system.to_circuit(time), inplace=True)
            circuits.append(circ)

        return circuits
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Module to build a Fermi-Hubbard problem.""""""

from abc import ABC, abstractmethod
from typing import List

from qiskit import QuantumCircuit
from qiskit_nature.second_q.operators import FermionicOp
from qiskit_cold_atom.fermions.fermion_circuit_solver import FermionicBasis
from qiskit_cold_atom.fermions.fermion_gate_library import FermiHubbard
from qiskit_cold_atom.exceptions import QiskitColdAtomError


class FermionicLattice(ABC):
    """"""Abstract base fermionic lattice.""""""

    @property
    @abstractmethod
    def size(self) -> int:
        """"""The number of lattice sites of the system.""""""

    @abstractmethod
    def to_fermionic_op(self) -> FermionicOp:
        """"""Creates the Hamiltonian of the lattice in second quantization.

        Returns:
            The Hamiltonian as a FermionicOp.
        """"""

    @abstractmethod
    def to_circuit(self, time: float = 1.0) -> QuantumCircuit:
        """"""
        Wrap the generator of the system in a QuantumCircuit.

        Args:
            time: Duration of the time evolution.

        Returns:
            A quantum circuit which corresponds to the time-evolved Hamiltonian.
        """"""


class FermiHubbard1D(FermionicLattice):
    """"""Describes a one-dimensional Fermi-Hubbard model with open boundary conditions.""""""

    def __init__(
        self,
        num_sites: int,
        particles_up: int,
        particles_down: int,
        hop_strength: float,
        int_strength: float,
        potential: List[float],
    ):
        r""""""
        Initialize a one-dimensional fermi-hubbard system. In second quantization this system is
        described by the Hamiltonian

        :math:`H = \sum_{i=1,\sigma}^{L-1} - J_i (f^\dagger_{i,\sigma} f_{i+1,\sigma} +
        f^\dagger_{i+1,\sigma} f_{i,\sigma}) + U \sum_{i=1}^{L} n_{i,\uparrow} n_{i,\downarrow}
        +  \sum_{i=1,\sigma}^{L} \mu_i n_{i,\sigma}`

        Args:
            num_sites: number of lattice sites in the 1D chain.
            particles_up: total number of spin-up particles in the lattice
            particles_down: total number of spin-down particles in the lattice
            hop_strength: strength of hopping between sites
            int_strength: strength of the local interaction
            potential: list of local phases, must be on length num_wires

        Raises:
            QiskitColdAtomError: if the length of the potential does not match the system size.
        """"""

        # pylint: disable=invalid-name
        self._size = num_sites
        self.particles_up = particles_up
        self.particles_down = particles_down
        self.J = hop_strength
        self.U = int_strength
        self.basis = FermionicBasis(self.size, n_particles=[self.particles_up, self.particles_down])

        if not len(potential) == self.size:
            raise QiskitColdAtomError(
                f""The length of the potentials {len(potential)} must match system size {self.size}""
            )

        self.mu = potential

    @property
    def size(self) -> int:
        """"""Return the number of sites of the problem.""""""
        return self._size

    def to_fermionic_op(self) -> FermionicOp:
        """"""Construct the hamiltonian of the lattice as a FermionicOp.

        Returns:
            A FermionicOp defining the systems Hamiltonian
        """"""

        operator_labels = {}

        # add hopping terms
        for idx in range(self.size - 1):
            right_to_left_up = f""+_{idx} -_{idx+1}""
            operator_labels[right_to_left_up] = -self.J
            left_to_right_up = f""-_{idx} +_{idx+1}""
            operator_labels[left_to_right_up] = self.J
            right_to_left_down = f""+_{self.size + idx} -_{self.size + idx+1}""
            operator_labels[right_to_left_down] = -self.J
            left_to_right_down = f""-_{self.size + idx} +_{self.size + idx+1}""
            operator_labels[left_to_right_down] = self.J

        # add interaction terms
        for idx in range(self.size):
            opstring = f""+_{idx} -_{idx} +_{self.size + idx} -_{self.size + idx}""
            operator_labels[opstring] = self.U

        # add potential terms
        for idx in range(self.size):
            op_up = f""+_{idx} -_{idx}""
            operator_labels[op_up] = self.mu[idx]
            op_down = f""+_{self.size + idx} -_{self.size + idx}""
            operator_labels[op_down] = self.mu[idx]

        return FermionicOp(operator_labels, num_spin_orbitals=2 * self.size)

    def to_circuit(self, time: float = 1.0) -> QuantumCircuit:
        """"""
        Wrap the generator of the system in a QuantumCircuit.

        Args:
            time: Duration of the time evolution.

        Returns:
            A quantum circuit which corresponds to the time-evolved Hamiltonian.
        """"""
        circ = QuantumCircuit(2 * self.size)
        circ.append(
            FermiHubbard(
                num_modes=2 * self.size,
                j=[self.J * time] * (self.size - 1),
                u=self.U * time,
                mu=[mu_i * time for mu_i in self.mu],
            ),
            qargs=range(2 * self.size),
        )

        return circ
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""A solver for time-evolution problems.""""""

from typing import List

from qiskit_nature.second_q.operators import FermionicOp
from qiskit_nature.second_q.mappers import (
    JordanWignerMapper,
    BravyiKitaevMapper,
    ParityMapper,
)

from qiskit import QuantumRegister
from qiskit import QuantumCircuit
from qiskit.algorithms import TimeEvolutionProblem
from qiskit.algorithms.time_evolvers import TrotterQRTE
from qiskit.quantum_info import Statevector

from qiskit_cold_atom.applications.fermionic_evolution_problem import (
    FermionicEvolutionProblem,
)
from qiskit_cold_atom.fermions.base_fermion_backend import BaseFermionBackend


class TimeEvolutionSolver:
    """"""
    Solver class that solves time evolution problem by either analog simulation on fermionic
    hardware or trotterized time evolution on qubit hardware. The computation that this time
    evolution solver will do depends on the type of the backend.
    """"""

    MAPPER_DICT = {
        ""bravyi_kitaev"": BravyiKitaevMapper(),
        ""jordan_wigner"": JordanWignerMapper(),
        ""parity"": ParityMapper(),
    }

    def __init__(
        self,
        backend,
        map_type: str = None,
        trotter_steps: int = None,
        shots: int = 1000,
    ):
        """"""
        Initialize a time evolution solver

        Args:
            backend: The backend on which to execute the problem, may be qubit or fermionic.
            map_type: The fermion-to-qubit mapping required if a qubit backend is given
            trotter_steps: The amount of trotter steps to approximate time evolution on
                qubit backends
            shots: number of measurements taken of the constructed circuits
        """"""

        self.backend = backend
        self.map_type = map_type
        self.trotter_steps = trotter_steps
        self.shots = shots

    def solve(self, problem: FermionicEvolutionProblem) -> List[float]:
        """"""Solve the problem using the provided backend

        Args:
            problem: The FermionicEvolutionProblem to solve.

        Returns:
            A list of expectation values of the observable of the problem. This list has the
            same length as the list of times for which to compute the time evolution.
        """"""

        if isinstance(self.backend, BaseFermionBackend):
            qc_load = self.backend.initialize_circuit(problem.initial_state.occupations)
            circuits = problem.circuits(qc_load)

            observable_evs = self.backend.measure_observable_expectation(
                circuits, problem.observable, self.shots
            )

        else:
            # use qubit pipeline
            circuits = self.construct_qubit_circuits(problem)

            mapper = self.MAPPER_DICT[self.map_type]
            qubit_observable = mapper.map(problem.observable)
            observable_evs = [
                Statevector(qc).expectation_value(qubit_observable) for qc in circuits
            ]

        return observable_evs

    def construct_qubit_circuits(self, problem: FermionicEvolutionProblem) -> List[QuantumCircuit]:
        """"""Convert the problem to a trotterized qubit circuit using the specified map_type

        Args:
            problem: The fermionic evolution problem specifying the system, evolution-time
                and observable to be measured

        Returns:
            a list of quantum circuits that simulate the time evolution.
            There is one circuit for each evolution time specified in the problem'
        """"""

        psi_0 = problem.initial_state
        system = problem.system
        hamiltonian = system.to_fermionic_op()

        mapper = self.MAPPER_DICT[self.map_type]

        circuits = []

        # construct circuit of initial state:
        label = {f""+_{i}"": 1.0 for i, bit in enumerate(psi_0.occupations_flat) if bit}
        bitstr_op = FermionicOp(label, num_spin_orbitals=len(psi_0.occupations_flat))
        qubit_op = mapper.map(bitstr_op)[0]
        init_circ = QuantumCircuit(QuantumRegister(qubit_op.num_qubits, ""q""))

        for i, pauli_label in enumerate(qubit_op.paulis.to_labels()[0][::-1]):
            if pauli_label == ""X"":
                init_circ.x(i)
            elif pauli_label == ""Y"":
                init_circ.y(i)
            elif pauli_label == ""Z"":
                init_circ.z(i)

        for time in problem.evolution_times:
            # map fermionic hamiltonian to qubits
            qubit_hamiltonian = mapper.map(hamiltonian)
            # construct trotterization circuits
            evolution_problem = TimeEvolutionProblem(qubit_hamiltonian, time, init_circ)
            trotter_qrte = TrotterQRTE(num_timesteps=self.trotter_steps)
            evolved_state = trotter_qrte.evolve(evolution_problem).evolved_state
            circuits.append(evolved_state)

        return circuits
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Module for cold-atom fermion backends.""""""

from abc import ABC
from typing import Union, List, Optional
import numpy as np

from qiskit.providers import BackendV1 as Backend
from qiskit import QuantumCircuit
from qiskit_nature.second_q.operators import FermionicOp

from qiskit_cold_atom.fermions.fermion_gate_library import LoadFermions
from qiskit_cold_atom.fermions.fermion_circuit_solver import FermionCircuitSolver
from qiskit_cold_atom.fermions.fermionic_state import FermionicState
from qiskit_cold_atom.exceptions import QiskitColdAtomError


class BaseFermionBackend(Backend, ABC):
    """"""Abstract base class for fermionic tweezer backends.""""""

    def initialize_circuit(self, occupations: Union[List[int], List[List[int]]]):
        """"""
        Initialize a fermionic quantum circuit with the given occupations.

        Args:
            occupations: List of occupation numbers. When ``List[int]`` is given, the occupations
                correspond to the number of indistinguishable fermionic particles in each mode,
                e.g. ``[0, 1, 1, 0]`` implies that sites one and two are occupied by a fermion.
                When ``List[List[int]]`` is given, the occupations describe the number of particles in
                fermionic modes with different (distinguishable) species of fermions. Each
                inner list gives the occupations of one fermionic species.

        Returns:
            circuit: Qiskit QuantumCircuit with a quantum register for each fermionic species
                     initialized with the ``load`` instructions corresponding to the given occupations

        Raises:
            QiskitColdAtomError: If occupations do not match the backend
        """"""
        try:
            backend_size = self.configuration().to_dict()[""n_qubits""]
        except NameError as name_error:
            raise QiskitColdAtomError(
                f""Number of tweezers not specified for {self.name()}""
            ) from name_error

        initial_state = FermionicState(occupations)

        n_wires = initial_state.sites * initial_state.num_species

        if n_wires > backend_size:
            raise QiskitColdAtomError(
                f""{self.name()} supports up to {backend_size} sites, {n_wires} were given""
            )

        # if num_species is specified by the backend, the wires describe different atomic species
        # and the circuit must exactly match the expected wire count of the backend.
        if ""num_species"" in self.configuration().to_dict().keys():
            num_species = self.configuration().num_species
            if num_species > 1 and n_wires < self.configuration().num_qubits:
                raise QiskitColdAtomError(
                    f""{self.name()} requires circuits with exactly ""
                    f""{self.configuration().num_qubits} wires, but an initial occupation of size ""
                    f""{n_wires} was given.""
                )

        from qiskit.circuit import QuantumRegister

        if initial_state.num_species > 1:
            registers = []
            for i in range(initial_state.num_species):
                registers.append(QuantumRegister(initial_state.sites, f""spin_{i}""))
            circuit = QuantumCircuit(*registers)

        else:
            circuit = QuantumCircuit(QuantumRegister(initial_state.sites, ""fer_mode""))

        for i, occupation_list in enumerate(initial_state.occupations):
            for j, occ in enumerate(occupation_list):
                if occ:
                    circuit.append(LoadFermions(), qargs=[i * initial_state.sites + j])

        return circuit

    def measure_observable_expectation(
        self,
        circuits: Union[QuantumCircuit, List[QuantumCircuit]],
        observable: FermionicOp,
        shots: int,
        seed: Optional[int] = None,
        num_species: int = 1,
        get_variance: bool = False,
    ):
        """"""Measure the expectation value of an observable in a state prepared by a given quantum circuit
        that uses fermionic gates. Measurements are added to the entire register if they are not yet
        applied in the circuit.

        Args:
            circuits: QuantumCircuit applying gates with fermionic generators
            observable: A FermionicOp describing an observable of which the expectation value is sampled
            shots: Number of measurement shots taken in case the circuit has measure instructions
            seed: seed for the random number generator of the measurement simulation
            num_species: number of different fermionic species described by the circuits
            get_variance: If True, also returns an estimate of the variance of the observable

        Raises:
            QiskitColdAtomError: if the observable is non-diagonal

        Returns:
            observable_ev: List of the measured expectation values of the observables in given circuits
            variance: List of the estimated variances of of the observables (if get_variance is True)
        """"""

        if isinstance(circuits, QuantumCircuit):
            circuits = [circuits]

        observable_evs = [0] * len(circuits)
        observable_vars = [0] * len(circuits)

        for idx, circuit in enumerate(circuits):
            # check whether the observable is diagonal in the computational basis.
            solver = FermionCircuitSolver(num_species=2)
            solver.preprocess_circuit(circuit)
            observable_mat = solver.operator_to_mat(observable)

            if list(observable_mat.nonzero()[0]) != list(observable_mat.nonzero()[1]):
                raise QiskitColdAtomError(
                    ""Measuring general observables that are non-diagonal in the ""
                    ""computational basis is not yet implemented for ""
                    ""fermionic backends. This requires non-trivial basis ""
                    ""transformations that are in general difficult to find and ""
                    ""depend on the backend's native gate set.""
                )

            circuit.remove_final_measurements()
            circuit.measure_all()

            # pylint: disable=unexpected-keyword-arg
            job = self.run(circuit, shots=shots, seed=seed, num_species=num_species)
            counts = job.result().get_counts()

            for bitstring in counts:
                # Extract the index of the measured count-bitstring in the fermionic basis.
                # In contrast to qubits, this is not trivial and requires an additional step.
                ind = solver.basis.get_index_of_measurement(bitstring)

                # contribution to the operator estimate of this outcome
                p = counts[bitstring] / shots
                observable_evs[idx] += p * observable_mat[ind, ind].real

                if get_variance:
                    # contribution to the variance of the operator
                    observable_vars[idx] += (
                        np.sqrt(p * (1 - p) / shots) * observable_mat[ind, ind]
                    ) ** 2

        if get_variance:
            return observable_evs, observable_vars
        else:
            return observable_evs

    def draw(self, qc: QuantumCircuit, **draw_options):
        """"""Modified circuit drawer to better display atomic mixture quantum  circuits.

        Note that in the future this method may be modified and tailored to fermionic quantum circuits.

        Args:
            qc: The quantum circuit to draw.
            draw_options: Key word arguments for the drawing of circuits.
        """"""
        qc.draw(**draw_options)
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Module to describe fermionic states in occupation number basis""""""

from typing import List, Union
import warnings
import numpy as np

from qiskit import QuantumCircuit

from qiskit_cold_atom.exceptions import QiskitColdAtomError


class FermionicState:
    """"""Fermionic states in an occupation number representation.""""""

    def __init__(self, occupations: Union[List[int], List[List[int]]]):
        """"""Create a :class:`FermionicState` from the given occupations.

        Args:
            occupations: List of occupation numbers. When List[int] is given, the occupations
            correspond to the number of indistinguishable fermionic particles in each mode,
            e.g. [0, 1, 1, 0] implies that sites one and two are occupied by a fermion.
            When List[List[int]] is given, the occupations describe the number of particles in
            fermionic modes with different (distinguishable) species of fermions. Each
            inner list gives the occupations of one fermionic species.

        Raises:
            QiskitColdAtomError:
                - If the inner lists do not have the same length
                - If the occupations are not 0 or 1
        """"""

        if isinstance(occupations[0], (int, np.integer)):
            occupations = [occupations]

        self._sites = len(occupations[0])
        self._occupations = occupations
        self._num_species = len(occupations)

        self._occupations_flat = []
        for occs in self.occupations:
            self._occupations_flat += occs

        for occs in self.occupations[0:]:
            if len(occs) != self._sites:
                raise QiskitColdAtomError(
                    f""All occupations of different fermionic species must have ""
                    f""same length, received {self.occupations[0]} and {occs}.""
                )
            for n in occs:
                if n not in (0, 1):
                    raise QiskitColdAtomError(f""Fermionic occupations must be 0 or 1, got {n}."")

    @property
    def occupations(self) -> List[List[int]]:
        """"""Return the occupation number of each fermionic mode.""""""
        return self._occupations

    @property
    def occupations_flat(self) -> List[int]:
        """"""Return the occupations of each fermionic mode in a flat list.""""""
        return self._occupations_flat

    @property
    def sites(self) -> int:
        """"""Return the number of fermionic sites.""""""
        return self._sites

    @property
    def num_species(self) -> int:
        """"""Return the number of species of fermions, e.g. 2 for spin up/down systems.""""""
        return self._num_species

    def __str__(self):
        output = """"
        for i in range(self.num_species):
            output += ""|"" + str(self.occupations[i])[1:-1] + "">""
        return output

    @classmethod
    def from_total_occupations(cls, occupations: List[int], num_species: int) -> ""FermionicState"":
        """"""
        Create a fermionic state from a single (flat) list of total occupations.

        Args:
            occupations: a list of occupations of all fermionic modes, e.g. [0, 1, 1, 0, 1, 0].
            num_species: number of fermionic species. If > 1, the total occupation list is cast
                into a nested list where each inner list describes one fermionic species. In the
                above example, for num_species = 2, this becomes
                FermionicState([[0, 1, 1], [0, 1, 0]]).

        Returns:
            A fermionic state initialized with the given input.

        Raises:
            QiskitColdAtomError: If the length of occupations is not a multiple of num_species.
        """"""
        if len(occupations) % num_species != 0:
            raise QiskitColdAtomError(
                ""The state must have a number of occupations that is a multiple of the""
                ""number of fermionic species.""
            )

        sites = int(len(occupations) / num_species)
        return cls(np.reshape(occupations, (num_species, sites)).tolist())

    @classmethod
    def initial_state(cls, circuit: QuantumCircuit, num_species: int = 1) -> ""FermionicState"":
        """"""
        Create a fermionic state from a quantum circuit that uses the `LoadFermion` instruction.
        This instruction must be the first instructions of the circuit and no further LoadFermion
        instruction can be applied, even after other instructions such as gates have been applied.

        Args:
            circuit: a quantum circuit with LoadFermions instructions that initialize fermionic
                particles.
            num_species: number of different fermionic species, e.g. 1 for a single
                type of spinless fermions (default), 2 for spin-1/2 fermions etc.

        Returns:
            A FermionicState initialized from the given circuit.

        Raises:
            QiskitColdAtomError:
                - If the number of wires in the circuit is not a multiple of num_species,
                - If LoadFermions instructions come after other instructions.
        """"""
        if num_species > 1:
            if circuit.num_qubits % num_species != 0:
                raise QiskitColdAtomError(
                    ""The circuit must have a number of wires that is a multiple of the""
                    ""number of fermionic species.""
                )

        occupations = [0] * circuit.num_qubits
        gates_applied = [False] * circuit.num_qubits

        if not circuit.data[0][0].name == ""load"":
            warnings.warn(
                ""No particles have been initialized, the circuit will return a trivial result.""
            )

        # check that there are no more 'LoadFermions' instructions
        for instruction in circuit.data:
            qargs = [circuit.qubits.index(qubit) for qubit in instruction[1]]

            if instruction[0].name == ""load"":
                for idx in qargs:
                    if gates_applied[idx]:
                        raise QiskitColdAtomError(
                            f""State preparation instruction in circuit after gates on wire {idx}""
                        )
                    occupations[idx] = 1
            else:
                for idx in qargs:
                    gates_applied[idx] = True

        return cls.from_total_occupations(occupations, num_species)
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Module to simulate fermionic circuits.""""""

from typing import List, Tuple, Optional
import numpy as np
from scipy.sparse import csc_matrix

from qiskit import QuantumCircuit
from qiskit_nature.second_q.operators import FermionicOp

from qiskit_cold_atom.base_circuit_solver import BaseCircuitSolver
from qiskit_cold_atom.exceptions import QiskitColdAtomError
from qiskit_cold_atom.fermions.fermionic_state import FermionicState
from qiskit_cold_atom.fermions.fermionic_basis import FermionicBasis
from qiskit_cold_atom.fermions.fermion_gate_library import FermionicGate


class FermionCircuitSolver(BaseCircuitSolver):
    """"""
    Numerically simulate fermionic systems by exactly computing the time
    evolution under unitary operations generated by fermionic Hamiltonians.
    """"""

    def __init__(
        self,
        shots: Optional[int] = None,
        seed: Optional[int] = None,
        num_species: int = 1,
    ):
        """"""
        Args:
            shots: amount of shots for the measurement simulation;
                if not None, measurements are performed
            seed: seed for the RNG for the measurement simulation
            num_species: number of different fermionic species, defaults to 1 for a single type of
                (spinless) fermions, 2 for spin-1/2 fermions etc. If > 1, the solver will check for
                conservation of the particle number per fermionic species in order to reduce the
                Hilbert space dimension of the simulation
        """"""
        self._basis = None
        self.num_species = num_species

        super().__init__(shots=shots, seed=seed)

    @property
    def basis(self) -> FermionicBasis:
        """"""
        Return the basis of fermionic occupation number states. This basis is updated via the
        setter whenever a new circuit is passed to __call__.
        """"""
        return self._basis

    @basis.setter
    def basis(self, basis: FermionicBasis):
        """"""
        Set the basis of the simulation and check its dimensions.

        Args:
            basis: The new basis.

        Raises:
            QiskitColdAtomError: If the dimension of the basis is too large.
        """"""
        if basis.dimension > self.max_dimension:
            raise QiskitColdAtomError(
                f""Dimension {basis.dimension} exceeds the maximum ""
                f""allowed dimension {self.max_dimension}.""
            )

        self._basis = basis

    def preprocess_circuit(self, circuit: QuantumCircuit):
        """"""
        Pre-processing fermionic circuits includes setting up the basis for the simulation
        by extracting the size, particle number and spin conservation from the circuit.

        Args:
            circuit: A fermionic quantum circuit for which to setup a basis.
        """"""
        initial_occupations = FermionicState.initial_state(circuit, self.num_species)
        _, spin_conservation = self._check_conservations(circuit)
        self.basis = FermionicBasis.from_state(initial_occupations, spin_conservation)
        self._dim = self.basis.dimension

    def get_initial_state(self, circuit: QuantumCircuit) -> csc_matrix:
        """"""
        Return the initial state of the quantum circuit as a sparse column vector.

        Args:
            circuit: The circuit for which to extract the initial_state.

        Returns:
            The initial state of the circuit as a sparse matrix.
        """"""

        init_state = FermionicState.initial_state(circuit, self.num_species)
        initial_occs = init_state.occupations_flat
        initial_index = self.basis.get_occupations().index(initial_occs)

        initial_state = csc_matrix(
            ([1 + 0j], ([initial_index], [0])),
            shape=(self.basis.dimension, 1),
            dtype=complex,
        )

        return initial_state

    def _embed_operator(
        self, operator: FermionicOp, num_wires: int, qargs: List[int]
    ) -> FermionicOp:
        """"""
        Turn a FermionicOp operator that acts on the wires given in qargs into an operator
        that acts on the entire state space of the circuit by padding with identities ""I"" on the
        remaining wires

        Args:
            operator: FermionicOp describing the generating Hamiltonian of a gate
            num_wires: The total number of wires in which the operator should be embedded into
            qargs: The wire indices the gate acts on

        Returns:
            FermionicOp, an operator acting on the entire quantum register of the Circuit

        Raises:
            QiskitColdAtomError:
                - If the given operator is not a FermionicOp
                - If the size of the operator does not match the given qargs
        """"""

        if not isinstance(operator, FermionicOp):
            raise QiskitColdAtomError(
                f""Expected FermionicOp; got {type(operator).__name__} instead.""
            )

        if operator.num_spin_orbitals != len(qargs):
            raise QiskitColdAtomError(
                f""length of gate labels {operator.num_spin_orbitals} does not match ""
                f""qargs {qargs} of the gates""
            )

        embedded_terms = []

        for partial_label, factor in operator.terms():
            embedded_terms.append((operator._permute_term(partial_label, qargs), factor))

        reordered_op = FermionicOp.from_terms(embedded_terms)
        reordered_op.num_spin_orbitals = num_wires

        return reordered_op

    def _check_conservations(self, circuit: QuantumCircuit) -> Tuple[bool, bool]:
        """"""
        Check if the fermionic operators defined in the circuit conserve the total particle number
        (i.e. there are as many creation operators as annihilation operators) and the particle
        number per spin species (e.g. there are as many up/down creation operators as there are
        up/down annihilation operators).

        Args:
            circuit: A quantum circuit with fermionic gates

        Returns:
            particle_conservation: True if the particle number is conserved in the circuit
            spin_conservation: True if the particle number is conserved for each spin species

        Raises:
            QiskitColdAtomError:
                - If an operator in the circuit is not a FermionicOp.
                - If the length of the fermionic operators does not match the system size.
                - If the circuit has a number of wires that is not a multiple of the number
                  of fermionic species.
        """"""
        particle_conservation = True
        spin_conservation = True

        for fermionic_op in self.to_operators(circuit):
            if not isinstance(fermionic_op, FermionicOp):
                raise QiskitColdAtomError(""operators need to be given as FermionicOp"")

            if fermionic_op.num_spin_orbitals != circuit.num_qubits:
                raise QiskitColdAtomError(
                    f""Expected length {circuit.num_qubits} for fermionic operator; ""
                    f""received {fermionic_op.num_spin_orbitals}.""
                )

            for opstring, _ in fermionic_op.terms():
                op_types = [op for op, _ in opstring]
                num_creators = op_types.count(""+"")
                num_annihilators = op_types.count(""-"")

                if num_creators != num_annihilators:
                    return False, False

                if self.num_species > 1:
                    if circuit.num_qubits % self.num_species != 0:
                        raise QiskitColdAtomError(
                            f""The number of wires in the circuit {circuit.num_qubits} is not a ""
                            f""multiple of the {self.num_species} fermionic species number.""
                        )

                    sites = circuit.num_qubits // self.num_species

                    # check if the particle number is conserved for each spin species
                    for i in range(self.num_species):
                        spin_range = range(i * sites, (i + 1) * sites)
                        op_types_in_range = [op for op, idx in opstring if idx in spin_range]
                        num_creators = op_types_in_range.count(""+"")
                        num_annihilators = op_types_in_range.count(""-"")

                        if num_creators != num_annihilators:
                            spin_conservation = False
                            break

        return particle_conservation, spin_conservation

    def operator_to_mat(self, operator: FermionicOp) -> csc_matrix:
        """"""Convert the fermionic operator to a sparse matrix.

        Args:
            operator: fermionic operator of which to compute the matrix representation

        Returns:
            scipy.sparse matrix of the Hamiltonian

        """"""
        return FermionicGate.operator_to_mat(operator, self.num_species, self._basis)

    def draw_shots(self, measurement_distribution: List[float]) -> List[str]:
        """"""
        Helper function to draw counts from a given distribution of measurement outcomes.

        Args:
            measurement_distribution: List of probabilities of the individual measurement outcomes

        Returns:
            a list of individual measurement results, e.g. [""011000"", ""100010"", ...]
            The outcome of each shot is denoted by a binary string of the occupations of the individual
            modes in little endian convention

        Raises:
            QiskitColdAtomError:
                - If the length of the given probabilities does not match the expected Hilbert space
                dimension.
                - If the number of shots self.shots has not been specified.
        """"""

        meas_dim = len(measurement_distribution)

        if meas_dim != self.dim:
            raise QiskitColdAtomError(
                f""Dimension of the measurement probabilities {meas_dim} does not ""
                f""match the dimension expected by the solver, {self.dim}""
            )

        if self.shots is None:
            raise QiskitColdAtomError(
                ""The number of shots has to be set before drawing measurements""
            )

        # list all possible outcomes as strings '001011', reversing the order of the wires
        # to comply with Qiskit's ordering convention
        outcome_strings = ["""".join(map(str, k)) for k in self.basis.get_occupations()]

        # Draw measurements:
        meas_results = np.random.choice(outcome_strings, self.shots, p=measurement_distribution)

        return meas_results.tolist()
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""General Fermion simulator backend.""""""

from typing import Union, List, Dict, Any, Optional
import uuid
import warnings
import time
import datetime

from qiskit.providers.models import BackendConfiguration
from qiskit.providers import Options
from qiskit import QuantumCircuit
from qiskit.result import Result
from qiskit_aer import AerJob

from qiskit_cold_atom.fermions.fermion_circuit_solver import FermionCircuitSolver
from qiskit_cold_atom.fermions.base_fermion_backend import BaseFermionBackend
from qiskit_cold_atom.circuit_tools import CircuitTools


class FermionSimulator(BaseFermionBackend):
    """"""A simulator to simulate general fermionic circuits.

    This general fermion simulator backend simulates fermionic circuits with gates that have
    generators described by fermionic Hamiltonians. It computes the statevector and unitary
    of a circuit and simulates measurements.
    """"""

    _DEFAULT_CONFIGURATION = {
        ""backend_name"": ""fermion_simulator"",
        ""backend_version"": ""0.0.1"",
        ""n_qubits"": 20,
        ""basis_gates"": None,
        ""gates"": [],
        ""local"": False,
        ""simulator"": True,
        ""conditional"": False,
        ""open_pulse"": False,
        ""memory"": True,
        ""max_shots"": 1e5,
        ""coupling_map"": None,
        ""description"": ""a base simulator for fermionic circuits. Instead of qubits, each wire represents""
        "" a single fermionic mode"",
        ""supported_instructions"": None,
    }

    def __init__(self, config_dict: Dict[str, Any] = None, provider=None):
        """"""Initializing the backend from a configuration dictionary""""""

        if config_dict is None:
            config_dict = self._DEFAULT_CONFIGURATION

        super().__init__(
            configuration=BackendConfiguration.from_dict(config_dict), provider=provider
        )

    @classmethod
    def _default_options(cls):
        return Options(shots=1)

    def _execute(self, data: Dict[str, Any], job_id: str = """"):
        """"""Helper function to execute a job. The circuit and all relevant parameters are given in the
        data dict. Performs validation checks on the received circuits and utilizes
        the FermionCircuitSolver to perform the numerical simulations.

         Args:
            data: Data dictionary that that contains the experiments to simulate, given in the shape:
                data = {
                    ""num_species"": int,
                    ""shots"": int,
                    ""seed"": int,
                    ""experiments"": Dict[str, QuantumCircuit],
                }
            job_id: The job id assigned by the run method

        Returns:
            result: A qiskit job result.
        """"""
        # Start timer
        start = time.time()

        output = {""results"": []}

        num_species = data[""num_species""]
        shots = data[""shots""]
        seed = data[""seed""]

        solver = FermionCircuitSolver(num_species=num_species, shots=shots, seed=seed)

        for exp_i, exp_name in enumerate(data[""experiments""]):
            experiment = data[""experiments""][exp_name]
            circuit = experiment[""circuit""]

            # perform compatibility checks with the backend configuration in case gates and supported
            # instructions are constrained by the backend's configuration
            if self.configuration().gates and self.configuration().supported_instructions:
                CircuitTools.validate_circuits(circuits=circuit, backend=self, shots=shots)

            # check whether all wires are measured
            measured_wires = []

            for inst in circuit.data:
                name = inst[0].name

                if name == ""measure"":
                    for wire in inst[1]:
                        index = circuit.qubits.index(wire)
                        if index in measured_wires:
                            warnings.warn(
                                f""Wire {index} has already been measured, ""
                                f""second measurement is ignored""
                            )
                        else:
                            measured_wires.append(index)

            if measured_wires and len(measured_wires) != len(circuit.qubits):
                warnings.warn(
                    f""Number of wires in circuit ({len(circuit.qubits)}) exceeds number of wires ""
                    + f"" with assigned measurement instructions ({len(measured_wires)}). ""
                    + ""This simulator backend only supports measurement of the entire quantum register ""
                    ""which will instead be performed.""
                )

            # If there are no measurements, set shots to None
            if not measured_wires:
                solver.shots = None

            simulation_result = solver(circuit)

            output[""results""].append(
                {
                    ""header"": {""name"": exp_name, ""random_seed"": seed},
                    ""shots"": shots,
                    ""status"": ""DONE"",
                    ""success"": True,
                }
            )
            # add the simulation result at the correct place in the result dictionary
            output[""results""][exp_i][""data""] = simulation_result

        output[""job_id""] = job_id
        output[""date""] = datetime.datetime.now().isoformat()
        output[""backend_name""] = self.name()
        output[""backend_version""] = self.configuration().backend_version
        output[""time_taken""] = time.time() - start
        output[""success""] = True
        output[""qobj_id""] = None

        return Result.from_dict(output)

    # pylint: disable=arguments-differ, unused-argument
    def run(
        self,
        circuits: Union[QuantumCircuit, List[QuantumCircuit]],
        shots: int = 1000,
        seed: Optional[int] = None,
        num_species: int = 1,
        **run_kwargs,
    ) -> AerJob:
        """"""
        Method to run circuits on the backend.

        Args:
            circuits: QuantumCircuit applying fermionic gates to run on the backend
            shots: Number of measurement shots taken in case the circuit has measure instructions
            seed: seed for the random number generator of the measurement simulation
            num_species: number of different fermionic species described by the circuits
            run_kwargs: Additional keyword arguments that might be passed down when calling
                qiskit.execute() which will have no effect on this backend.

        Returns:
            aer_job: a job object containing the result of the simulation
        """"""

        if isinstance(circuits, QuantumCircuit):
            circuits = [circuits]

        data = {
            ""num_species"": num_species,
            ""shots"": shots,
            ""seed"": seed,
            ""experiments"": {},
        }

        for idx, circuit in enumerate(circuits):
            data[""experiments""][f""experiment_{idx}""] = {
                ""circuit"": circuit,
            }

        job_id = str(uuid.uuid4())
        aer_job = AerJob(self, job_id, self._execute, data)
        aer_job.submit()
        return aer_job

    @staticmethod
    def get_basis(circuit: QuantumCircuit, num_species: int = 1):
        """"""Get the basis of fermionic states in occupation number representation for the simulation
        of a given quantum circuit.

        Args:
            circuit: A quantum circuit using Fermionic Gates.
            num_species: Number of different fermionic species described by the circuit.

        Returns:
            basis: the fermionic basis in which the simulation of the circuit is performed.
        """"""
        solver = FermionCircuitSolver(num_species=num_species)
        solver.preprocess_circuit(circuit)
        basis = solver.basis

        return basis

    def draw(self, qc: QuantumCircuit, **draw_options):
        """"""Draw the circuit by defaulting to the draw method of QuantumCircuit.

        Note that in the future this method may be modified and tailored to fermion
        quantum circuits.

        Args:
            qc: The quantum circuit to draw.
            draw_options: Key word arguments for the drawing of circuits.
        """"""
        qc.draw(**draw_options)
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Fermionic simulator backend that uses ffsim.""""""

from __future__ import annotations

import datetime
import time
import uuid
import warnings
from collections import Counter
from typing import Any, Dict, List, Optional, Union

import ffsim  # pylint: disable=import-error
import numpy as np
import scipy.linalg
from qiskit import QuantumCircuit
from qiskit.circuit.library import Barrier, Measure
from qiskit.providers import Options
from qiskit.providers.models import BackendConfiguration
from qiskit.result import Result
from qiskit_aer import AerJob
from qiskit_nature.second_q.operators import FermionicOp
from scipy.sparse.linalg import expm_multiply

from qiskit_cold_atom.circuit_tools import CircuitTools
from qiskit_cold_atom.fermions.base_fermion_backend import BaseFermionBackend
from qiskit_cold_atom.fermions.fermion_gate_library import (
    FermionicGate,
    FRXGate,
    FRYGate,
    FRZGate,
    Hop,
    Interaction,
    LoadFermions,
    Phase,
)


class FfsimBackend(BaseFermionBackend):
    """"""Fermionic simulator backend that uses ffsim.

    This is a high-performance simulator backend for fermionic circuits that uses `ffsim`_.
    It computes the state vector and simulate measurements with vastly improved efficiency
    compared with the :class:`~.FermionSimulator` backend. Unlike :class:`~.FermionSimulator`,
    it does not compute the full unitary of a circuit.

    Currently, this simulator only supports simulations with 1 or 2 species of fermions.
    The number of fermions of each species is assumed to be preserved, so that the
    dimension of the state vector can be determined from the number of species and the
    number of particles of each species. In particular, when simulating 2 species of fermions,
    gates that mix particles of different species, such as :class:`~.FRXGate` and
    :class:`FRYGate`, are not supported. In this respect, the behavior of this simulator
    differs from :class:`FermionSimulator`, which would automatically resort to a
    single-species simulation in which particles of each species are not distinguished.

    This backend is not supported on Windows, and in order for it to be available,
    Qiskit Cold Atom must be installed with the ``ffsim`` extra, e.g.

    .. code::

        pip install ""qiskit-cold-atom[ffsim]""

    .. _ffsim: https://github.com/qiskit-community/ffsim
    """"""

    _DEFAULT_CONFIGURATION = {
        ""backend_name"": ""ffsim_simulator"",
        ""backend_version"": ""0.0.1"",
        ""n_qubits"": 100,
        ""basis_gates"": None,
        ""gates"": [],
        ""local"": False,
        ""simulator"": True,
        ""conditional"": False,
        ""open_pulse"": False,
        ""memory"": True,
        ""max_shots"": 1e6,
        ""coupling_map"": None,
        ""description"": ""ffsim simulator for fermionic circuits. Instead of qubits, each wire represents""
        "" a single fermionic mode"",
        ""supported_instructions"": None,
    }

    def __init__(self, config_dict: Dict[str, Any] = None, provider=None):
        """"""Initializing the backend from a configuration dictionary""""""

        if config_dict is None:
            config_dict = self._DEFAULT_CONFIGURATION

        super().__init__(
            configuration=BackendConfiguration.from_dict(config_dict), provider=provider
        )

    @classmethod
    def _default_options(cls):
        return Options(shots=1)

    def _execute(self, data: Dict[str, Any], job_id: str = """"):
        """"""Helper function to execute a job. The circuit and all relevant parameters are given in the
        data dict. Performs validation checks on the received circuits and utilizes
        ffsim to perform the numerical simulations.

         Args:
            data: Data dictionary that that contains the experiments to simulate, given in the shape:
                data = {
                    ""num_species"": int,
                    ""shots"": int,
                    ""seed"": int,
                    ""experiments"": Dict[str, QuantumCircuit],
                }
            job_id: The job id assigned by the run method

        Returns:
            result: A qiskit job result.
        """"""
        # Start timer
        start = time.time()

        output = {""results"": []}

        num_species = data[""num_species""]
        shots = data[""shots""]
        seed = data[""seed""]

        for exp_i, exp_name in enumerate(data[""experiments""]):
            experiment = data[""experiments""][exp_name]
            circuit = experiment[""circuit""]

            # perform compatibility checks with the backend configuration in case gates and supported
            # instructions are constrained by the backend's configuration
            if self.configuration().gates and self.configuration().supported_instructions:
                CircuitTools.validate_circuits(circuits=circuit, backend=self, shots=shots)

            # check whether all wires are measured
            measured_wires = []

            for inst in circuit.data:
                name = inst[0].name

                if name == ""measure"":
                    for wire in inst[1]:
                        index = circuit.qubits.index(wire)
                        if index in measured_wires:
                            warnings.warn(
                                f""Wire {index} has already been measured, ""
                                f""second measurement is ignored""
                            )
                        else:
                            measured_wires.append(index)

            if measured_wires and len(measured_wires) != len(circuit.qubits):
                warnings.warn(
                    f""Number of wires in circuit ({len(circuit.qubits)}) exceeds number of wires ""
                    + f"" with assigned measurement instructions ({len(measured_wires)}). ""
                    + ""This simulator backend only supports measurement of the entire quantum register ""
                    ""which will instead be performed.""
                )

            # If there are no measurements, set shots to None
            if not measured_wires:
                shots = None

            simulation_result = _simulate_ffsim(circuit, num_species, shots, seed)

            output[""results""].append(
                {
                    ""header"": {""name"": exp_name, ""random_seed"": seed},
                    ""shots"": shots,
                    ""status"": ""DONE"",
                    ""success"": True,
                }
            )
            # add the simulation result at the correct place in the result dictionary
            output[""results""][exp_i][""data""] = simulation_result

        output[""job_id""] = job_id
        output[""date""] = datetime.datetime.now().isoformat()
        output[""backend_name""] = self.name()
        output[""backend_version""] = self.configuration().backend_version
        output[""time_taken""] = time.time() - start
        output[""success""] = True
        output[""qobj_id""] = None

        return Result.from_dict(output)

    # pylint: disable=arguments-differ, unused-argument
    def run(
        self,
        circuits: Union[QuantumCircuit, List[QuantumCircuit]],
        shots: int = 1000,
        seed: Optional[int] = None,
        num_species: int = 1,
        **run_kwargs,
    ) -> AerJob:
        """"""
        Method to run circuits on the backend.

        Args:
            circuits: QuantumCircuit applying fermionic gates to run on the backend
            shots: Number of measurement shots taken in case the circuit has measure instructions
            seed: seed for the random number generator of the measurement simulation
            num_species: number of different fermionic species described by the circuits
            run_kwargs: Additional keyword arguments that might be passed down when calling
                qiskit.execute() which will have no effect on this backend.

        Returns:
            aer_job: a job object containing the result of the simulation

        Raises:
            ValueError: FfsimBackend only supports num_species=1 or 2.
        """"""
        if num_species not in (1, 2):
            raise ValueError(f""FfsimBackend only supports num_species=1 or 2. Got {num_species}."")

        if isinstance(circuits, QuantumCircuit):
            circuits = [circuits]

        data = {
            ""num_species"": num_species,
            ""shots"": shots,
            ""seed"": seed,
            ""experiments"": {},
        }

        for idx, circuit in enumerate(circuits):
            data[""experiments""][f""experiment_{idx}""] = {
                ""circuit"": circuit,
            }

        job_id = str(uuid.uuid4())
        aer_job = AerJob(self, job_id, self._execute, data)
        aer_job.submit()
        return aer_job


def _simulate_ffsim(
    circuit: QuantumCircuit, num_species: int, shots: int | None = None, seed=None
) -> dict[str, Any]:
    assert circuit.num_qubits % num_species == 0
    norb = circuit.num_qubits // num_species
    occ_a, occ_b = _get_initial_occupations(circuit, num_species)
    nelec = len(occ_a), len(occ_b)
    vec = ffsim.slater_determinant(norb, (occ_a, occ_b))
    qubit_indices = {q: i for i, q in enumerate(circuit.qubits)}
    for instruction in circuit.data:
        op, qubits, _ = instruction.operation, instruction.qubits, instruction.clbits
        if isinstance(op, Hop):
            orbs = [qubit_indices[q] for q in qubits]
            spatial_orbs = _get_spatial_orbitals(orbs, norb, num_species)
            vec = _simulate_hop(
                vec,
                np.array(op.params),
                spatial_orbs,
                norb=norb,
                nelec=nelec,
                num_species=num_species,
                copy=False,
            )
        elif isinstance(op, Interaction):
            orbs = [qubit_indices[q] for q in qubits]
            spatial_orbs = _get_spatial_orbitals(orbs, norb, num_species)
            (interaction,) = op.params
            vec = _simulate_interaction(
                vec,
                interaction,
                spatial_orbs,
                norb=norb,
                nelec=nelec,
                num_species=num_species,
                copy=False,
            )
        elif isinstance(op, Phase):
            orbs = [qubit_indices[q] for q in qubits]
            spatial_orbs = _get_spatial_orbitals(orbs, norb, num_species)
            vec = _simulate_phase(
                vec,
                np.array(op.params),
                spatial_orbs,
                norb=norb,
                nelec=nelec,
                num_species=num_species,
                copy=False,
            )
        elif isinstance(op, FRZGate):
            orbs = [qubit_indices[q] for q in qubits]
            # pass num_species=1 here due to the definition of FRZGate
            spatial_orbs = _get_spatial_orbitals(orbs, norb, num_species=1)
            (phi,) = op.params
            vec = _simulate_frz(
                vec,
                phi,
                spatial_orbs,
                norb=norb,
                nelec=nelec,
                num_species=num_species,
                copy=False,
            )
        elif isinstance(op, FRXGate):
            if num_species != 1:
                raise RuntimeError(
                    f""Encountered FRXGate even though num_species={num_species}. ""
                    ""FRXGate is only supported for num_species=1.""
                )
            orbs = [qubit_indices[q] for q in qubits]
            spatial_orbs = _get_spatial_orbitals(orbs, norb, num_species=1)
            (phi,) = op.params
            vec = ffsim.apply_tunneling_interaction(
                vec, -phi, spatial_orbs, norb, nelec, copy=False
            )
        elif isinstance(op, FRYGate):
            if num_species != 1:
                raise RuntimeError(
                    f""Encountered FRXGate even though num_species={num_species}. ""
                    ""FRXGate is only supported for num_species=1.""
                )
            orbs = [qubit_indices[q] for q in qubits]
            spatial_orbs = _get_spatial_orbitals(orbs, norb, num_species=1)
            (phi,) = op.params
            vec = ffsim.apply_givens_rotation(vec, -phi, spatial_orbs, norb, nelec, copy=False)
        elif isinstance(op, FermionicGate):
            orbs = [qubit_indices[q] for q in qubits]
            spatial_orbs = _get_spatial_orbitals(orbs, norb, num_species)
            ferm_op = _fermionic_op_to_fermion_operator(op.generator, spatial_orbs)
            linop = ffsim.linear_operator(ferm_op, norb, nelec)
            # TODO use ferm_op.values once it's available
            scale = sum(abs(ferm_op[k]) for k in ferm_op)
            vec = expm_multiply(-1j * linop, vec, traceA=scale)
        elif isinstance(op, (LoadFermions, Measure, Barrier)):
            # these gates are handled separately or are no-ops
            pass
        else:
            warnings.warn(f""Unrecognized gate type {type(op)}, skipping it..."")

    result = {""statevector"": vec}

    if shots is None:
        result[""memory""] = []
        result[""counts""] = {}
    else:
        rng = np.random.default_rng(seed)
        probs = np.abs(vec) ** 2
        samples = rng.choice(np.arange(len(vec)), size=shots, replace=True, p=probs)
        bitstrings = ffsim.indices_to_strings(samples, norb, nelec)
        # flip beta-alpha to alpha-beta ordering
        bitstrings = [f""{b[len(b) // 2 :]}{b[: len(b) // 2]}"" for b in bitstrings]
        # remove bits from absent spins
        bitstrings = [b[: num_species * norb] for b in bitstrings]
        result[""memory""] = bitstrings
        result[""counts""] = Counter(bitstrings)

    return result


def _get_initial_occupations(circuit: QuantumCircuit, num_species: int):
    norb = circuit.num_qubits // num_species
    occ_a, occ_b = set(), set()
    occupations = [occ_a, occ_b]
    active_qubits = set()
    for instruction in circuit.data:
        if isinstance(instruction.operation, LoadFermions):
            for q in instruction.qubits:
                if q in active_qubits:
                    raise ValueError(
                        f""Encountered Load instruction on qubit {q} after it has ""
                        ""already been operated on.""
                    )
                spin, orb = divmod(circuit.qubits.index(q), norb)
                # reverse index due to qiskit convention
                occupations[spin].add(norb - 1 - orb)
        else:
            active_qubits |= set(instruction.qubits)
    return tuple(occ_a), tuple(occ_b)


def _get_spatial_orbitals(orbs: list[int], norb: int, num_species: int) -> list[int]:
    assert len(orbs) % num_species == 0
    alpha_orbs = orbs[: len(orbs) // num_species]
    if num_species == 2:
        beta_orbs = [orb - norb for orb in orbs[len(orbs) // 2 :]]
        assert alpha_orbs == beta_orbs
    # reverse orbitals due to qiskit convention
    alpha_orbs = [norb - 1 - orb for orb in alpha_orbs]
    return alpha_orbs


def _simulate_hop(
    vec: np.ndarray,
    coeffs: np.ndarray,
    target_orbs: list[int],
    norb: int,
    nelec: tuple[int, int],
    num_species: int,
    copy: bool,
) -> np.ndarray:
    if num_species == 1:
        return _simulate_hop_spinless(
            vec=vec,
            coeffs=coeffs,
            target_orbs=target_orbs,
            norb=norb,
            nelec=nelec,
            copy=copy,
        )
    else:  # num_species == 2
        return _simulate_hop_spinful(
            vec=vec,
            coeffs=coeffs,
            target_orbs=target_orbs,
            norb=norb,
            nelec=nelec,
            copy=copy,
        )


def _simulate_hop_spinless(
    vec: np.ndarray,
    coeffs: np.ndarray,
    target_orbs: list[int],
    norb: int,
    nelec: tuple[int, int],
    copy: bool,
) -> np.ndarray:
    assert norb % 2 == 0
    assert len(target_orbs) % 2 == 0
    mat = np.zeros((norb, norb))
    for i, val in zip(range(len(target_orbs) // 2 - 1), coeffs):
        j, k = target_orbs[i], target_orbs[i + 1]
        mat[j, k] = -val
        mat[k, j] = -val
    for i, val in zip(range(len(target_orbs) // 2, len(target_orbs) - 1), coeffs):
        j, k = target_orbs[i], target_orbs[i + 1]
        mat[j, k] = -val
        mat[k, j] = -val
    coeffs, orbital_rotation = scipy.linalg.eigh(mat)
    return ffsim.apply_num_op_sum_evolution(
        vec,
        coeffs,
        1.0,
        norb=norb,
        nelec=nelec,
        orbital_rotation=orbital_rotation,
        copy=copy,
    )


def _simulate_hop_spinful(
    vec: np.ndarray,
    coeffs: np.ndarray,
    target_orbs: list[int],
    norb: int,
    nelec: tuple[int, int],
    copy: bool,
) -> np.ndarray:
    mat = np.zeros((norb, norb))
    for i, val in zip(range(len(target_orbs) - 1), coeffs):
        j, k = target_orbs[i], target_orbs[i + 1]
        mat[j, k] = -val
        mat[k, j] = -val
    coeffs, orbital_rotation = scipy.linalg.eigh(mat)
    return ffsim.apply_num_op_sum_evolution(
        vec,
        coeffs,
        1.0,
        norb=norb,
        nelec=nelec,
        orbital_rotation=orbital_rotation,
        copy=copy,
    )


def _simulate_interaction(
    vec: np.ndarray,
    interaction: float,
    target_orbs: list[int],
    norb: int,
    nelec: tuple[int, int],
    num_species: int,
    copy: bool,
) -> np.ndarray:
    if num_species == 1:
        return _simulate_interaction_spinless(
            vec=vec,
            interaction=interaction,
            target_orbs=target_orbs,
            norb=norb,
            nelec=nelec,
            copy=copy,
        )
    else:  # num_species == 2
        return _simulate_interaction_spinful(
            vec=vec,
            interaction=interaction,
            target_orbs=target_orbs,
            norb=norb,
            nelec=nelec,
            copy=copy,
        )


def _simulate_interaction_spinless(
    vec: np.ndarray,
    interaction: float,
    target_orbs: list[int],
    norb: int,
    nelec: tuple[int, int],
    copy: bool,
) -> np.ndarray:
    assert len(target_orbs) % 2 == 0
    n_spatial_orbs = len(target_orbs) // 2
    mat = np.zeros((norb, norb))
    mat[target_orbs[:n_spatial_orbs], target_orbs[n_spatial_orbs:]] = interaction
    mat[target_orbs[n_spatial_orbs:], target_orbs[:n_spatial_orbs]] = interaction
    return ffsim.apply_diag_coulomb_evolution(
        vec,
        mat=mat,
        time=1.0,
        norb=norb,
        nelec=nelec,
        copy=copy,
    )


def _simulate_interaction_spinful(
    vec: np.ndarray,
    interaction: float,
    target_orbs: list[int],
    norb: int,
    nelec: tuple[int, int],
    copy: bool,
) -> np.ndarray:
    mat_alpha_beta = np.zeros((norb, norb))
    mat_alpha_beta[target_orbs, target_orbs] = interaction
    return ffsim.apply_diag_coulomb_evolution(
        vec,
        mat=np.zeros((norb, norb)),
        mat_alpha_beta=mat_alpha_beta,
        time=1.0,
        norb=norb,
        nelec=nelec,
        copy=copy,
    )


def _simulate_phase(
    vec: np.ndarray,
    mu: np.ndarray,
    target_orbs: list[int],
    norb: int,
    nelec: tuple[int, int],
    num_species: int,
    copy: bool,
) -> np.ndarray:
    if num_species == 1:
        return _simulate_phase_spinless(
            vec=vec,
            mu=mu,
            target_orbs=target_orbs,
            norb=norb,
            nelec=nelec,
            copy=copy,
        )
    else:  # num_species == 2
        return _simulate_phase_spinful(
            vec=vec,
            mu=mu,
            target_orbs=target_orbs,
            norb=norb,
            nelec=nelec,
            copy=copy,
        )


def _simulate_phase_spinless(
    vec: np.ndarray,
    mu: np.ndarray,
    target_orbs: list[int],
    norb: int,
    nelec: tuple[int, int],
    copy: bool,
) -> np.ndarray:
    assert len(target_orbs) % 2 == 0
    n_spatial_orbs = len(target_orbs) // 2
    coeffs = np.zeros(norb)
    coeffs[target_orbs[:n_spatial_orbs]] = mu
    coeffs[target_orbs[n_spatial_orbs:]] = mu
    return ffsim.apply_num_op_sum_evolution(
        vec, coeffs, time=1.0, norb=norb, nelec=nelec, copy=copy
    )


def _simulate_phase_spinful(
    vec: np.ndarray,
    mu: np.ndarray,
    target_orbs: list[int],
    norb: int,
    nelec: tuple[int, int],
    copy: bool,
) -> np.ndarray:
    coeffs = np.zeros(norb)
    coeffs[target_orbs] = mu
    return ffsim.apply_num_op_sum_evolution(
        vec, coeffs, time=1.0, norb=norb, nelec=nelec, copy=copy
    )


def _simulate_frz(
    vec: np.ndarray,
    phi: np.ndarray,
    target_orbs: list[int],
    norb: int,
    nelec: tuple[int, int],
    num_species: int,
    copy: bool,
) -> np.ndarray:
    if num_species == 1:
        a, b = target_orbs
        vec = ffsim.apply_num_interaction(vec, -phi, a, norb, nelec, copy=copy)
        vec = ffsim.apply_num_interaction(vec, phi, b, norb, nelec, copy=False)
        return vec
    else:  # num_species == 2
        a, b = target_orbs
        spin_a, orb_a = divmod(a, norb)
        spin_b, orb_b = divmod(b, norb)
        spins = (ffsim.Spin.ALPHA, ffsim.Spin.BETA)
        vec = ffsim.apply_num_interaction(vec, -phi, orb_a, norb, nelec, spins[spin_a], copy=copy)
        vec = ffsim.apply_num_interaction(vec, phi, orb_b, norb, nelec, spins[spin_b], copy=False)
        return vec


def _fermionic_op_to_fermion_operator(  # pylint: disable=invalid-name
    op: FermionicOp, target_orbs: list[int]
) -> ffsim.FermionOperator:
    """"""Convert a Qiskit Nature FermionicOp to an ffsim FermionOperator.""""""
    norb_small = len(target_orbs)
    coeffs = {}
    for term, coeff in op.terms():
        fermion_actions = []
        for action_str, index in term:
            action = action_str == ""+""
            spin, orb = divmod(index, norb_small)
            fermion_actions.append((action, bool(spin), target_orbs[orb]))
        coeffs[tuple(fermion_actions)] = coeff
    return ffsim.FermionOperator(coeffs)
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Classes for remote cold atom backends.""""""

import json
from typing import List, Dict, Union
import requests

from qiskit.providers.models import BackendConfiguration
from qiskit.providers import Options
from qiskit import QuantumCircuit
from qiskit.providers import ProviderV1 as Provider
from qiskit.providers import BackendV1 as Backend
from qiskit.providers import JobStatus

from qiskit_cold_atom.spins.base_spin_backend import BaseSpinBackend
from qiskit_cold_atom.fermions.base_fermion_backend import BaseFermionBackend
from qiskit_cold_atom.circuit_tools import CircuitTools
from qiskit_cold_atom.providers.cold_atom_job import ColdAtomJob
from qiskit_cold_atom.exceptions import QiskitColdAtomError


class RemoteBackend(Backend):
    """"""Remote cold atom backend.""""""

    def __init__(self, provider: Provider, url: str):
        """"""
        Initialize the backend by querying the server for the backend configuration dictionary.

        Args:
            provider: The provider which need to have the correct credentials attributes in place
            url: The url of the backend server

        Raises:
            QiskitColdAtomError: If the connection to the backend server can not be established.

        """"""

        self.url = url
        self.username = provider.credentials[""username""]
        self.token = provider.credentials[""token""]
        # Get the config file from the remote server
        try:
            r = requests.get(
                self.url + ""/get_config"",
                params={
                    ""username"": self.username,
                    ""token"": self.token,
                },
            )
        except requests.exceptions.ConnectionError as err:
            raise QiskitColdAtomError(
                ""connection to the backend server can not be established.""
            ) from err

        super().__init__(configuration=BackendConfiguration.from_dict(r.json()), provider=provider)

    @classmethod
    def _default_options(cls) -> Options:
        """"""Return the default options.

        Returns:
            qiskit.providers.Options: A options object with default values set
        """"""
        return Options(shots=1)

    @property
    def credentials(self) -> Dict[str, Union[str, List[str]]]:
        """"""Returns: the access credentials used.""""""
        return self.provider().credentials

    # pylint: disable=arguments-differ, unused-argument
    def run(
        self,
        circuit: Union[QuantumCircuit, List[QuantumCircuit]],
        shots: int = 1,
        convert_wires: bool = True,
        **run_kwargs,
    ) -> ColdAtomJob:
        """"""
        Run a quantum circuit or list of quantum circuits.

        Args:
            circuit: The quantum circuits to be executed on the device backend
            shots: The number of measurement shots to be measured for each given circuit
            convert_wires: If True (the default), the circuits are converted to the wiring convention
            of the backend.
            run_kwargs: Additional keyword arguments that might be passed down when calling
            qiskit.execute() which will have no effect on this backend.

        Raises:
            QiskitColdAtomError: If the response from the backend does not have a job_id.

        Returns:
            A Job object through the backend can be queried for status, result etc.
        """"""

        job_payload = CircuitTools.circuit_to_cold_atom(circuit, self, shots=shots)

        res = requests.post(
            self.url + ""/post_job"",
            json={
                ""job"": json.dumps(job_payload),
                ""username"": self.username,
                ""token"": self.token,
            },
        )

        res.raise_for_status()
        response = res.json()

        if ""job_id"" not in response:
            raise QiskitColdAtomError(""The response has no job_id."")

        return ColdAtomJob(self, response[""job_id""])

    def retrieve_job(self, job_id: str) -> ColdAtomJob:
        """"""Return a single job submitted to this backend.

        Args:
            job_id: The ID of the job to retrieve.

        Returns:
            The job with the given ID.

        Raises:
            QiskitColdAtomError: If the job retrieval failed.
        """"""

        retrieved_job = ColdAtomJob(backend=self, job_id=job_id)

        try:
            job_status = retrieved_job.status()
        except requests.exceptions.RequestException as request_error:
            raise QiskitColdAtomError(
                ""connection to the remote backend could not be established""
            ) from request_error

        if job_status == JobStatus.ERROR:
            raise QiskitColdAtomError(f""Job with id {job_id} could not be retrieved"")

        return retrieved_job


class RemoteSpinBackend(RemoteBackend, BaseSpinBackend):
    """"""Remote backend which runs spin circuits.""""""


class RemoteFermionBackend(RemoteBackend, BaseFermionBackend):
    """"""Remote backend which runs fermionic circuits.""""""
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Module for cold-atom spin backends.""""""

from abc import ABC

from qiskit.providers import BackendV1 as Backend
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit_cold_atom import QiskitColdAtomError


class BaseSpinBackend(Backend, ABC):
    """"""Abstract base class for atomic mixture backends.""""""

    def get_empty_circuit(self) -> QuantumCircuit:
        """"""
        Convenience function to set up an empty circuit with the right QuantumRegisters.
        For each atomic species specified in the config file, a quantum register is added to the circuit.

        Returns:
            qc: An empty quantum circuit ready to use in spin-based cold-atom setups.

        Raises:
            QiskitColdAtomError:
                - If backend has no config file.
                - If number of wires of the backend config is not a multiple of the atomic species.
        """"""
        config = self.configuration().to_dict()

        try:
            num_wires = config[""n_qubits""]
            num_species = len(config[""atomic_species""])

        except NameError as name_error:
            raise QiskitColdAtomError(
                ""backend needs to be initialized with config file first""
            ) from name_error

        if not (isinstance(num_wires, int) and num_wires % num_species == 0):
            raise QiskitColdAtomError(
                ""num_wires {num_wires} must be multiple of num_species {num_species}""
            )

        qregs = [
            QuantumRegister(num_wires / num_species, species)
            for species in config[""atomic_species""]
        ]

        class_reg = ClassicalRegister(num_wires, ""c{}"".format(num_wires))
        empty_circuit = QuantumCircuit(*qregs, class_reg)

        return empty_circuit

    def draw(self, qc: QuantumCircuit, **draw_options):
        """"""Modified circuit drawer to better display atomic mixture quantum circuits.

        For now this method is just an alias to `QuantumCircuit.draw()` but in the future this method
        may be modified and tailored to spin quantum circuits.

        Args:
            qc: The quantum circuit to draw.
            draw_options: Key word arguments for the drawing of circuits.
        """"""
        qc.draw(**draw_options)
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Module to simulate spin circuits.""""""

import math
from typing import List, Union, Optional
from fractions import Fraction
import numpy as np
from scipy.sparse import csc_matrix
from qiskit import QuantumCircuit
from qiskit_nature.second_q.operators import SpinOp
from qiskit_cold_atom.base_circuit_solver import BaseCircuitSolver
from qiskit_cold_atom.exceptions import QiskitColdAtomError


class SpinCircuitSolver(BaseCircuitSolver):
    """"""Performs numerical simulations of spin systems by exactly computing the time
    evolution under unitary operations generated by exponentiating spin Hamiltonians.""""""

    def __init__(
        self,
        spin: Union[float, Fraction] = Fraction(1, 2),
        shots: Optional[int] = None,
        seed: Optional[int] = None,
    ):
        """"""
        Initialize a spin circuit solver.

        Args:
            spin: The length of the spin of each wire in the circuit.
            shots: Amount of shots for the measurement simulation;
                   if not None, measurements are performed.
            seed: The seed for the RNG for the measurement simulation.

        Raises:
            QiskitColdAtomError: if the spin is not a positive integer or half-integer.
        """"""

        self.spin = Fraction(spin)
        if self.spin.denominator not in (1, 2):
            raise QiskitColdAtomError(
                f""spin must be a positive half-integer (integer or half-odd-integer), ""
                f""not {self.spin}.""
            )

        super().__init__(shots=shots, seed=seed)

    def get_initial_state(self, circuit: QuantumCircuit) -> csc_matrix:
        """"""
        Return the initial state as a sparse column vector.

        Args:
            circuit: A circuit that tells us the dimension of the initial state to return.

        Returns:
            initial state: A sparse column vector of the initial state.
        """"""

        dim = int((2 * self.spin + 1) ** circuit.num_qubits)

        initial_state = csc_matrix(([1 + 0j], ([0], [0])), shape=(dim, 1), dtype=complex)
        return initial_state

    def _embed_operator(self, operator: SpinOp, num_wires: int, qargs: List[int]) -> SpinOp:
        """"""
        Turning a SpinOp operator that acts onto the wires given in qargs into an operator
        that acts on the entire register of the circuit by manipulating the indices of the
        sparse labels of the SpinOps.

        Args:
            operator: SpinOp describing the generating Hamiltonian of a gate
            num_wires: The total number of wires in which the operator should be embedded into
            qargs: The wire indices the gate acts on

        Returns:
            A SpinOp acting on the entire quantum register of the Circuit

        Raises:
            QiskitColdAtomError: - If the given operator is not a SpinOp
                                 - If the size of the operator does not match the given qargs
        """"""
        if not isinstance(operator, SpinOp):
            raise QiskitColdAtomError(f""Expected SpinOp; got {type(operator).__name__} instead"")

        if operator.num_spins != len(qargs):
            raise QiskitColdAtomError(
                f""operator size {operator.num_spins} does not match qargs {qargs} of the gates.""
            )

        embedded_op_dict = {}
        for label, factor in operator._data.items():
            old_labels = label.split()
            new_labels = [term[:2] + str(qargs[int(term[2])]) + term[3:] for term in old_labels]
            embedded_op_dict["" "".join(map(str, new_labels))] = factor

        return SpinOp(embedded_op_dict, spin=self.spin, num_spins=num_wires)

    def operator_to_mat(self, operator: SpinOp) -> csc_matrix:
        """"""
        Convert a SpinOp describing a gate generator to a sparse matrix.

        Args:
            operator: spin operator of which to compute the matrix representation

        Returns:
            scipy.sparse matrix of the Hamiltonian
        """"""
        return csc_matrix(operator.to_matrix())

    def preprocess_circuit(self, circuit: QuantumCircuit):
        r""""""
        Compute the Hilbert space dimension of the given quantum circuit as :math:`(2S+1)^N`
        where :math:`S` is the length of the spin and :math:`N` is the number of spins in
        the quantum circuit.

        Args:
            circuit: The circuit to pre-process.
        """"""
        self._dim = int((2 * self.spin + 1) ** circuit.num_qubits)

    def draw_shots(self, measurement_distribution: List[float]) -> List[str]:
        r""""""A helper function to draw counts from a given distribution of measurement outcomes.

        Args:
            measurement_distribution: List of probabilities of the individual measurement outcomes.

        Returns:
            outcome_memory: A list of individual measurement results, e.g. [""12 3 4"", ""0 4 9"", ...]
            The outcome of each shot is denoted by a space-delimited string ""a1 a2 a3 ..."" where
            :math:`a_i` is the measured level of the spin with possible values ranging from 0 to 2S
            The :math:`a_i` are in reverse order of the spins of the register to comply with qiskit's
            little endian convention.

        Raises:
            QiskitColdAtomError:
                - If the length of the given probabilities does not math the expected Hilbert
                    space dimension.
                - If the dimension is not a power of the spin length of the solver.
                - If the number of shots self.shots has not been specified.
        """"""

        meas_dim = len(measurement_distribution)

        if meas_dim != self.dim:
            raise QiskitColdAtomError(
                f""Dimension of the measurement probabilities {meas_dim} does not ""
                f""match the dimension expected by the solver, {self.dim}""
            )

        if self.shots is None:
            raise QiskitColdAtomError(
                ""The number of shots has to be set before drawing measurements""
            )

        # Draw measurements as the indices of the basis states:
        meas_results = np.random.choice(range(meas_dim), self.shots, p=measurement_distribution)
        base = int(2 * self.spin + 1)
        num_wires = math.log(meas_dim, base)

        if num_wires.is_integer():
            num_wires = int(num_wires)
        else:
            raise QiskitColdAtomError(
                ""The length of given measurement distribution it not compatible with ""
                ""the spin-length of the solver.""
            )

        outcome_memory = []
        for meas_idx in meas_results:
            digits = [0] * num_wires
            for i in range(num_wires):
                digits[i] = meas_idx % base
                meas_idx //= base

            outcome_memory.append("" "".join(map(str, digits)))

        return outcome_memory
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""General spin simulator backend.""""""

from typing import Union, List, Dict, Any, Optional
import uuid
from fractions import Fraction
import warnings
import time
import datetime

from qiskit.providers.models import BackendConfiguration
from qiskit.providers import Options
from qiskit import QuantumCircuit
from qiskit.result import Result
from qiskit.circuit.measure import Measure
from qiskit_aer import AerJob

from qiskit_cold_atom.spins.spin_circuit_solver import SpinCircuitSolver
from qiskit_cold_atom.spins.base_spin_backend import BaseSpinBackend
from qiskit_cold_atom.circuit_tools import CircuitTools


class SpinSimulator(BaseSpinBackend):
    """"""A simulator to simulate general spin circuits.

    This general spin simulator backend simulates spin circuits with gates that have
    generators described by spin Hamiltonians. It computes the statevector and unitary
    of a circuit and simulates measurements.
    """"""

    # Default configuration of the backend if the user does not provide one.
    __DEFAULT_CONFIGURATION__ = {
        ""backend_name"": ""spin_simulator"",
        ""backend_version"": ""0.0.1"",
        ""n_qubits"": None,
        ""basis_gates"": None,
        ""gates"": [],
        ""local"": True,
        ""simulator"": True,
        ""conditional"": False,
        ""open_pulse"": False,
        ""memory"": True,
        ""max_shots"": 1e5,
        ""coupling_map"": None,
        ""description"": ""a base simulator for spin circuits. Instead of a qubit, each wire represents a ""
        ""single high-dimensional spin"",
    }

    def __init__(self, config_dict: Optional[Dict[str, Any]] = None, provider=None):
        """"""
        Initialize the backend from a configuration dictionary.

        Args:
            config_dict: Configuration dictionary of the backend. If None is given
                a default is assumed.
        """"""

        if config_dict is None:
            config_dict = self.__DEFAULT_CONFIGURATION__

        super().__init__(
            configuration=BackendConfiguration.from_dict(config_dict), provider=provider
        )

    @classmethod
    def _default_options(cls):
        return Options(shots=1)

    def _execute(self, data: Dict[str, Any], job_id: str = """") -> Result:
        """"""
        Helper function to execute a job. The circuit and all relevant parameters are
        given in the data dict. Performs validation checks on the received circuits
        and utilizes the SpinCircuitSolver to perform the numerical simulations.

        Args:
            data: Data dictionary that that contains the experiments to simulate, given in the shape:
                data = {
                    ""num_species"": int,
                    ""shots"": int,
                    ""seed"": int,
                    ""experiments"": Dict[str, QuantumCircuit],
                }
            job_id: The job id assigned by the run method

        Returns:
            result: A qiskit job result.
        """"""
        # Start timer
        start = time.time()

        output = {""results"": []}

        spin = data[""spin""]
        shots = data[""shots""]
        seed = data[""seed""]

        solver = SpinCircuitSolver(spin, shots, seed)

        for exp_i, exp_name in enumerate(data[""experiments""]):
            experiment = data[""experiments""][exp_name]
            circuit = experiment[""circuit""]

            # perform compatibility checks with the backend configuration in case gates and supported
            # instructions are constrained by the backend's configuration
            if self.configuration().gates and self.configuration().supported_instructions:
                CircuitTools.validate_circuits(circuits=circuit, backend=self, shots=shots)

            # check whether all wires are measured
            measured_wires = set()

            for inst in circuit.data:
                if isinstance(inst[0], Measure):
                    for wire in inst[1]:
                        index = circuit.qubits.index(wire)
                        if index in measured_wires:
                            warnings.warn(
                                f""Wire {index} has already been measured, ""
                                f""second measurement is ignored""
                            )
                        else:
                            measured_wires.add(index)

            if measured_wires and len(measured_wires) != len(circuit.qubits):
                warnings.warn(
                    f""Number of wires in the circuit ({len(circuit.qubits)}) does not equal the ""
                    f""number of wires with measurement instructions ({len(measured_wires)}). ""
                    f""{self.__class__.__name__} only supports measurement of the entire quantum ""
                    ""register which will be performed instead.""
                )

            if not measured_wires:
                solver.shots = None

            simulation_result = solver(circuit)

            output[""results""].append(
                {
                    ""header"": {""name"": exp_name, ""random_seed"": seed},
                    ""shots"": shots,
                    ""spin"": spin,
                    ""status"": ""DONE"",
                    ""success"": True,
                }
            )
            # add the simulation result at the correct place in the result dictionary
            output[""results""][exp_i][""data""] = simulation_result

        output[""job_id""] = job_id
        output[""date""] = datetime.datetime.now().isoformat()
        output[""backend_name""] = self.name()
        output[""backend_version""] = self.configuration().backend_version
        output[""time_taken""] = time.time() - start
        output[""success""] = True
        output[""qobj_id""] = None

        return Result.from_dict(output)

    # pylint: disable=arguments-differ, unused-argument
    def run(
        self,
        circuits: Union[QuantumCircuit, List[QuantumCircuit]],
        shots: int = 1000,
        spin: Union[float, Fraction] = Fraction(1, 2),
        seed: Optional[int] = None,
        **run_kwargs,
    ) -> AerJob:
        """"""
        Run the simulator with a variable length of the individual spins.

        Args:
            circuits: A list of quantum circuits.
            shots: The number of shots to measure.
            spin: The spin length of the simulated system which must be a positive
                integer or half-integer. Defaults to 1/2 which is equivalent to qubits.
            seed: The seed for the simulator.
            run_kwargs: Additional keyword arguments that might be passed down when calling
            qiskit.execute() which will have no effect on this backend.

        Returns:
             aer_job: a job object containing the result of the simulation
        """"""

        if isinstance(circuits, QuantumCircuit):
            circuits = [circuits]

        data = {""spin"": spin, ""shots"": shots, ""seed"": seed, ""experiments"": {}}

        for idx, circuit in enumerate(circuits):
            data[""experiments""][""experiment_%i"" % idx] = {
                ""circuit"": circuit,
            }

        job_id = str(uuid.uuid4())
        aer_job = AerJob(self, job_id, self._execute, data)
        aer_job.submit()
        return aer_job
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""tests for circuit_to_cold_atom functions""""""

from typing import Dict

from qiskit import QuantumCircuit
from qiskit.test import QiskitTestCase
from qiskit.circuit import Parameter
from qiskit.providers import BackendV1 as Backend
from qiskit.providers.models import BackendConfiguration
from qiskit_cold_atom.exceptions import QiskitColdAtomError
from qiskit_cold_atom.circuit_tools import CircuitTools, WireOrder

# These imports are needed to decorate the quantum circuit
import qiskit_cold_atom.spins  # pylint: disable=unused-import
import qiskit_cold_atom.fermions  # pylint: disable=unused-import


class DummyBackend(Backend):
    """"""dummy backend class for test purposes only""""""

    def __init__(self, config_dict: Dict):
        super().__init__(configuration=BackendConfiguration.from_dict(config_dict))

    def run(self, run_input, **options):
        pass

    @classmethod
    def _default_options(cls):
        pass


class TestCircuitToColdAtom(QiskitTestCase):
    """"""circuit to cold atom tests.""""""

    def setUp(self):
        super().setUp()
        # Set up a dummy backend from a configuration dictionary

        test_config = {
            ""backend_name"": ""test_backend"",
            ""backend_version"": ""0.0.1"",
            ""simulator"": True,
            ""local"": True,
            ""coupling_map"": None,
            ""description"": ""dummy backend for testing purposes only"",
            ""basis_gates"": [""hop, int""],
            ""memory"": False,
            ""n_qubits"": 5,
            ""conditional"": False,
            ""max_shots"": 100,
            ""max_experiments"": 2,
            ""open_pulse"": False,
            ""gates"": [
                {
                    ""coupling_map"": [[0], [1], [2], [3], [4]],
                    ""name"": ""rlz"",
                    ""parameters"": [""delta""],
                    ""qasm_def"": ""gate rLz(delta) {}"",
                },
                {
                    ""coupling_map"": [[0], [1], [2]],
                    ""name"": ""rlz2"",
                    ""parameters"": [""chi""],
                    ""qasm_def"": ""gate rlz2(chi) {}"",
                },
                {
                    ""coupling_map"": [[0], [1], [2], [3], [4]],
                    ""name"": ""rlx"",
                    ""parameters"": [""omega""],
                    ""qasm_def"": ""gate rx(omega) {}"",
                },
            ],
            ""supported_instructions"": [
                ""delay"",
                ""rlx"",
                ""rlz"",
                ""rlz2"",
                ""measure"",
                ""barrier"",
            ],
        }

        self.dummy_backend = DummyBackend(test_config)

    def test_circuit_to_cold_atom(self):
        """"""test the circuit_to_cold_atom function""""""

        circ1 = QuantumCircuit(3)
        circ1.rlx(0.5, [0, 1])
        circ1.rlz(0.3, [1, 2])
        circ1.measure_all()

        circ2 = QuantumCircuit(2)
        circ2.rlz2(0.5, 1)
        circ2.measure_all()

        shots = 10

        target_output = {
            ""experiment_0"": {
                ""instructions"": [
                    [""rlx"", [0], [0.5]],
                    [""rlx"", [1], [0.5]],
                    [""rlz"", [1], [0.3]],
                    [""rlz"", [2], [0.3]],
                    [""barrier"", [0, 1, 2], []],
                    [""measure"", [0], []],
                    [""measure"", [1], []],
                    [""measure"", [2], []],
                ],
                ""num_wires"": 3,
                ""shots"": shots,
                ""wire_order"": ""sequential"",
            },
            ""experiment_1"": {
                ""instructions"": [
                    [""rlz2"", [1], [0.5]],
                    [""barrier"", [0, 1], []],
                    [""measure"", [0], []],
                    [""measure"", [1], []],
                ],
                ""num_wires"": 2,
                ""shots"": shots,
                ""wire_order"": ""sequential"",
            },
        }

        actual_output = CircuitTools.circuit_to_cold_atom(
            [circ1, circ2], backend=self.dummy_backend, shots=shots
        )

        self.assertEqual(actual_output, target_output)

    def test_validate_circuits(self):
        """"""test the validation of circuits against the backend configuration""""""

        with self.subTest(""test size of circuit""):
            circ = QuantumCircuit(6)
            circ.rlx(0.4, 2)
            with self.assertRaises(QiskitColdAtomError):
                CircuitTools.validate_circuits(circ, backend=self.dummy_backend)

        with self.subTest(""test support of native instructions""):
            circ = QuantumCircuit(4)
            # add gate that is not supported by the backend
            circ.fhop([0.5], [0, 1, 2, 3])
            with self.assertRaises(QiskitColdAtomError):
                CircuitTools.validate_circuits(circ, backend=self.dummy_backend)

        with self.subTest(""check gate coupling map""):
            circ = QuantumCircuit(5)
            circ.rlz2(0.5, 4)
            with self.assertRaises(QiskitColdAtomError):
                CircuitTools.validate_circuits(circ, backend=self.dummy_backend)

        with self.subTest(""test max. allowed circuits""):
            circuits = [QuantumCircuit(2)] * 3
            with self.assertRaises(QiskitColdAtomError):
                CircuitTools.circuit_to_cold_atom(circuits=circuits, backend=self.dummy_backend)

        with self.subTest(""test max. allowed shots""):
            circuits = QuantumCircuit(2)
            with self.assertRaises(QiskitColdAtomError):
                CircuitTools.circuit_to_cold_atom(
                    circuits=circuits, backend=self.dummy_backend, shots=1000
                )

        with self.subTest(""test running with unbound parameters""):
            theta = Parameter(""θ"")
            circ = QuantumCircuit(1)
            circ.rlx(theta, 0)
            with self.assertRaises(QiskitColdAtomError):
                CircuitTools.validate_circuits(circ, backend=self.dummy_backend)

    def test_circuit_to_data(self):
        """"""test the circuit to data method""""""

        circ = QuantumCircuit(3)
        circ.rlx(0.5, [0, 1])
        circ.rlz(0.3, [1, 2])
        circ.measure_all()

        target_output = [
            [""rlx"", [0], [0.5]],
            [""rlx"", [1], [0.5]],
            [""rlz"", [1], [0.3]],
            [""rlz"", [2], [0.3]],
            [""barrier"", [0, 1, 2], []],
            [""measure"", [0], []],
            [""measure"", [1], []],
            [""measure"", [2], []],
        ]

        actual_output = CircuitTools.circuit_to_data(circ, backend=self.dummy_backend)

        self.assertEqual(actual_output, target_output)

    def test_convert_wire_order(self):
        """"""test the convert_wire_order method""""""

        num_sites = 4
        num_species = 3
        # conversion rule: i -> (i % num_sites) * num_species + i // num_sites
        wires_sequential = [0, 1, 4, 5, 8, 9]
        wires_interleaved = [0, 3, 1, 4, 2, 5]

        with self.subTest(""test sequential to interleaved""):
            wires_converted = CircuitTools.convert_wire_order(
                wires=wires_sequential,
                convention_from=WireOrder.SEQUENTIAL,
                convention_to=WireOrder.INTERLEAVED,
                num_sites=num_sites,
                num_species=num_species,
            )
            self.assertEqual(wires_converted, wires_interleaved)

        with self.subTest(""test interleaved to sequential""):
            wires_converted = CircuitTools.convert_wire_order(
                wires=wires_interleaved,
                convention_from=WireOrder.INTERLEAVED,
                convention_to=WireOrder.SEQUENTIAL,
                num_sites=num_sites,
                num_species=num_species,
            )
            self.assertEqual(wires_converted, wires_sequential)
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Fermionic circuit solver tests.""""""

import numpy as np

from qiskit import QuantumCircuit
from qiskit.test import QiskitTestCase
from qiskit_nature.second_q.operators import FermionicOp, SpinOp

from qiskit_cold_atom.fermions.fermion_circuit_solver import (
    FermionCircuitSolver,
    FermionicBasis,
)
from qiskit_cold_atom.fermions.fermion_gate_library import Hop
from qiskit_cold_atom.exceptions import QiskitColdAtomError

# Black import needed to decorate the quantum circuit with spin gates.
import qiskit_cold_atom.spins  # pylint: disable=unused-import


class TestFermionCircuitSolver(QiskitTestCase):
    """"""class to test the FermionCircuitSolver class.""""""

    def setUp(self):
        super().setUp()
        # Setup two solvers with different number of fermionic species
        self.solver1 = FermionCircuitSolver()
        self.solver2 = FermionCircuitSolver(num_species=2)

    def test_basis_setter(self):
        """"""test max. dimension of the basis""""""
        self.solver1.max_dimension = 500
        with self.assertRaises(QiskitColdAtomError):
            self.solver1.basis = FermionicBasis(sites=12, n_particles=6)

    def test_preprocess_circuit(self):
        """"""test the preprocessing of the circuit""""""
        circ = QuantumCircuit(4, 4)
        circ.fload([0, 2])
        circ.fhop([0.5], [0, 1, 2, 3])
        with self.subTest(""spin conserving circuit""):
            self.solver2.preprocess_circuit(circ)
            self.assertEqual(self.solver2._dim, 4)
        with self.subTest(""non spin conserving circuit""):
            self.solver1.preprocess_circuit(circ)
            self.assertEqual(self.solver1._dim, 6)

    def test_get_initial_state(self):
        """"""test initialization of the state for the simulation""""""
        circ = QuantumCircuit(4, 4)
        circ.fload([0, 3])
        self.solver2.preprocess_circuit(circ)
        init_state = self.solver2.get_initial_state(circ)
        target = np.array([0, 0, 1, 0])
        self.assertTrue(np.all(init_state.toarray().T == target))

    def test_embed_operator(self):
        """"""test embedding of an operator""""""
        fer_op = FermionicOp({""+_0 -_1"": 1.0})
        spin_op = SpinOp({""X_0 Y_1"": 1})
        num_wires = 4
        qargs = [1, 3]
        qargs_wrong = [0, 1, 3]

        with self.subTest(""check operator type""):
            with self.assertRaises(QiskitColdAtomError):
                self.solver1._embed_operator(spin_op, num_wires, qargs)

        with self.subTest(""check operator wiring""):
            with self.assertRaises(QiskitColdAtomError):
                self.solver1._embed_operator(fer_op, num_wires, qargs_wrong)

        with self.subTest(""operator embedding""):
            embedded_op = self.solver1._embed_operator(fer_op, num_wires, qargs)
            target_op = FermionicOp({""+_1 -_3"": 1.0}, num_spin_orbitals=4)
            self.assertTrue(embedded_op.simplify() == target_op.simplify())

    def test_conservation_checks(self):
        """"""test the checks for conservation of spin-species.""""""
        with self.subTest(""check operator type""):
            circ = QuantumCircuit(4, 4)
            circ.fhop([0.5], [0, 1, 2, 3])
            circ.rlx(0.5, 0)  # apply gate with a SpinOp generator
            with self.assertRaises(QiskitColdAtomError):
                self.solver1._check_conservations(circ)

        with self.subTest(""check compatibility with number of species""):
            circ = QuantumCircuit(5, 5)
            circ.fhop([0.5], [0, 1, 2, 3])
            self.assertTrue(self.solver1._check_conservations(circ) == (True, True))
            with self.assertRaises(QiskitColdAtomError):
                self.solver2._check_conservations(circ)

        with self.subTest(""spin conserved""):
            circ = QuantumCircuit(4, 4)
            circ.fload([0, 3])
            circ.fhop([0.5], [0, 1, 2, 3])
            self.assertTrue(self.solver2._check_conservations(circ) == (True, True))

        with self.subTest(""spin not conserved""):
            circ = QuantumCircuit(4, 4)
            circ.fload([0, 3])
            circ.fhop([0.5], [0, 1, 2, 3])
            circ.frx(0.3, [0, 2])  # non spin-conserving gate
            self.assertTrue(self.solver2._check_conservations(circ) == (True, False))

    def test_operator_to_mat(self):
        """"""test matrix representation of fermionic gates""""""

        with self.subTest(""check operator type""):
            spin_op = SpinOp({""X_0 Y_1"": 1.0})
            with self.assertRaises(QiskitColdAtomError):
                self.solver1.operator_to_mat(spin_op)

        circ = QuantumCircuit(4, 4)
        circ.fload([0, 3])
        circ.fhop([0.5], [0, 1, 2, 3])

        with self.subTest(""check dimensionality of operator""):
            self.solver2.preprocess_circuit(circ)
            fer_op_wrong = FermionicOp({""+_0 -_1"": 1.0}, num_spin_orbitals=3)
            fer_op_correct = FermionicOp({""+_0 -_1"": 1.0}, num_spin_orbitals=4)
            with self.assertRaises(QiskitColdAtomError):
                self.solver2.operator_to_mat(fer_op_wrong)
            self.solver2.operator_to_mat(fer_op_correct)

        with self.subTest(""test matrix representation""):
            self.solver2.preprocess_circuit(circ)
            target = np.array(
                [
                    [0.0, -0.5, -0.5, 0.0],
                    [-0.5, 0.0, 0.0, -0.5],
                    [-0.5, 0.0, 0.0, -0.5],
                    [0.0, -0.5, -0.5, 0.0],
                ]
            )
            test_op = self.solver2.operator_to_mat(Hop(num_modes=4, j=[0.5]).generator)
            self.assertTrue(np.all(test_op.toarray() == target))

    def test_draw_shots(self):
        """"""test drawing of the shots from a measurement distribution""""""
        circ = QuantumCircuit(4, 4)
        circ.fload([0, 3])
        circ.fhop([0.5], [0, 1, 2, 3])
        self.solver2.preprocess_circuit(circ)

        with self.subTest(""check missing shot number""):
            # error because the number of shots is not specified
            with self.assertRaises(QiskitColdAtomError):
                self.solver2.draw_shots(np.ones(4) / 4)

        self.solver2.shots = 5

        with self.subTest(""check match of dimensions""):
            # error because there is a mismatch in the dimension
            with self.assertRaises(QiskitColdAtomError):
                self.solver2.draw_shots(np.ones(3) / 3)

        with self.subTest(""formatting of measurement outcomes""):
            self.solver2.seed = 40
            outcomes = self.solver2.draw_shots(np.ones(4) / 4)
            self.assertEqual(outcomes, [""0110"", ""0101"", ""1010"", ""0110"", ""0110""])

    def test_to_operators(self):
        """"""test the to_operators method inherited form BaseCircuitSolver""""""

        test_circ = QuantumCircuit(4, 4)
        test_circ.fload([0, 3])
        test_circ.fhop([0.5], [0, 1, 2, 3])
        test_circ.fint(1.0, [0, 1, 2, 3])
        test_circ.measure_all()

        with self.subTest(""test ignore barriers""):
            self.solver1.ignore_barriers = False
            with self.assertRaises(NotImplementedError):
                self.solver1.to_operators(test_circ)
            self.solver1.ignore_barriers = True

        with self.subTest(""check for gate generators""):
            qubit_circ = QuantumCircuit(1)
            qubit_circ.h(0)
            with self.assertRaises(QiskitColdAtomError):
                self.solver1.to_operators(qubit_circ)

        with self.subTest(""gate after previous measurement instruction""):
            meas_circ = QuantumCircuit(4, 4)
            meas_circ.measure_all()
            meas_circ.fhop([0.5], [0, 1, 2, 3])
            with self.assertRaises(QiskitColdAtomError):
                self.solver1.to_operators(meas_circ)

        with self.subTest(""check returned operators""):
            operators = self.solver1.to_operators(test_circ)
            target_ops = [
                FermionicOp(
                    {
                        ""+_0 -_1"": -0.5,
                        ""-_0 +_1"": 0.5,
                        ""+_2 -_3"": -0.5,
                        ""-_2 +_3"": 0.5,
                    },
                    num_spin_orbitals=4,
                ),
                FermionicOp({""+_0 -_0 +_2 -_2"": 1, ""+_1 -_1 +_3 -_3"": 1}, num_spin_orbitals=4),
            ]
            for op, target in zip(operators, target_ops):
                self.assertTrue(op == target)

    def test_call_method(self):
        """"""test the call method inherited form BaseCircuitSolver that simulates a circuit""""""

        test_circ = QuantumCircuit(4)
        test_circ.fload([0, 3])
        test_circ.fhop([np.pi / 4], [0, 1, 2, 3])
        test_circ.fint(np.pi, [0, 1, 2, 3])

        with self.subTest(""running the circuit""):
            self.solver2.shots = 5
            self.solver2.seed = 40
            simulation = self.solver2(test_circ)

            self.assertEqual(simulation[""memory""], [""0110"", ""0101"", ""1010"", ""0110"", ""0110""])
            self.assertEqual(simulation[""counts""], {""1010"": 1, ""0110"": 3, ""0101"": 1})
            self.assertTrue(
                np.allclose(simulation[""statevector""], np.array([-0.5j, -0.5, 0.5, -0.5j]))
            )
            self.assertTrue(
                np.allclose(
                    simulation[""unitary""],
                    np.array(
                        [
                            [-0.5, -0.5j, -0.5j, 0.5],
                            [0.5j, 0.5, -0.5, 0.5j],
                            [0.5j, -0.5, 0.5, 0.5j],
                            [0.5, -0.5j, -0.5j, -0.5],
                        ]
                    ),
                )
            )

        with self.subTest(""check for maximum dimension""):
            self.solver2.max_dimension = 3
            with self.assertRaises(QiskitColdAtomError):
                simulation = self.solver2(test_circ)
            self.solver2.max_dimension = 100

        with self.subTest(""check if shots are specified""):
            self.solver2.shots = None
            simulation = self.solver2(test_circ)
            self.assertEqual(simulation[""memory""], [])
            self.assertEqual(simulation[""counts""], {})
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""General fermionic simulator backend tests.""""""

from time import sleep

import numpy as np
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.providers import JobStatus
from qiskit.result import Result
from qiskit.test import QiskitTestCase
from qiskit_aer import AerJob
from qiskit_nature.second_q.operators import FermionicOp

from qiskit_cold_atom.exceptions import QiskitColdAtomError
from qiskit_cold_atom.fermions.base_fermion_backend import BaseFermionBackend
from qiskit_cold_atom.fermions.fermion_gate_library import FermionicGate
from qiskit_cold_atom.fermions.fermion_simulator_backend import FermionSimulator


class TestFermionSimulatorBackend(QiskitTestCase):
    """"""class to test the FermionSimulatorBackend class.""""""

    def setUp(self):
        super().setUp()
        self.backend = FermionSimulator()

    def test_initialization(self):
        """"""test the initialization of the backend""""""
        target_config = {
            ""backend_name"": ""fermion_simulator"",
            ""backend_version"": ""0.0.1"",
            ""n_qubits"": 20,
            ""basis_gates"": None,
            ""gates"": [],
            ""local"": False,
            ""simulator"": True,
            ""conditional"": False,
            ""open_pulse"": False,
            ""memory"": True,
            ""max_shots"": 1e5,
            ""coupling_map"": None,
            ""description"": r""a base simulator for fermionic circuits. Instead of qubits, ""
            r""each wire represents a single fermionic mode"",
        }

        backend = FermionSimulator()
        self.assertIsInstance(backend, BaseFermionBackend)
        self.assertTrue(target_config.items() <= backend.configuration().to_dict().items())

    def test_run_method(self):
        """"""Test the run method of the backend simulator""""""

        with self.subTest(""test call""):
            circ = self.backend.initialize_circuit([[0, 1], [1, 0]])
            job = self.backend.run(circ)
            self.assertIsInstance(job, AerJob)
            self.assertIsInstance(job.job_id(), str)
            self.assertIsInstance(job.result(), Result)
            sleep(0.01)
            self.assertEqual(job.status(), JobStatus.DONE)

        circ1 = self.backend.initialize_circuit([[0, 1], [1, 0]])
        circ2 = self.backend.initialize_circuit([[1, 1], [1, 0]])

        with self.subTest(""test call with multiple circuits""):
            job = self.backend.run([circ1, circ2])
            self.assertIsInstance(job, AerJob)

        with self.subTest(""test shot number""):
            target_shots = 123
            job = self.backend.run([circ1, circ2], shots=target_shots)
            for exp in job.result().results:
                self.assertEqual(exp.shots, target_shots)

        with self.subTest(""test seed of RNG""):
            target_seed = 123
            job = self.backend.run([circ1, circ2], seed=target_seed)
            for exp in job.result().results:
                self.assertEqual(exp.header.random_seed, target_seed)

        with self.subTest(""test number of fermionic species""):
            # define a circuit that conserves the particle number per fermionic spin species
            test_circ = QuantumCircuit(4)
            test_circ.fload([0, 3])
            test_circ.fhop([np.pi / 4], [0, 1, 2, 3])

            statevector_1 = self.backend.run(test_circ).result().get_statevector()
            self.assertEqual(len(statevector_1), 6)
            # check whether specifying the number of species reduces the dimension of the simulation
            statevector_2 = self.backend.run(test_circ, num_species=2).result().get_statevector()
            self.assertEqual(len(statevector_2), 4)

    def test_execute(self):
        """"""test the ._execute() method internally called by .run()""""""

        with self.subTest(""test partial measurement""):
            circ_meas = QuantumCircuit(2, 2)
            circ_meas.fload(0)
            circ_meas.measure(0, 0)
            with self.assertWarns(UserWarning):
                self.backend.run(circ_meas)

        test_circ = QuantumCircuit(4)
        test_circ.fload([0, 3])
        test_circ.fhop([np.pi / 4], [0, 1, 2, 3])
        test_circ.fint(np.pi, [0, 1, 2, 3])
        test_circ.measure_all()

        result = self.backend.run(test_circ, num_species=2, seed=40, shots=5).result()

        with self.subTest(""test simulation counts""):
            self.assertEqual(result.get_counts(), {""1010"": 1, ""0110"": 3, ""0101"": 1})

        with self.subTest(""test simulation memory""):
            self.assertEqual(result.get_memory(), [""0110"", ""0101"", ""1010"", ""0110"", ""0110""])

        with self.subTest(""test simulation statevector""):
            self.assertTrue(
                np.allclose(result.get_statevector(), np.array([-0.5j, -0.5, 0.5, -0.5j]))
            )

        with self.subTest(""test simulation unitary""):
            self.assertTrue(
                np.allclose(
                    result.get_unitary(),
                    np.array(
                        [
                            [-0.5, -0.5j, -0.5j, 0.5],
                            [0.5j, 0.5, -0.5, 0.5j],
                            [0.5j, -0.5, 0.5, 0.5j],
                            [0.5, -0.5j, -0.5j, -0.5],
                        ]
                    ),
                )
            )

        with self.subTest(""test time taken""):
            self.assertTrue(result.to_dict()[""time_taken""] < 0.1)

        with self.subTest(""test result success""):
            self.assertTrue(result.to_dict()[""success""])

    def test_initialize_circuit(self):
        """"""test of initialize_circuit inherited from the abstract base class BaseFermionBackend""""""

        with self.subTest(""Initialize circuit with single species of fermions""):
            actual_circ = self.backend.initialize_circuit([0, 1, 0, 1])
            target_circ = QuantumCircuit(QuantumRegister(4, ""fer_mode""))
            target_circ.fload(1)
            target_circ.fload(3)
            self.assertEqual(actual_circ, target_circ)

        with self.subTest(""Initialize circuit with multiple species of fermions""):
            actual_circ = self.backend.initialize_circuit([[0, 1], [0, 1]])
            target_circ = QuantumCircuit(QuantumRegister(2, ""spin_0""), QuantumRegister(2, ""spin_1""))
            target_circ.fload(1)
            target_circ.fload(3)
            self.assertEqual(actual_circ, target_circ)

        with self.subTest(""check maximum size of circuit""):
            with self.assertRaises(QiskitColdAtomError):
                self.backend.initialize_circuit(np.ones(30, dtype=int).tolist())

    def test_measure_observable_expectation(self):
        """"""test of the measure_observable_expectation method inherited from the abstract base class
        BaseFermionBackend""""""

        with self.subTest(""test error for non-diagonal observables""):
            non_diag_observable = FermionicOp({""+_0 -_1 +_2 -_2"": 1.0}, num_spin_orbitals=4)
            test_circ = self.backend.initialize_circuit([0, 1, 0, 1])
            with self.assertRaises(QiskitColdAtomError):
                self.backend.measure_observable_expectation(
                    test_circ, non_diag_observable, shots=10
                )

        with self.subTest(""test match of dimensionality""):
            observable_too_small = FermionicOp({""+_0 -_1"": 1.0}, num_spin_orbitals=2)
            test_circ = self.backend.initialize_circuit([0, 1, 0, 1])
            with self.assertRaises(QiskitColdAtomError):
                self.backend.measure_observable_expectation(
                    test_circ, observable_too_small, shots=10
                )

        with self.subTest(""test single measurement circuit""):
            observable_1 = FermionicOp({""+_1 -_1 -_2 +_2"": 1}, num_spin_orbitals=4)
            observable_2 = FermionicOp({""+_1 -_1"": 1}, num_spin_orbitals=4) + FermionicOp(
                {""-_2 +_2"": 1}, num_spin_orbitals=4
            )
            observable_3 = FermionicOp({""+_0 -_0 +_1 -_1"": 1}, num_spin_orbitals=4)

            eval_1 = self.backend.measure_observable_expectation(
                circuits=self.backend.initialize_circuit([0, 1, 0, 1]),
                observable=observable_1,
                shots=1,
            )
            eval_2 = self.backend.measure_observable_expectation(
                circuits=self.backend.initialize_circuit([0, 1, 0, 1]),
                observable=observable_2,
                shots=1,
            )
            eval_3 = self.backend.measure_observable_expectation(
                circuits=self.backend.initialize_circuit([0, 1, 0, 1]),
                observable=observable_3,
                shots=1,
            )

            self.assertEqual(eval_1, [1.0])
            self.assertEqual(eval_2, [2.0])
            self.assertEqual(eval_3, [0.0])

        with self.subTest(""test multiple measurement circuits""):
            test_circ_1 = self.backend.initialize_circuit([0, 1, 0, 1])
            test_circ_2 = self.backend.initialize_circuit([1, 0, 0, 1])
            observable = FermionicOp({""+_1 -_1 -_2 +_2"": 1}, num_spin_orbitals=4)
            expval = self.backend.measure_observable_expectation(
                [test_circ_1, test_circ_2], observable, shots=1
            )
            self.assertEqual(expval, [1.0, 0.0])

    def test_parameterized_circuits(self):
        """"""Test that parameterized circuits work.""""""
        from qiskit.circuit import Parameter

        theta = Parameter(""theta"")

        test_circ = QuantumCircuit(4)
        test_circ.fload([0, 3])
        test_circ.fhop([theta], [0, 1, 2, 3])

        with self.subTest(""test running with unbound parameters:""):
            with self.assertRaises(TypeError):
                self.assertTrue(isinstance(self.backend.run(test_circ).result(), Result))

        with self.subTest(""test running with bound parameters""):
            bound_circ = test_circ.assign_parameters([0.2])
            self.assertTrue(isinstance(self.backend.run(bound_circ).result(), Result))

    def test_permutation_invariance(self):
        """"""Test that a permutation-invariant gate doesn't care about qubit order.""""""
        generator = FermionicOp(
            {""+_0 -_1"": 1, ""+_1 -_0"": 1},
            num_spin_orbitals=2,
        )
        gate = FermionicGate(name=""test"", num_modes=2, generator=generator)

        circuit01 = self.backend.initialize_circuit([1, 0])
        circuit01.append(gate, [0, 1])
        vec01 = self.backend.run(circuit01).result().get_statevector()

        circuit10 = self.backend.initialize_circuit([1, 0])
        circuit10.append(gate, [1, 0])
        vec10 = self.backend.run(circuit10).result().get_statevector()

        np.testing.assert_allclose(vec01, vec10)
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""""" Fermionic state tests.""""""

from qiskit import QuantumCircuit
from qiskit.test import QiskitTestCase

from qiskit_cold_atom.exceptions import QiskitColdAtomError
from qiskit_cold_atom.fermions.fermion_circuit_solver import FermionicState


class TestFermionState(QiskitTestCase):
    """"""Class to test the fermion state class.""""""

    def test_initialize(self):
        """"""Test the initialization of fermionic states.""""""

        state = FermionicState([0, 1, 1, 0])

        self.assertEqual(state.sites, 4)
        self.assertEqual(state.num_species, 1)

        with self.assertRaises(QiskitColdAtomError):
            FermionicState([0, 2])

        with self.assertRaises(QiskitColdAtomError):
            FermionicState([[0, 1], [1, 0, 1]])

        state = FermionicState([[0, 1, 0], [1, 0, 1]])

        self.assertEqual(state.occupations_flat, [0, 1, 0, 1, 0, 1])
        self.assertEqual(state.num_species, 2)

    def test_string(self):
        """"""Test the string representation.""""""

        state = FermionicState([0, 1])

        self.assertEqual(str(state), ""|0, 1>"")

        state = FermionicState([[0, 1], [1, 0]])
        self.assertEqual(str(state), ""|0, 1>|1, 0>"")

    def test_occupations(self):
        """"""Test that to get the fermionic occupations.""""""
        state = FermionicState([0, 1])

        self.assertEqual(state.occupations, [[0, 1]])

    def test_from_flat_list(self):
        """"""Test the creation of fermionic states from flat lists.""""""

        state = FermionicState.from_total_occupations([0, 1, 1, 0], 2)
        self.assertEqual(state.occupations, [[0, 1], [1, 0]])

        with self.assertRaises(QiskitColdAtomError):
            FermionicState.from_total_occupations([0, 1, 1, 0], 3)

        state = FermionicState.from_total_occupations([0, 1, 1, 0], 1)
        self.assertEqual(state.occupations, [[0, 1, 1, 0]])

    def test_from_initial_state(self):
        """"""Test that we can load an initial state from a circuit.""""""

        circ = QuantumCircuit(4)
        circ.fload(0)
        circ.fload(2)

        state = FermionicState.initial_state(circ, 2)
        self.assertEqual(state.occupations, [[1, 0], [1, 0]])
        self.assertEqual(state.occupations_flat, [1, 0, 1, 0])

        state = FermionicState.initial_state(circ, 1)
        self.assertEqual(state.occupations, [[1, 0, 1, 0]])
        self.assertEqual(state.occupations_flat, [1, 0, 1, 0])
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Spin circuit solver tests""""""

import numpy as np

from qiskit import QuantumCircuit
from qiskit.test import QiskitTestCase
from qiskit_nature.second_q.operators import FermionicOp, SpinOp
from qiskit_cold_atom.spins.spin_circuit_solver import SpinCircuitSolver
from qiskit_cold_atom.exceptions import QiskitColdAtomError


class TestSpinCircuitSolver(QiskitTestCase):
    """"""class to test the SpinCircuitSolver class.""""""

    def setUp(self):
        super().setUp()
        # Set up the simulator
        self.solver = SpinCircuitSolver(spin=3 / 2)

    def test_spin_solver_initialization(self):
        """"""test constructor of SpinCircuitSolver""""""
        with self.assertRaises(QiskitColdAtomError):
            SpinCircuitSolver(spin=2 / 3)

    def test_get_initial_state(self):
        """"""test initialization of the state for the simulation""""""
        circ = QuantumCircuit(1)
        init_state = self.solver.get_initial_state(circ)
        target = np.array([1, 0, 0, 0])
        self.assertTrue(np.all(init_state.toarray().T == target))

    def test_embed_operator(self):
        """"""test embedding of an operator""""""
        fer_op = FermionicOp({""+_0 -_1"": 1}, num_spin_orbitals=2)
        # define a spin operator that has terms with different prefactors, support and power
        spin_op = SpinOp(
            {""X_0 X_1"": 1, ""Y_0 X_1"": 1j, ""X_0 Y_1"": -1j, ""Y_0 Y_1"": 1}, num_spins=2
        ) + 2 * SpinOp({""X_0^2"": 1}, num_spins=2)
        num_wires = 4
        qargs = [1, 3]
        qargs_wrong = [0, 1, 3]

        with self.subTest(""check operator type""):
            with self.assertRaises(QiskitColdAtomError):
                self.solver._embed_operator(fer_op, num_wires, qargs)

        with self.subTest(""check operator wiring""):
            with self.assertRaises(QiskitColdAtomError):
                self.solver._embed_operator(spin_op, num_wires, qargs_wrong)

        with self.subTest(""operator embedding""):
            embedded_op = self.solver._embed_operator(spin_op, num_wires, qargs)
            target_op = SpinOp(
                {""X_1 X_3"": 1, ""Y_1 X_3"": 1j, ""X_1 Y_3"": -1j, ""Y_1 Y_3"": 1, ""X_1^2"": 2.0},
                spin=3 / 2,
                num_spins=4,
            )
            self.assertTrue(
                np.allclose(embedded_op.simplify().to_matrix(), target_op.simplify().to_matrix())
            )

    def test_preprocess_circuit(self):
        """"""test whether preprocessing of the circuit correctly sets the dimension""""""
        circ = QuantumCircuit(2)
        self.solver.preprocess_circuit(circ)
        self.assertEqual(self.solver.dim, 4**2)

    def test_draw_shots(self):
        """"""test drawing of the shots from a measurement distribution""""""
        n_spins = 5
        circ = QuantumCircuit(n_spins)
        circ.rly(np.pi / 2, [3])
        self.solver.preprocess_circuit(circ)
        dim = int((2 * self.solver.spin + 1) ** n_spins)

        with self.subTest(""check missing shot number""):
            # error because the number of shots is not specified
            with self.assertRaises(QiskitColdAtomError):
                self.solver.draw_shots(np.ones(dim) / dim)

        self.solver.shots = 3

        with self.subTest(""check match of dimensions""):
            # error because there is a mismatch in the dimension
            with self.assertRaises(QiskitColdAtomError):
                self.solver.draw_shots(np.ones(dim - 1) / (dim - 1))

        with self.subTest(""formatting of measurement outcomes""):
            meas_distr = np.abs(self.solver(circ)[""statevector""]) ** 2
            self.solver.seed = 45
            outcomes = self.solver.draw_shots(meas_distr)
            # Note the second index changing with the gate being applied to wire [3] of 5
            self.assertEqual(outcomes, [""0 3 0 0 0"", ""0 2 0 0 0"", ""0 1 0 0 0""])

    def test_to_operators(self):
        """"""test the to_operators method inherited form BaseCircuitSolver""""""

        test_circ = QuantumCircuit(2)
        test_circ.rlx(0.5, [0, 1])
        test_circ.rlz2(0.25, 1)
        test_circ.measure_all()

        with self.subTest(""test ignore barriers""):
            self.solver.ignore_barriers = False
            with self.assertRaises(NotImplementedError):
                self.solver.to_operators(test_circ)
            self.solver.ignore_barriers = True

        with self.subTest(""check for gate generators""):
            qubit_circ = QuantumCircuit(1)
            qubit_circ.h(0)
            with self.assertRaises(QiskitColdAtomError):
                self.solver.to_operators(qubit_circ)

        with self.subTest(""gate after previous measurement instruction""):
            meas_circ = QuantumCircuit(2)
            meas_circ.measure_all()
            meas_circ.rlx(0.5, 0)
            with self.assertRaises(QiskitColdAtomError):
                self.solver.to_operators(meas_circ)

        with self.subTest(""check returned operators""):
            operators = self.solver.to_operators(test_circ)
            target = [
                SpinOp({""X_0"": (0.5 + 0j)}, spin=3 / 2, num_spins=2),
                SpinOp({""X_1"": (0.5 + 0j)}, spin=3 / 2, num_spins=2),
                SpinOp({""Z_1^2"": (0.25 + 0j)}, spin=3 / 2, num_spins=2),
            ]
            for i, op in enumerate(operators):
                self.assertTrue(
                    np.allclose(op.simplify().to_matrix(), target[i].simplify().to_matrix())
                )

    def test_call_method(self):
        """"""test the call method inherited from BaseCircuitSolver that simulates a circuit""""""

        test_circ = QuantumCircuit(1)
        test_circ.rlx(np.pi / 2, 0)
        test_circ.measure_all()

        with self.subTest(""running the circuit""):
            self.solver.shots = 5
            self.solver.seed = 45
            simulation = self.solver(test_circ)

            self.assertEqual(simulation[""memory""], [""3"", ""2"", ""1"", ""0"", ""1""])
            self.assertEqual(simulation[""counts""], {""0"": 1, ""1"": 2, ""2"": 1, ""3"": 1})
            self.assertTrue(
                np.allclose(
                    simulation[""statevector""],
                    np.array(
                        [
                            np.sqrt(1 / 8),
                            -1j * np.sqrt(3 / 8),
                            -np.sqrt(3 / 8),
                            1j * np.sqrt(1 / 8),
                        ]
                    ),
                )
            )
            self.assertTrue(
                np.allclose(
                    simulation[""unitary""],
                    np.array(
                        [
                            [
                                np.sqrt(1 / 8),
                                -1j * np.sqrt(3 / 8),
                                -np.sqrt(3 / 8),
                                1j * np.sqrt(1 / 8),
                            ],
                            [
                                -1j * np.sqrt(3 / 8),
                                -np.sqrt(1 / 8),
                                -1j * np.sqrt(1 / 8),
                                -np.sqrt(3 / 8),
                            ],
                            [
                                -np.sqrt(3 / 8),
                                -1j * np.sqrt(1 / 8),
                                -np.sqrt(1 / 8),
                                -1j * np.sqrt(3 / 8),
                            ],
                            [
                                1j * np.sqrt(1 / 8),
                                -np.sqrt(3 / 8),
                                -1j * np.sqrt(3 / 8),
                                np.sqrt(1 / 8),
                            ],
                        ]
                    ),
                )
            )

        with self.subTest(""check for maximum dimension""):
            self.solver.max_dimension = 3
            with self.assertRaises(QiskitColdAtomError):
                self.solver(test_circ)
            self.solver.max_dimension = 100

        with self.subTest(""check if shots are specified""):
            self.solver.shots = None
            simulation = self.solver(test_circ)
            self.assertEqual(simulation[""memory""], [])
            self.assertEqual(simulation[""counts""], {})
            self.solver.shots = 5

        multiple_wire_circ = QuantumCircuit(2)
        multiple_wire_circ.rlx(np.pi / 2, [0])
        multiple_wire_circ.rlz(-np.pi / 2, [0, 1])

        with self.subTest(""formatting of multiple wires""):
            self.solver.seed = 45
            simulation = self.solver(multiple_wire_circ)
            self.assertTrue(simulation[""memory""], [""0 3"", ""0 2"", ""0 1"", ""0 0"", ""0 1""])
            self.assertTrue(simulation[""counts""], {""0 2"": 1, ""0 0"": 1, ""0 3"": 1, ""0 1"": 2})

        with self.subTest(""check equivalence to qubits for spin-1/2""):
            from qiskit_aer import AerSimulator

            qubit_circ = QuantumCircuit(2)
            qubit_circ.rx(np.pi / 2, [0])
            qubit_circ.rz(-np.pi / 2, [0, 1])
            qubit_circ.save_unitary()
            qubit_backend = AerSimulator()
            job = qubit_backend.run(qubit_circ)
            qubit_unitary = job.result().get_unitary()

            spin_half_solver = SpinCircuitSolver(spin=1 / 2)
            simulation = spin_half_solver(multiple_wire_circ)
            spin_unitary = simulation[""unitary""]
            # Switch some axes in the spin simulator unitary because the basis of qiskit_nature.SpinOp
            # uses an ordering of the states (00, 10, 01, 11) that is different from qiskit Aer which
            # uses (00, 01, 10, 11)
            spin_unitary[[1, 2]] = spin_unitary[[2, 1]]
            spin_unitary[:, [1, 2]] = spin_unitary[:, [2, 1]]

            self.assertTrue(np.allclose(qubit_unitary, spin_unitary))
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""""" Spin gate tests.""""""

import numpy as np
from scipy.linalg import expm

from qiskit.test import QiskitTestCase
from qiskit import QuantumCircuit
from qiskit_nature.second_q.operators import SpinOp

from qiskit_cold_atom.spins.spin_circuit_solver import SpinCircuitSolver
from qiskit_cold_atom.spins import SpinSimulator
from qiskit_cold_atom.spins.spins_gate_library import (
    RLXGate,
    RLYGate,
    RLZGate,
    RLZ2Gate,
    RLXLYGate,
    RydbergBlockade,
    RydbergFull,
)


class TestSpinGates(QiskitTestCase):
    """"""Tests for the spin hardware gates""""""

    def setUp(self):
        super().setUp()
        self.backend = SpinSimulator()
        self.spin = 3 / 2
        self.solver = SpinCircuitSolver(spin=self.spin)

    def test_lx_gate(self):
        """"""check matrix form of the lx gate""""""
        omega = np.pi / 2
        circ = QuantumCircuit(1)
        circ.append(RLXGate(omega), qargs=[0])
        # add gate to circuit via the @add_gate-decorated method
        circ_decorated = QuantumCircuit(1)
        circ_decorated.rlx(omega, 0)

        for circuit in [circ, circ_decorated]:
            unitary = self.backend.run(circuit, spin=self.spin).result().get_unitary()
            self.assertTrue(
                np.allclose(
                    unitary,
                    expm(
                        -1j
                        * omega
                        * np.array(
                            [
                                [0.0, np.sqrt(3) / 2, 0, 0],
                                [np.sqrt(3) / 2, 0, 1, 0],
                                [0, 1, 0, np.sqrt(3) / 2],
                                [0, 0, np.sqrt(3) / 2, 0],
                            ]
                        )
                    ),
                )
            )

    def test_lxly_gate(self):
        """"""check matrix form of the lxly gate""""""
        omega = np.pi
        circ = QuantumCircuit(2)
        circ.append(RLXLYGate(omega), qargs=[0, 1])

        # add gate to circuit via the @add_gate-decorated method
        circ_decorated = QuantumCircuit(2)
        circ_decorated.rlxly(omega, [0, 1])

        for circuit in [circ, circ_decorated]:
            unitary = self.backend.run(circuit, spin=1 / 2).result().get_unitary()
            self.assertTrue(
                np.allclose(
                    unitary,
                    [
                        [1, 0, 0, 0],
                        [0, 0, -1j, 0],
                        [0, -1j, 0, 0],
                        [0, 0, 0, 1],
                    ],
                )
            )

    def test_ly_gate(self):
        """"""check matrix form of the ly gate""""""
        omega = np.pi / 2
        circ = QuantumCircuit(1)
        circ.append(RLYGate(omega), qargs=[0])
        # add gate to circuit via the @add_gate-decorated method
        circ_decorated = QuantumCircuit(1)
        circ_decorated.rly(omega, 0)

        for circuit in [circ, circ_decorated]:
            unitary = self.backend.run(circuit, spin=self.spin).result().get_unitary()
            self.assertTrue(
                np.allclose(
                    unitary,
                    expm(
                        -1j
                        * omega
                        * np.array(
                            [
                                [0.0, -1j * np.sqrt(3) / 2, 0, 0],
                                [1j * np.sqrt(3) / 2, 0, -1j, 0],
                                [0, 1j, 0, -1j * np.sqrt(3) / 2],
                                [0, 0, 1j * np.sqrt(3) / 2, 0],
                            ]
                        )
                    ),
                )
            )

    def test_lz_gate(self):
        """"""check matrix form of the lz gate""""""
        delta = np.pi / 2
        circ = QuantumCircuit(1)
        circ.append(RLZGate(delta), qargs=[0])
        # add gate to circuit via the @add_gate-decorated method
        circ_decorated = QuantumCircuit(1)
        circ_decorated.rlz(delta, 0)

        for circuit in [circ, circ_decorated]:
            unitary = self.backend.run(circuit, spin=self.spin).result().get_unitary()
            self.assertTrue(
                np.allclose(
                    unitary,
                    expm(
                        -1j
                        * delta
                        * np.array(
                            [
                                [3 / 2, 0, 0, 0],
                                [0, 1 / 2, 0, 0],
                                [0, 0, -1 / 2, 0],
                                [0, 0, 0, -3 / 2],
                            ]
                        )
                    ),
                )
            )

    def test_lz2_gate(self):
        """"""check matrix form of the lz2 gate""""""
        chi = np.pi / 2
        circ = QuantumCircuit(1)
        circ.append(RLZ2Gate(chi), qargs=[0])
        # add gate to circuit via the @add_gate-decorated method
        circ_decorated = QuantumCircuit(1)
        circ_decorated.rlz2(chi, 0)

        for circuit in [circ, circ_decorated]:
            unitary = self.backend.run(circuit, spin=self.spin).result().get_unitary()
            self.assertTrue(
                np.allclose(
                    unitary,
                    expm(
                        -1j
                        * chi
                        * np.array(
                            [
                                [3 / 2, 0, 0, 0],
                                [0, 1 / 2, 0, 0],
                                [0, 0, -1 / 2, 0],
                                [0, 0, 0, -3 / 2],
                            ]
                        )
                        ** 2
                    ),
                )
            )

    def test_rydberg_block_gate(self):
        """"""check matrix form of the rydberg blockade gate on two qubits""""""
        chi = 2 * np.pi

        # the expected unitary is the following
        expected = np.exp(1j * np.pi / 2) * expm(
            -1j
            * chi
            * np.array(
                [
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 1],
                ]
            )
        )
        # first test the RydbergBlockade only
        with self.subTest(""test generation of operator""):
            from qiskit.quantum_info import Operator

            self.assertTrue(np.allclose(Operator(RydbergBlockade(2, phi=chi)).data, expected))

        # add gate to circuit via the @add_gate-decorated method
        circ_decorated = QuantumCircuit(2)
        circ_decorated.rydberg_block(chi, [0, 1])
        unitary = self.backend.run(circ_decorated).result().get_unitary()
        self.assertTrue(np.allclose(unitary, expected))

    def test_rydberg_full_gate(self):
        """"""check matrix form of the full rydberg Hamiltonian on two qubits""""""
        chi = 2 * np.pi
        circ = QuantumCircuit(2)
        circ.append(RydbergFull(2, omega=0, delta=0, phi=chi), qargs=[0, 1])

        # add gate to circuit via the @add_gate-decorated method
        circ_decorated = QuantumCircuit(2)
        circ_decorated.rydberg_full(omega=0, delta=0, phi=chi, modes=range(2))
        for circuit in [circ, circ_decorated]:
            unitary = self.backend.run(circuit).result().get_unitary()
            self.assertTrue(
                np.allclose(
                    unitary,
                    np.exp(1j * np.pi / 2)
                    * expm(
                        -1j
                        * chi
                        * np.array(
                            [
                                [0, 0, 0, 0],
                                [0, 0, 0, 0],
                                [0, 0, 0, 0],
                                [0, 0, 0, 1],
                            ]
                        )
                    ),
                )
            )

        # also test the sigma gates
        circ = QuantumCircuit(2)
        circ.append(RydbergFull(2, omega=np.pi, delta=0, phi=0), qargs=[0, 1])
        # add gate to circuit via the @add_gate-decorated method
        circ_decorated = QuantumCircuit(2)
        circ_decorated.rydberg_full(omega=np.pi, delta=0, phi=0, modes=range(2))
        for circuit in [circ, circ_decorated]:
            unitary = self.backend.run(circuit).result().get_unitary()
            self.assertTrue(
                np.allclose(
                    unitary,
                    expm(
                        -1j
                        * np.pi
                        / 2
                        * np.array(
                            [
                                [0, 1, 1, 0],
                                [1, 0, 0, 1],
                                [1, 0, 0, 1],
                                [0, 1, 1, 0],
                            ]
                        )
                    ),
                )
            )

        # also test the sigmaz gates
        circ = QuantumCircuit(2)
        circ.append(RydbergFull(2, omega=0, delta=np.pi, phi=0), qargs=[0, 1])
        # add gate to circuit via the @add_gate-decorated method
        circ_decorated = QuantumCircuit(2)
        circ_decorated.rydberg_full(omega=0, delta=np.pi, phi=0, modes=range(2))
        for circuit in [circ, circ_decorated]:
            unitary = self.backend.run(circuit).result().get_unitary()
            self.assertTrue(
                np.allclose(
                    unitary,
                    expm(
                        -1j
                        * np.pi
                        / 2
                        * np.array(
                            [
                                [-2, 0, 0, 0],
                                [0, 0, 0, 0],
                                [0, 0, 0, 0],
                                [0, 0, 0, 2],
                            ]
                        )
                    ),
                )
            )

    def test_spin_gate(self):
        """"""test the functionality of the base class for fermionic gates""""""
        test_gates = [RLXGate(0.8), RLYGate(2.4), RLZGate(5.6), RLZ2Gate(1.3)]
        with self.subTest(""test to_matrix and power""):
            for gate in test_gates:
                exp_matrix = gate.to_matrix() @ gate.to_matrix()
                exp_gate = gate.power(2)
                self.assertTrue(np.allclose(exp_matrix, exp_gate.to_matrix()))

        with self.subTest(""test generation of operator""):
            from qiskit.quantum_info import Operator

            for gate in test_gates:
                self.assertTrue(isinstance(Operator(gate), Operator))

    def test_identity_gates(self):
        """"""test that gates with parameters equal to zero still have a well-defined generator.""""""
        test_gates = [RLXGate(0.0), RLYGate(0.0), RLZGate(0.0), RLZ2Gate(0.0)]

        for gate in test_gates:
            self.assertIsInstance(gate.generator, SpinOp)
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""General spin simulator backend tests.""""""

from time import sleep
import numpy as np

from qiskit import QuantumCircuit
from qiskit.providers import JobStatus
from qiskit.result import Result
from qiskit.test import QiskitTestCase
from qiskit_aer import AerJob

from qiskit_cold_atom.exceptions import QiskitColdAtomError
from qiskit_cold_atom.spins import SpinSimulator
from qiskit_cold_atom.spins.base_spin_backend import BaseSpinBackend


class TestSpinSimulatorBackend(QiskitTestCase):
    """"""class to test the FermionSimulatorBackend class.""""""

    def setUp(self):
        super().setUp()
        self.backend = SpinSimulator()

    def test_initialization(self):
        """"""test the initialization of the backend""""""
        target_config = {
            ""backend_name"": ""spin_simulator"",
            ""backend_version"": ""0.0.1"",
            ""n_qubits"": None,
            ""basis_gates"": None,
            ""gates"": [],
            ""local"": True,
            ""simulator"": True,
            ""conditional"": False,
            ""open_pulse"": False,
            ""memory"": True,
            ""max_shots"": 1e5,
            ""coupling_map"": None,
            ""description"": ""a base simulator for spin circuits. Instead of a qubit, each wire ""
            ""represents a single high-dimensional spin"",
        }

        backend = SpinSimulator()
        self.assertIsInstance(backend, BaseSpinBackend)
        self.assertTrue(target_config.items() <= backend.configuration().to_dict().items())

    def test_run_method(self):
        """"""Test the run method of the backend simulator""""""

        with self.subTest(""test call""):
            circ = QuantumCircuit(2)
            job = self.backend.run(circ)
            self.assertIsInstance(job, AerJob)
            self.assertIsInstance(job.job_id(), str)
            self.assertIsInstance(job.result(), Result)
            self.assertEqual(job.status(), JobStatus.DONE)

        circ1 = QuantumCircuit(2)
        circ2 = QuantumCircuit(3)

        with self.subTest(""test call with multiple circuits""):
            job = self.backend.run([circ1, circ2])
            self.assertIsInstance(job, AerJob)

        with self.subTest(""test shot number""):
            target_shots = 123
            job = self.backend.run([circ1, circ2], shots=target_shots)
            for exp in job.result().results:
                self.assertEqual(exp.shots, target_shots)

        with self.subTest(""test seed of RNG""):
            target_seed = 123
            job = self.backend.run([circ1, circ2], seed=target_seed)
            for exp in job.result().results:
                self.assertEqual(exp.header.random_seed, target_seed)

        with self.subTest(""test dimension of simulation""):
            test_circ = QuantumCircuit(2)
            test_circ.rlx(np.pi / 2, 0)
            test_circ.rly(np.pi / 4, [0, 1])

            statevector_1 = self.backend.run(test_circ, spin=1).result().get_statevector()
            self.assertEqual(len(statevector_1), 3**2)

            statevector_2 = self.backend.run(test_circ, spin=5 / 2).result().get_statevector()
            self.assertEqual(len(statevector_2), 6**2)

        with self.subTest(""test irregular spin values""):
            test_circ = QuantumCircuit(2)
            job = self.backend.run(test_circ, spin=5 / 4)
            sleep(0.01)
            self.assertIs(job.status(), JobStatus.ERROR)
            with self.assertRaises(QiskitColdAtomError):
                job.result()

    def test_execute(self):
        """"""test the ._execute() method internally called by .run()""""""

        test_circ = QuantumCircuit(2)
        test_circ.rly(np.pi / 2, 0)
        test_circ.rlx(np.pi / 2, 1)
        test_circ.measure_all()

        result = self.backend.run(test_circ, spin=1, seed=45, shots=5).result()

        with self.subTest(""test simulation counts""):
            self.assertEqual(result.get_counts(), {""0 1"": 1, ""2 2"": 1, ""1 1"": 2, ""1 0"": 1})

        with self.subTest(""test simulation memory""):
            self.assertEqual(result.get_memory(), [""2 2"", ""1 1"", ""0 1"", ""1 0"", ""1 1""])

        with self.subTest(""test simulation statevector""):
            self.assertTrue(
                np.allclose(
                    result.get_statevector(),
                    np.array(
                        [
                            1 / 4,
                            -1j / np.sqrt(8),
                            -1 / 4,
                            1 / np.sqrt(8),
                            -1j / 2,
                            -1 / np.sqrt(8),
                            1 / 4,
                            -1j / np.sqrt(8),
                            -1 / 4,
                        ]
                    ),
                )
            )

        with self.subTest(""test simulation unitary""):
            # test the unitary on a single spin-2 example
            test_circ = QuantumCircuit(1)
            test_circ.rlx(np.pi / 2, 0)
            test_circ.rlz(np.pi / 2, 0)
            test_circ.measure_all()

            result = self.backend.run(test_circ, spin=2, seed=45, shots=5).result()

            self.assertTrue(
                np.allclose(
                    result.get_unitary(),
                    np.array(
                        [
                            [-0.25, 0.5j, np.sqrt(3 / 8), -0.5j, -0.25],
                            [-0.5, 0.5j, 0.0, 0.5j, 0.5],
                            [-np.sqrt(3 / 8), 0.0, -0.5, 0.0, -np.sqrt(3 / 8)],
                            [-0.5, -0.5j, 0.0, -0.5j, 0.5],
                            [-0.25, -0.5j, np.sqrt(3 / 8), 0.5j, -0.25],
                        ]
                    ),
                )
            )

        with self.subTest(""test time taken""):
            self.assertTrue(result.to_dict()[""time_taken""] < 0.5)

        with self.subTest(""test result success""):
            self.assertTrue(result.to_dict()[""success""])
"
https://github.com/qiskit-community/qiskit-cold-atom,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Testing module for transpiling.""""""

import numpy as np

from qiskit import QuantumCircuit
from qiskit.transpiler import PassManager
from qiskit.test import QiskitTestCase

from qiskit_cold_atom.transpiler import Optimize1SpinGates


# pylint: disable=no-member
class TestSpinTranspilation(QiskitTestCase):
    """"""Test class for spin-based transpilation.""""""

    def test_optimize_1s_gates(self):
        """"""Test the single-spin gate transpilation.""""""

        circ = QuantumCircuit(1)
        circ.rlx(np.pi / 2, 0)
        circ.rlx(np.pi / 2, 0)
        circ.rlx(np.pi / 2, 0)
        circ.rly(np.pi / 2, 0)
        circ.rly(np.pi / 2, 0)
        circ.rlz2(np.pi / 4, 0)
        circ.rlz2(np.pi / 4, 0)
        circ.rlz2(np.pi / 4, 0)
        circ.rlx(np.pi / 2, 0)

        pass_manager = PassManager(Optimize1SpinGates())

        circ_new = pass_manager.run(circ)

        self.assertEqual(circ_new.count_ops()[""rlx""], 2)
        self.assertEqual(circ_new.count_ops()[""rly""], 1)
        self.assertEqual(circ_new.count_ops()[""rlz2""], 1)

        self.assertTrue(np.allclose(circ_new.data[0][0].params[0], 3 * np.pi / 2))
        self.assertTrue(np.allclose(circ_new.data[1][0].params[0], np.pi))
        self.assertTrue(np.allclose(circ_new.data[2][0].params[0], 3 * np.pi / 4))
        self.assertTrue(np.allclose(circ_new.data[3][0].params[0], np.pi / 2))

    def test_optimize_1s_gates_multi_spin(self):
        """"""Test the single-spin gate transpilation.""""""

        circ = QuantumCircuit(2)
        circ.rlx(np.pi / 3, 0)
        circ.rlx(np.pi / 3, 0)
        circ.rlx(np.pi / 3, 0)
        circ.rly(np.pi / 4, 1)
        circ.rly(np.pi / 4, 1)

        pass_manager = PassManager(Optimize1SpinGates())

        circ_new = pass_manager.run(circ)

        self.assertEqual(circ_new.count_ops()[""rlx""], 1)
        self.assertEqual(circ_new.count_ops()[""rly""], 1)

        self.assertTrue(np.allclose(circ_new.data[0][0].params[0], np.pi))
        self.assertTrue(np.allclose(circ_new.data[1][0].params[0], np.pi / 2))
"
https://github.com/qiskit-community/qiskit-quantinuum-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# Copyright 2019-2020 Quantinuum, Intl. (www.quantinuum.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""Module for interfacing with a Quantinuum Backend.""""""

import logging
import warnings

from qiskit.circuit import QuantumCircuit
from qiskit.providers import BackendV1
from qiskit.providers.models import BackendStatus
from qiskit.providers import Options
from qiskit.utils import deprecate_arguments
from qiskit import qobj as qobj_mod
from qiskit import pulse

from qiskit_quantinuum.exceptions import QiskitError
from .quantinuumjob import QuantinuumJob

logger = logging.getLogger(__name__)


class QuantinuumBackend(BackendV1):
    """"""Backend class interfacing with a Quantinuum backend.""""""

    def __init__(self, name, configuration, provider, api):
        """"""Initialize remote backend for Quantinuum Quantum Computer.

        Args:
            name (String): name of backend.
            configuration (BackendConfiguration): backend configuration
            provider (QuantinuumProvider): provider.
            api (QuantinuumClient): API client instance to use for backend
                communication
        """"""

        super().__init__(configuration=configuration, provider=provider)

        self._api = api
        self._name = name

    @classmethod
    def _default_options(cls):
        return Options(shots=1024, priority='normal')

    @deprecate_arguments({'qobj': 'run_input'})
    def run(self, run_input, **kwargs):
        """"""Run a circuit on the backend.

        Args:
            run_input (QuantumCircuit|list): A QuantumCircuit or a list of
                QuantumCircuit objects to run on the backend

        Returns:
            HoneywelJob: a handle to the async execution of the circuit(s) on
                the backend
        Raises:
            QiskitError: If a pulse schedule is passed in for ``run_input``
        """"""
        if isinstance(run_input, qobj_mod.QasmQobj):
            warnings.warn(""Passing in a QASMQobj object to run() is ""
                          ""deprecated and will be removed in a future ""
                          ""release"", DeprecationWarning)
            job = QuantinuumJob(self, None, self._api, circuits=run_input)
        elif isinstance(run_input, (qobj_mod.PulseQobj, pulse.Schedule)):
            raise QiskitError(""Pulse jobs are not accepted"")
        else:
            if isinstance(run_input, QuantumCircuit):
                run_input = [run_input]
            job_config = {}
            for kwarg in kwargs:
                if not hasattr(self.options, kwarg):
                    warnings.warn(
                        ""Option %s is not used by this backend"" % kwarg,
                        UserWarning, stacklevel=2)
                else:
                    job_config[kwarg] = kwargs[kwarg]
            if 'shots' not in job_config:
                job_config['shots'] = self.options.shots
                job_config['priority'] = self.options.priority
            job = QuantinuumJob(self, None, self._api, circuits=run_input,
                                job_config=job_config)
        job.submit()
        return job

    def retrieve_job(self, job_id):
        """""" Returns the job associated with the given job_id """"""
        job = QuantinuumJob(self, job_id, self._api)
        return job

    def retrieve_jobs(self, job_ids):
        """""" Returns a list of jobs associated with the given job_ids """"""
        return [QuantinuumJob(self, job_id, self._api) for job_id in job_ids]

    def status(self):
        """"""Return the online backend status.

        Returns:
            BackendStatus: The status of the backend.

        Raises:
            LookupError: If status for the backend can't be found.
            QuantinuumBackendError: If the status can't be formatted properly.
        """"""
        api_status = self._api.backend_status(self.name())

        try:
            return BackendStatus.from_dict(api_status)
        except QiskitError as ex:
            raise LookupError(
                ""Couldn't get backend status: {0}"".format(ex)
            )

    def name(self):
        return self._name
"
https://github.com/qiskit-community/qiskit-quantinuum-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# Copyright 2019-2020 Quantinuum, Intl. (www.quantinuum.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# pylint: disable=arguments-differ

""""""QuantinuumJob module

This module is used for creating asynchronous job objects for Quantinuum.
""""""
import asyncio
import json
import logging
from collections import Counter
from datetime import datetime, timezone
from time import sleep
import nest_asyncio
import websockets
from qiskit.assembler.disassemble import disassemble
from qiskit.providers import JobV1, JobError
from qiskit.providers.jobstatus import JOB_FINAL_STATES, JobStatus
from qiskit import qobj as qobj_mod
from qiskit.result import Result

from .apiconstants import ApiJobStatus

from .api import QuantinuumClient

logger = logging.getLogger(__name__)

# Because Qiskit is often used with the Jupyter notebook who runs its own asyncio event loop
# (via Tornado), we must be able to apply our own event loop. This is something that is done
# in the IBMQ provider as well
nest_asyncio.apply()


class QuantinuumJob(JobV1):
    """"""Representation of a job that will be execute on a Quantinuum backend.

    Represent the jobs that will be executed on Quantinuum devices. Jobs are
    intended to be created calling ``run()`` on a particular backend.

    Currently jobs that are created using a qobj can only have one experiment
    in the qobj. If more that one experiment exists in the qobj only the first
    experiment will be run and the rest will be ignored.

    Creating a ``Job`` instance does not imply running it. You need to do it in
    separate steps::

        job = QuantinuumJob(...)
        job.submit()

    An error while submitting a job will cause the next call to ``status()`` to
    raise. If submitting the job successes, you can inspect the job's status by
    using ``status()``. Status can be one of ``JobStatus`` members::

        from qiskit.backends.jobstatus import JobStatus

        job = QuantinuumJob(...)
        job.submit()

        try:
            job_status = job.status() # It will query the backend API.
            if job_status is JobStatus.RUNNING:
                print('The job is still running')

        except JobError as ex:
            print(""Something wrong happened!: {}"".format(ex))

    A call to ``status()`` can raise if something happens at the API level that
    prevents Qiskit from determining the status of the job. An example of this
    is a temporary connection lose or a network failure.

    ``Job`` instances also have `id()` and ``result()`` methods which will
    block::

        job = QuantinuumJob(...)
        job.submit()

        try:
            job_id = job.id()
            print('The job {} was successfully submitted'.format(job_id))

            job_result = job.result() # It will block until finishing.
            print('The job finished with result {}'.format(job_result))

        except JobError as ex:
            print(""Something wrong happened!: {}"".format(ex))

    Both methods can raise if something at the API level happens that prevent
    Qiskit from determining the status of the job.

    Note:
        When querying the API for getting the status, two kinds of errors are
        possible. The most severe is the one preventing Qiskit from getting a
        response from the backend. This can be caused by a network failure or a
        temporary system break. In these cases, calling ``status()`` will raise.

        If Qiskit successfully retrieves the status of a job, it could be it
        finished with errors. In that case, ``status()`` will simply return
        ``JobStatus.ERROR`` and you can call ``error_message()`` to get more
        info.
    """"""
    def __init__(self, backend, job_id, api=None, circuits=None, job_config=None):
        """"""QuantinuumJob init function.

        We can instantiate jobs from two sources: A circuit, and an already
        submitted job returned by the API servers.

        Args:
            backend (QuantinuumBackend): The backend instance used to run this job.
            job_id (str or None): The job ID of an already submitted job.
                Pass `None` if you are creating a new job.
            api (QuantinuumClient): Quantinuum api client.
            circuits (list): A list of quantum circuit objects to run. Can also
                be a ``QasmQobj`` object, but this is deprecated (and won't raise a
                warning (since it's raised by ``backend.run()``). See notes below
            job_config (dict): A dictionary for the job configuration options

        Notes:
            It is mandatory to pass either ``circuits`` or ``job_id``. Passing a ``circuits``
            will ignore ``job_id`` and will create an instance to be submitted to the
            API server for job creation. Passing only a `job_id` will create an instance
            representing an already-created job retrieved from the API server.
        """"""
        super().__init__(backend, job_id)

        if api:
            self._api = api
        else:
            self._api = QuantinuumClient(backend.provider().credentials)
        self._creation_date = datetime.utcnow().replace(tzinfo=timezone.utc).isoformat()

        # Properties used for caching.
        self._cancelled = False
        self._api_error_msg = None
        self._result = None
        self._job_ids = []
        self._experiment_results = []

        self._qobj_payload = {}
        self._circuits_job = False
        if circuits:
            if isinstance(circuits, qobj_mod.QasmQobj):
                self._qobj_payload = circuits.to_dict()
                # Extract individual experiments
                #  if we want user qobj headers, the third argument contains it
                self._experiments, self._job_config, _ = disassemble(circuits)
                self._status = JobStatus.INITIALIZING
            else:
                self._experiments = circuits
                self._job_config = job_config
                self._circuits_job = True
        else:
            self._status = JobStatus.INITIALIZING
            self._job_ids.append(job_id)
            self._job_config = {}

    def submit(self):
        """"""Submit the job to the backend.""""""
        backend_name = self.backend().name()

        for exp in self._experiments:
            submit_info = self._api.job_submit(backend_name, self._job_config, exp.qasm())
            # Error in job after submission:
            # Transition to the `ERROR` final state.
            if 'error' in submit_info:
                self._status = JobStatus.ERROR
                self._api_error_msg = str(submit_info['error'])
                # Don't continue
                return
            self._job_ids.append(submit_info['job'])

        # Take the last submitted job's info
        self._creation_date = submit_info.get('submit-date')
        self._status = submit_info.get('status')
        self._job_id = submit_info.get('job')

    def result(self, timeout=300):
        """"""Return the result of the job.

        Args:
           timeout (float): number of seconds to wait for job

        Returns:
            qiskit.Result: Result object

        Raises:
            JobError: if attempted to recover a result on a failed job.

        Notes:
            Currently when calling get_counts() on a result returned by a Quantinuum
            backend, since Quantinuum backends currently support only running one
            experiment per job, do not supply an argument to the get_counts() function.
            Doing so may raise an exception.
        """"""
        if self._result:
            return self._result

        # Wait for results sequentially
        for job_id in self._job_ids:
            self._experiment_results.append(
                asyncio.get_event_loop().run_until_complete(self._get_status(job_id, timeout))
                )

        # Process results
        self._result = self._process_results()

        if not (self._status is JobStatus.DONE or self._status is JobStatus.CANCELLED):
            raise JobError('Invalid job state. The job should be DONE or CANCELLED but '
                           'it is {}'.format(str(self._status)))

        if not self._result:
            raise JobError('Server did not return result')

        return self._result

    def cancel(self):
        """"""Attempt to cancel job.""""""
        pass

    async def _get_status(self, job_id, timeout=300):
        """"""Query the API to update the status.

        Returns:
            qiskit.providers.JobStatus: The api response including the job status

        Raises:
            JobError: if there was an exception in the future being executed
                          or the server sent an unknown answer.
        """"""
        if job_id is None or self._status in JOB_FINAL_STATES:
            return self._status

        try:
            api_response = self._api.job_status(job_id)
            if 'websocket' in api_response:
                task_token = api_response['websocket']['task_token']
                execution_arn = api_response['websocket']['executionArn']
                credentials = self.backend().provider().credentials
                websocket_uri = credentials.url.replace('https://', 'wss://ws.')
                async with websockets.connect(
                        websocket_uri, extra_headers={
                            'Authorization': credentials.access_token}) as websocket:

                    body = {
                        ""action"": ""OpenConnection"",
                        ""task_token"": task_token,
                        ""executionArn"": execution_arn
                    }
                    await websocket.send(json.dumps(body))
                    api_response = await asyncio.wait_for(websocket.recv(), timeout=timeout)
                    api_response = json.loads(api_response)
            else:
                logger.warning('Websockets via proxy not supported.  Falling-back to polling.')
                residual_delay = timeout/1000  # convert us -> s
                request_delay = min(1.0, residual_delay)
                while api_response['status'] not in ['failed', 'completed', 'canceled']:
                    sleep(request_delay)
                    api_response = self._api.job_status(job_id)

                    residual_delay = residual_delay - request_delay
                    if residual_delay <= 0:
                        # break if we have exceeded timeout
                        break

                    # Max-out at 10 second delay
                    request_delay = min(min(request_delay*1.5, 10), residual_delay)
        except Exception as err:
            raise JobError(str(err))

        return api_response

    def status(self, timeout=300):
        """"""Query the API to update the status.

        Returns:
            qiskit.providers.JobStatus: The status of the job, once updated.

        Raises:
            JobError: if there was an exception in the future being executed
                          or the server sent an unknown answer.
        """"""
        # Wait for results sequentially
        for job_id in self._job_ids:
            self._experiment_results.append(
                asyncio.get_event_loop().run_until_complete(self._get_status(job_id, timeout))
                )

        # Process results
        self._result = self._process_results()

        return self._status

    def error_message(self):
        """"""Provide details about the reason of failure.

        Returns:
            str: An error report if the job errored or ``None`` otherwise.
        """"""
        for job_id in self._job_ids:
            if self.status(job_id) is not JobStatus.ERROR:
                return None

        if not self._api_error_msg:
            self._api_error_msg = 'An unknown error occurred.'

        return self._api_error_msg

    def _process_results(self):
        """"""Convert Quantinuum job result to qiskit.Result""""""
        results = []
        self._status = JobStatus.DONE
        for i, res_resp in enumerate(self._experiment_results):
            status = res_resp.get('status', 'failed')
            if status == 'failed':
                self._status = JobStatus.ERROR
            res = res_resp['results']
            counts = dict(Counter(hex(int("""".join(r), 2)) for r in [*zip(*list(res.values()))]))

            experiment_result = {
                'shots': self._job_config.get('shots', 1),
                'success': ApiJobStatus(status) is ApiJobStatus.COMPLETED,
                'data': {'counts': counts},
                'job_id': self._job_ids[i]
            }
            if self._circuits_job:
                if self._experiments[i].metadata is None:
                    metadata = {}
                else:
                    metadata = self._experiments[i].metadata
                experiment_result['header'] = metadata
            else:
                experiment_result['header'] = self._qobj_payload[
                    'experiments'][i]['header'] if self._qobj_payload else {}
            results.append(experiment_result)

        result = {
            'success': self._status is JobStatus.DONE,
            'job_id': self._job_id,
            'results': results,
            'backend_name': self._backend.name(),
            'backend_version': self._backend.status().backend_version,
            'qobj_id': self._job_id
        }
        return Result.from_dict(result)

    def creation_date(self):
        """"""Return creation date.""""""
        return self._creation_date

    def job_ids(self):
        """""" Return all the job_ids associated with this experiment """"""
        return self._job_ids
"
https://github.com/qiskit-community/qiskit-quantinuum-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# Copyright 2019-2020 Quantinuum, Intl. (www.quantinuum.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""Quantinuum TestCase for testing backends.""""""

from qiskit import execute
from qiskit import QuantumCircuit
from qiskit.providers.jobstatus import JobStatus
from qiskit.providers.models import BackendStatus
from qiskit.test import QiskitTestCase

from qiskit_quantinuum import Quantinuum
from qiskit_quantinuum import QuantinuumProvider
from qiskit_quantinuum import QuantinuumJob
from qiskit_quantinuum import QuantinuumBackend
from qiskit_quantinuum.api import QuantinuumClient

from .decorators import online_test


class QuantinuumBackendTestCase(QiskitTestCase):
    """"""Test case for Quantinuum backend.

    Members:
        proivder_cls (BaseProvider): provider to be used in this test case.
        api_cls (QuantinuumClient): api to be used in this test case
        backend_cls (BaseBackend): backend to be used in this test case. Its
            instantiation can be further customized by overriding the
            ``_get_backend`` function.
        backend_name (str): name of backend to be used in tests.
    """"""
    provider_cls = QuantinuumProvider
    api_cls = QuantinuumClient

    backend_cls = QuantinuumBackend
    backend_name = 'H1-1SC'

    def setUp(self):
        super().setUp()
        self.circuit = QuantumCircuit(4)
        self.circuit.h(0)
        self.circuit.cx(0, 1)
        self.circuit.h(0)
        self.circuit.cp(1.0, 0, 1)
        self.circuit.toffoli(0, 1, 2)
        self.circuit.toffoli(1, 2, 3)
        self.circuit.x(0)
        self.circuit.y(0)
        self.circuit.z(0)
        self.circuit.cx(0, 1)
        self.circuit.h(0)
        self.circuit.s(0)
        self.circuit.sdg(0)
        self.circuit.t(0)
        self.circuit.tdg(0)
        self.circuit.rx(1.0, 0)
        self.circuit.ry(1.0, 0)
        self.circuit.rz(1.0, 0)
        self.circuit.cz(0, 1)
        self.circuit.cy(0, 2)
        self.circuit.ch(0, 3)
        self.circuit.ccx(0, 1, 2)
        self.circuit.crz(1.0, 0, 1)
        self.circuit.crx(1.0, 0, 1)
        self.circuit.cry(1.0, 0, 1)
        self.circuit.cp(1.0, 0, 1)
        self.circuit.cu(1.0, 2.0, 3.0, 0.0, 0, 1)
        self.circuit.measure_all()

    def test_configuration(self):
        """"""Test backend.configuration().""""""
        pass

    def test_properties(self):
        """"""Test backend.properties().""""""
        pass

    @online_test
    def test_provider(self):
        """"""Test backend.provider().""""""
        Quantinuum.load_account()
        backend = Quantinuum.get_backend(self.backend_name)
        provider = backend.provider()
        self.assertEqual(provider, self.provider_cls())

    @online_test
    def test_status(self):
        """"""Test backend.status().""""""
        Quantinuum.load_account()
        backend = Quantinuum.get_backend(self.backend_name)
        status = backend.status()
        self.assertIsInstance(status, BackendStatus)

    @online_test
    def test_name(self):
        """"""Test backend.name().""""""
        Quantinuum.load_account()
        backend = Quantinuum.get_backend(self.backend_name)
        name = backend.name()
        self.assertEqual(name, self.backend_name)

    @online_test
    def _submit_job(self):
        """"""Helper method to submit job and return job instance""""""
        Quantinuum.load_account()
        backend = Quantinuum.get_backend(self.backend_name)
        return execute(self.circuit, backend)

    @online_test
    def test_submit_job(self):
        """"""Test running a single circuit.""""""
        Quantinuum.load_account()
        job = self._submit_job()
        self.assertIsInstance(job, QuantinuumJob)

    @online_test
    def test_get_job_result(self):
        """"""Test get result of job""""""
        Quantinuum.load_account()
        job = self._submit_job()
        result = job.result()
        self.assertEqual(result.success, True)
        return result

    @online_test
    def test_get_job_status(self):
        """"""Test get status of job""""""
        job = self._submit_job()
        Quantinuum.load_account()
        status = job.status()
        self.assertIsInstance(status, JobStatus)

    def test_get_job_error_message(self):
        """"""Test get error message of job""""""
        pass

    @online_test
    def test_get_creation_date(self):
        """"""Test get creation date of job""""""
        Quantinuum.load_account()
        job = self._submit_job()
        creation_date = job.creation_date()
        self.assertIsNotNone(creation_date)

    @online_test
    def test_get_job_id(self):
        """"""Test get id of job""""""
        Quantinuum.load_account()
        job = self._submit_job()
        job_id = job.job_id()
        self.assertIsNotNone(job_id)

    @online_test
    def test_job_with_id(self):
        """"""Test creating a job with an id.""""""
        Quantinuum.load_account()
        backend = Quantinuum.get_backend(self.backend_name)
        job = self._submit_job()
        job_id = job.job_id()
        credentials = backend.provider().credentials
        job_created_with_id = QuantinuumJob(backend, job_id, self.api_cls(credentials))
        result = job_created_with_id.result()
        self.assertEqual(result.success, True)
        return result
"
https://github.com/Qiskit/qiskit-neko,Qiskit,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Qiskit Aer default backend plugin.""""""

import qiskit_aer as aer
from qiskit_ibm_runtime import fake_provider

from qiskit_neko import backend_plugin


class AerBackendPlugin(backend_plugin.BackendPlugin):
    """"""A backend plugin for using qiskit-aer as the backend.""""""

    def __init__(self):
        super().__init__()
        self.mock_provider = fake_provider.FakeProvider()
        self.mock_provider_backend_names = set()
        for backend in self.mock_provider.backends():
            if backend.version == 1:
                self.mock_provider_backend_names.add(backend.name())
            elif backend.version == 2:
                self.mock_provider_backend_names.add(backend.name)

    def get_backend(self, backend_selection=None):
        """"""Return the Backend object to run tests on.

        :param str backend_selection: An optional selection string to specify
            the backend object returned from this method. This can be used
            in two different ways. Either it can be used to specify a fake
            backend name from ``qiskit.test.mock`` in ``qiskit-terra`` such
            as ``fake_quito`` which will return that fake backend object or
            alternatively if the string starts with ``method=`` an ideal
            :class:`~qiskit.providers.aer.AerSimulator` object with that method
            will be set. If this is not specified a
            :class:`~qiskit.providers.aer.AerSimulator` will be returned with
            the defailt settings.
        :raises ValueError: If an invalid backend selection string is passed in
        """"""
        if backend_selection is None:
            return aer.AerSimulator()
        if backend_selection.startswith(""method=""):
            method = backend_selection.split(""="")[1]
            return aer.AerSimulator(method=method)
        if backend_selection in self.mock_provider_backend_names:
            return self.mock_provider.get_backend(backend_selection)
        raise ValueError(f""Invalid selection string {backend_selection}."")
"
https://github.com/Qiskit/qiskit-neko,Qiskit,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Tests from circuit basics tutorial.""""""

import math

import ddt
from qiskit import QuantumCircuit, transpile

from qiskit_neko import decorators
from qiskit_neko.tests import base


@ddt.ddt
class TestCircuitBasics(base.BaseTestCase):
    """"""Tests adapted from circuit basics tutorial.""""""

    def setUp(self):
        super().setUp()
        self.circ = QuantumCircuit(3)
        self.circ.h(0)
        self.circ.cx(0, 1)
        self.circ.cx(0, 2)

    @decorators.component_attr(""terra"", ""backend"")
    @ddt.data(0, 1, 2, 3)
    def test_ghz_circuit(self, opt_level):
        """"""Test execution of ghz circuit.""""""
        self.circ.measure_all()
        tqc = transpile(self.circ, self.backend, optimization_level=opt_level)
        run_kwargs = {}
        expected_value = None
        if hasattr(self.backend.options, ""shots""):
            run_kwargs[""shots""] = 1000
            expected_value = 500
        if hasattr(self.backend.options, ""seed_simulator""):
            run_kwargs[""seed_simulator""] = 42
        job = self.backend.run(tqc, **run_kwargs)
        result = job.result()
        counts = result.get_counts()
        if expected_value is None:
            expected_value = sum(counts.values()) / 2
        expected = {""000"": expected_value, ""111"": expected_value}
        delta = 10 ** math.floor(math.log10(expected_value))
        self.assertDictAlmostEqual(counts, expected, delta=delta)
"
https://github.com/Qiskit/qiskit-neko,Qiskit,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Test backend on execute().""""""

import math

from qiskit.circuit import QuantumCircuit
from qiskit import transpile

from qiskit_neko import decorators
from qiskit_neko.tests import base


class TestExecute(base.BaseTestCase):
    """"""Test the use of the execute() method in qiskit-terra.""""""

    def setUp(self):
        super().setUp()
        if not hasattr(self.backend.options, ""shots""):
            raise self.skipException(
                ""Provided backend {self.backend} does not have a configurable shots option""
            )
        if hasattr(self.backend.options, ""seed_simulator""):
            self.backend.set_options(seed_simulator=42)

    @decorators.component_attr(""terra"", ""backend"")
    def test_bell_execute_fixed_shots(self):
        """"""Test the execution of a bell circuit with an explicit shot count.""""""
        circuit = QuantumCircuit(2)
        circuit.h(0)
        circuit.cx(0, 1)
        circuit.measure_all()
        job = self.backend.run(transpile(circuit, self.backend), shots=100)
        result = job.result()
        counts = result.get_counts()
        self.assertDictAlmostEqual(counts, {""00"": 50, ""11"": 50}, delta=10)

    @decorators.component_attr(""terra"", ""backend"")
    def test_bell_execute_default_shots(self):
        """"""Test the execution of a bell circuit with an explicit shot count.""""""
        circuit = QuantumCircuit(2)
        circuit.h(0)
        circuit.cx(0, 1)
        circuit.measure_all()
        expected_count = self.backend.options.shots / 2
        job = self.backend.run(transpile(circuit, self.backend))
        result = job.result()
        counts = result.get_counts()
        delta = 10 ** (math.log10(self.backend.options.shots) - 1)
        self.assertDictAlmostEqual(
            counts, {""00"": expected_count, ""11"": expected_count}, delta=delta
        )

    @decorators.component_attr(""terra"", ""backend"")
    def test_bell_execute_backend_shots_set_options(self):
        """"""Test the execution of a bell circuit with an explicit shot count set via options.""""""
        circuit = QuantumCircuit(2)
        circuit.h(0)
        circuit.cx(0, 1)
        circuit.measure_all()
        self.backend.set_options(shots=100)
        job = self.backend.run(transpile(circuit, self.backend))
        result = job.result()
        counts = result.get_counts()
        self.assertDictAlmostEqual(counts, {""00"": 50, ""11"": 50}, delta=10)
"
https://github.com/Qiskit/qiskit-neko,Qiskit,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Tests for quantum state tomography.""""""

from qiskit_experiments.library import StateTomography
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix, state_fidelity

from qiskit_neko import decorators
from qiskit_neko.tests import base


class TestQuantumStateTomography(base.BaseTestCase):
    """"""Tests adapted from circuit basics tutorial.""""""

    @decorators.component_attr(""terra"", ""backend"", ""experiment"")
    def test_ghz_circuit_quantum_info(self):
        """"""Test state tomography of ghz state circuit""""""
        nq = 3
        qc_ghz = QuantumCircuit(nq)
        qc_ghz.h(0)
        qc_ghz.s(0)
        for i in range(1, nq):
            qc_ghz.cx(0, i)
        qstexp1 = StateTomography(qc_ghz)
        qstdata1 = qstexp1.run(self.backend, seed_simulation=42).block_for_results()
        state_result = qstdata1.analysis_results(""state"")
        density_matrix = state_result.value
        ideal_density_matrix = DensityMatrix(qc_ghz)
        fidelity = state_fidelity(density_matrix, ideal_density_matrix)
        self.assertGreaterEqual(fidelity, 0.55)
"
https://github.com/Qiskit/qiskit-neko,Qiskit,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022, 2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Tests for quantum neural networks.""""""

import numpy as np
from ddt import ddt, data, unpack
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.primitives import Sampler as ReferenceSampler, Estimator as ReferenceEstimator
from qiskit.quantum_info import SparsePauliOp

from qiskit_aer.primitives import Sampler as AerSampler, Estimator as AerEstimator
from qiskit_machine_learning.neural_networks import SamplerQNN, EstimatorQNN

from qiskit_neko import decorators
from qiskit_neko.tests import base


@ddt
class TestNeuralNetworksOnPrimitives(base.BaseTestCase):
    """"""Test adapted from the qiskit_machine_learning tutorials.""""""

    def setUp(self):
        super().setUp()

        self.input_params = [Parameter(""x"")]
        self.weight_params = [Parameter(""w"")]
        self.circuit = QuantumCircuit(1)
        self.circuit.ry(self.input_params[0], 0)
        self.circuit.rx(self.weight_params[0], 0)
        self.samplers = dict(reference=ReferenceSampler(), aer=AerSampler(run_options={""seed"": 42}))
        self.estimators = dict(
            reference=ReferenceEstimator(), aer=AerEstimator(run_options={""seed"": 42})
        )

    @decorators.component_attr(""terra"", ""aer"", ""machine_learning"")
    @data([""reference"", 4], [""aer"", 1])
    @unpack
    def test_sampler_qnn(self, implementation, decimal):
        """"""Test the execution of quantum neural networks using SamplerQNN.""""""
        sampler = self.samplers[implementation]

        qnn = SamplerQNN(
            circuit=self.circuit,
            input_params=self.input_params,
            weight_params=self.weight_params,
            input_gradients=True,
            sampler=sampler,
        )
        input_data = np.ones(len(self.input_params))
        weights = np.ones(len(self.weight_params))
        probabilities = qnn.forward(input_data, weights)
        np.testing.assert_array_almost_equal(probabilities, [[0.6460, 0.3540]], decimal)
        input_grad, weight_grad = qnn.backward(input_data, weights)
        np.testing.assert_array_almost_equal(input_grad, [[[-0.2273], [0.2273]]], decimal)
        np.testing.assert_array_almost_equal(weight_grad, [[[-0.2273], [0.2273]]], decimal)

    @decorators.component_attr(""terra"", ""aer"", ""machine_learning"")
    @data([""reference"", 4], [""aer"", 1])
    @unpack
    def test_estimator_qnn(self, implementation, decimal):
        """"""Test the execution of quantum neural networks using EstimatorQNN.""""""
        estimator = self.estimators[implementation]

        qnn = EstimatorQNN(
            circuit=self.circuit,
            observables=SparsePauliOp.from_list([(""Z"", 1)]),
            input_params=self.input_params,
            weight_params=self.weight_params,
            input_gradients=True,
            estimator=estimator,
        )
        input_data = np.ones(len(self.input_params))
        weights = np.ones(len(self.weight_params))
        expectations = qnn.forward(input_data, weights)
        np.testing.assert_array_almost_equal(expectations, [[0.2919]], decimal)
        input_grad, weight_grad = qnn.backward(input_data, weights)
        np.testing.assert_array_almost_equal(input_grad, [[[-0.4546]]], decimal)
        np.testing.assert_array_almost_equal(weight_grad, [[[-0.4546]]], decimal)
"
https://github.com/Qiskit/qiskit-neko,Qiskit,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022, 2024.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Test ground state solvers.""""""
import unittest

from qiskit_algorithms import NumPyMinimumEigensolver, VQE
from qiskit_algorithms.optimizers import SLSQP
from qiskit.primitives import Estimator

import qiskit_nature
from qiskit_nature.second_q.algorithms import GroundStateEigensolver
from qiskit_nature.second_q.circuit.library import HartreeFock, UCCSD
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.mappers import JordanWignerMapper

from qiskit_neko.tests import base
from qiskit_neko import decorators


class TestGroundStateSolvers(base.BaseTestCase):
    """"""Test the use of the execute() method in qiskit-terra.""""""

    @unittest.skipIf(
        tuple(map(int, qiskit_nature.__version__.split(""."")[:2])) < (0, 7),
        ""This test is incompatible with qiskit_nature versions below 0.7.0"",
    )
    @decorators.component_attr(""terra"", ""backend"", ""nature"", ""algorithms"")
    def test_ground_state_solver(self):
        """"""Test the execution of a bell circuit with an explicit shot count.""""""
        driver = PySCFDriver(atom=""H 0.0 0.0 0.0; H 0.0 0.0 0.735"", basis=""sto3g"")
        es_problem = driver.run()
        qubit_mapper = JordanWignerMapper()
        estimator = Estimator()
        optimizer = SLSQP()
        ansatz = UCCSD(
            es_problem.num_spatial_orbitals,
            es_problem.num_particles,
            qubit_mapper,
            initial_state=HartreeFock(
                es_problem.num_spatial_orbitals,
                es_problem.num_particles,
                qubit_mapper,
            ),
        )
        vqe_solver = VQE(estimator, ansatz, optimizer)
        vqe_solver.initial_point = [0.0] * ansatz.num_parameters
        calc = GroundStateEigensolver(qubit_mapper, vqe_solver)
        result = calc.solve(es_problem)

        # Calculate expected result from numpy solver
        numpy_solver = NumPyMinimumEigensolver()
        np_calc = GroundStateEigensolver(qubit_mapper, numpy_solver)
        expected = np_calc.solve(es_problem)
        self.assertAlmostEqual(result.hartree_fock_energy, expected.hartree_fock_energy)
        self.assertEqual(len(result.total_energies), 1)
        self.assertAlmostEqual(result.total_energies[0], expected.total_energies[0], delta=0.02)
"
https://github.com/qiskit-community/qiskit-aqua-interfaces,qiskit-community,"# -*- coding: utf-8 -*-

# This code is part of Qiskit.
#
# (C) Copyright IBM 2018, 2019.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Root main view""""""

import sys
import tkinter as tk
import tkinter.messagebox as tkmb
import tkinter.ttk as ttk
import tkinter.filedialog as tkfd
from tkinter import font
import webbrowser
import os
from qiskit_aqua_interfaces import __version__, APP_DEPRECATION_MSG
from ._sectionsview import SectionsView
from ._sectiontextview import SectionTextView
from ._threadsafeoutputview import ThreadSafeOutputView
from ._emptyview import EmptyView
from ._preferencesdialog import PreferencesDialog

# pylint: disable=import-outside-toplevel


class MainView(ttk.Frame):
    """""" Main View """"""
    def __init__(self, parent, guiprovider) -> None:
        """"""Create MainView object.""""""
        super(MainView, self).__init__(parent)
        self._guiprovider = guiprovider
        self._guiprovider.controller.view = self
        self.pack(expand=tk.YES, fill=tk.BOTH)
        self._create_widgets()
        self.master.title(self._guiprovider.title)
        if parent is not None:
            parent.protocol('WM_DELETE_WINDOW', self.quit)

    def _show_about_dialog(self):
        import qiskit.aqua as qa
        lines = ['Qiskit Aqua Interfaces',
                 'Version: {}'.format(__version__),
                 '',
                 'Qiskit Aqua',
                 'Version: {}'.format(qa.__version__),
                 ]
        tkmb.showinfo(self._guiprovider.title, message='\n'.join(lines))

    def _show_preferences(self):
        dialog = PreferencesDialog(self, self._guiprovider)
        dialog.do_init(tk.LEFT)
        dialog.do_modal()

    def _create_widgets(self):
        self._make_menubar()
        self._make_toolbar()
        self._create_pane()

    def _make_toolbar(self):
        toolbar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=2)
        toolbar.pack(side=tk.BOTTOM, fill=tk.X)
        self._guiprovider.controller._button_text = tk.StringVar()
        self._guiprovider.controller._button_text.set(self._guiprovider.controller._command)
        self._guiprovider.controller._start_button = \
            ttk.Button(toolbar,
                       textvariable=self._guiprovider.controller._button_text,
                       state='disabled',
                       command=self._guiprovider.controller.toggle)
        self._guiprovider.controller._start_button.pack(side=tk.LEFT)
        self._guiprovider.add_toolbar_items(toolbar)
        self._guiprovider.controller._progress = ttk.Progressbar(toolbar, orient=tk.HORIZONTAL)
        self._guiprovider.controller._progress.pack(side=tk.RIGHT, fill=tk.BOTH, expand=tk.TRUE)

    def _make_menubar(self):
        menubar = tk.Menu(self.master)
        if sys.platform == 'darwin':
            app_menu = tk.Menu(menubar, name='apple')
            menubar.add_cascade(menu=app_menu)
            app_menu.add_command(label='About {}'.format(
                self._guiprovider.title), command=self._show_about_dialog)
            self.master.createcommand('tk::mac::ShowPreferences', self._show_preferences)
            self.master.createcommand('tk::mac::Quit', self.quit)

        self.master.config(menu=menubar)
        self._guiprovider.controller._filemenu = self._make_filemenu(menubar)

        if sys.platform != 'darwin':
            tools_menu = tk.Menu(menubar, tearoff=False)
            tools_menu.add_command(label='Options', command=self._show_preferences)
            menubar.add_cascade(label='Tools', menu=tools_menu)

        help_menu = tk.Menu(menubar, tearoff=False)
        if sys.platform != 'darwin':
            help_menu.add_command(label='About {}'.format(self._guiprovider.title),
                                  command=self._show_about_dialog)

        help_menu.add_command(label='Open Help Center', command=self._open_help_center)
        menubar.add_cascade(label='Help', menu=help_menu)

    def _open_help_center(self):
        webbrowser.open(self._guiprovider.help_hyperlink)

    def _make_filemenu(self, menubar):
        file_menu = tk.Menu(menubar, tearoff=False, postcommand=self._recent_files_menu)
        file_menu.add_command(label='New', command=self._new_input)
        file_menu.add_command(label='Open...', command=self._open_file)
        file_menu.add_cascade(label='Open Recent', menu=tk.Menu(file_menu, tearoff=False))
        file_menu.add_separator()
        file_menu.add_command(label='Save', command=self._save_file)
        file_menu.add_command(label='Save As...', command=self._save_file_as)

        self._guiprovider.add_file_menu_items(file_menu)

        if sys.platform != 'darwin':
            file_menu.add_separator()
            file_menu.add_command(label='Exit', command=self.quit)

        menubar.add_cascade(label='File', menu=file_menu)
        return file_menu

    def _recent_files_menu(self):
        recent_menu = tk.Menu(self._guiprovider.controller._filemenu, tearoff=False)
        preferences = self._guiprovider.create_uipreferences()
        for file in preferences.get_recent_files():
            recent_menu.add_command(label=file, command=lambda f=file: self._open_recent_file(f))

        recent_menu.add_separator()
        recent_menu.add_command(label='Clear', command=self._clear_recent)
        self._guiprovider.controller._filemenu.entryconfig(2, menu=recent_menu)

    def _new_input(self):
        self._guiprovider.controller.new_input()

    def _open_file(self):
        preferences = self._guiprovider.create_uipreferences()
        filename = tkfd.askopenfilename(parent=self,
                                        title='Open File',
                                        initialdir=preferences.get_openfile_initialdir())
        if filename and self._guiprovider.controller.open_file(filename):
            preferences.add_recent_file(filename)
            preferences.set_openfile_initialdir(os.path.dirname(filename))
            preferences.save()

    def _open_recent_file(self, filename):
        self._guiprovider.controller.open_file(filename)

    def _clear_recent(self):
        preferences = self._guiprovider.create_uipreferences()
        preferences.clear_recent_files()
        preferences.save()

    def _save_file(self):
        self._guiprovider.controller.save_file()

    def _save_file_as(self):
        if self._guiprovider.controller.is_empty():
            self._guiprovider.controller.outputview.write_line(""No data to save."")
            return

        preferences = self._guiprovider.create_uipreferences()
        filename = tkfd.asksaveasfilename(parent=self,
                                          title='Save File',
                                          initialdir=preferences.get_savefile_initialdir())
        if filename and self._guiprovider.controller.save_file_as(filename):
            preferences.add_recent_file(filename)
            preferences.set_savefile_initialdir(os.path.dirname(filename))
            preferences.save()

    def _create_pane(self):
        label_font = font.nametofont('TkHeadingFont').copy()
        label_font.configure(size=12, weight='bold')
        style = ttk.Style()
        style.configure('Title.TLabel',
                        borderwidth=0,
                        anchor=tk.CENTER)
        label = ttk.Label(self,
                          style='Title.TLabel',
                          padding=(5, 5, 5, 5),
                          textvariable=self._guiprovider.controller._title)
        label['font'] = label_font
        label.pack(side=tk.TOP, expand=tk.NO, fill=tk.X)
        main_pane = ttk.PanedWindow(self, orient=tk.VERTICAL)
        main_pane.pack(expand=tk.YES, fill=tk.BOTH)
        top_pane = ttk.PanedWindow(main_pane, orient=tk.HORIZONTAL)
        top_pane.pack(expand=tk.YES, fill=tk.BOTH)
        main_pane.add(top_pane)

        self._guiprovider.controller._sections_view = \
            SectionsView(self._guiprovider.controller, top_pane)
        self._guiprovider.controller._sections_view.pack(expand=tk.YES, fill=tk.BOTH)
        top_pane.add(self._guiprovider.controller._sections_view, weight=1)

        main_container = tk.Frame(top_pane)
        main_container.pack(expand=tk.YES, fill=tk.BOTH)
        style = ttk.Style()
        style.configure('PropViewTitle.TLabel',
                        borderwidth=1,
                        relief=tk.RIDGE,
                        anchor=tk.CENTER)
        label = ttk.Label(main_container,
                          style='PropViewTitle.TLabel',
                          padding=(5, 5, 5, 5),
                          textvariable=self._guiprovider.controller._sections_view_title)
        label['font'] = label_font

        label.pack(side=tk.TOP, expand=tk.NO, fill=tk.X)
        container = tk.Frame(main_container)
        container.pack(side=tk.BOTTOM, expand=tk.YES, fill=tk.BOTH)
        container.grid_rowconfigure(0, weight=1)
        container.grid_columnconfigure(0, weight=1)
        self._guiprovider.controller._empty_view = EmptyView(container)
        self._guiprovider.controller._empty_view.grid(row=0, column=0, sticky='nsew')

        self._guiprovider.controller._text_view = \
            SectionTextView(self._guiprovider.controller, container)
        self._guiprovider.controller._text_view.grid(row=0, column=0, sticky='nsew')

        self._guiprovider.controller._properties_view = \
            self._guiprovider.create_section_properties_view(container)
        self._guiprovider.controller._properties_view.grid(row=0, column=0, sticky='nsew')
        self._guiprovider.controller._empty_view.tkraise()
        top_pane.add(main_container, weight=1)

        self._guiprovider.controller.outputview = ThreadSafeOutputView(main_pane)
        self._guiprovider.controller.outputview.pack(expand=tk.YES, fill=tk.BOTH)
        main_pane.add(self._guiprovider.controller.outputview)

        # redirect output
        sys.stdout = self._guiprovider.controller.outputview
        sys.stderr = self._guiprovider.controller.outputview
        # update logging after redirect
        self.after(0, self._set_preferences_logging)

        self.update_idletasks()
        self._guiprovider.controller._sections_view.show_add_button(False)
        self._guiprovider.controller._sections_view.show_remove_button(False)
        self._guiprovider.controller._sections_view.show_defaults_button(False)
        self._guiprovider.controller._empty_view.set_toolbar_size(
            self._guiprovider.controller._sections_view.get_toolbar_size())

        self._guiprovider.controller.outputview.write_line(APP_DEPRECATION_MSG)

    def _set_preferences_logging(self):
        preferences = self._guiprovider.create_uipreferences()
        config = preferences.get_logging_config()
        if config is not None:
            self._guiprovider.set_logging_config(config)

    def quit(self):
        if tkmb.askyesno('Verify quit', 'Are you sure you want to quit?'):
            preferences = self._guiprovider.create_uipreferences()
            preferences.set_geometry(self.master.winfo_geometry())
            preferences.save()
            self._guiprovider.controller.stop()
            ttk.Frame.quit(self)
            return True

        return False
"
https://github.com/qiskit-community/qiskit-aqua-interfaces,qiskit-community,"# -*- coding: utf-8 -*-

# This code is part of Qiskit.
#
# (C) Copyright IBM 2018, 2019.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Root main view""""""

import sys
import tkinter as tk
import tkinter.messagebox as tkmb
import tkinter.ttk as ttk
import tkinter.filedialog as tkfd
from tkinter import font
import webbrowser
import os
from qiskit_aqua_interfaces import __version__, APP_DEPRECATION_MSG
from ._sectionsview import SectionsView
from ._sectiontextview import SectionTextView
from ._threadsafeoutputview import ThreadSafeOutputView
from ._emptyview import EmptyView
from ._preferencesdialog import PreferencesDialog

# pylint: disable=import-outside-toplevel


class MainView(ttk.Frame):
    """""" Main View """"""
    def __init__(self, parent, guiprovider) -> None:
        """"""Create MainView object.""""""
        super(MainView, self).__init__(parent)
        self._guiprovider = guiprovider
        self._guiprovider.controller.view = self
        self.pack(expand=tk.YES, fill=tk.BOTH)
        self._create_widgets()
        self.master.title(self._guiprovider.title)
        if parent is not None:
            parent.protocol('WM_DELETE_WINDOW', self.quit)

    def _show_about_dialog(self):
        import qiskit.aqua as qa
        lines = ['Qiskit Aqua Interfaces',
                 'Version: {}'.format(__version__),
                 '',
                 'Qiskit Aqua',
                 'Version: {}'.format(qa.__version__),
                 ]
        tkmb.showinfo(self._guiprovider.title, message='\n'.join(lines))

    def _show_preferences(self):
        dialog = PreferencesDialog(self, self._guiprovider)
        dialog.do_init(tk.LEFT)
        dialog.do_modal()

    def _create_widgets(self):
        self._make_menubar()
        self._make_toolbar()
        self._create_pane()

    def _make_toolbar(self):
        toolbar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=2)
        toolbar.pack(side=tk.BOTTOM, fill=tk.X)
        self._guiprovider.controller._button_text = tk.StringVar()
        self._guiprovider.controller._button_text.set(self._guiprovider.controller._command)
        self._guiprovider.controller._start_button = \
            ttk.Button(toolbar,
                       textvariable=self._guiprovider.controller._button_text,
                       state='disabled',
                       command=self._guiprovider.controller.toggle)
        self._guiprovider.controller._start_button.pack(side=tk.LEFT)
        self._guiprovider.add_toolbar_items(toolbar)
        self._guiprovider.controller._progress = ttk.Progressbar(toolbar, orient=tk.HORIZONTAL)
        self._guiprovider.controller._progress.pack(side=tk.RIGHT, fill=tk.BOTH, expand=tk.TRUE)

    def _make_menubar(self):
        menubar = tk.Menu(self.master)
        if sys.platform == 'darwin':
            app_menu = tk.Menu(menubar, name='apple')
            menubar.add_cascade(menu=app_menu)
            app_menu.add_command(label='About {}'.format(
                self._guiprovider.title), command=self._show_about_dialog)
            self.master.createcommand('tk::mac::ShowPreferences', self._show_preferences)
            self.master.createcommand('tk::mac::Quit', self.quit)

        self.master.config(menu=menubar)
        self._guiprovider.controller._filemenu = self._make_filemenu(menubar)

        if sys.platform != 'darwin':
            tools_menu = tk.Menu(menubar, tearoff=False)
            tools_menu.add_command(label='Options', command=self._show_preferences)
            menubar.add_cascade(label='Tools', menu=tools_menu)

        help_menu = tk.Menu(menubar, tearoff=False)
        if sys.platform != 'darwin':
            help_menu.add_command(label='About {}'.format(self._guiprovider.title),
                                  command=self._show_about_dialog)

        help_menu.add_command(label='Open Help Center', command=self._open_help_center)
        menubar.add_cascade(label='Help', menu=help_menu)

    def _open_help_center(self):
        webbrowser.open(self._guiprovider.help_hyperlink)

    def _make_filemenu(self, menubar):
        file_menu = tk.Menu(menubar, tearoff=False, postcommand=self._recent_files_menu)
        file_menu.add_command(label='New', command=self._new_input)
        file_menu.add_command(label='Open...', command=self._open_file)
        file_menu.add_cascade(label='Open Recent', menu=tk.Menu(file_menu, tearoff=False))
        file_menu.add_separator()
        file_menu.add_command(label='Save', command=self._save_file)
        file_menu.add_command(label='Save As...', command=self._save_file_as)

        self._guiprovider.add_file_menu_items(file_menu)

        if sys.platform != 'darwin':
            file_menu.add_separator()
            file_menu.add_command(label='Exit', command=self.quit)

        menubar.add_cascade(label='File', menu=file_menu)
        return file_menu

    def _recent_files_menu(self):
        recent_menu = tk.Menu(self._guiprovider.controller._filemenu, tearoff=False)
        preferences = self._guiprovider.create_uipreferences()
        for file in preferences.get_recent_files():
            recent_menu.add_command(label=file, command=lambda f=file: self._open_recent_file(f))

        recent_menu.add_separator()
        recent_menu.add_command(label='Clear', command=self._clear_recent)
        self._guiprovider.controller._filemenu.entryconfig(2, menu=recent_menu)

    def _new_input(self):
        self._guiprovider.controller.new_input()

    def _open_file(self):
        preferences = self._guiprovider.create_uipreferences()
        filename = tkfd.askopenfilename(parent=self,
                                        title='Open File',
                                        initialdir=preferences.get_openfile_initialdir())
        if filename and self._guiprovider.controller.open_file(filename):
            preferences.add_recent_file(filename)
            preferences.set_openfile_initialdir(os.path.dirname(filename))
            preferences.save()

    def _open_recent_file(self, filename):
        self._guiprovider.controller.open_file(filename)

    def _clear_recent(self):
        preferences = self._guiprovider.create_uipreferences()
        preferences.clear_recent_files()
        preferences.save()

    def _save_file(self):
        self._guiprovider.controller.save_file()

    def _save_file_as(self):
        if self._guiprovider.controller.is_empty():
            self._guiprovider.controller.outputview.write_line(""No data to save."")
            return

        preferences = self._guiprovider.create_uipreferences()
        filename = tkfd.asksaveasfilename(parent=self,
                                          title='Save File',
                                          initialdir=preferences.get_savefile_initialdir())
        if filename and self._guiprovider.controller.save_file_as(filename):
            preferences.add_recent_file(filename)
            preferences.set_savefile_initialdir(os.path.dirname(filename))
            preferences.save()

    def _create_pane(self):
        label_font = font.nametofont('TkHeadingFont').copy()
        label_font.configure(size=12, weight='bold')
        style = ttk.Style()
        style.configure('Title.TLabel',
                        borderwidth=0,
                        anchor=tk.CENTER)
        label = ttk.Label(self,
                          style='Title.TLabel',
                          padding=(5, 5, 5, 5),
                          textvariable=self._guiprovider.controller._title)
        label['font'] = label_font
        label.pack(side=tk.TOP, expand=tk.NO, fill=tk.X)
        main_pane = ttk.PanedWindow(self, orient=tk.VERTICAL)
        main_pane.pack(expand=tk.YES, fill=tk.BOTH)
        top_pane = ttk.PanedWindow(main_pane, orient=tk.HORIZONTAL)
        top_pane.pack(expand=tk.YES, fill=tk.BOTH)
        main_pane.add(top_pane)

        self._guiprovider.controller._sections_view = \
            SectionsView(self._guiprovider.controller, top_pane)
        self._guiprovider.controller._sections_view.pack(expand=tk.YES, fill=tk.BOTH)
        top_pane.add(self._guiprovider.controller._sections_view, weight=1)

        main_container = tk.Frame(top_pane)
        main_container.pack(expand=tk.YES, fill=tk.BOTH)
        style = ttk.Style()
        style.configure('PropViewTitle.TLabel',
                        borderwidth=1,
                        relief=tk.RIDGE,
                        anchor=tk.CENTER)
        label = ttk.Label(main_container,
                          style='PropViewTitle.TLabel',
                          padding=(5, 5, 5, 5),
                          textvariable=self._guiprovider.controller._sections_view_title)
        label['font'] = label_font

        label.pack(side=tk.TOP, expand=tk.NO, fill=tk.X)
        container = tk.Frame(main_container)
        container.pack(side=tk.BOTTOM, expand=tk.YES, fill=tk.BOTH)
        container.grid_rowconfigure(0, weight=1)
        container.grid_columnconfigure(0, weight=1)
        self._guiprovider.controller._empty_view = EmptyView(container)
        self._guiprovider.controller._empty_view.grid(row=0, column=0, sticky='nsew')

        self._guiprovider.controller._text_view = \
            SectionTextView(self._guiprovider.controller, container)
        self._guiprovider.controller._text_view.grid(row=0, column=0, sticky='nsew')

        self._guiprovider.controller._properties_view = \
            self._guiprovider.create_section_properties_view(container)
        self._guiprovider.controller._properties_view.grid(row=0, column=0, sticky='nsew')
        self._guiprovider.controller._empty_view.tkraise()
        top_pane.add(main_container, weight=1)

        self._guiprovider.controller.outputview = ThreadSafeOutputView(main_pane)
        self._guiprovider.controller.outputview.pack(expand=tk.YES, fill=tk.BOTH)
        main_pane.add(self._guiprovider.controller.outputview)

        # redirect output
        sys.stdout = self._guiprovider.controller.outputview
        sys.stderr = self._guiprovider.controller.outputview
        # update logging after redirect
        self.after(0, self._set_preferences_logging)

        self.update_idletasks()
        self._guiprovider.controller._sections_view.show_add_button(False)
        self._guiprovider.controller._sections_view.show_remove_button(False)
        self._guiprovider.controller._sections_view.show_defaults_button(False)
        self._guiprovider.controller._empty_view.set_toolbar_size(
            self._guiprovider.controller._sections_view.get_toolbar_size())

        self._guiprovider.controller.outputview.write_line(APP_DEPRECATION_MSG)

    def _set_preferences_logging(self):
        preferences = self._guiprovider.create_uipreferences()
        config = preferences.get_logging_config()
        if config is not None:
            self._guiprovider.set_logging_config(config)

    def quit(self):
        if tkmb.askyesno('Verify quit', 'Are you sure you want to quit?'):
            preferences = self._guiprovider.create_uipreferences()
            preferences.set_geometry(self.master.winfo_geometry())
            preferences.save()
            self._guiprovider.controller.stop()
            ttk.Frame.quit(self)
            return True

        return False
"
https://github.com/qiskit-community/qiskit-nature-pyscf,qiskit-community,"import qiskit_qasm3_import

project = 'Qiskit OpenQASM 3 Importer'
copyright = '2022, Jake Lishman'
author = 'Jake Lishman'
version = qiskit_qasm3_import.__version__
release = qiskit_qasm3_import.__version__

extensions = [
    ""sphinx.ext.autodoc"",
    ""sphinx.ext.intersphinx"",
    ""reno.sphinxext"",
    'qiskit_sphinx_theme',
]
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']

# Document the docstring for the class and the __init__ method together.
autoclass_content = ""both""

html_theme = ""qiskit-ecosystem""
html_title = f""{project} {release}""

intersphinx_mapping = {
    ""qiskit-terra"": (""https://docs.quantum.ibm.com/api/qiskit/"", None),
}
"
https://github.com/qiskit-community/qiskit-qcgpu-provider,qiskit-community,"import click
import time
import random
import statistics
import csv
import os.path
import math

from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit
from qiskit import QiskitError, execute, Aer

from qiskit_qcgpu_provider import QCGPUProvider

# Implementation of the Quantum Fourier Transform

def construct_circuit(num_qubits):
    q = QuantumRegister(num_qubits)
    c = ClassicalRegister(num_qubits)
    circ = QuantumCircuit(q, c)

    # Quantum Fourier Transform
    for j in range(num_qubits):
        for k in range(j):
            circ.cu1(math.pi / float(2**(j - k)), q[j], q[k])
        circ.h(q[j])
    # circ.measure(q, c)

    return circ


# Benchmarking functions
# qiskit_backend = Aer.get_backend('qasm_simulator')
# qcgpu_backend = QCGPUProvider().get_backend('qasm_simulator')
qiskit_backend = Aer.get_backend('statevector_simulator')
qcgpu_backend = QCGPUProvider().get_backend('statevector_simulator')


def bench_qiskit(qc):
    start = time.time()
    job_sim = execute(qc, qiskit_backend)
    sim_result = job_sim.result()
    return time.time() - start


def bench_qcgpu(qc):
    start = time.time()
    job_sim = execute(qc, qcgpu_backend)
    sim_result = job_sim.result()
    return time.time() - start

# Reporting


def create_csv(filename):
    file_exists = os.path.isfile(filename)
    csvfile = open(filename, 'a')

    headers = ['name', 'num_qubits', 'time']
    writer = csv.DictWriter(csvfile, delimiter=',', lineterminator='\n', fieldnames=headers)

    if not file_exists:
        writer.writeheader()  # file doesn't exist yet, write a header

    return writer


def write_csv(writer, data):
    writer.writerow(data)


@click.command()
@click.option('--samples', default=5, help='Number of samples to take for each qubit.')
@click.option('--qubits', default=5, help='How many qubits you want to test for')
@click.option('--out', default='benchmark_data.csv',
              help='Where to store the CSV output of each test')
@click.option(
    '--single',
    default=False,
    help='Only run the benchmark for a single amount of qubits, and print an analysis')
@click.option('--burn', default=True, help='Burn the first few samples for accuracy')
def benchmark(samples, qubits, out, single, burn):
    burn_count = 5 if burn else 0

    if single:
        functions = bench_qcgpu, bench_qiskit
        times = {f.__name__: [] for f in functions}

        names = []
        means = []

        qc = construct_circuit(qubits)

        # Run the benchmarks
        for i in range(samples + burn_count):
            progress = (i) / (samples + burn_count)
            if samples > 1:
                print(""\rProgress: [{0:50s}] {1:.1f}%"".format('#' * int(progress * 50), progress * 100), end="""", flush=True)

            func = random.choice(functions)
            t = func(qc)
            
            if i >= burn_count:
                times[func.__name__].append(t)

        print('')

        for name, numbers in times.items():
            print('FUNCTION:', name, 'Used', len(numbers), 'times')
            print('\tMEDIAN', statistics.median(numbers))
            print('\tMEAN  ', statistics.mean(numbers))
            if len(numbers) > 1:
                print('\tSTDEV ', statistics.stdev(numbers))

        return

    functions = bench_qcgpu, bench_qiskit

    writer = create_csv(out)

    for n in range(1, qubits):
        # Progress counter
        progress = (n + 1) / (qubits)
        print(""\rProgress: [{0:50s}] {1:.1f}%"".format('#' * int(progress * 50), progress * 100), end="""", flush=True)

        # Construct the circuit
        qc = construct_circuit(n + 1)

        # Run the benchmarks
        for i in range(samples):
            func = random.choice(functions)
            t = func(qc)
            # times[func.__name__].append(t)
            write_csv(writer, {'name': func.__name__, 'num_qubits': n + 1, 'time': t})


if __name__ == '__main__':
    benchmark()
"
https://github.com/qiskit-community/qiskit-qcgpu-provider,qiskit-community,"""""""
Example used in the README. In this example a Bell state is made.

""""""

# Import the Qiskit
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, QiskitError
from qiskit import execute
from qiskit_qcgpu_provider import QCGPUProvider

# Create a Quantum Register with 2 qubits.
q = QuantumRegister(2)
# Create a Classical Register with 2 bits.
c = ClassicalRegister(2)
# Create a Quantum Circuit
qc = QuantumCircuit(q, c)

# Add a H gate on qubit 0, putting this qubit in superposition.
qc.h(q[0])
# Add a CX (CNOT) gate on control qubit 0 and target qubit 1, putting
# the qubits in a Bell state.
qc.cx(q[0], q[1])
# Add a Measure gate to see the state.
qc.measure(q, c)

# Get the QCGPU Provider
Provider = QCGPUProvider()

# See a list of available local simulators
print(""QCGPU backends: "", Provider.backends())
backend_sim = Provider.get_backend('qasm_simulator')

# Compile and run the Quantum circuit on a simulator backend
job_sim = execute(qc, backend_sim)
result_sim = job_sim.result()

# Show the results
print(result_sim.get_counts(qc))
"
https://github.com/qiskit-community/qiskit-qcgpu-provider,qiskit-community,"""""""
In this example a Bell state is made.
""""""

from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import execute
from qiskit_qcgpu_provider import QCGPUProvider

Provider = QCGPUProvider()

# Create a Quantum Register with 2 qubits.
q = QuantumRegister(2)
# Create a Quantum Circuit with 2 Qubits
qc = QuantumCircuit(q)

# Add a H gate on qubit 0, putting this qubit in superposition.
qc.h(q[0])
# Add a CX (CNOT) gate on control qubit 0 and target qubit 1, putting
# the qubits in a Bell state.
qc.cx(q[0], q[1])


# See a list of available local simulators
print(""QCGPU backends: "", Provider.backends())
backend_sim = Provider.get_backend('statevector_simulator')

# Compile and run the Quantum circuit on a simulator backend
job_sim = execute(qc, backend_sim)
result_sim = job_sim.result()

# Show the results
print(""Simulation Results: "", result_sim)
print(result_sim.get_statevector(qc))
"
https://github.com/qiskit-community/qiskit-qcgpu-provider,qiskit-community,"""""""
Exception for errors raised by QCGPU simulators
""""""

from qiskit import QiskitError


class QCGPUSimulatorError(QiskitError):
    """"""Base class for errors raised by simulators.""""""

    def __init__(self, *message):
        """"""Set the error message""""""
        super().__init__(*message)
        self.message = ' '.join(message)

    def __str__(self):
        """"""Return the message""""""
        return repr(self.message)
"
https://github.com/qiskit-community/qiskit-qcgpu-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2017, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

# pylint: disable=missing-docstring,redefined-builtin

import unittest
import os
from qiskit import QuantumCircuit
from .common import QiskitTestCase
from qiskit_jku_provider import QasmSimulator
from qiskit import execute


class TestQasmSimulatorJKUBasic(QiskitTestCase):
    """"""Runs the Basic qasm_simulator tests from Terra on JKU.""""""

    def setUp(self):
        self.seed = 88
        self.backend = QasmSimulator(silent=True)
        qasm_filename = os.path.join(os.path.dirname(__file__), 'qasms', 'example.qasm')
        compiled_circuit = QuantumCircuit.from_qasm_file(qasm_filename)
        compiled_circuit.name = 'test'
        self.circuit = compiled_circuit

    def test_qasm_simulator_single_shot(self):
        """"""Test single shot run.""""""
        result = execute(self.circuit, self.backend, seed_transpiler=34342, shots=1).result()
        self.assertEqual(result.success, True)

    def test_qasm_simulator(self):
        """"""Test data counts output for single circuit run against reference.""""""
        shots = 1024
        result = execute(self.circuit, self.backend, seed_transpiler=34342, shots=shots).result()
        threshold = 0.04 * shots
        counts = result.get_counts('test')
        target = {'100 100': shots / 8, '011 011': shots / 8,
                  '101 101': shots / 8, '111 111': shots / 8,
                  '000 000': shots / 8, '010 010': shots / 8,
                  '110 110': shots / 8, '001 001': shots / 8}
        self.assertDictAlmostEqual(counts, target, threshold)


if __name__ == '__main__':
    unittest.main()
"
https://github.com/qiskit-community/qiskit-qcgpu-provider,qiskit-community,"import unittest
import math

from qiskit_qcgpu_provider import QCGPUProvider
from qiskit import execute, QuantumRegister, QuantumCircuit, BasicAer
from qiskit.quantum_info import state_fidelity

from .case import MyTestCase


class TestStatevectorSimulator(MyTestCase):
    """"""Test the state vector simulator""""""

    def test_computations(self):
        for n in range(2, 10):
            circ = self.random_circuit(n, 5)
            self._compare_outcomes(circ)


    def _compare_outcomes(self, circ):
        Provider = QCGPUProvider()
        backend_qcgpu = Provider.get_backend('statevector_simulator')
        statevector_qcgpu = execute(circ, backend_qcgpu).result().get_statevector()

        backend_qiskit = BasicAer.get_backend('statevector_simulator')
        statevector_qiskit = execute(circ, backend_qiskit).result().get_statevector()

        self.assertAlmostEqual(state_fidelity(statevector_qcgpu, statevector_qiskit), 1, 5)


if __name__ == '__main__':
    unittest.main()
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2019, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

""""""
Example use of the JKU Provider and the Qasm Simulator backend for creating a 
Bell state
""""""
from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit, execute
from qiskit_jku_provider import JKUProvider

JKU = JKUProvider()

qubits_num = 2
qr = QuantumRegister(qubits_num)
cr = ClassicalRegister(qubits_num)

qc = QuantumCircuit(qr, cr)
qc.h(qr[0])
qc.cx(qr[0], qr[1])
qc.measure(qr, cr)

jku_backend = JKU.get_backend('qasm_simulator')
job = execute(qc, backend=jku_backend, shots=1000, seed=42)
result = job.result()
print(result.get_counts())
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2019, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

""""""Usage examples for the JKU Provider""""""

from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit, execute
from qiskit_jku_provider import JKUProvider

JKU = JKUProvider()

jku_backend = JKU.get_backend('qasm_simulator')

print(jku_backend)

# gets the name of the backend.
print(jku_backend.name())

# gets the status of the backend.
print(jku_backend.status())

# returns the provider of the backend
print(jku_backend.provider())

# gets the configuration of the backend.
print(jku_backend.configuration())

# gets the properties of the backend.
print(jku_backend.properties())

# Demonstration of Job
qr = QuantumRegister(2)
cr = ClassicalRegister(2)

qc = QuantumCircuit(qr, cr)
qc.h(qr[0])
qc.cx(qr[0], qr[1])
qc.measure(qr, cr)

job = execute(qc, backend=jku_backend)

# gets the backend the job was run on
backend = job.backend()
print(backend)

# returns the status of the job. Should be running
print(job.status())

# returns the obj that was run
qobj = job.qobj()
print(qobj)

# prints the job id
print(job.job_id())

# cancels the job
print(job.cancel())

# returns the status of the job. Should be canceled
print(job.status())

# runs the qjob on the backend
job2 = backend.run(qobj)

# gets the result of the job. This is a blocker
print(job2.result())
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2019, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

""""""
Example use of the JKU Provider and the Qasm Simulator backend for creating the 
state '01 10'.
""""""
from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit, execute
from qiskit_jku_provider import JKUProvider

JKU = JKUProvider()

qreg0 = QuantumRegister(2, 'q0')
creg0 = ClassicalRegister(2, 'c0')
qreg1 = QuantumRegister(2, 'q1')
creg1 = ClassicalRegister(2, 'c1')
circ = QuantumCircuit(qreg0, qreg1)
circ.x(qreg0[1])
circ.x(qreg1[0])

meas = QuantumCircuit(qreg0, qreg1, creg0, creg1)
meas.measure(qreg0, creg0)
meas.measure(qreg1, creg1)

qc = circ + meas

backend_sim = JKU.get_backend('qasm_simulator')
job = execute(qc, backend_sim)
result = job.result()
counts = result.get_counts(qc)
print(counts)
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2018, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

""""""
Exception for errors raised by JKU simulator.
""""""


from qiskit import QiskitError


class JKUSimulatorError(QiskitError):
    """"""Class for errors raised by the JKU simulator.""""""

    def __init__(self, *message):
        """"""Set the error message.""""""
        super().__init__(*message)
        self.message = ' '.join(message)

    def __str__(self):
        """"""Return the message.""""""
        return repr(self.message)
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""""" pauli common functions """"""

import logging

import numpy as np
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.algorithms import AlgorithmError
from qiskit.circuit import Parameter, ParameterExpression
from qiskit.qasm import pi
from qiskit.quantum_info import Pauli  # pylint: disable=unused-import

logger = logging.getLogger(__name__)


# pylint: disable=too-many-arguments,too-many-branches,too-many-locals
def pauli_measurement(circuit, pauli, qreg, creg, barrier=False):
    """"""
    Add the proper post-rotation gate on the circuit.

    Args:
        circuit (QuantumCircuit): the circuit to be modified.
        pauli (Pauli): the pauli will be added.
        qreg (QuantumRegister): the quantum register associated with the circuit.
        creg (ClassicalRegister): the classical register associated with the circuit.
        barrier (bool, optional): whether or not add barrier before measurement.

    Returns:
        QuantumCircuit: the original circuit object with post-rotation gate
    """"""
    num_qubits = pauli.num_qubits
    for qubit_idx in range(num_qubits):
        if pauli.x[qubit_idx]:
            if pauli.z[qubit_idx]:
                # Measure Y
                circuit.sdg(qreg[qubit_idx])  # sdg
                circuit.h(qreg[qubit_idx])  # h
            else:
                # Measure X
                circuit.h(qreg[qubit_idx])  # h
        if barrier:
            circuit.barrier(qreg[qubit_idx])
        circuit.measure(qreg[qubit_idx], creg[qubit_idx])

    return circuit


def measure_pauli_z(data, pauli):
    """"""
    Appropriate post-rotations on the state are assumed.

    Args:
        data (dict): a dictionary of the form data = {'00000': 10} ({str: int})
        pauli (Pauli): a Pauli object

    Returns:
        float: Expected value of paulis given data
    """"""
    observable = 0.0
    num_shots = sum(data.values())
    p_z_or_x = np.logical_or(pauli.z, pauli.x)
    for key, value in data.items():
        bitstr = np.asarray(list(key))[::-1].astype(int).astype(bool)
        # pylint: disable=no-member
        sign = -1.0 if np.logical_xor.reduce(np.logical_and(bitstr, p_z_or_x)) else 1.0
        observable += sign * value
    observable /= num_shots
    return observable


def covariance(data, pauli_1, pauli_2, avg_1, avg_2):
    """"""
    Compute the covariance matrix element between two
    Paulis, given the measurement outcome.
    Appropriate post-rotations on the state are assumed.

    Args:
        data (dict): a dictionary of the form data = {'00000': 10} ({str:int})
        pauli_1 (Pauli): a Pauli class member
        pauli_2 (Pauli): a Pauli class member
        avg_1 (float): expectation value of pauli_1 on `data`
        avg_2 (float): expectation value of pauli_2 on `data`

    Returns:
        float: the element of the covariance matrix between two Paulis
    """"""
    cov = 0.0
    num_shots = sum(data.values())

    if num_shots == 1:
        return cov

    p1_z_or_x = np.logical_or(pauli_1.z, pauli_1.x)
    p2_z_or_x = np.logical_or(pauli_2.z, pauli_2.x)
    for key, value in data.items():
        bitstr = np.asarray(list(key))[::-1].astype(int).astype(bool)
        # pylint: disable=no-member
        sign_1 = (
            -1.0 if np.logical_xor.reduce(np.logical_and(bitstr, p1_z_or_x)) else 1.0
        )
        sign_2 = (
            -1.0 if np.logical_xor.reduce(np.logical_and(bitstr, p2_z_or_x)) else 1.0
        )
        cov += (sign_1 - avg_1) * (sign_2 - avg_2) * value
    cov /= num_shots - 1
    return cov


# pylint: disable=invalid-name
def suzuki_expansion_slice_pauli_list(pauli_list, lam_coef, expansion_order):
    """"""
    Compute the list of pauli terms for a single slice of the suzuki expansion following the paper
    https://arxiv.org/pdf/quant-ph/0508139.pdf.

    Args:
        pauli_list (list[list[complex, Pauli]]): The slice's weighted Pauli list for the
                                                 suzuki expansion
        lam_coef (float): The parameter lambda as defined in said paper,
                          adjusted for the evolution time and the number of time slices
        expansion_order (int): The order for suzuki expansion

    Returns:
        list: slice pauli list
    """"""
    if expansion_order == 1:
        half = [[lam_coef / 2 * c, p] for c, p in pauli_list]
        res = half + list(reversed(half))
    else:
        p_k = (4 - 4 ** (1 / (2 * expansion_order - 1))) ** -1
        side_base = suzuki_expansion_slice_pauli_list(
            pauli_list, lam_coef * p_k, expansion_order - 1
        )
        side = side_base * 2
        middle = suzuki_expansion_slice_pauli_list(
            pauli_list, lam_coef * (1 - 4 * p_k), expansion_order - 1
        )
        res = side + middle + side
    return res


def check_commutativity(op_1, op_2, anti=False):
    """"""
    Check the (anti-)commutativity between two operators.

    Args:
        op_1 (WeightedPauliOperator): operator
        op_2 (WeightedPauliOperator): operator
        anti (bool): if True, check anti-commutativity, otherwise check commutativity.

    Returns:
        bool: whether or not two operators are commuted or anti-commuted.
    """"""
    com = op_1 * op_2 - op_2 * op_1 if not anti else op_1 * op_2 + op_2 * op_1
    com.simplify()
    return bool(com.is_empty())


# pylint: disable=too-many-statements
def evolution_instruction(
    pauli_list,
    evo_time,
    num_time_slices,
    controlled=False,
    power=1,
    use_basis_gates=True,
    shallow_slicing=False,
    barrier=False,
):
    """"""
    Construct the evolution circuit according to the supplied specification.

    Args:
        pauli_list (list([[complex, Pauli]])): The list of pauli terms corresponding
                                               to a single time slice to be evolved
        evo_time (Union(complex, float, Parameter, ParameterExpression)): The evolution time
        num_time_slices (int): The number of time slices for the expansion
        controlled (bool, optional): Controlled circuit or not
        power (int, optional): The power to which the unitary operator is to be raised
        use_basis_gates (bool, optional): boolean flag for indicating only using basis
                                          gates when building circuit.
        shallow_slicing (bool, optional): boolean flag for indicating using shallow
                                          qc.data reference repetition for slicing
        barrier (bool, optional): whether or not add barrier for every slice

    Returns:
        Instruction: The Instruction corresponding to specified evolution.

    Raises:
        AlgorithmError: power must be an integer and greater or equal to 1
        ValueError: Unrecognized pauli
    """"""

    if not isinstance(power, int) or power < 1:
        raise AlgorithmError(""power must be an integer and greater or equal to 1."")

    state_registers = QuantumRegister(pauli_list[0][1].num_qubits)
    if controlled:
        inst_name = f""Controlled-Evolution^{power}""
        ancillary_registers = QuantumRegister(1)
        qc_slice = QuantumCircuit(state_registers, ancillary_registers, name=inst_name)
    else:
        inst_name = f""Evolution^{power}""
        qc_slice = QuantumCircuit(state_registers, name=inst_name)

    # for each pauli [IXYZ]+, record the list of qubit pairs needing CX's
    cnot_qubit_pairs = [None] * len(pauli_list)
    # for each pauli [IXYZ]+, record the highest index of the nontrivial pauli gate (X,Y, or Z)
    top_xyz_pauli_indices = [-1] * len(pauli_list)

    for pauli_idx, pauli in enumerate(reversed(pauli_list)):
        n_qubits = pauli[1].num_qubits
        # changes bases if necessary
        nontrivial_pauli_indices = []
        for qubit_idx in range(n_qubits):
            # pauli I
            if not pauli[1].z[qubit_idx] and not pauli[1].x[qubit_idx]:
                continue

            if cnot_qubit_pairs[pauli_idx] is None:
                nontrivial_pauli_indices.append(qubit_idx)

            if pauli[1].x[qubit_idx]:
                # pauli X
                if not pauli[1].z[qubit_idx]:
                    if use_basis_gates:
                        qc_slice.h(state_registers[qubit_idx])
                    else:
                        qc_slice.h(state_registers[qubit_idx])
                # pauli Y
                elif pauli[1].z[qubit_idx]:
                    if use_basis_gates:
                        qc_slice.u(pi / 2, -pi / 2, pi / 2, state_registers[qubit_idx])
                    else:
                        qc_slice.rx(pi / 2, state_registers[qubit_idx])
            # pauli Z
            elif pauli[1].z[qubit_idx] and not pauli[1].x[qubit_idx]:
                pass
            else:
                raise ValueError(f""Unrecognized pauli: {pauli[1]}"")

        if nontrivial_pauli_indices:
            top_xyz_pauli_indices[pauli_idx] = nontrivial_pauli_indices[-1]

        # insert lhs cnot gates
        if cnot_qubit_pairs[pauli_idx] is None:
            cnot_qubit_pairs[pauli_idx] = list(
                zip(
                    sorted(nontrivial_pauli_indices)[:-1],
                    sorted(nontrivial_pauli_indices)[1:],
                )
            )

        for pair in cnot_qubit_pairs[pauli_idx]:
            qc_slice.cx(state_registers[pair[0]], state_registers[pair[1]])

        # insert Rz gate
        if top_xyz_pauli_indices[pauli_idx] >= 0:

            # Because Parameter does not support complexity number operation; thus, we do
            # the following tricks to generate parameterized instruction.
            # We assume the coefficient in the pauli is always real. and can not do imaginary time
            # evolution
            if isinstance(evo_time, (Parameter, ParameterExpression)):
                lam = 2.0 * pauli[0] / num_time_slices
                lam = lam.real if lam.imag == 0 else lam
                lam = lam * evo_time
            else:
                lam = (2.0 * pauli[0] * evo_time / num_time_slices).real

            if not controlled:
                if use_basis_gates:
                    qc_slice.p(lam, state_registers[top_xyz_pauli_indices[pauli_idx]])
                else:
                    qc_slice.rz(lam, state_registers[top_xyz_pauli_indices[pauli_idx]])
            else:
                if use_basis_gates:
                    qc_slice.p(
                        lam / 2, state_registers[top_xyz_pauli_indices[pauli_idx]]
                    )
                    qc_slice.cx(
                        ancillary_registers[0],
                        state_registers[top_xyz_pauli_indices[pauli_idx]],
                    )
                    qc_slice.p(
                        -lam / 2, state_registers[top_xyz_pauli_indices[pauli_idx]]
                    )
                    qc_slice.cx(
                        ancillary_registers[0],
                        state_registers[top_xyz_pauli_indices[pauli_idx]],
                    )
                else:
                    qc_slice.crz(
                        lam,
                        ancillary_registers[0],
                        state_registers[top_xyz_pauli_indices[pauli_idx]],
                    )

        # insert rhs cnot gates
        for pair in reversed(cnot_qubit_pairs[pauli_idx]):
            qc_slice.cx(state_registers[pair[0]], state_registers[pair[1]])

        # revert bases if necessary
        for qubit_idx in range(n_qubits):
            if pauli[1].x[qubit_idx]:
                # pauli X
                if not pauli[1].z[qubit_idx]:
                    if use_basis_gates:
                        qc_slice.h(state_registers[qubit_idx])
                    else:
                        qc_slice.h(state_registers[qubit_idx])
                # pauli Y
                elif pauli[1].z[qubit_idx]:
                    if use_basis_gates:
                        qc_slice.u(-pi / 2, -pi / 2, pi / 2, state_registers[qubit_idx])
                    else:
                        qc_slice.rx(-pi / 2, state_registers[qubit_idx])
    # repeat the slice
    if shallow_slicing:
        logger.info(
            ""Under shallow slicing mode, the qc.data reference is repeated shallowly. ""
            ""Thus, changing gates of one slice of the output circuit might affect ""
            ""other slices.""
        )
        if barrier:
            qc_slice.barrier(state_registers)
        qc_slice.data *= num_time_slices * power
        qc = qc_slice
    else:
        qc = QuantumCircuit(*qc_slice.qregs, name=inst_name)
        for _ in range(num_time_slices * power):
            qc.append(qc_slice, qc.qubits)
            if barrier:
                qc.barrier(state_registers)
    return qc.to_instruction()
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2019, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

""""""Test JKU backend.""""""

from qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit import execute
from qiskit_jku_provider import QasmSimulator

from .common import QiskitTestCase


class JKUBackendTestCase(QiskitTestCase):
    """"""Tests for the JKU backend.""""""

    def setUp(self):
        super().setUp()
        self.backend = QasmSimulator(silent=True)

    def test_configuration(self):
        """"""Test backend.configuration().""""""
        configuration = self.backend.configuration()
        return configuration

    def test_properties(self):
        """"""Test backend.properties().""""""
        properties = self.backend.properties()
        self.assertEqual(properties, None)

    def test_status(self):
        """"""Test backend.status().""""""
        status = self.backend.status()
        return status

    def test_run_circuit(self):
        """"""Test running a single circuit.""""""
        result = execute(bell(), self.backend, seed_transpiler=34342).result()
        self.assertEqual(result.success, True)
        return result


def bell():
    """"""Return a Bell circuit.""""""
    qr = QuantumRegister(2, name='qr')
    cr = ClassicalRegister(2, name='qc')
    qc = QuantumCircuit(qr, cr, name='bell')
    qc.h(qr[0])
    qc.cx(qr[0], qr[1])
    qc.measure(qr, cr)
    return qc
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2018, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

# pylint: disable=missing-docstring,broad-except

import unittest
from qiskit import QuantumCircuit, QuantumRegister
from qiskit import execute

from .common import QiskitTestCase
from qiskit_jku_provider import QasmSimulator


class JKUSnapshotTest(QiskitTestCase):
    """"""Test JKU's statevector return capatbilities.""""""

    def setUp(self):
        super().setUp()
        self.backend = QasmSimulator(silent=True)
        qr = QuantumRegister(2)
        self.q_circuit = QuantumCircuit(qr)
        self.q_circuit.h(qr[0])
        self.q_circuit.cx(qr[0], qr[1])

    def test_statevector_output(self):
        """"""Test final state vector for single circuit run.""""""
        result = execute(self.q_circuit, backend=self.backend).result()
        self.assertEqual(result.success, True)
        actual = result.get_statevector(self.q_circuit)

        # state is 1/sqrt(2)|00> + 1/sqrt(2)|11>, up to a global phase
        self.assertAlmostEqual((abs(actual[0]))**2, 1/2, places=5)
        self.assertEqual(actual[1], 0)
        self.assertEqual(actual[2], 0)
        self.assertAlmostEqual((abs(actual[3]))**2, 1/2, places=5)


if __name__ == '__main__':
    unittest.main()
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2018, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

# pylint: disable=unused-import
# pylint: disable=redefined-builtin

""""""Test Qiskit's QuantumCircuit class for multiple registers.""""""

from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit import execute
from qiskit.quantum_info import state_fidelity, basis_state
from qiskit.test import QiskitTestCase
from qiskit_jku_provider import QasmSimulator


class TestCircuitMultiRegs(QiskitTestCase):
    """"""QuantumCircuit Qasm tests.""""""

    def test_circuit_multi(self):
        """"""Test circuit multi regs declared at start.
        """"""
        qreg0 = QuantumRegister(2, 'q0')
        creg0 = ClassicalRegister(2, 'c0')
        qreg1 = QuantumRegister(2, 'q1')
        creg1 = ClassicalRegister(2, 'c1')
        circ = QuantumCircuit(qreg0, qreg1)
        circ.x(qreg0[1])
        circ.x(qreg1[0])

        meas = QuantumCircuit(qreg0, qreg1, creg0, creg1)
        meas.measure(qreg0, creg0)
        meas.measure(qreg1, creg1)

        qc = circ + meas

        backend_sim = QasmSimulator(silent=True)

        result = execute(qc, backend_sim, seed_transpiler=34342).result()
        counts = result.get_counts(qc)

        target = {'01 10': 1024}

        result = execute(circ, backend_sim, seed_transpiler=3438).result()
        state = result.get_statevector(circ)

        self.assertEqual(counts, target)
        self.assertAlmostEqual(state_fidelity(basis_state('0110', 4), state), 1.0, places=7)
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2017, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

# pylint: disable=missing-docstring,redefined-builtin

import unittest
import os
from qiskit import QuantumCircuit
from .common import QiskitTestCase
from qiskit_jku_provider import QasmSimulator
from qiskit import execute


class TestQasmSimulatorJKUBasic(QiskitTestCase):
    """"""Runs the Basic qasm_simulator tests from Terra on JKU.""""""

    def setUp(self):
        self.seed = 88
        self.backend = QasmSimulator(silent=True)
        qasm_filename = os.path.join(os.path.dirname(__file__), 'qasms', 'example.qasm')
        compiled_circuit = QuantumCircuit.from_qasm_file(qasm_filename)
        compiled_circuit.name = 'test'
        self.circuit = compiled_circuit

    def test_qasm_simulator_single_shot(self):
        """"""Test single shot run.""""""
        result = execute(self.circuit, self.backend, seed_transpiler=34342, shots=1).result()
        self.assertEqual(result.success, True)

    def test_qasm_simulator(self):
        """"""Test data counts output for single circuit run against reference.""""""
        shots = 1024
        result = execute(self.circuit, self.backend, seed_transpiler=34342, shots=shots).result()
        threshold = 0.04 * shots
        counts = result.get_counts('test')
        target = {'100 100': shots / 8, '011 011': shots / 8,
                  '101 101': shots / 8, '111 111': shots / 8,
                  '000 000': shots / 8, '010 010': shots / 8,
                  '110 110': shots / 8, '001 001': shots / 8}
        self.assertDictAlmostEqual(counts, target, threshold)


if __name__ == '__main__':
    unittest.main()
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2018, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

import random
import unittest

import numpy
from scipy.stats import chi2_contingency

from qiskit import execute
from qiskit import QuantumCircuit
from qiskit import QuantumRegister
from qiskit import ClassicalRegister
from qiskit import BasicAer
from qiskit_jku_provider import QasmSimulator

try:
    global_pq_simulator = QasmSimulator(silent=True)
except ImportError:
    _skip_class = True
else:
    _skip_class = False


from ._random_circuit_generator import RandomCircuitGenerator
from .common import QiskitTestCase


@unittest.skipIf(_skip_class, 'JKU C++ simulator unavailable')
class TestQasmSimulatorJKU(QiskitTestCase):
    """"""
    Test JKU simulator.
    """"""

    # noinspection PyPep8Naming
    @classmethod
    def setUpClass(cls):
        super().setUpClass()

        # Set up random circuits
        n_circuits = 20
        min_depth = 1
        max_depth = 50
        min_qubits = 1
        max_qubits = 4
        random_circuits = RandomCircuitGenerator(min_qubits=min_qubits,
                                                 max_qubits=max_qubits,
                                                 min_depth=min_depth,
                                                 max_depth=max_depth,
                                                 seed=None)
        for _ in range(n_circuits):
            basis = list(random.sample(random_circuits.op_signature.keys(),
                                       random.randint(2, 7)))
            if 'reset' in basis:
                basis.remove('reset')
            if 'u0' in basis:
                basis.remove('u0')
            if 'measure' in basis:
                basis.remove('measure')
            random_circuits.add_circuits(1, basis=basis)
        cls.rqg = random_circuits

    def run_on_simulators(self, qc, pq_simulator, qk_simulator, shots, seed):
        job_pq = execute(qc, pq_simulator, shots=shots, seed_simulator=seed)
        job_qk = execute(qc, qk_simulator, shots=shots, seed_simulator=seed)
        counts_pq = job_pq.result().get_counts()
        counts_qk = job_qk.result().get_counts()
        states = counts_qk.keys() | counts_pq.keys()
        # contingency table
        ctable = numpy.array([[counts_pq.get(key, 0) for key in states],
                              [counts_qk.get(key, 0) for key in states]])
        result = chi2_contingency(ctable)
        return counts_pq, counts_qk, result

    def test_gate_x(self):
        shots = 100
        qr = QuantumRegister(1)
        cr = ClassicalRegister(1)
        qc = QuantumCircuit(qr, cr, name='test_gate_x')
        qc.x(qr[0])
        qc.measure(qr, cr)
        job = execute(qc, global_pq_simulator, shots=shots)
        result_pq = job.result(timeout=30)
        self.assertEqual(result_pq.get_counts(),
                         {'1': shots})

    def test_entangle(self):
        shots = 100
        N = 5
        qr = QuantumRegister(N)
        cr = ClassicalRegister(N)
        qc = QuantumCircuit(qr, cr, name='test_entangle')

        qc.h(qr[0])
        for i in range(1, N):
            qc.cx(qr[0], qr[i])
        qc.measure(qr, cr)
        timeout = 30
        job = execute(qc, global_pq_simulator, shots=shots)
        result = job.result(timeout=timeout)
        counts = result.get_counts()
        self.log.info(counts)
        for key, _ in counts.items():
            with self.subTest(key=key):
                self.assertTrue(key in ['0' * N, '1' * N])

    def test_output_style(self):
        qk_simulator = BasicAer.get_backend('qasm_simulator', )

        qr = QuantumRegister(2)
        cr = ClassicalRegister(2)
        qc = QuantumCircuit(qr, cr, name='test_output_order')
        qc.h(qr[0])
        qc.measure(qr[0], cr[0])
        qc.measure(qr[1], cr[1])
        shots = 100

        counts_pq, counts_qk, result = self.run_on_simulators(qc, global_pq_simulator,
                                                              qk_simulator, shots=shots, seed=1)
        self.assertGreater(result[1], 0.01)

        cr1 = ClassicalRegister(1)
        cr2 = ClassicalRegister(1)
        qc = QuantumCircuit(qr, cr1, cr2, name='test_output_separation')
        qc.h(qr[0])
        qc.measure(qr[0], cr1[0])
        qc.measure(qr[1], cr2[0])

        counts_pq, counts_qk, result = self.run_on_simulators(qc, global_pq_simulator,
                                                              qk_simulator, shots=shots, seed=1)
        self.log.info('chi2_contingency: %s', str(result))
        self.assertGreater(result[1], 0.01)

    def test_random_circuits(self):
        qk_simulator = BasicAer.get_backend('qasm_simulator', )
        for circuit in self.rqg.get_circuits(format_='QuantumCircuit'):
            self.log.info(circuit.qasm())
            shots = 100
            job_pq = execute(circuit, global_pq_simulator, shots=shots, seed_simulator=1)
            job_qk = execute(circuit, qk_simulator, shots=shots, seed_simulator=1)
            result_pq = job_pq.result()
            result_qk = job_qk.result()
            counts_pq = result_pq.get_counts()
            counts_qk = result_qk.get_counts()
            self.log.info('local_qasm_simulator_jku: %s', str(counts_pq))
            self.log.info('local_qasm_simulator: %s', str(counts_qk))
            states = counts_qk.keys() | counts_pq.keys()
            # contingency table
            ctable = numpy.array([[counts_pq.get(key, 0) for key in states],
                                  [counts_qk.get(key, 0) for key in states]])
            result = chi2_contingency(ctable)
            self.log.info('chi2_contingency: %s', str(result))
            with self.subTest(circuit=circuit):
                self.assertGreater(result[1], 0.01)


if __name__ == '__main__':
    unittest.main(verbosity=2)
"
https://github.com/qiskit-community/qiskit-jku-provider,qiskit-community,"# -*- coding: utf-8 -*-

# Copyright 2017, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

""""""Generate random circuits.""""""

import random

import numpy

from qiskit import (qasm, ClassicalRegister, QuantumCircuit,
                    QuantumRegister)


def choices(population, weights=None, k=1):
    """"""
    Replacement for `random.choices()`, which is only available in Python 3.6+.
    TODO: drop once Python 3.6 is required by the sdk.
    """"""
    if weights and sum(weights) != 1:
        # Normalize the weights if needed, as numpy.random.choice requires so.
        weights = [float(i)/sum(weights) for i in weights]

    return numpy.random.choice(population, size=k, p=weights)


class RandomCircuitGenerator(object):
    """"""
    Generate random size circuits for profiling.
    """"""
    def __init__(self, seed=None,
                 max_qubits=5, min_qubits=1,
                 max_depth=100, min_depth=1):
        """"""
        Args:
          seed (int): Random number seed. If none, don't seed the generator.
          max_qubits (int): Maximum number of qubits in a circuit.
          min_qubits (int): Minimum number of operations in a cirucit.
          max_depth (int): Maximum number of operations in a circuit.
          min_depth (int): Minimum number of operations in circuit.
        """"""
        self.max_depth = max_depth
        self.max_qubits = max_qubits
        self.min_depth = min_depth
        self.min_qubits = min_qubits
        self.circuit_list = []
        self.n_qubit_list = []
        self.depth_list = []
        self.basis_gates = None
        self.circuit_name_list = []
        if seed is not None:
            random.seed(a=seed)
        # specify number of parameters and args for each op
        # in the standard extension. If type hints (PEP484) are followed
        # maybe we can guess this. ""nregs"" are the number of qubits the
        # operation uses. If nregs=0 then it means either 1 qubit or
        # 1 register. ""nparams"" are the number of parameters the operation takes.
        self.op_signature = {
            'barrier': {'nregs': 0, 'nparams': None},
            'ccx': {'nregs': 3, 'nparams': None},
            'ch': {'nregs': 2, 'nparams': None},
            'crz': {'nregs': 2, 'nparams': 1},
            'cswap': {'nregs': 3, 'nparams': None},
            'cu1': {'nregs': 2, 'nparams': 1},
            'cu3': {'nregs': 2, 'nparams': 3},
            'cx': {'nregs': 2, 'nparams': None},
            'cy': {'nregs': 2, 'nparams': None},
            'cz': {'nregs': 2, 'nparams': None},
            'h': {'nregs': 1, 'nparams': None},
            'iden': {'nregs': 1, 'nparams': None},
            'measure': {'nregs': 0, 'nparams': None},
            'reset': {'nregs': 1, 'nparams': None},
            'rx': {'nregs': 1, 'nparams': 1},
            'ry': {'nregs': 1, 'nparams': 1},
            'rz': {'nregs': 1, 'nparams': 1},
            's': {'nregs': 1, 'nparams': None},
            't': {'nregs': 1, 'nparams': None},
            'u1': {'nregs': 1, 'nparams': 1},
            'u2': {'nregs': 1, 'nparams': 2},
            'u3': {'nregs': 1, 'nparams': 3},
            'x': {'nregs': 1, 'nparams': None},
            'y': {'nregs': 1, 'nparams': None},
            'z': {'nregs': 1, 'nparams': None}}

    def add_circuits(self, n_circuits, do_measure=True, basis=None,
                     basis_weights=None):
        """"""Adds circuits to program.

        Generates a circuit with a random number of operations in `basis`.
        Also adds a random number of measurements in
        [1,nQubits] to end of circuit.

        Args:
            n_circuits (int): Number of circuits to add.
            do_measure (bool): Whether to add measurements.
            basis (list(str) or None): List of op names. If None, basis
                is randomly chosen with unique ops in (2,7)
            basis_weights (list(float) or None): List of weights
                corresponding to indices in `basis`.
        Raises:
            AttributeError: if operation is not recognized.
        """"""
        if basis is None:
            basis = list(random.sample(self.op_signature.keys(),
                                       random.randint(2, 7)))
            basis_weights = [1./len(basis)] * len(basis)
        if basis_weights is not None:
            assert len(basis) == len(basis_weights)
        uop_basis = basis[:]
        if basis_weights:
            uop_basis_weights = basis_weights[:]
        else:
            uop_basis_weights = None
        # remove barrier from uop basis if it is specified
        if 'barrier' in uop_basis:
            ind = uop_basis.index('barrier')
            del uop_basis[ind]
            if uop_basis_weights:
                del uop_basis_weights[ind]
        # remove measure from uop basis if it is specified
        if 'measure' in uop_basis:
            ind = uop_basis.index('measure')
            del uop_basis[ind]
            if uop_basis_weights:
                del uop_basis_weights[ind]
        # self.basis_gates = uop_basis
        self.basis_gates = basis
        self.circuit_name_list = []
        # TODO: replace choices with random.choices() when python 3.6 is
        # required.
        self.n_qubit_list = choices(
            range(self.min_qubits, self.max_qubits + 1), k=n_circuits)
        self.depth_list = choices(
            range(self.min_depth, self.max_depth + 1), k=n_circuits)
        for i_circuit in range(n_circuits):
            n_qubits = self.n_qubit_list[i_circuit]
            if self.min_regs_exceeds_nqubits(uop_basis, n_qubits):
                # no gate operation from this circuit can fit in the available
                # number of qubits.
                continue
            depth_cnt = self.depth_list[i_circuit]
            reg_pop = numpy.arange(1, n_qubits+1)
            register_weights = reg_pop[::-1].astype(float)
            register_weights /= register_weights.sum()
            max_registers = numpy.random.choice(reg_pop, p=register_weights)
            reg_weight = numpy.ones(max_registers) / float(max_registers)
            reg_sizes = rand_register_sizes(n_qubits, reg_weight)
            n_registers = len(reg_sizes)
            circuit = QuantumCircuit()
            for i_size, size in enumerate(reg_sizes):
                cr_name = 'cr' + str(i_size)
                qr_name = 'qr' + str(i_size)
                creg = ClassicalRegister(int(size), cr_name)
                qreg = QuantumRegister(int(size), qr_name)
                circuit.add_register(qreg, creg)
            while depth_cnt > 0:
                # TODO: replace choices with random.choices() when python 3.6
                # is required.
                op_name = choices(basis, weights=basis_weights)[0]
                if hasattr(circuit, op_name):
                    operator = getattr(circuit, op_name)
                else:
                    raise AttributeError('operation \""{0}\""'
                                         ' not recognized'.format(op_name))
                n_regs = self.op_signature[op_name]['nregs']
                n_params = self.op_signature[op_name]['nparams']
                if n_regs == 0:  # this is a barrier or measure
                    n_regs = random.randint(1, n_qubits)
                if n_qubits >= n_regs:
                    # warning: assumes op function signature specifies
                    # op parameters before qubits
                    op_args = []
                    if n_params:
                        op_args = [random.random() for _ in range(n_params)]
                    if op_name == 'measure':
                        # if measure occurs here, assume it's to do a conditional
                        # randomly select a register to measure
                        ireg = random.randint(0, n_registers-1)
                        qr_name = 'qr' + str(ireg)
                        cr_name = 'cr' + str(ireg)
                        qreg = circuit.regs[qr_name]
                        creg = circuit.regs[cr_name]
                        for qind in range(qreg.size):
                            operator(qreg[qind], creg[qind])
                        ifval = random.randint(0, (1 << qreg.size) - 1)
                        # TODO: replace choices with random.choices() when
                        # python 3.6 is required.
                        uop_name = choices(uop_basis, weights=uop_basis_weights)[0]
                        if hasattr(circuit, uop_name):
                            uop = getattr(circuit, uop_name)
                        else:
                            raise AttributeError('operation \""{0}\""'
                                                 ' not recognized'.format(uop_name))
                        unregs = self.op_signature[uop_name]['nregs']
                        unparams = self.op_signature[uop_name]['nparams']
                        if unregs == 0:  # this is a barrier or measure
                            unregs = random.randint(1, n_qubits)
                        if qreg.size >= unregs:
                            qind_list = random.sample(range(qreg.size), unregs)
                            uop_args = []
                            if unparams:
                                uop_args = [random.random() for _ in range(unparams)]
                            uop_args.extend([qreg[qind] for qind in qind_list])
                            uop(*uop_args).c_if(creg, ifval)
                        depth_cnt -= 1
                    elif op_name == 'barrier':
                        ireg = random.randint(0, n_registers-1)
                        qreg = circuit.qregs[ireg]
                        bar_args = [(qreg, mi) for mi in range(qreg.size)]
                        operator(*bar_args)
                    else:
                        # select random register
                        ireg = random.randint(0, n_registers-1)
                        qreg = circuit.qregs[ireg]
                        if qreg.size >= n_regs:
                            qind_list = random.sample(range(qreg.size), n_regs)
                            op_args.extend([qreg[qind] for qind in qind_list])
                            operator(*op_args)
                            depth_cnt -= 1
                        else:
                            break
            nmeasure = random.randint(1, n_qubits)
            m_list = random.sample(range(nmeasure), nmeasure)
            if do_measure:
                for qind in m_list:
                    rind = 0  # register index
                    cumtot = 0
                    while qind >= cumtot + circuit.qregs[rind].size:
                        cumtot += circuit.qregs[rind].size
                        rind += 1
                    qrind = int(qind - cumtot)
                    qreg = circuit.qregs[rind]
                    creg = circuit.cregs[rind]
                    circuit.measure(qreg[qrind], creg[qrind])
            self.circuit_list.append(circuit)

    def min_regs_exceeds_nqubits(self, basis, n_qubits):
        """"""Check whether the minimum number of qubits used by the operations
        in basis is between 1 and the number of qubits.

        Args:
            basis (list): list of basis names
            n_qubits (int): number of qubits in circuit
        Returns:
            boolean: result of the check.
        """"""
        return not any((n_qubits >= self.op_signature[opName]['nregs'] > 0
                        for opName in basis))

    def get_circuits(self, format_='QuantumCircuit'):
        """"""Get the compiled circuits generated.

        Args:
            format_ (str, optional): ""qasm"" | ""qobj"" | ""QuantumCircuit""

        Returns:
           list: List of Compiled QuantumCircuit objects.

        Raises:
            NameError: if the output format is not valid.
        """"""
        if format_ == 'qasm':
            qasm_list = []
            for circuit in self.circuit_list:
                qasm_list.append(circuit.qasm())
            return qasm_list
        elif format_ == 'QuantumCircuit':
            qc_list = []
            for circuit in self.circuit_list:
                qc_list.append(circuit)
            return qc_list
        else:
            raise NameError('Unrecognized circuit output format: ""{}""'.format(
                format_))


def rand_register_sizes(n_registers, pvals):
    """"""Return a randomly chosen list of nRegisters summing to nQubits.""""""
    vector = numpy.random.multinomial(n_registers, pvals)
    return vector[vector.nonzero()]
"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"from dell_runtime import DellRuntimeProvider
from qiskit import QuantumCircuit
import os

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

# PROGRAM_PREFIX = 'qiskit-test'

def main():
    provider = DellRuntimeProvider()
    here = os.path.dirname(os.path.realpath(__file__))
    program_id = provider.runtime.upload_program(here + ""/dirtest"", metadata=RUNTIME_PROGRAM_METADATA)
    
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure([0, 1], [0, 1])

    program_inputs = {
        'circuits': qc,
    }

    job = provider.runtime.run(program_id, options=None, inputs=program_inputs)

    job.result(timeout=120)
    

if __name__ == ""__main__"":
    main()
"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017, 2018.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
# Copyright 2021 Dell (www.dell.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from dell_runtime.emulator_runtime_job import EmulatorRuntimeJob
import unittest
from qiskit import QuantumCircuit, execute, transpile
from dell_runtime import DellRuntimeProvider
from qiskit.providers import JobStatus
from time import sleep
import os
import logging
import json
import requests
from urllib.parse import urljoin
from qiskit.providers.ibmq.runtime.utils import RuntimeDecoder

logger = logging.getLogger(__name__)

RUNTIME_PROGRAM = """"""
from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    **kwargs,
):

    user_messenger.publish({'results': 'intermittently'})

    circuits = transpile(
        circuits,
    )

    if not isinstance(circuits, list):
        circuits = [circuits]

    # Compute raw results
    result = backend.run(circuits, **kwargs).result()

    user_messenger.publish({'results': 'finally'})
    user_messenger.publish(result.to_dict(), final=True)
    print(""job complete successfully"")
""""""

FAIL_PROGRAM = """"""
from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    **kwargs,
):

    raise Exception('test failure')
""""""

VQE_PROGRAM = """"""
from qiskit import Aer
from qiskit.opflow import X, Z, I
from qiskit.utils import QuantumInstance, algorithm_globals
from qiskit.providers.ibmq.runtime.utils import RuntimeEncoder
from qiskit.algorithms import VQE
from qiskit.algorithms.optimizers import SLSQP
from qiskit.circuit.library import TwoLocal
import json

def result_to_jsonstr(res):
    resd = {}
    resd['eigenvalue'] = res.eigenvalue
    resd['opt_time'] = res.optimizer_time
    return json.dumps(resd, cls=RuntimeEncoder)

def main(backend, user_messenger, **kwargs):
    H2_op = (-1.052373245772859 * I ^ I) + \
            (0.39793742484318045 * I ^ Z) + \
            (-0.39793742484318045 * Z ^ I) + \
            (-0.01128010425623538 * Z ^ Z) + \
            (0.18093119978423156 * X ^ X)

#     seed = random.randint(0, 1000)
#     print(seed)
    seed = kwargs['seed']
    algorithm_globals.random_seed = seed
    qi = QuantumInstance(backend, seed_transpiler=seed, seed_simulator=seed, shots=kwargs['shots'])
    ansatz = TwoLocal(rotation_blocks='ry', entanglement_blocks='cz')
    slsqp = SLSQP(maxiter=1000)
    vqe = VQE(ansatz, optimizer=slsqp, quantum_instance=qi, include_custom=kwargs['include_custom'])
    result = vqe.compute_minimum_eigenvalue(operator=H2_op)

    result = result_to_jsonstr(result)

    user_messenger.publish(result, final=True)
""""""

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

PROGRAM_PREFIX = 'qiskit-test'

SERVER_URL = os.getenv('SERVER_URL')

class AcceptanceTest(unittest.TestCase):
    def test_circuit_runner(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        # program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
        
    def test_remote_fail(self):
        exc = False
        try:
            provider = DellRuntimeProvider()
            provider.remote(""http://thisurldoesntexist.com"")
        except Exception:
            exc = True
        self.assertTrue(exc)

    def test_upload(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
        proglist = provider.runtime.programs()
        self.assertIsNotNone(proglist[program_id])
        findProgId = False
        logger.debug(proglist)
        if program_id in proglist:
            findProgId = True
        self.assertTrue(findProgId)

    def test_view_program(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)

        runtime_program = provider.runtime.program(program_id)
        self.assertEqual(runtime_program.description, ""Qiskit test program"")
        self.assertEqual(runtime_program.program_id, program_id)

    def test_view_program_refresh(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
        prog_list = provider.runtime.programs(refresh=False)

        self.assertTrue(len(prog_list) >= 1)

        new_program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
        new_prog_list = provider.runtime.programs(refresh=False)
        
        self.assertEqual(len(prog_list), len(new_prog_list))

        newnew_prog_list = provider.runtime.programs(refresh=True)

        self.assertGreater(len(newnew_prog_list), len(prog_list))

    def test_run_program(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        self.assertEqual(job.host, SERVER_URL)
    
    def test_get_results(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        # runtime_program = provider.runtime.program(program_id)
        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        response = job.result(timeout=180)
        logger.debug(""through"")
        # print(json.dumps(results))
        # results['results'] = json.loads(results['results'])

        results = response['results'][0]

        self.assertIsNotNone(results)
        self.assertTrue(results['success'])
        self.assertTrue(results['success'])
        self.assertEqual(""DONE"", results['status'])

        shots = results['shots']
        count = results['data']['counts']['0x0']

        self.assertGreater(count, (0.45 * shots))
        self.assertLess(count, (0.55 * shots))

    def test_delete_program(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
        prog_list = provider.runtime.programs(refresh=False)

        self.assertTrue(len(prog_list) >= 1)

        deleted = provider.runtime.delete_program(program_id)

        self.assertTrue(deleted)

        new_prog_list = provider.runtime.programs(refresh=True)
        
        self.assertGreater(len(prog_list), len(new_prog_list))

    def test_update_program(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)

        new_meta = {'description': 'Qiskit Test Update', 'max_execution_time': RUNTIME_PROGRAM_METADATA['max_execution_time']}

        updated = provider.runtime.update_program(program_id, name='Test Update', metadata=new_meta)

        self.assertTrue(updated)

        program2 = provider.runtime.program(program_id, refresh=True)

        self.assertEqual('Qiskit Test Update', program2.description)
        self.assertEqual('Test Update', program2.name)

    def test_intermittent_results(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        # runtime_program = provider.runtime.program(program_id)
        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        
        result = job.result(timeout=120)
        messages = job.get_unread_messages()
        logger.debug(f'unread messages {messages}')
            
        self.assertEqual(len(messages), 2)
        self.assertEqual(""intermittently"", messages[0]['results'])
        self.assertEqual(""finally"", messages[1]['results'])

        messages = job.get_unread_messages()
        
        self.assertEqual(0, len(messages))

    def test_get_status(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        # runtime_program = provider.runtime.program(program_id)
        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        status = job.status()
        correct_status = status == ""Creating"" or status == ""Pending"" or status == ""Running""
        self.assertTrue(correct_status)
        job.result(timeout=120)
        status = job.status()
        self.assertEqual(status, ""Completed"")

    def test_get_failed_status(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(FAIL_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)

        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        status = job.status()
        self.assertTrue(status == ""Creating"" or status == ""Pending"")
        
        while status == ""Running"" or status == ""Creating"" or status == ""Pending"":
            status = job.status()
            sleep(5)

        self.assertEqual(status, ""Failed"")

    def test_cancel_job(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        # runtime_program = provider.runtime.program(program_id)
        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        res = job.cancel()
        self.assertTrue(res)

        status = job.status()
        self.assertEqual(status, ""Canceled"")
    def test_pprint_programs(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        self.assertIsNotNone(provider)
        self.assertIsNotNone(provider.runtime)

        pr_id_1 = provider.runtime.upload_program(""fake-program1"", metadata=RUNTIME_PROGRAM_METADATA)
        import sys
        import io
        old_stdout = sys.stdout
        new_stdout = io.StringIO()
        sys.stdout = new_stdout
        provider.runtime.pprint_programs()
        output = new_stdout.getvalue()
        sys.stdout = old_stdout
        print(output)
        self.assertTrue(
        '''==================================================
{}:
  Name: {}'''.format(pr_id_1,pr_id_1)
         in output)


    def test_dir_circuit_runner(self):
        from . import dir_circuit_runner as dcr
        try:
            dcr.main()
        except Exception as e:
            self.fail(""should pass"")

    def test_upload_file(self):
        provider = DellRuntimeProvider()
        self.assertIsNotNone(provider)
        self.assertIsNotNone(provider.runtime)

        here = os.path.dirname(os.path.realpath(__file__))
        provider.remote(SERVER_URL)

        program_id = provider.runtime.upload_program(here + ""/program.py"", metadata=RUNTIME_PROGRAM_METADATA)
        self.assertGreaterEqual(len(provider.runtime.programs()), 1)

        runtime_program = provider.runtime.program(program_id)
        self.assertIsNotNone(runtime_program)
        try:
            qc = QuantumCircuit(2, 2)
            qc.h(0)
            qc.cx(0, 1)
            qc.measure([0, 1], [0, 1])

            program_inputs = {
                'circuits': qc,
            }

            job = provider.runtime.run(program_id, options=None, inputs=program_inputs)

            result = job.result(timeout=90)
            self.assertIsNotNone(result)

        except Exception:
            self.fail(""should pass"")

    def test_reserved_names(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)

        try:
            here = os.path.dirname(os.path.realpath(__file__))
            program_id = provider.runtime.upload_program(here + ""/dirfail/"", metadata=RUNTIME_PROGRAM_METADATA)
            self.fail(""Should not allow upload"")
        except Exception:
            self.assertTrue(True)

    def test_large_directory(self):
        
        provider = DellRuntimeProvider()

        provider.remote(SERVER_URL)
        here = os.path.dirname(os.path.realpath(__file__))
        program_id = provider.runtime.upload_program(here + ""/qkad"", metadata=RUNTIME_PROGRAM_METADATA)

        job = provider.runtime.run(program_id, options=None, inputs={'garbage': 'nonsense'})

        res = job.result(timeout=600)
        self.assertTrue(""aligned_kernel_parameters"" in res)
        self.assertTrue(""aligned_kernel_matrix"" in res)

    def test_callback_function(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        
        import sys
        import io
        old_stdout = sys.stdout
        new_stdout = io.StringIO()
        sys.stdout = new_stdout
        job = provider.runtime.run(program_id, options=None, inputs=program_inputs,callback=print)
        result =job.result(timeout=120)
        output = new_stdout.getvalue()
        sys.stdout = old_stdout
        
        print(output)
        self.assertTrue(""{'results': 'intermittently'}"" in output)
    
    def test_reconnect(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        del(provider)

        # delete session and sign back in via SSO
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)

        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)

        response = job.result(timeout=120)
        logger.debug(""through"")


        results = response['results'][0]

        self.assertIsNotNone(results)
        self.assertTrue(results['success'])
        self.assertTrue(results['success'])
        self.assertEqual(""DONE"", results['status'])

        shots = results['shots']
        count = results['data']['counts']['0x0']

        self.assertGreater(count, (0.45 * shots))
        self.assertLess(count, (0.55 * shots))

    def test_data_security(self):
        provider = DellRuntimeProvider()
        provider.remote(SERVER_URL)
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)

        url = urljoin(SERVER_URL, f'/program/{program_id}/data')
        res = requests.get(url)
        
        self.assertEqual(res.text, ""Id and token not presented"")
        self.assertEqual(res.status_code, 401)

    def test_block_nonsso_on_sso_server(self):
        res = requests.get(urljoin(SERVER_URL, '/sso_enabled'))
        sso_enabled = json.loads(res.text)
        if sso_enabled:
            url = urljoin(SERVER_URL, '/new_user')
            res = requests.get(url)
            self.assertEqual(res.status_code, 401)

            url = urljoin(SERVER_URL, '/existing_user/2187121124')
            res = requests.get(url)
            self.assertEqual(res.status_code, 401) 

    def test_block_sso_on_nonsso_server(self):
        res = requests.get(urljoin(SERVER_URL, '/sso_enabled'))
        sso_enabled = json.loads(res.text)
        if not sso_enabled:
            url = urljoin(SERVER_URL, '/login')
            res = requests.get(url)
            self.assertEqual(res.status_code, 401)

            url = urljoin(SERVER_URL, '/authenticate')
            res = requests.post(url)
            self.assertEqual(res.status_code, 401)


            url = urljoin(SERVER_URL, '/tokeninfo/109129612')
            res = requests.get(url)
            self.assertEqual(res.status_code, 401)


            url = urljoin(SERVER_URL, '/callback')
            res = requests.get(url)
            self.assertEqual(res.status_code, 401)

    def test_vqe_emulation(self):
        vqe_inputs = {
            'shots': 2,
            'seed': 10,
            'include_custom': True
        }

        provider = DellRuntimeProvider()
        provider.remote(os.getenv(""SERVER_URL""))

        program_id = provider.runtime.upload_program(VQE_PROGRAM)

        job = provider.runtime.run(
            program_id=program_id,
            inputs=vqe_inputs,
            options=None)
            
        # result = job.result()

        result = job.result(timeout=100)
        
        result = json.loads(job.result(), cls=RuntimeDecoder)

        self.assertEqual(-1.8572748921516753, result['eigenvalue'])
        self.assertLessEqual(result['opt_time'], 0.4)"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Test QRAO steps on various hardware and simulator backends""""""

import pytest

from docplex.mp.model import Model

from qiskit.utils import QuantumInstance
from qiskit.algorithms.minimum_eigen_solvers import VQE
from qiskit.circuit.library import RealAmplitudes
from qiskit.algorithms.optimizers import SPSA
from qiskit import BasicAer
from qiskit_aer import Aer
from qiskit_optimization.algorithms import OptimizationResultStatus
from qiskit_optimization.translators import from_docplex_mp
from qiskit_ibm_provider import IBMProvider, least_busy, IBMAccountError

from qrao import (
    QuantumRandomAccessOptimizer,
    QuantumRandomAccessEncoding,
    MagicRounding,
)

# pylint: disable=redefined-outer-name

# TODO:
# - update these tests to include solution checking once behavior can be made
# - deterministic.
#    - This might just require us to set seeds in the QuantumInstance and
#    - remove that as an argument altogether.

backends = [
    (BasicAer.get_backend, ""qasm_simulator""),
    (Aer.get_backend, ""qasm_simulator""),
    (Aer.get_backend, ""statevector_simulator""),
    (Aer.get_backend, ""aer_simulator""),
    (Aer.get_backend, ""aer_simulator_statevector""),
    (Aer.get_backend, ""aer_simulator_density_matrix""),
    (Aer.get_backend, ""aer_simulator_matrix_product_state""),
    # The following takes forever, haven't yet waited long enough to know the
    # real timescale
    # (Aer.get_backend, ""aer_simulator_extended_stabilizer""),
]


@pytest.fixture(scope=""module"")
def my_encoding():
    """"""Fixture to construct ``my_encoding`` for use in this file""""""
    # Load small reference problem
    elist = [(0, 1), (0, 4), (0, 3), (1, 2), (1, 5), (2, 3), (2, 4), (4, 5), (5, 3)]
    num_nodes = 6
    mod = Model(""maxcut"")
    nodes = list(range(num_nodes))
    var = [mod.binary_var(name=""x"" + str(i)) for i in nodes]
    mod.maximize(mod.sum((var[i] + var[j] - 2 * var[i] * var[j]) for i, j in elist))
    problem = from_docplex_mp(mod)
    encoding = QuantumRandomAccessEncoding(max_vars_per_qubit=3)
    encoding.encode(problem)
    return encoding


@pytest.fixture(scope=""module"")
def my_ansatz(my_encoding):
    """"""Fixture to construct ``my_ansatz`` for use in this file""""""
    return RealAmplitudes(my_encoding.num_qubits)


@pytest.mark.parametrize(""relaxed_backend"", backends)
@pytest.mark.parametrize(""rounding_backend"", backends)
@pytest.mark.filterwarnings(""ignore::PendingDeprecationWarning"")
@pytest.mark.filterwarnings(
    ""ignore:.*statevector_simulator.*:UserWarning""
)  # ignore magic rounding's UserWarning when using statevector_simulator
@pytest.mark.backend
def test_backend(relaxed_backend, rounding_backend, my_encoding, my_ansatz, shots=3):
    """"""Smoke test of each backend combination""""""

    def cb(f, *args):
        ""Construct backend""
        return f(*args)

    relaxed_qi = QuantumInstance(backend=cb(*relaxed_backend), shots=shots)
    rounding_qi = QuantumInstance(backend=cb(*rounding_backend), shots=shots)
    vqe = VQE(
        ansatz=my_ansatz,
        optimizer=SPSA(maxiter=1, learning_rate=0.01, perturbation=0.1),
        quantum_instance=relaxed_qi,
    )
    rounding_scheme = MagicRounding(rounding_qi)
    qrao = QuantumRandomAccessOptimizer(
        encoding=my_encoding, min_eigen_solver=vqe, rounding_scheme=rounding_scheme
    )
    result = qrao.solve()
    assert result.status == OptimizationResultStatus.SUCCESS


@pytest.mark.backend
def test_magic_rounding_on_hardware_backend(my_encoding, my_ansatz):
    """"""Test *magic rounding* on a hardware backend, if available.""""""
    try:
        provider = IBMProvider()
    except IBMAccountError:
        pytest.skip(""No hardware backend available"")
    print(f""Encoding requires {my_encoding.num_qubits} qubits"")
    backend = least_busy(
        provider.backends(
            min_num_qubits=my_encoding.num_qubits,
            simulator=False,
            operational=True,
        )
    )
    print(f""Using backend: {backend}"")
    relaxed_qi = QuantumInstance(backend=Aer.get_backend(""aer_simulator""), shots=100)
    rounding_qi = QuantumInstance(backend=backend, shots=32)
    vqe = VQE(
        ansatz=my_ansatz,
        optimizer=SPSA(maxiter=1, learning_rate=0.01, perturbation=0.1),
        quantum_instance=relaxed_qi,
    )
    rounding_scheme = MagicRounding(quantum_instance=rounding_qi)
    qrao = QuantumRandomAccessOptimizer(
        encoding=my_encoding, min_eigen_solver=vqe, rounding_scheme=rounding_scheme
    )
    result = qrao.solve()
    assert result.status == OptimizationResultStatus.SUCCESS
"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""The FeatureMap class.""""""

import json

import numpy as np

from qiskit import QuantumCircuit, QuantumRegister


class FeatureMap:
    """"""Mapping data with the feature map.""""""

    def __init__(self, feature_dimension, entangler_map=None):
        """"""
        Args:
            feature_dimension (int): number of features (twice the number of qubits for this
                encoding)
            entangler_map (list[list]): connectivity of qubits with a list of [source, target],
                or None for full entanglement. Note that the order in the list is the order of
                applying the two-qubit gate.

        Raises:
            ValueError: If the value of ``feature_dimension`` is odd.
        """"""

        if isinstance(feature_dimension, int):
            if feature_dimension % 2 == 0:
                self._feature_dimension = feature_dimension
            else:
                raise ValueError(""Feature dimension must be an even integer."")
        else:
            raise ValueError(""Feature dimension must be an even integer."")

        self._num_qubits = int(feature_dimension / 2)

        if entangler_map is None:
            self._entangler_map = [
                [i, j] for i in range(self._num_qubits) for j in range(i + 1, self._num_qubits)
            ]
        else:
            self._entangler_map = entangler_map

        self._num_parameters = self._num_qubits

    def construct_circuit(self, x=None, parameters=None, q=None, inverse=False, name=None):
        """"""Construct the feature map circuit.

        Args:
            x (numpy.ndarray): data vector of size feature_dimension
            parameters (numpy.ndarray): optional parameters in feature map
            q (QauntumRegister): the QuantumRegister object for the circuit
            inverse (bool): whether or not to invert the circuit
            name (str): The name to use for the constructed ``QuantumCircuit`` object

        Returns:
            QuantumCircuit: a quantum circuit transforming data x

        Raises:
            ValueError: If the input parameters or vector are invalid
        """"""

        if parameters is not None:
            if isinstance(parameters, (int, float)):
                raise ValueError(""Parameters must be a list."")
            if len(parameters) == 1:
                parameters = parameters * np.ones(self._num_qubits)
            else:
                if len(parameters) != self._num_parameters:
                    raise ValueError(
                        ""The number of feature map parameters must be {}."".format(
                            self._num_parameters
                        )
                    )

        if len(x) != self._feature_dimension:
            raise ValueError(
                ""The input vector must be of length {}."".format(self._feature_dimension)
            )

        if q is None:
            q = QuantumRegister(self._num_qubits, name=""q"")

        circuit = QuantumCircuit(q, name=name)

        for i in range(self._num_qubits):
            circuit.ry(-parameters[i], q[i])

        for source, target in self._entangler_map:
            circuit.cz(q[source], q[target])

        for i in range(self._num_qubits):
            circuit.rz(-2 * x[2 * i + 1], q[i])
            circuit.rx(-2 * x[2 * i], q[i])

        if inverse:
            return circuit.inverse()
        else:
            return circuit

    def to_json(self):
        """"""Return JSON representation of this object.

        Returns:
            str: JSON string representing this object.
        """"""
        return json.dumps(
            {""feature_dimension"": self._feature_dimension, ""entangler_map"": self._entangler_map}
        )

    @classmethod
    def from_json(cls, data):
        """"""Return an instance of this class from the JSON representation.

        Args:
            data (str): JSON string representing an object.

        Returns:
            FeatureMap: An instance of this class.
        """"""
        return cls(**json.loads(data))"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# pylint: disable=invalid-name

import itertools
import json
import numpy as np
from numpy.random import RandomState
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.compiler import transpile
from cvxopt import matrix, solvers  # pylint: disable=import-error
from qtils.featuremap import FeatureMap
from qtils.qka import QKA
import os
import pandas as pd


def main(backend, user_messenger, **kwargs):

    df = pd.read_csv(os.path.dirname(os.path.abspath(__file__)) + '/aux_file/dataset_graph7.csv',sep=',', header=None) # alterative problem: dataset_graph10.csv
    data = df.values

    # choose number of training and test samples per class:
    num_train = 10
    num_test = 10

    # extract training and test sets and sort them by class label
    train = data[:2*num_train, :]
    test = data[2*num_train:2*(num_train+num_test), :]

    ind=np.argsort(train[:,-1])
    x_train = train[ind][:,:-1]
    y_train = train[ind][:,-1]

    ind=np.argsort(test[:,-1])
    x_test = test[ind][:,:-1]
    y_test = test[ind][:,-1]


    C = 1
    maxiters = 1
    initial_point = [0.1]
    initial_layout = [10, 11, 12, 13, 14, 15, 16]                   # see figure above for the 7-qubit graph
    # initial_layout = [9, 8, 11, 14, 16, 19, 22, 25, 24, 23]       # see figure above for the 10-qubit graph

    d = np.shape(data)[1]-1                                         # feature dimension is twice the qubit number

    em = [[0,2],[3,4],[2,5],[1,4],[2,3],[4,6]]
    fm = FeatureMap(feature_dimension=d, entangler_map=em)

    qka = QKA(
        feature_map=fm,
        backend=backend,
        initial_layout=initial_layout,
        user_messenger=user_messenger,
    )
    qka_results = qka.align_kernel(
        data=x_train,
        labels=y_train,
        initial_kernel_parameters=initial_point,
        maxiters=maxiters,
        C=C,
    )

    user_messenger.publish(qka_results, final=True)"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"import itertools
import json
import numpy as np
from numpy.random import RandomState
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.compiler import transpile
from cvxopt import matrix, solvers  # pylint: disable=import-error
from .qka import QKA

class FeatureMap:

    def __init__(self, feature_dimension, entangler_map=None):
        if isinstance(feature_dimension, int):
            if feature_dimension % 2 == 0:
                self._feature_dimension = feature_dimension
            else:
                raise ValueError(""Feature dimension must be an even integer."")
        else:
            raise ValueError(""Feature dimension must be an even integer."")

        self._num_qubits = int(feature_dimension / 2)

        if entangler_map is None:
            self._entangler_map = [
                [i, j]
                for i in range(self._feature_dimension)
                for j in range(i + 1, self._feature_dimension)
            ]
        else:
            self._entangler_map = entangler_map

        self._num_parameters = self._num_qubits

    def construct_circuit(self, x=None, parameters=None, q=None, inverse=False, name=None):

        if parameters is not None:
            if isinstance(parameters, (int, float)):
                raise ValueError(""Parameters must be a list."")
            if len(parameters) == 1:
                parameters = parameters * np.ones(self._num_qubits)
            else:
                if len(parameters) != self._num_parameters:
                    raise ValueError(
                        ""The number of feature map parameters must be {}."".format(
                            self._num_parameters
                        )
                    )

        if len(x) != self._feature_dimension:
            raise ValueError(
                ""The input vector must be of length {}."".format(self._feature_dimension)
            )

        if q is None:
            q = QuantumRegister(self._num_qubits, name=""q"")

        circuit = QuantumCircuit(q, name=name)

        for i in range(self._num_qubits):
            circuit.ry(-parameters[i], q[i])

        for source, target in self._entangler_map:
            circuit.cz(q[source], q[target])

        for i in range(self._num_qubits):
            circuit.rz(-2 * x[2 * i + 1], q[i])
            circuit.rx(-2 * x[2 * i], q[i])

        if inverse:
            return circuit.inverse()
        else:
            return circuit

    def to_json(self):
        return json.dumps(
            {""feature_dimension"": self._feature_dimension, ""entangler_map"": self._entangler_map}
        )

    @classmethod
    def from_json(cls, data):
        return cls(**json.loads(data))

"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"import itertools
import json
import numpy as np
from numpy.random import RandomState
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.compiler import transpile
from cvxopt import matrix, solvers  # pylint: disable=import-error

"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"import itertools
import json
import numpy as np
from numpy.random import RandomState
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.compiler import transpile
from cvxopt import matrix, solvers  # pylint: disable=import-error

class QKA:
    def __init__(self, feature_map, backend, initial_layout=None, user_messenger=None):
        self.feature_map = feature_map
        self.feature_map_circuit = self.feature_map.construct_circuit
        self.backend = backend
        self.initial_layout = initial_layout
        self.num_parameters = self.feature_map._num_parameters

        self._user_messenger = user_messenger
        self.result = {}
        self.kernel_matrix = KernelMatrix(
            feature_map=self.feature_map, backend=self.backend, initial_layout=self.initial_layout
        )

    def spsa_parameters(self):
        spsa_params = np.zeros((5))
        spsa_params[0] = 0.05  # a
        spsa_params[1] = 0.1  # c
        spsa_params[2] = 0.602  # alpha
        spsa_params[3] = 0.101  # gamma
        spsa_params[4] = 0  # A

        return spsa_params

    def cvxopt_solver(self, K, y, C, max_iters=10000, show_progress=False):
        if y.ndim == 1:
            y = y[:, np.newaxis]
        H = np.outer(y, y) * K
        f = -np.ones(y.shape)

        n = K.shape[1]  # number of training points

        y = y.astype(""float"")

        P = matrix(H)
        q = matrix(f)
        G = matrix(np.vstack((-np.eye((n)), np.eye((n)))))
        h = matrix(np.vstack((np.zeros((n, 1)), np.ones((n, 1)) * C)))
        A = matrix(y, y.T.shape)
        b = matrix(np.zeros(1), (1, 1))

        solvers.options[""maxiters""] = max_iters
        solvers.options[""show_progress""] = show_progress

        ret = solvers.qp(P, q, G, h, A, b, kktsolver=""ldl"")

        return ret

    def spsa_step_one(self, lambdas, spsa_params, count):
        prng = RandomState(count)

        c_spsa = float(spsa_params[1]) / np.power(count + 1, spsa_params[3])
        delta = 2 * prng.randint(0, 2, size=np.shape(lambdas)[0]) - 1

        lambda_plus = lambdas + c_spsa * delta
        lambda_minus = lambdas - c_spsa * delta

        return lambda_plus, lambda_minus, delta

    def spsa_step_two(self, cost_plus, cost_minus, lambdas, spsa_params, delta, count):
        a_spsa = float(spsa_params[0]) / np.power(count + 1 + spsa_params[4], spsa_params[2])
        c_spsa = float(spsa_params[1]) / np.power(count + 1, spsa_params[3])

        g_spsa = (cost_plus - cost_minus) * delta / (2.0 * c_spsa)

        lambdas_new = lambdas - a_spsa * g_spsa
        lambdas_new = lambdas_new.flatten()

        cost_final = (cost_plus + cost_minus) / 2

        return cost_final, lambdas_new

    def align_kernel(self, data, labels, initial_kernel_parameters=None, maxiters=1, C=1):
        if initial_kernel_parameters is not None:
            lambdas = initial_kernel_parameters
        else:
            lambdas = np.random.uniform(-1.0, 1.0, size=(self.num_parameters))

        spsa_params = self.spsa_parameters()

        lambda_save = []
        cost_final_save = []

        for count in range(maxiters):

            lambda_plus, lambda_minus, delta = self.spsa_step_one(
                lambdas=lambdas, spsa_params=spsa_params, count=count
            )

            kernel_plus = self.kernel_matrix.construct_kernel_matrix(
                x1_vec=data, x2_vec=data, parameters=lambda_plus
            )
            kernel_minus = self.kernel_matrix.construct_kernel_matrix(
                x1_vec=data, x2_vec=data, parameters=lambda_minus
            )

            ret_plus = self.cvxopt_solver(K=kernel_plus, y=labels, C=C)
            cost_plus = -1 * ret_plus[""primal objective""]

            ret_minus = self.cvxopt_solver(K=kernel_minus, y=labels, C=C)
            cost_minus = -1 * ret_minus[""primal objective""]

            cost_final, lambda_best = self.spsa_step_two(
                cost_plus=cost_plus,
                cost_minus=cost_minus,
                lambdas=lambdas,
                spsa_params=spsa_params,
                delta=delta,
                count=count,
            )

            lambdas = lambda_best

            interim_result = {""cost"": cost_final, ""kernel_parameters"": lambdas}
            print(interim_result)
            self._user_messenger.publish(interim_result)

            lambda_save.append(lambdas)
            cost_final_save.append(cost_final)

        # Evaluate aligned kernel matrix with optimized set of
        # parameters averaged over last 10% of SPSA steps:
        num_last_lambdas = int(len(lambda_save) * 0.10)
        if num_last_lambdas > 0:
            last_lambdas = np.array(lambda_save)[-num_last_lambdas:, :]
            lambdas = np.sum(last_lambdas, axis=0) / num_last_lambdas
        else:
            lambdas = np.array(lambda_save)[-1, :]

        kernel_best = self.kernel_matrix.construct_kernel_matrix(
            x1_vec=data, x2_vec=data, parameters=lambdas
        )

        self.result[""aligned_kernel_parameters""] = lambdas
        self.result[""aligned_kernel_matrix""] = kernel_best

        return self.result


        
class KernelMatrix:
    def __init__(self, feature_map, backend, initial_layout=None):
        self._feature_map = feature_map
        self._feature_map_circuit = self._feature_map.construct_circuit
        self._backend = backend
        self._initial_layout = initial_layout

        self.results = {}

    def construct_kernel_matrix(self, x1_vec, x2_vec, parameters=None):
        is_identical = False
        if np.array_equal(x1_vec, x2_vec):
            is_identical = True

        experiments = []

        measurement_basis = ""0"" * self._feature_map._num_qubits

        if is_identical:

            my_product_list = list(
                itertools.combinations(range(len(x1_vec)), 2)
            )  # all pairwise combos of datapoint indices

            for index_1, index_2 in my_product_list:

                circuit_1 = self._feature_map_circuit(
                    x=x1_vec[index_1], parameters=parameters, name=""{}_{}"".format(index_1, index_2)
                )
                circuit_2 = self._feature_map_circuit(
                    x=x1_vec[index_2], parameters=parameters, inverse=True
                )
                circuit = circuit_1.compose(circuit_2)
                circuit.measure_all()
                experiments.append(circuit)

            experiments = transpile(
                experiments, backend=self._backend, initial_layout=self._initial_layout
            )
            program_data = self._backend.run(experiments, shots=8192).result()

            self.results[""program_data""] = program_data

            mat = np.eye(
                len(x1_vec), len(x1_vec)
            )  # kernel matrix element on the diagonal is always 1
            for experiment, [index_1, index_2] in enumerate(my_product_list):

                counts = program_data.get_counts(experiment=experiment)
                shots = sum(counts.values())

                mat[index_1][index_2] = (
                    counts.get(measurement_basis, 0) / shots
                )  # kernel matrix element is the probability of measuring all 0s
                mat[index_2][index_1] = mat[index_1][index_2]  # kernel matrix is symmetric

            return mat

        else:

            for index_1, point_1 in enumerate(x1_vec):
                for index_2, point_2 in enumerate(x2_vec):

                    circuit_1 = self._feature_map_circuit(
                        x=point_1, parameters=parameters, name=""{}_{}"".format(index_1, index_2)
                    )
                    circuit_2 = self._feature_map_circuit(
                        x=point_2, parameters=parameters, inverse=True
                    )
                    circuit = circuit_1.compose(circuit_2)
                    circuit.measure_all()
                    experiments.append(circuit)

            experiments = transpile(
                experiments, backend=self._backend, initial_layout=self._initial_layout
            )
            program_data = self._backend.run(experiments, shots=8192).result()

            self.results[""program_data""] = program_data

            mat = np.zeros((len(x1_vec), len(x2_vec)))
            i = 0
            for index_1, _ in enumerate(x1_vec):
                for index_2, _ in enumerate(x2_vec):

                    counts = program_data.get_counts(experiment=i)
                    shots = sum(counts.values())

                    mat[index_1][index_2] = counts.get(measurement_basis, 0) / shots
                    i += 1

            return mat"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017, 2018.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
# Copyright 2021 Dell (www.dell.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from dell_runtime.emulator_runtime_job import EmulatorRuntimeJob
import unittest
from qiskit import QuantumCircuit, execute, transpile
from qiskit.providers import JobStatus
import unittest
from urllib.parse import urljoin
import os, requests
import json
# import pytest_mysql
from server.orchestrator.models import DBService, Job, User, RuntimeProgram, Message, db_service
import pytest
from datetime import datetime
from time import sleep
SERVER_URL = os.getenv('SERVER_URL')
RUNTIME_PROGRAM = """"""
from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    **kwargs,
):

    user_messenger.publish({'results': 'intermittently'})

    circuits = transpile(
        circuits,
    )

    if not isinstance(circuits, list):
        circuits = [circuits]

    # Compute raw results
    result = backend.run(circuits, **kwargs).result()

    user_messenger.publish({'results': 'finally'})
    user_messenger.publish(result.to_dict(), final=True)
    print(""job complete successfully"")
""""""
RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

# mysql_proc = pytest_mysql.factories.mysql_proc(port=3307)


def test_fetch_program_owner():
    db_service = DBService()

    rp = RuntimeProgram()
    rp.program_id = ""12""
    rp.user_id = 1
    rp.name = ""test program""
    rp.data = b'test program'
    rp.program_metadata = ""meta""
    rp.status = 'Active'
    rp.data_type = ""DIR""

    db_service.save_runtime_program(rp)

    assert(db_service.fetch_program_owner(""12"") == 1)

def test_fetch_job_owner():
    db_service = DBService()

    rp = RuntimeProgram()
    rp.program_id = ""12""
    rp.user_id = 1
    rp.name = ""test program""
    rp.data = b'test program'
    rp.program_metadata = ""meta""
    rp.status = 'Active'
    rp.data_type = ""DIR""

    db_service.save_runtime_program(rp)

    jb = Job()
    jb.job_id = ""123""
    jb.program_id = ""12""
    jb.job_status = ""Completed""
    jb.pod_name = ""pod""
    jb.pod_status = ""Running""
    jb.data_token = ""USED""

    db_service.save_runtime_program(jb)


    assert(db_service.fetch_job_owner(""123"") == 1)

def test_see_programs():
    db_service = DBService()

    rp = RuntimeProgram()
    rp.program_id = ""14""
    rp.user_id = 1
    rp.name = ""test program""
    rp.data = b'test program'
    rp.program_metadata = ""meta""
    rp.status = 'Active'
    rp.data_type = ""DIR""

    db_service.save_runtime_program(rp)

    rp = RuntimeProgram()
    rp.program_id = ""13""
    rp.user_id = 1
    rp.name = ""test program""
    rp.data = b'test program'
    rp.program_metadata = ""meta""
    rp.status = 'Active'
    rp.data_type = ""DIR""

    db_service.save_runtime_program(rp)

    rp = RuntimeProgram()
    rp.program_id = ""12""
    rp.user_id = 2
    rp.name = ""test program""
    rp.data = b'test program'
    rp.program_metadata = ""meta""
    rp.status = 'Active'
    rp.data_type = ""DIR""

    db_service.save_runtime_program(rp)

    assert(len(db_service.fetch_runtime_programs(1)) == 2)

def test_use_job_token():
    db_service = DBService()

    jb = Job()
    jb.job_id = ""123""
    jb.program_id = ""12""
    jb.job_status = ""Completed""
    jb.pod_name = ""pod""
    jb.pod_status = ""Running""
    jb.data_token = ""token""

    db_service.save_runtime_program(jb)

    db_service.use_job_token(""123"")

    assert(db_service.fetch_job_token(""123"") == ""USED"")

def test_fetch_messages_timestamp():
    db_service = DBService()

    db_service.save_message(""123"", ""this message"")

    msgs = db_service.fetch_messages(""123"", None)

    assert(len(msgs) == 1)
    ts = datetime.fromisoformat(msgs[0][""timestamp""])

    sleep(2)

    db_service.save_message(""123"", ""another message"")

    newmsgs = db_service.fetch_messages(""123"", ts)

    assert(len(newmsgs) == 1)

"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""The FeatureMap class.""""""

import json

import numpy as np

from qiskit import QuantumCircuit, QuantumRegister


class FeatureMap:
    """"""Mapping data with the feature map.""""""

    def __init__(self, feature_dimension, entangler_map=None):
        """"""
        Args:
            feature_dimension (int): number of features (twice the number of qubits for this
                encoding)
            entangler_map (list[list]): connectivity of qubits with a list of [source, target],
                or None for full entanglement. Note that the order in the list is the order of
                applying the two-qubit gate.

        Raises:
            ValueError: If the value of ``feature_dimension`` is odd.
        """"""

        if isinstance(feature_dimension, int):
            if feature_dimension % 2 == 0:
                self._feature_dimension = feature_dimension
            else:
                raise ValueError(""Feature dimension must be an even integer."")
        else:
            raise ValueError(""Feature dimension must be an even integer."")

        self._num_qubits = int(feature_dimension / 2)

        if entangler_map is None:
            self._entangler_map = [
                [i, j] for i in range(self._num_qubits) for j in range(i + 1, self._num_qubits)
            ]
        else:
            self._entangler_map = entangler_map

        self._num_parameters = self._num_qubits

    def construct_circuit(self, x=None, parameters=None, q=None, inverse=False, name=None):
        """"""Construct the feature map circuit.

        Args:
            x (numpy.ndarray): data vector of size feature_dimension
            parameters (numpy.ndarray): optional parameters in feature map
            q (QauntumRegister): the QuantumRegister object for the circuit
            inverse (bool): whether or not to invert the circuit
            name (str): The name to use for the constructed ``QuantumCircuit`` object

        Returns:
            QuantumCircuit: a quantum circuit transforming data x

        Raises:
            ValueError: If the input parameters or vector are invalid
        """"""

        if parameters is not None:
            if isinstance(parameters, (int, float)):
                raise ValueError(""Parameters must be a list."")
            if len(parameters) == 1:
                parameters = parameters * np.ones(self._num_qubits)
            else:
                if len(parameters) != self._num_parameters:
                    raise ValueError(
                        ""The number of feature map parameters must be {}."".format(
                            self._num_parameters
                        )
                    )

        if len(x) != self._feature_dimension:
            raise ValueError(
                ""The input vector must be of length {}."".format(self._feature_dimension)
            )

        if q is None:
            q = QuantumRegister(self._num_qubits, name=""q"")

        circuit = QuantumCircuit(q, name=name)

        for i in range(self._num_qubits):
            circuit.ry(-parameters[i], q[i])

        for source, target in self._entangler_map:
            circuit.cz(q[source], q[target])

        for i in range(self._num_qubits):
            circuit.rz(-2 * x[2 * i + 1], q[i])
            circuit.rx(-2 * x[2 * i], q[i])

        if inverse:
            return circuit.inverse()
        else:
            return circuit

    def to_json(self):
        """"""Return JSON representation of this object.

        Returns:
            str: JSON string representing this object.
        """"""
        return json.dumps(
            {""feature_dimension"": self._feature_dimension, ""entangler_map"": self._entangler_map}
        )

    @classmethod
    def from_json(cls, data):
        """"""Return an instance of this class from the JSON representation.

        Args:
            data (str): JSON string representing an object.

        Returns:
            FeatureMap: An instance of this class.
        """"""
        return cls(**json.loads(data))"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"from dell_runtime import DellRuntimeProvider
from qiskit import QuantumCircuit

RUNTIME_PROGRAM = """"""
# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    **kwargs,
):
    circuits = transpile(
        circuits,
    )

    if not isinstance(circuits, list):
        circuits = [circuits]

    # Compute raw results
    result = backend.run(circuits, **kwargs).result()

    user_messenger.publish(result.to_dict(), final=True)
""""""

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

# PROGRAM_PREFIX = 'qiskit-test'

def main():
    provider = DellRuntimeProvider()
    program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
    
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure([0, 1], [0, 1])

    program_inputs = {
        'circuits': qc,
    }

    runtime_program = provider.runtime.program(program_id)

    
    job = provider.runtime.run(program_id, options=None, inputs=program_inputs)

    job.result(timeout=120)
    

if __name__ == ""__main__"":
    main()
"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""The FeatureMap class.""""""

import json

import numpy as np

from qiskit import QuantumCircuit, QuantumRegister


class FeatureMap:
    """"""Mapping data with the feature map.""""""

    def __init__(self, feature_dimension, entangler_map=None):
        """"""
        Args:
            feature_dimension (int): number of features (twice the number of qubits for this
                encoding)
            entangler_map (list[list]): connectivity of qubits with a list of [source, target],
                or None for full entanglement. Note that the order in the list is the order of
                applying the two-qubit gate.

        Raises:
            ValueError: If the value of ``feature_dimension`` is odd.
        """"""

        if isinstance(feature_dimension, int):
            if feature_dimension % 2 == 0:
                self._feature_dimension = feature_dimension
            else:
                raise ValueError(""Feature dimension must be an even integer."")
        else:
            raise ValueError(""Feature dimension must be an even integer."")

        self._num_qubits = int(feature_dimension / 2)

        if entangler_map is None:
            self._entangler_map = [
                [i, j] for i in range(self._num_qubits) for j in range(i + 1, self._num_qubits)
            ]
        else:
            self._entangler_map = entangler_map

        self._num_parameters = self._num_qubits

    def construct_circuit(self, x=None, parameters=None, q=None, inverse=False, name=None):
        """"""Construct the feature map circuit.

        Args:
            x (numpy.ndarray): data vector of size feature_dimension
            parameters (numpy.ndarray): optional parameters in feature map
            q (QauntumRegister): the QuantumRegister object for the circuit
            inverse (bool): whether or not to invert the circuit
            name (str): The name to use for the constructed ``QuantumCircuit`` object

        Returns:
            QuantumCircuit: a quantum circuit transforming data x

        Raises:
            ValueError: If the input parameters or vector are invalid
        """"""

        if parameters is not None:
            if isinstance(parameters, (int, float)):
                raise ValueError(""Parameters must be a list."")
            if len(parameters) == 1:
                parameters = parameters * np.ones(self._num_qubits)
            else:
                if len(parameters) != self._num_parameters:
                    raise ValueError(
                        ""The number of feature map parameters must be {}."".format(
                            self._num_parameters
                        )
                    )

        if len(x) != self._feature_dimension:
            raise ValueError(
                ""The input vector must be of length {}."".format(self._feature_dimension)
            )

        if q is None:
            q = QuantumRegister(self._num_qubits, name=""q"")

        circuit = QuantumCircuit(q, name=name)

        for i in range(self._num_qubits):
            circuit.ry(-parameters[i], q[i])

        for source, target in self._entangler_map:
            circuit.cz(q[source], q[target])

        for i in range(self._num_qubits):
            circuit.rz(-2 * x[2 * i + 1], q[i])
            circuit.rx(-2 * x[2 * i], q[i])

        if inverse:
            return circuit.inverse()
        else:
            return circuit

    def to_json(self):
        """"""Return JSON representation of this object.

        Returns:
            str: JSON string representing this object.
        """"""
        return json.dumps(
            {""feature_dimension"": self._feature_dimension, ""entangler_map"": self._entangler_map}
        )

    @classmethod
    def from_json(cls, data):
        """"""Return an instance of this class from the JSON representation.

        Args:
            data (str): JSON string representing an object.

        Returns:
            FeatureMap: An instance of this class.
        """"""
        return cls(**json.loads(data))"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"from dell_runtime import DellRuntimeProvider
from qiskit import QuantumCircuit
import logging
import requests
import time

RUNTIME_PROGRAM = """"""
# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
from qiskit.compiler import transpile, schedule
import time

def main(backend, user_messenger, **kwargs):
    iterations = kwargs.pop(""iterations"", 5)
    for it in range(iterations):
        user_messenger.publish({""iteration"": it })
        time.sleep(5)

    user_messenger.publish(""All done!"", final=True)
""""""

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

PROGRAM_PREFIX = 'qiskit-test'
REMOTE_RUNTIME = 'http://localhost:8080'
def main():
    print(""Starting..."")
    logging.basicConfig(level=logging.DEBUG)

    provider = DellRuntimeProvider()
    # provider.remote(REMOTE_RUNTIME)
    program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
    print(f""PROGRAM ID: {program_id}"")


    program_inputs = {
        'iterations': 3,
    }

    
    job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
    time.sleep(2)
    print(job.get_unread_messages())
    results = job.result(timeout=25)
    print(results)
if __name__ == ""__main__"":
    main()"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"from dell_runtime import DellRuntimeProvider
from qiskit import QuantumCircuit
import os
import logging
logging.basicConfig(level=logging.DEBUG)
RUNTIME_PROGRAM = """"""
# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# This is a simplified version of the circuit-runner program.

from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    initial_layout=None,
    seed_transpiler=None,
    optimization_level=None,
    transpiler_options=None,
    scheduling_method=None,
    schedule_circuit=False,
    inst_map=None,
    meas_map=None,
    measurement_error_mitigation=False,
    **kwargs,
):

    # transpiling the circuits using given transpile options
    transpiler_options = transpiler_options or {}
    circuits = transpile(
        circuits,
        initial_layout=initial_layout,
        seed_transpiler=seed_transpiler,
        optimization_level=optimization_level,
        backend=backend,
        **transpiler_options,
    )

    if schedule_circuit:
        circuits = schedule(
            circuits=circuits,
            backend=backend,
            inst_map=inst_map,
            meas_map=meas_map,
            method=scheduling_method,
        )

    if not isinstance(circuits, list):
        circuits = [circuits]

    # Compute raw results
    result = backend.run(circuits, **kwargs).result()

    if measurement_error_mitigation:
        # Performs measurement error mitigation.
        pass

    user_messenger.publish(result.to_dict(), final=True)
""""""

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

PROGRAM_PREFIX = 'qiskit-test'
def main():
    provider = DellRuntimeProvider()
    program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
    N = 6
    qc = QuantumCircuit(N)

    qc.x(range(0, N))
    qc.h(range(0, N))

    for kk in range(N//2,0,-1):
        qc.ch(kk, kk-1)
    for kk in range(N//2, N-1):
        qc.ch(kk, kk+1)
    qc.measure_all()

    program_inputs = {
        'circuits': qc,
        'shots': 2048,
        'optimization_level': 0,
        'initial_layout': [0,1,4,7,10,12],
        'measurement_error_mitigation': False
    }

    runtime_program = provider.runtime.program(program_id)

    
    job = provider.runtime.run(program_id, options=None, inputs=program_inputs)

    res = job.result(timeout=120)

    print(f""res: {res}"")

if __name__ == ""__main__"":
    main()
"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"import itertools
import json
import numpy as np
from numpy.random import RandomState
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.compiler import transpile
from cvxopt import matrix, solvers  # pylint: disable=import-error

class QKA:
    def __init__(self, feature_map, backend, initial_layout=None, user_messenger=None):
        self.feature_map = feature_map
        self.feature_map_circuit = self.feature_map.construct_circuit
        self.backend = backend
        self.initial_layout = initial_layout
        self.num_parameters = self.feature_map._num_parameters

        self._user_messenger = user_messenger
        self.result = {}
        self.kernel_matrix = KernelMatrix(
            feature_map=self.feature_map, backend=self.backend, initial_layout=self.initial_layout
        )

    def spsa_parameters(self):
        spsa_params = np.zeros((5))
        spsa_params[0] = 0.05  # a
        spsa_params[1] = 0.1  # c
        spsa_params[2] = 0.602  # alpha
        spsa_params[3] = 0.101  # gamma
        spsa_params[4] = 0  # A

        return spsa_params

    def cvxopt_solver(self, K, y, C, max_iters=10000, show_progress=False):
        if y.ndim == 1:
            y = y[:, np.newaxis]
        H = np.outer(y, y) * K
        f = -np.ones(y.shape)

        n = K.shape[1]  # number of training points

        y = y.astype(""float"")

        P = matrix(H)
        q = matrix(f)
        G = matrix(np.vstack((-np.eye((n)), np.eye((n)))))
        h = matrix(np.vstack((np.zeros((n, 1)), np.ones((n, 1)) * C)))
        A = matrix(y, y.T.shape)
        b = matrix(np.zeros(1), (1, 1))

        solvers.options[""maxiters""] = max_iters
        solvers.options[""show_progress""] = show_progress

        ret = solvers.qp(P, q, G, h, A, b, kktsolver=""ldl"")

        return ret

    def spsa_step_one(self, lambdas, spsa_params, count):
        prng = RandomState(count)

        c_spsa = float(spsa_params[1]) / np.power(count + 1, spsa_params[3])
        delta = 2 * prng.randint(0, 2, size=np.shape(lambdas)[0]) - 1

        lambda_plus = lambdas + c_spsa * delta
        lambda_minus = lambdas - c_spsa * delta

        return lambda_plus, lambda_minus, delta

    def spsa_step_two(self, cost_plus, cost_minus, lambdas, spsa_params, delta, count):
        a_spsa = float(spsa_params[0]) / np.power(count + 1 + spsa_params[4], spsa_params[2])
        c_spsa = float(spsa_params[1]) / np.power(count + 1, spsa_params[3])

        g_spsa = (cost_plus - cost_minus) * delta / (2.0 * c_spsa)

        lambdas_new = lambdas - a_spsa * g_spsa
        lambdas_new = lambdas_new.flatten()

        cost_final = (cost_plus + cost_minus) / 2

        return cost_final, lambdas_new

    def align_kernel(self, data, labels, initial_kernel_parameters=None, maxiters=1, C=1):
        if initial_kernel_parameters is not None:
            lambdas = initial_kernel_parameters
        else:
            lambdas = np.random.uniform(-1.0, 1.0, size=(self.num_parameters))

        spsa_params = self.spsa_parameters()

        lambda_save = []
        cost_final_save = []

        for count in range(maxiters):

            lambda_plus, lambda_minus, delta = self.spsa_step_one(
                lambdas=lambdas, spsa_params=spsa_params, count=count
            )

            kernel_plus = self.kernel_matrix.construct_kernel_matrix(
                x1_vec=data, x2_vec=data, parameters=lambda_plus
            )
            kernel_minus = self.kernel_matrix.construct_kernel_matrix(
                x1_vec=data, x2_vec=data, parameters=lambda_minus
            )

            ret_plus = self.cvxopt_solver(K=kernel_plus, y=labels, C=C)
            cost_plus = -1 * ret_plus[""primal objective""]

            ret_minus = self.cvxopt_solver(K=kernel_minus, y=labels, C=C)
            cost_minus = -1 * ret_minus[""primal objective""]

            cost_final, lambda_best = self.spsa_step_two(
                cost_plus=cost_plus,
                cost_minus=cost_minus,
                lambdas=lambdas,
                spsa_params=spsa_params,
                delta=delta,
                count=count,
            )

            lambdas = lambda_best

            interim_result = {""cost"": cost_final, ""kernel_parameters"": lambdas}
            print(interim_result)
            self._user_messenger.publish(interim_result)

            lambda_save.append(lambdas)
            cost_final_save.append(cost_final)

        # Evaluate aligned kernel matrix with optimized set of
        # parameters averaged over last 10% of SPSA steps:
        num_last_lambdas = int(len(lambda_save) * 0.10)
        if num_last_lambdas > 0:
            last_lambdas = np.array(lambda_save)[-num_last_lambdas:, :]
            lambdas = np.sum(last_lambdas, axis=0) / num_last_lambdas
        else:
            lambdas = np.array(lambda_save)[-1, :]

        kernel_best = self.kernel_matrix.construct_kernel_matrix(
            x1_vec=data, x2_vec=data, parameters=lambdas
        )

        self.result[""aligned_kernel_parameters""] = lambdas
        self.result[""aligned_kernel_matrix""] = kernel_best

        return self.result


        
class KernelMatrix:
    def __init__(self, feature_map, backend, initial_layout=None):
        self._feature_map = feature_map
        self._feature_map_circuit = self._feature_map.construct_circuit
        self._backend = backend
        self._initial_layout = initial_layout

        self.results = {}

    def construct_kernel_matrix(self, x1_vec, x2_vec, parameters=None):
        is_identical = False
        if np.array_equal(x1_vec, x2_vec):
            is_identical = True

        experiments = []

        measurement_basis = ""0"" * self._feature_map._num_qubits

        if is_identical:

            my_product_list = list(
                itertools.combinations(range(len(x1_vec)), 2)
            )  # all pairwise combos of datapoint indices

            for index_1, index_2 in my_product_list:

                circuit_1 = self._feature_map_circuit(
                    x=x1_vec[index_1], parameters=parameters, name=""{}_{}"".format(index_1, index_2)
                )
                circuit_2 = self._feature_map_circuit(
                    x=x1_vec[index_2], parameters=parameters, inverse=True
                )
                circuit = circuit_1.compose(circuit_2)
                circuit.measure_all()
                experiments.append(circuit)

            experiments = transpile(
                experiments, backend=self._backend, initial_layout=self._initial_layout
            )
            program_data = self._backend.run(experiments, shots=8192).result()

            self.results[""program_data""] = program_data

            mat = np.eye(
                len(x1_vec), len(x1_vec)
            )  # kernel matrix element on the diagonal is always 1
            for experiment, [index_1, index_2] in enumerate(my_product_list):

                counts = program_data.get_counts(experiment=experiment)
                shots = sum(counts.values())

                mat[index_1][index_2] = (
                    counts.get(measurement_basis, 0) / shots
                )  # kernel matrix element is the probability of measuring all 0s
                mat[index_2][index_1] = mat[index_1][index_2]  # kernel matrix is symmetric

            return mat

        else:

            for index_1, point_1 in enumerate(x1_vec):
                for index_2, point_2 in enumerate(x2_vec):

                    circuit_1 = self._feature_map_circuit(
                        x=point_1, parameters=parameters, name=""{}_{}"".format(index_1, index_2)
                    )
                    circuit_2 = self._feature_map_circuit(
                        x=point_2, parameters=parameters, inverse=True
                    )
                    circuit = circuit_1.compose(circuit_2)
                    circuit.measure_all()
                    experiments.append(circuit)

            experiments = transpile(
                experiments, backend=self._backend, initial_layout=self._initial_layout
            )
            program_data = self._backend.run(experiments, shots=8192).result()

            self.results[""program_data""] = program_data

            mat = np.zeros((len(x1_vec), len(x2_vec)))
            i = 0
            for index_1, _ in enumerate(x1_vec):
                for index_2, _ in enumerate(x2_vec):

                    counts = program_data.get_counts(experiment=i)
                    shots = sum(counts.values())

                    mat[index_1][index_2] = counts.get(measurement_basis, 0) / shots
                    i += 1

            return mat"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"#!/usr/bin/env python
# coding: utf-8

# In[2]:
from dell_runtime import DellRuntimeProvider
from qiskit import QuantumCircuit
import pandas as pd
from time import sleep
import os
import base64
import shutil
import json

# here = os.path.dirname(os.path.realpath(__file__))
# zipped = shutil.make_archive(here + ""/tmp"", ""zip"", here + ""/qkad"")
# with open(zipped, ""rb"") as z:
#     data = z.read()
# data = base64.urlsafe_b64encode(data)
# sdata = str(data, ""utf-8"")
# bdata = bytes(sdata, ""utf-8"")

# sdata = str(bdata, ""utf-8"")

# obj = {
#     'data': sdata,
#     'data_type': ""DIR""
# }

# jsonstr = json.dumps(obj)
# ljson = json.loads(jsonstr)

# bdata = bytes(ljson['data'], ""utf-8"")
# b64data = base64.urlsafe_b64decode(bdata)

# with open(zipped, ""wb"") as temp:
#     temp.write(b64data)
# shutil.unpack_archive(zipped, extract_dir=here + ""/qkad1"", format=""zip"")
# os.remove(zipped)




provider = DellRuntimeProvider()



RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}


provider.remote(os.getenv(""SERVER_URL""))
here = os.path.dirname(os.path.realpath(__file__))

program_id = provider.runtime.upload_program(here + ""/qkad"", metadata=RUNTIME_PROGRAM_METADATA)

job = provider.runtime.run(program_id, options=None, inputs={})

res = job.result(timeout=1000)
print(res)
"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"from dell_runtime import DellRuntimeProvider
from qiskit import QuantumCircuit
import logging
import requests
import time
import os

RUNTIME_PROGRAM = """"""
# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    **kwargs,
):
    circuits = transpile(
        circuits,
    )

    if not isinstance(circuits, list):
        circuits = [circuits]

    # Compute raw results
    result = backend.run(circuits, **kwargs).result()

    user_messenger.publish(result.to_dict(), final=True)
""""""

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

PROGRAM_PREFIX = 'qiskit-test'
REMOTE_RUNTIME = os.getenv(""SERVER_URL"") 
def main():
    print(""Starting..."")
    logging.basicConfig(level=logging.DEBUG)

    provider = DellRuntimeProvider()
    provider.remote(REMOTE_RUNTIME)
    program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
    print(f""PROGRAM ID: {program_id}"")

    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure([0, 1], [0, 1])

    program_inputs = {
        'circuits': qc,
    }

    
    job = provider.runtime.run(program_id, options=None, inputs=program_inputs)

    # job.stream_results(print)
    results = job.result(timeout=60)
    print(results)
if __name__ == ""__main__"":
    main()"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# pylint: disable=invalid-name

import itertools
import json
import numpy as np
from numpy.random import RandomState
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.compiler import transpile
from cvxopt import matrix, solvers  # pylint: disable=import-error
from qtils.featuremap import FeatureMap
from qtils.qka import QKA
import os
import pandas as pd


def main(backend, user_messenger, **kwargs):

    df = pd.read_csv(os.path.dirname(os.path.abspath(__file__)) + '/aux_file/dataset_graph7.csv',sep=',', header=None) # alterative problem: dataset_graph10.csv
    data = df.values

    # choose number of training and test samples per class:
    num_train = 10
    num_test = 10

    # extract training and test sets and sort them by class label
    train = data[:2*num_train, :]
    test = data[2*num_train:2*(num_train+num_test), :]

    ind=np.argsort(train[:,-1])
    x_train = train[ind][:,:-1]
    y_train = train[ind][:,-1]

    ind=np.argsort(test[:,-1])
    x_test = test[ind][:,:-1]
    y_test = test[ind][:,-1]


    C = 1
    maxiters = 1
    initial_point = [0.1]
    initial_layout = [10, 11, 12, 13, 14, 15, 16]                   # see figure above for the 7-qubit graph
    # initial_layout = [9, 8, 11, 14, 16, 19, 22, 25, 24, 23]       # see figure above for the 10-qubit graph

    d = np.shape(data)[1]-1                                         # feature dimension is twice the qubit number

    em = [[0,2],[3,4],[2,5],[1,4],[2,3],[4,6]]
    fm = FeatureMap(feature_dimension=d, entangler_map=em)

    qka = QKA(
        feature_map=fm,
        backend=backend,
        initial_layout=initial_layout,
        user_messenger=user_messenger,
    )
    qka_results = qka.align_kernel(
        data=x_train,
        labels=y_train,
        initial_kernel_parameters=initial_point,
        maxiters=maxiters,
        C=C,
    )

    user_messenger.publish(qka_results, final=True)"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"import itertools
import json
import numpy as np
from numpy.random import RandomState
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.compiler import transpile
from cvxopt import matrix, solvers  # pylint: disable=import-error
from .qka import QKA

class FeatureMap:

    def __init__(self, feature_dimension, entangler_map=None):
        if isinstance(feature_dimension, int):
            if feature_dimension % 2 == 0:
                self._feature_dimension = feature_dimension
            else:
                raise ValueError(""Feature dimension must be an even integer."")
        else:
            raise ValueError(""Feature dimension must be an even integer."")

        self._num_qubits = int(feature_dimension / 2)

        if entangler_map is None:
            self._entangler_map = [
                [i, j]
                for i in range(self._feature_dimension)
                for j in range(i + 1, self._feature_dimension)
            ]
        else:
            self._entangler_map = entangler_map

        self._num_parameters = self._num_qubits

    def construct_circuit(self, x=None, parameters=None, q=None, inverse=False, name=None):

        if parameters is not None:
            if isinstance(parameters, (int, float)):
                raise ValueError(""Parameters must be a list."")
            if len(parameters) == 1:
                parameters = parameters * np.ones(self._num_qubits)
            else:
                if len(parameters) != self._num_parameters:
                    raise ValueError(
                        ""The number of feature map parameters must be {}."".format(
                            self._num_parameters
                        )
                    )

        if len(x) != self._feature_dimension:
            raise ValueError(
                ""The input vector must be of length {}."".format(self._feature_dimension)
            )

        if q is None:
            q = QuantumRegister(self._num_qubits, name=""q"")

        circuit = QuantumCircuit(q, name=name)

        for i in range(self._num_qubits):
            circuit.ry(-parameters[i], q[i])

        for source, target in self._entangler_map:
            circuit.cz(q[source], q[target])

        for i in range(self._num_qubits):
            circuit.rz(-2 * x[2 * i + 1], q[i])
            circuit.rx(-2 * x[2 * i], q[i])

        if inverse:
            return circuit.inverse()
        else:
            return circuit

    def to_json(self):
        return json.dumps(
            {""feature_dimension"": self._feature_dimension, ""entangler_map"": self._entangler_map}
        )

    @classmethod
    def from_json(cls, data):
        return cls(**json.loads(data))

"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"import itertools
import json
import numpy as np
from numpy.random import RandomState
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.compiler import transpile
from cvxopt import matrix, solvers  # pylint: disable=import-error

"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"import itertools
import json
import numpy as np
from numpy.random import RandomState
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.compiler import transpile
from cvxopt import matrix, solvers  # pylint: disable=import-error

class QKA:
    def __init__(self, feature_map, backend, initial_layout=None, user_messenger=None):
        self.feature_map = feature_map
        self.feature_map_circuit = self.feature_map.construct_circuit
        self.backend = backend
        self.initial_layout = initial_layout
        self.num_parameters = self.feature_map._num_parameters

        self._user_messenger = user_messenger
        self.result = {}
        self.kernel_matrix = KernelMatrix(
            feature_map=self.feature_map, backend=self.backend, initial_layout=self.initial_layout
        )

    def spsa_parameters(self):
        spsa_params = np.zeros((5))
        spsa_params[0] = 0.05  # a
        spsa_params[1] = 0.1  # c
        spsa_params[2] = 0.602  # alpha
        spsa_params[3] = 0.101  # gamma
        spsa_params[4] = 0  # A

        return spsa_params

    def cvxopt_solver(self, K, y, C, max_iters=10000, show_progress=False):
        if y.ndim == 1:
            y = y[:, np.newaxis]
        H = np.outer(y, y) * K
        f = -np.ones(y.shape)

        n = K.shape[1]  # number of training points

        y = y.astype(""float"")

        P = matrix(H)
        q = matrix(f)
        G = matrix(np.vstack((-np.eye((n)), np.eye((n)))))
        h = matrix(np.vstack((np.zeros((n, 1)), np.ones((n, 1)) * C)))
        A = matrix(y, y.T.shape)
        b = matrix(np.zeros(1), (1, 1))

        solvers.options[""maxiters""] = max_iters
        solvers.options[""show_progress""] = show_progress

        ret = solvers.qp(P, q, G, h, A, b, kktsolver=""ldl"")

        return ret

    def spsa_step_one(self, lambdas, spsa_params, count):
        prng = RandomState(count)

        c_spsa = float(spsa_params[1]) / np.power(count + 1, spsa_params[3])
        delta = 2 * prng.randint(0, 2, size=np.shape(lambdas)[0]) - 1

        lambda_plus = lambdas + c_spsa * delta
        lambda_minus = lambdas - c_spsa * delta

        return lambda_plus, lambda_minus, delta

    def spsa_step_two(self, cost_plus, cost_minus, lambdas, spsa_params, delta, count):
        a_spsa = float(spsa_params[0]) / np.power(count + 1 + spsa_params[4], spsa_params[2])
        c_spsa = float(spsa_params[1]) / np.power(count + 1, spsa_params[3])

        g_spsa = (cost_plus - cost_minus) * delta / (2.0 * c_spsa)

        lambdas_new = lambdas - a_spsa * g_spsa
        lambdas_new = lambdas_new.flatten()

        cost_final = (cost_plus + cost_minus) / 2

        return cost_final, lambdas_new

    def align_kernel(self, data, labels, initial_kernel_parameters=None, maxiters=1, C=1):
        if initial_kernel_parameters is not None:
            lambdas = initial_kernel_parameters
        else:
            lambdas = np.random.uniform(-1.0, 1.0, size=(self.num_parameters))

        spsa_params = self.spsa_parameters()

        lambda_save = []
        cost_final_save = []

        for count in range(maxiters):

            lambda_plus, lambda_minus, delta = self.spsa_step_one(
                lambdas=lambdas, spsa_params=spsa_params, count=count
            )

            kernel_plus = self.kernel_matrix.construct_kernel_matrix(
                x1_vec=data, x2_vec=data, parameters=lambda_plus
            )
            kernel_minus = self.kernel_matrix.construct_kernel_matrix(
                x1_vec=data, x2_vec=data, parameters=lambda_minus
            )

            ret_plus = self.cvxopt_solver(K=kernel_plus, y=labels, C=C)
            cost_plus = -1 * ret_plus[""primal objective""]

            ret_minus = self.cvxopt_solver(K=kernel_minus, y=labels, C=C)
            cost_minus = -1 * ret_minus[""primal objective""]

            cost_final, lambda_best = self.spsa_step_two(
                cost_plus=cost_plus,
                cost_minus=cost_minus,
                lambdas=lambdas,
                spsa_params=spsa_params,
                delta=delta,
                count=count,
            )

            lambdas = lambda_best

            interim_result = {""cost"": cost_final, ""kernel_parameters"": lambdas}
            print(interim_result)
            self._user_messenger.publish(interim_result)

            lambda_save.append(lambdas)
            cost_final_save.append(cost_final)

        # Evaluate aligned kernel matrix with optimized set of
        # parameters averaged over last 10% of SPSA steps:
        num_last_lambdas = int(len(lambda_save) * 0.10)
        if num_last_lambdas > 0:
            last_lambdas = np.array(lambda_save)[-num_last_lambdas:, :]
            lambdas = np.sum(last_lambdas, axis=0) / num_last_lambdas
        else:
            lambdas = np.array(lambda_save)[-1, :]

        kernel_best = self.kernel_matrix.construct_kernel_matrix(
            x1_vec=data, x2_vec=data, parameters=lambdas
        )

        self.result[""aligned_kernel_parameters""] = lambdas
        self.result[""aligned_kernel_matrix""] = kernel_best

        return self.result


        
class KernelMatrix:
    def __init__(self, feature_map, backend, initial_layout=None):
        self._feature_map = feature_map
        self._feature_map_circuit = self._feature_map.construct_circuit
        self._backend = backend
        self._initial_layout = initial_layout

        self.results = {}

    def construct_kernel_matrix(self, x1_vec, x2_vec, parameters=None):
        is_identical = False
        if np.array_equal(x1_vec, x2_vec):
            is_identical = True

        experiments = []

        measurement_basis = ""0"" * self._feature_map._num_qubits

        if is_identical:

            my_product_list = list(
                itertools.combinations(range(len(x1_vec)), 2)
            )  # all pairwise combos of datapoint indices

            for index_1, index_2 in my_product_list:

                circuit_1 = self._feature_map_circuit(
                    x=x1_vec[index_1], parameters=parameters, name=""{}_{}"".format(index_1, index_2)
                )
                circuit_2 = self._feature_map_circuit(
                    x=x1_vec[index_2], parameters=parameters, inverse=True
                )
                circuit = circuit_1.compose(circuit_2)
                circuit.measure_all()
                experiments.append(circuit)

            experiments = transpile(
                experiments, backend=self._backend, initial_layout=self._initial_layout
            )
            program_data = self._backend.run(experiments, shots=8192).result()

            self.results[""program_data""] = program_data

            mat = np.eye(
                len(x1_vec), len(x1_vec)
            )  # kernel matrix element on the diagonal is always 1
            for experiment, [index_1, index_2] in enumerate(my_product_list):

                counts = program_data.get_counts(experiment=experiment)
                shots = sum(counts.values())

                mat[index_1][index_2] = (
                    counts.get(measurement_basis, 0) / shots
                )  # kernel matrix element is the probability of measuring all 0s
                mat[index_2][index_1] = mat[index_1][index_2]  # kernel matrix is symmetric

            return mat

        else:

            for index_1, point_1 in enumerate(x1_vec):
                for index_2, point_2 in enumerate(x2_vec):

                    circuit_1 = self._feature_map_circuit(
                        x=point_1, parameters=parameters, name=""{}_{}"".format(index_1, index_2)
                    )
                    circuit_2 = self._feature_map_circuit(
                        x=point_2, parameters=parameters, inverse=True
                    )
                    circuit = circuit_1.compose(circuit_2)
                    circuit.measure_all()
                    experiments.append(circuit)

            experiments = transpile(
                experiments, backend=self._backend, initial_layout=self._initial_layout
            )
            program_data = self._backend.run(experiments, shots=8192).result()

            self.results[""program_data""] = program_data

            mat = np.zeros((len(x1_vec), len(x2_vec)))
            i = 0
            for index_1, _ in enumerate(x1_vec):
                for index_2, _ in enumerate(x2_vec):

                    counts = program_data.get_counts(experiment=i)
                    shots = sum(counts.values())

                    mat[index_1][index_2] = counts.get(measurement_basis, 0) / shots
                    i += 1

            return mat"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017, 2018.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
# Copyright 2021 Dell (www.dell.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from qiskit.providers import JobV1
from qiskit.providers import JobStatus, JobError
from qiskit import transpile
from qiskit_aer import Aer
import functools

def requires_submit(func):
    """"""
    Decorator to ensure that a submit has been performed before
    calling the method.
    Args:
        func (callable): test function to be decorated.
    Returns:
        callable: the decorated function.
    """"""
    @functools.wraps(func)
    def _wrapper(self, *args, **kwargs):
        if self.my_job is None:
            raise JobError(""Job not submitted yet!. You have to .submit() first!"")
        return func(self, *args, **kwargs)
    return _wrapper

class EmulatorJob(JobV1):
    def __init__(self, backend, job_id, circuit, shots):
        super().__init__(backend, job_id)
        self.circuit = circuit
        self.shots = shots
        self.my_job = None

    @requires_submit
    def result(self, timeout=None):
        return self.my_job.result(timeout=timeout)

    def submit(self):
        backend = Aer.get_backend('aer_simulator')
        self.my_job = backend.run(self.circuit, shots = self.shots)

    @requires_submit
    def cancel(self):
        return self.my_job.cancel()

    @requires_submit
    def status(self):
        return self.my_job.status()"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017, 2018.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
# Copyright 2021 Dell (www.dell.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from qiskit_aer import Aer
from qiskit.providers.exceptions import QiskitBackendNotFoundError
# from qiskit import IBMQ

from .emulator_backend import EmulatorBackend

class LocalSubProviderManager():
    def __init__(self, provider):
        self._provider = provider
        self._init_backends()
            
    def _init_backends(self):
        self._backends = [Aer.get_backend('aer_simulator')]
        self._backends.append(EmulatorBackend(self._provider))

        # for sub_provider in self.sub_providers:
            # self._backends += sub_provider.backends()
        
        self._backends_by_name = {}
        for backend in self._backends:
            self._backends_by_name[backend.name] = backend


    def backends(self):
        return self._backends

    def get_backend(self, name=None, **kwargs):
        if name not in self._backends_by_name:
            raise QiskitBackendNotFoundError(""No backend matches criteria."")
        else:
            return self._backends_by_name[name]



    
"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"from dell_runtime import DellRuntimeProvider
from qiskit import QuantumCircuit

RUNTIME_PROGRAM = """"""
# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    **kwargs,
):
    circuits = transpile(
        circuits,
    )

    if not isinstance(circuits, list):
        circuits = [circuits]

    # Compute raw results
    result = backend.run(circuits, **kwargs).result()

    user_messenger.publish(result.to_dict(), final=True)
""""""

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

# PROGRAM_PREFIX = 'qiskit-test'

def main():
    provider = DellRuntimeProvider()
    program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
    
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure([0, 1], [0, 1])

    program_inputs = {
        'circuits': qc,
    }

    runtime_program = provider.runtime.program(program_id)

    
    job = provider.runtime.run(program_id, options=None, inputs=program_inputs)

    job.result(timeout=120)
    

if __name__ == ""__main__"":
    main()
"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"from dell_runtime import DellRuntimeProvider
from qiskit import QuantumCircuit
import os

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

# PROGRAM_PREFIX = 'qiskit-test'

def main():
    provider = DellRuntimeProvider()
    here = os.path.dirname(os.path.realpath(__file__))
    program_id = provider.runtime.upload_program(here + ""/dirtest"", metadata=RUNTIME_PROGRAM_METADATA)
    
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure([0, 1], [0, 1])

    program_inputs = {
        'circuits': qc,
    }

    job = provider.runtime.run(program_id, options=None, inputs=program_inputs)

    job.result(timeout=120)
    

if __name__ == ""__main__"":
    main()
"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017, 2018.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
# Copyright 2021 Dell (www.dell.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import unittest
import os
import json
import logging

# from ..dell_runtime.emulation_executor import EmulationExecutor
from dell_runtime import EmulationExecutor

RUNTIME_PROGRAM = """"""
import random

from qiskit import transpile
from qiskit.circuit.random import random_circuit

def prepare_circuits(backend):
    circuit = random_circuit(num_qubits=5, depth=4, measure=True,
                            seed=random.randint(0, 1000))
    return transpile(circuit, backend)

def main(backend, user_messenger, **kwargs):
    iterations = kwargs['iterations']
    interim_results = kwargs.pop('interim_results', {})
    final_result = kwargs.pop(""final_result"", {})
    for it in range(iterations):
        qc = prepare_circuits(backend)
        user_messenger.publish({""iteration"": it, ""interim_results"": interim_results})
        backend.run(qc).result()

    user_messenger.publish(final_result, final=True)
""""""
logger = logging.getLogger(__name__)

class EmulationExecutorTest(unittest.TestCase):
    def test_pre_post_run(self):
        try:
            executor = EmulationExecutor(program=None, program_data=(RUNTIME_PROGRAM, ""STRING""))
            self.assertIsNotNone(executor)

            executor._pre_run()
            self.assertTrue(os.path.isdir(executor.temp_dir()))

            program_path = os.path.join(executor.temp_dir(), ""program.py"")
            self.assertTrue(os.path.isfile(program_path))

            with open(program_path, ""r"") as program_file:
                program_text = program_file.read()
                self.assertEqual(RUNTIME_PROGRAM, program_text)

            executor_path = os.path.join(executor.temp_dir(), ""executor.py"")
            self.assertTrue(os.path.isfile(executor_path))

        finally:
            executor._post_run()
            self.assertFalse(os.path.isdir(executor.temp_dir()))

        
    


        

        "
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017, 2018.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
# Copyright 2021 Dell (www.dell.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import unittest
from qiskit import QuantumCircuit, execute, transpile
from dell_runtime import BackendProvider
from qiskit.providers import JobStatus
from time import sleep

class ProviderTest(unittest.TestCase):
    def test_job_submission(self):
        provider = BackendProvider()
        self.assertIsNotNone(provider)
        
        backend = provider.get_backend(name=""aer_simulator"")
        self.assertIsNotNone(backend)

        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])
        job = backend.run(qc, shots=1) 
        self.assertIsNotNone(job)
        # self.assertNotEqual(JobStatus.DONE, job.status())
        
        count = 0
        # 5 second
        max = 50 
        while count < max and job.status() != JobStatus.DONE:
            count += 1
            sleep(0.1)
        self.assertEqual(JobStatus.DONE, job.status())

        job.result()


    def test_execute(self):
        provider = BackendProvider()
        self.assertIsNotNone(provider)
        
        backend = provider.get_backend(name=""aer_simulator"")
        self.assertIsNotNone(backend)

        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])
        job = execute(qc, backend, shots=2)
        self.assertIsNotNone(job)

        count = 0
        # 5 second
        max = 50 
        while count < max and job.status() != JobStatus.DONE:
            count += 1
            sleep(0.1)
        self.assertEqual(JobStatus.DONE, job.status())

    def test_get_counts(self):
        provider = BackendProvider()
        self.assertIsNotNone(provider)
        
        backend = provider.get_backend(name=""aer_simulator"")
        self.assertIsNotNone(backend)

        circ = QuantumCircuit(2)
        circ.h(0)
        circ.cx(0, 1)
        circ.measure_all()

        # Transpile for simulator
        circ = transpile(circ, backend)

        # Run and get counts
        result = backend.run(circ).result()
        counts = result.get_counts(circ)
        total = counts.get('11') + counts.get('00')
        self.assertEqual(total, 1024)

"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017, 2018.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
# Copyright 2021 Dell (www.dell.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from dell_runtime import DellRuntimeProvider
import unittest
from dell_runtime import LocalUserMessengerClient
from dell_runtime import EmulatorRuntimeJob, EmulationExecutor
from qiskit import QuantumCircuit, execute, transpile
from time import sleep
import logging

# RUNTIME_PROGRAM = """"""
# import random

# from qiskit import transpile
# from qiskit.circuit.random import random_circuit

# def prepare_circuits(backend):
#     circuit = random_circuit(num_qubits=5, depth=4, measure=True,
#                             seed=random.randint(0, 1000))
#     return transpile(circuit, backend)

# def main(backend, user_messenger, **kwargs):
#     iterations = kwargs['iterations']
#     interim_results = kwargs.pop('interim_results', {})
#     final_result = kwargs.pop(""final_result"", {})
#     for it in range(iterations):
#         qc = prepare_circuits(backend)
#         user_messenger.publish({""iteration"": it, ""interim_results"": interim_results})
#         backend.run(qc).result()

#     user_messenger.publish(final_result, final=True)
# """"""
RUNTIME_PROGRAM = """"""
from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    **kwargs,
):

    user_messenger.publish({'results': 'intermittently'})

    circuits = transpile(
        circuits,
    )

    if not isinstance(circuits, list):
        circuits = [circuits]

    # Compute raw results
    result = backend.run(circuits, **kwargs).result()

    user_messenger.publish({'results': 'finally'})
    user_messenger.publish(result.to_dict(), final=True)
    print(""job complete successfully"")
""""""

FAIL_PROGRAM = """"""
from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    **kwargs,
):

    raise Exception('test failure')
""""""

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

logger = logging.getLogger(__name__)

class EmulatorRuntimeJobTest(unittest.TestCase):
    def test_multiple_runtime_jobs(self):
        executor = EmulationExecutor(program=None, program_data=(RUNTIME_PROGRAM, ""STRING""), inputs = { ""iterations"": 2 })
        executor2 = EmulationExecutor(program=None, program_data=(RUNTIME_PROGRAM, ""STRING""), inputs = { ""iterations"": 2 })
        executor3 = EmulationExecutor(program=None, program_data=(RUNTIME_PROGRAM, ""STRING""), inputs = { ""iterations"": 2 })
        self.assertIsNotNone(executor)
        job = EmulatorRuntimeJob(""1"", None, executor=executor)
        job2 = EmulatorRuntimeJob(""1"", None, executor=executor2)
        job3 = EmulatorRuntimeJob(""1"", None, executor=executor3)
        sleep(1)        
        self.assertIsNotNone(job)
        job.cancel()
        job2.cancel()
        job3.cancel()
        # pdb.set_trace()
        sleep(1)
        status = job.status()
        self.assertEqual(status, ""Canceled"")

    def test_intermittent_results(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        # runtime_program = provider.runtime.program(program_id)
        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        
        result = job.result(timeout=120)
        messages = job.get_unread_messages()
        logger.debug(f'unread messages {messages}')
            
        self.assertEqual(len(messages), 2)
        self.assertEqual(""intermittently"", messages[0]['results'])
        self.assertEqual(""finally"", messages[1]['results'])

        messages = job.get_unread_messages()
        
        self.assertEqual(0, len(messages))

            
    def test_get_results(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        response = job.result(timeout=120)

        results = response['results'][0]

        self.assertIsNotNone(results)
        self.assertTrue(results['success'])
        self.assertTrue(results['success'])
        self.assertEqual(""DONE"", results['status'])

        shots = results['shots']
        count = results['data']['counts']['0x0']

        self.assertGreater(count, (0.45 * shots))
        self.assertLess(count, (0.55 * shots))

    

    def test_get_status(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        # runtime_program = provider.runtime.program(program_id)
        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        status = job.status()
        correct_status = status == ""Creating"" or status == ""Running""
        self.assertTrue(correct_status)
        job.result(timeout=120)
        status = job.status()

        max_try = 50
        attempt = 0
        while (status == ""Creating"" or status == ""Running"") and attempt < max_try:
            sleep(0.1)
            attempt += 1
            status = job.status()
            
        self.assertEqual(status, ""Completed"")

    def test_get_failed_status(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(FAIL_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)

        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        status = job.status()
        self.assertEqual(status, ""Creating"")
        
        max_try = 500
        attempt = 0
        while (status == ""Creating"" or status == ""Running"") and attempt < max_try:
            sleep(0.1)
            attempt += 1
            status = job.status()

        self.assertEqual(status, ""Failed"")

    def test_cancel_job(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        # runtime_program = provider.runtime.program(program_id)
        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        sleep(1)

        res = job.cancel()
        self.assertTrue(res)

        status = job.status()
        self.assertEqual(status, ""Canceled"")

    def test_callback_function(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)


        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
        }

        
        import sys
        import io
        old_stdout = sys.stdout
        new_stdout = io.StringIO()
        sys.stdout = new_stdout
        job = provider.runtime.run(program_id, options=None, inputs=program_inputs,callback=print)
        result =job.result(timeout=600)
        output = new_stdout.getvalue()
        sys.stdout = old_stdout
        
        self.assertTrue(""{'results': 'intermittently'}""
         in output)
"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017, 2018.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
# Copyright 2021 Dell (www.dell.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import unittest
from dell_runtime import DellRuntimeProvider
from qiskit.providers.ibmq.runtime import RuntimeProgram, RuntimeJob, ResultDecoder
from qiskit import QuantumCircuit
import os

RUNTIME_PROGRAM = """"""
import random

from qiskit import transpile
from qiskit.circuit.random import random_circuit

def prepare_circuits(backend):
    circuit = random_circuit(num_qubits=5, depth=4, measure=True,
                            seed=random.randint(0, 1000))
    return transpile(circuit, backend)

def main(backend, user_messenger, **kwargs):
    iterations = kwargs['iterations']
    interim_results = kwargs.pop('interim_results', {})
    final_result = kwargs.pop(""final_result"", {})
    for it in range(iterations):
        qc = prepare_circuits(backend)
        # user_messenger.publish({""iteration"": it, ""interim_results"": interim_results})
        backend.run(qc).result()

    user_messenger.publish(final_result, final=True)
""""""

RUNTIME_PROGRAM_METADATA = {
    ""description"": ""Test program"",
    ""max_execution_time"": 300,
    ""backend_requirements"": {""min_num_qubits"":  5},
    ""parameters"": [
        {""name"": ""param1"", ""description"": ""Some parameter."",
            ""type"": ""integer"", ""required"": True}
    ],
    ""return_values"": [
        {""name"": ""ret_val"", ""description"": ""Some return value."", ""type"": ""string""}
    ],
    ""interim_results"": [
        {""name"": ""int_res"", ""description"": ""Some interim result"", ""type"": ""string""},
    ],
    ""name"": ""qiskit-test"",
}

# PROGRAM_PREFIX = 'qiskit-test'

class EmulatorRuntimeServiceTest(unittest.TestCase):
    def test_upload(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
        proglist = provider.runtime.programs()
        self.assertIsNotNone(proglist[program_id])
        findProgId = False
        if program_id in proglist:
            findProgId = True
        self.assertTrue(findProgId)

    def test_runtime_backends(self):
        provider = DellRuntimeProvider()
        backends = provider.runtime.backends()
        self.assertGreater(len(backends), 1)

    def test_view_program(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)

        runtime_program = provider.runtime.program(program_id)
        self.assertEqual(runtime_program.description, ""Test program"")
        self.assertEqual(runtime_program.program_id, program_id)


    def test_run_program(self):
        provider = DellRuntimeProvider()
        self.assertIsNotNone(provider)
        self.assertIsNotNone(provider.runtime)

        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
        self.assertEqual(1, len(provider.runtime.programs()))

        runtime_program = provider.runtime.program(program_id)
        self.assertIsNotNone(runtime_program)
        try:
            job = provider.runtime.run(program_id, options=None, inputs={""iterations"": 2})

            result = job.result(timeout=120)
            self.assertIsNotNone(result)
        except Exception:
            self.fail(""should pass"")


    def test_programs(self):
        provider = DellRuntimeProvider()
        self.assertIsNotNone(provider)
        self.assertIsNotNone(provider.runtime)

        provider.runtime.upload_program(""fake-program1"", metadata=RUNTIME_PROGRAM_METADATA)
        provider.runtime.upload_program(""fake-program2"", metadata=RUNTIME_PROGRAM_METADATA)
        programs = provider.runtime.programs()
        self.assertEqual(len(programs), 2)

    
    def test_update_program(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)

        new_meta = {'description': 'Qiskit Test Update', 'max_execution_time': RUNTIME_PROGRAM_METADATA['max_execution_time']}

        updated = provider.runtime.update_program(program_id, name='Test Update', metadata=new_meta)

        self.assertTrue(updated)

        program2 = provider.runtime.program(program_id, refresh=True)

        self.assertEqual('Qiskit Test Update', program2.description)
        self.assertEqual('Test Update', program2.name)

    def test_pprint_programs(self):
        provider = DellRuntimeProvider()
        self.assertIsNotNone(provider)
        self.assertIsNotNone(provider.runtime)

        pr_id_1 = provider.runtime.upload_program(""fake-program1"", metadata=RUNTIME_PROGRAM_METADATA)
        import sys
        import io
        old_stdout = sys.stdout
        new_stdout = io.StringIO()
        sys.stdout = new_stdout
        provider.runtime.pprint_programs()
        output = new_stdout.getvalue()
        sys.stdout = old_stdout
        self.assertTrue(output.startswith( 
        '''==================================================
{}:
  Name: {}'''.format(pr_id_1,'qiskit-test')
        ))

    def test_has_service(self):
        provider = DellRuntimeProvider()
        self.assertTrue(provider.has_service('runtime'))
        self.assertFalse(provider.has_service('fake-service'))

    def test_metadata(self):
        provider = DellRuntimeProvider()
        
        pr_id = provider.runtime.upload_program(""fake-program1"", metadata=RUNTIME_PROGRAM_METADATA)
        program = provider.runtime.program(pr_id)
        self.assertEqual('qiskit-test', program.name)
        self.assertEqual(RUNTIME_PROGRAM_METADATA['description'], program.description)
        self.assertEqual(RUNTIME_PROGRAM_METADATA['max_execution_time'],
                            program.max_execution_time)
        self.assertEqual(RUNTIME_PROGRAM_METADATA['backend_requirements'],
                            program.backend_requirements)

    def test_circuit_runner(self):
        from . import circuit_runner as cr
        try:
            cr.main()
        except Exception as e:
            self.fail(""should pass"")

    def test_dir_circuit_runner(self):
        from . import dir_circuit_runner as dcr
        try:
            dcr.main()
        except Exception as e:
            self.fail(""should pass"")

    def test_upload_file(self):
        provider = DellRuntimeProvider()
        self.assertIsNotNone(provider)
        self.assertIsNotNone(provider.runtime)

        here = os.path.dirname(os.path.realpath(__file__))
        program_id = provider.runtime.upload_program(here + ""/dirtest/"", metadata=RUNTIME_PROGRAM_METADATA)
        self.assertEqual(1, len(provider.runtime.programs()))

        runtime_program = provider.runtime.program(program_id)
        self.assertIsNotNone(runtime_program)
        try:
            qc = QuantumCircuit(2, 2)
            qc.h(0)
            qc.cx(0, 1)
            qc.measure([0, 1], [0, 1])

            program_inputs = {
                'circuits': qc,
            }

            job = provider.runtime.run(program_id, options=None, inputs=program_inputs)

            result = job.result(timeout=120)
            self.assertIsNotNone(result)
        except Exception:
            self.fail(""should pass"")

    def test_reserved_names(self):
        provider = DellRuntimeProvider()
        self.assertIsNotNone(provider)
        self.assertIsNotNone(provider.runtime)

        try:
            here = os.path.dirname(os.path.realpath(__file__))
            program_id = provider.runtime.upload_program(here + ""/dirfail/"", metadata=RUNTIME_PROGRAM_METADATA)
            self.fail(""Should not allow upload"")
        except Exception:
            self.assertTrue(True)

    def test_delete_program(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)
        prog_list = provider.runtime.programs(refresh=False)

        self.assertTrue(len(prog_list) >= 1)

        deleted = provider.runtime.delete_program(program_id)

        self.assertTrue(deleted)

        new_prog_list = provider.runtime.programs(refresh=True)
        
        self.assertGreater(len(prog_list), len(new_prog_list))"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2017, 2018.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
# Copyright 2021 Dell (www.dell.com)
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from dell_runtime import DellRuntimeProvider
import unittest
from qiskit import QuantumCircuit, execute, transpile
from time import sleep
import logging

RUNTIME_PROGRAM = """"""
from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    **kwargs,
):

    user_messenger.publish({'results': 'intermittently'})

    circuits = transpile(
        circuits,
    )

    if not isinstance(circuits, list):
        circuits = [circuits]

    # Compute raw results
    result = backend.run(circuits, **kwargs).result()

    user_messenger.publish({'results': 'finally'})
    user_messenger.publish(result.to_dict(), final=True)
    print(""job complete successfully"")
""""""

FAIL_PROGRAM = """"""
from qiskit.compiler import transpile, schedule


def main(
    backend,
    user_messenger,
    circuits,
    **kwargs,
):

    raise Exception('test failure')
""""""

RUNTIME_PROGRAM_METADATA = {
    ""max_execution_time"": 600,
    ""description"": ""Qiskit test program""
}

logger = logging.getLogger(__name__)

class MultiLocalBackendTest(unittest.TestCase):

    def test_get_results_emulator_backend(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)

        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
            'backend_name': 'emulator'
        }

        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        response = job.result(timeout=120)

        results = response['results'][0]

        self.assertIsNotNone(results)
        self.assertTrue(results['success'])
        self.assertTrue(results['success'])
        self.assertEqual(""DONE"", results['status'])

        shots = results['shots']
        count = results['data']['counts']['0x0']

        self.assertGreater(count, (0.45 * shots))
        self.assertLess(count, (0.55 * shots))

    def test_get_results_aer_backend(self):
        provider = DellRuntimeProvider()
        program_id = provider.runtime.upload_program(RUNTIME_PROGRAM, metadata=RUNTIME_PROGRAM_METADATA)

        qc = QuantumCircuit(2, 2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure([0, 1], [0, 1])

        program_inputs = {
            'circuits': qc,
            'backend_name': 'aer_simulator'
        }

        job = provider.runtime.run(program_id, options=None, inputs=program_inputs)
        response = job.result(timeout=120)

        results = response['results'][0]

        self.assertIsNotNone(results)
        self.assertTrue(results['success'])
        self.assertTrue(results['success'])
        self.assertEqual(""DONE"", results['status'])

        shots = results['shots']
        count = results['data']['counts']['0x0']

        self.assertGreater(count, (0.45 * shots))
        self.assertLess(count, (0.55 * shots))"
https://github.com/qiskit-community/qiskit-dell-runtime,qiskit-community,"# This code is part of qiskit-runtime.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""The FeatureMap class.""""""

import json

import numpy as np

from qiskit import QuantumCircuit, QuantumRegister


class FeatureMap:
    """"""Mapping data with the feature map.""""""

    def __init__(self, feature_dimension, entangler_map=None):
        """"""
        Args:
            feature_dimension (int): number of features (twice the number of qubits for this
                encoding)
            entangler_map (list[list]): connectivity of qubits with a list of [source, target],
                or None for full entanglement. Note that the order in the list is the order of
                applying the two-qubit gate.

        Raises:
            ValueError: If the value of ``feature_dimension`` is odd.
        """"""

        if isinstance(feature_dimension, int):
            if feature_dimension % 2 == 0:
                self._feature_dimension = feature_dimension
            else:
                raise ValueError(""Feature dimension must be an even integer."")
        else:
            raise ValueError(""Feature dimension must be an even integer."")

        self._num_qubits = int(feature_dimension / 2)

        if entangler_map is None:
            self._entangler_map = [
                [i, j] for i in range(self._num_qubits) for j in range(i + 1, self._num_qubits)
            ]
        else:
            self._entangler_map = entangler_map

        self._num_parameters = self._num_qubits

    def construct_circuit(self, x=None, parameters=None, q=None, inverse=False, name=None):
        """"""Construct the feature map circuit.

        Args:
            x (numpy.ndarray): data vector of size feature_dimension
            parameters (numpy.ndarray): optional parameters in feature map
            q (QauntumRegister): the QuantumRegister object for the circuit
            inverse (bool): whether or not to invert the circuit
            name (str): The name to use for the constructed ``QuantumCircuit`` object

        Returns:
            QuantumCircuit: a quantum circuit transforming data x

        Raises:
            ValueError: If the input parameters or vector are invalid
        """"""

        if parameters is not None:
            if isinstance(parameters, (int, float)):
                raise ValueError(""Parameters must be a list."")
            if len(parameters) == 1:
                parameters = parameters * np.ones(self._num_qubits)
            else:
                if len(parameters) != self._num_parameters:
                    raise ValueError(
                        ""The number of feature map parameters must be {}."".format(
                            self._num_parameters
                        )
                    )

        if len(x) != self._feature_dimension:
            raise ValueError(
                ""The input vector must be of length {}."".format(self._feature_dimension)
            )

        if q is None:
            q = QuantumRegister(self._num_qubits, name=""q"")

        circuit = QuantumCircuit(q, name=name)

        for i in range(self._num_qubits):
            circuit.ry(-parameters[i], q[i])

        for source, target in self._entangler_map:
            circuit.cz(q[source], q[target])

        for i in range(self._num_qubits):
            circuit.rz(-2 * x[2 * i + 1], q[i])
            circuit.rx(-2 * x[2 * i], q[i])

        if inverse:
            return circuit.inverse()
        else:
            return circuit

    def to_json(self):
        """"""Return JSON representation of this object.

        Returns:
            str: JSON string representing this object.
        """"""
        return json.dumps(
            {""feature_dimension"": self._feature_dimension, ""entangler_map"": self._entangler_map}
        )

    @classmethod
    def from_json(cls, data):
        """"""Return an instance of this class from the JSON representation.

        Args:
            data (str): JSON string representing an object.

        Returns:
            FeatureMap: An instance of this class.
        """"""
        return cls(**json.loads(data))"
https://github.com/qiskit-community/qiskit_rng,qiskit-community,"# -*- coding: utf-8 -*-

# This code is part of Qiskit.
#
# (C) Copyright IBM 2020.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# (C) Copyright CQC 2020.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the Programs
# directory of this source or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Module for random number generator.""""""

import logging
import pickle
import uuid
import os
from itertools import product
from typing import List, Tuple, Callable, Optional, Any, Union

from qiskit import QuantumCircuit, transpile, assemble
from qiskit.providers.basebackend import BaseBackend
from qiskit.providers.basejob import BaseJob
from qiskit.providers.ibmq.ibmqbackend import IBMQBackend
from qiskit.providers.ibmq.managed.ibmqjobmanager import IBMQJobManager, ManagedJobSet
from qiskit.providers.ibmq.accountprovider import AccountProvider

from .generator_job import GeneratorJob
from .utils import generate_wsr

try:
    from qiskit.providers.backend import Backend
    HAS_V2_BACKEND = True
except ImportError:
    HAS_V2_BACKEND = False

logger = logging.getLogger(__name__)


class Generator:
    """"""Class for generating random numbers.

    You can use the :meth:`sample` method to run quantum circuits on a backend
    to generate random bits. When the circuit jobs finish and their results
    processed, you can examine the generated random bits as well as the
    bell values. An example of this flow::

        from qiskit import IBMQ
        from qiskit_rng import Generator

        provider = IBMQ.load_account()
        generator = Generator(backend=provider.backends.ibmq_valencia)
        output = generator.sample(num_raw_bits=1024).block_until_ready()
        print(""Mermin correlator value is {}"".format(output.mermin_correlator))
        print(""first 8 raw bits are {}"".format(output.raw_bits[:8]))

    Note that due to the way the circuits are constructed and executed, the resulting
    size of ``raw_bits`` might be slightly larger than the input ``num_raw_bits``.

    The bits generated by the :meth:`sample` method are only weakly random. You
    will need to apply a randomness extractor to this output in order to obtain
    a more uniformly distributed string of random bits.
    """"""

    _file_prefix = ""qiskit_rng""
    _job_tag = 'qiskit_rng'

    def __init__(
            self,
            backend: BaseBackend,
            wsr_generator: Optional[Callable] = None,
            noise_model: Any = None,
            save_local: bool = False
    ) -> None:
        """"""Generator constructor.

        Args:
            backend: Backend to use for generating random numbers.
            wsr_generator: Function used to generate WSR. It must take the
                number of bits as the input and a list of random bits (0s and 1s)
                as the output. If ``None``, :func:`qiskit_rng.generate_wsr` is used.
            noise_model: Noise model to use. Only applicable if `backend` is a
                simulator.
            save_local: If ``True``, the generated WSR and other metadata is
                saved into a pickle file in the local directory. The file can
                be used to recover and resume a sampling if needed.
                The file name will be in the format of
                ``qiskit_rng_<backend>_<num_raw_bits>_<id>``.
                The file will be deleted automatically when the corresponding
                :meth:`GeneratorJob.block_until_ready()` method is invoked.
                Only supported if `backend` is an ``IBMQBackend``.
        """"""
        self.backend = backend
        self.job_manager = IBMQJobManager()
        self.wsr_generator = wsr_generator or generate_wsr
        self.noise_model = noise_model
        self.save_local = save_local

    def sample(
            self,
            num_raw_bits: int
    ) -> GeneratorJob:
        """"""Use the target system to generate raw bit strings.

        Args:
            num_raw_bits: Number of raw bits to sample. Note that the raw
                bits are only weakly random and needs to go through extraction
                to generate highly random output.

        Returns:
            A :class:`GeneratorJob` instance that contains all the information
                needed to extract randomness.

        Raises:
            ValueError: If an input argument is invalid.
        """"""
        if not isinstance(self.backend, BaseBackend) and \
                (HAS_V2_BACKEND and not isinstance(self.backend, Backend)):
            raise ValueError(""Backend needs to be a Qiskit `BaseBackend` or `Backend` instance."")

        max_shots = self.backend.configuration().max_shots
        num_raw_bits_qubit = int((num_raw_bits + 2)/3)
        if num_raw_bits_qubit <= max_shots:
            shots = num_raw_bits_qubit
            num_circuits = 1
        else:
            num_circuits = int((num_raw_bits_qubit + max_shots - 1)/max_shots)
            shots = int((num_raw_bits_qubit + num_circuits - 1)/num_circuits)

        logger.debug(""Using %s circuits with %s shots each"", num_circuits, shots)

        initial_wsr = self.wsr_generator(num_circuits * 3)

        wsr_bits = self._get_wsr(num_circuits, initial_wsr)
        circuits = self._generate_all_circuits(num_circuits, wsr_bits)

        job = self._run_circuits(circuits, shots)
        saved_fn = None
        if self.save_local and isinstance(self.backend, IBMQBackend):
            saved_fn = self._save_local(num_raw_bits, wsr_bits, job, shots)
        return GeneratorJob(
            initial_wsr=initial_wsr,
            wsr=wsr_bits,
            job=job,
            shots=shots,
            saved_fn=saved_fn
        )

    def _run_circuits(
            self,
            circuits: List[QuantumCircuit],
            shots: int
    ) -> Union[ManagedJobSet, BaseJob]:
        """"""Run circuits on a backend.

        Args:
            circuits: Circuits to run.
            shots: Number of shots.

        Returns:
            An IBMQ managed job set or a job.
        """"""
        transpiled = transpile(circuits, backend=self.backend, optimization_level=2)
        transpiled = [transpiled] if not isinstance(transpiled, list) else transpiled

        if isinstance(self.backend, IBMQBackend):
            job = self.job_manager.run(transpiled, backend=self.backend, shots=shots,
                                       job_tags=[self._job_tag], memory=True)
            logger.info(""Jobs submitted to %s. Job set ID is %s."", self.backend, job.job_set_id())
        else:
            job = self.backend.run(assemble(transpiled, backend=self.backend, shots=shots,
                                            memory=True, noise_model=self.noise_model))
            logger.info(""Jobs submitted to %s. Job ID is %s."", self.backend, job.job_id())

        return job

    def _get_wsr(self, num_circuits: int, initial_wsr: List[int]) -> List:
        """"""Obtain the weak source of randomness bits used to generate circuits.

        Args:
            num_circuits: Number of circuits.
            initial_wsr: Raw WSR bits used to generate the output WSR.

        Returns:
            A list the size of `num_circuits`. Each element in the
                list is another list of 3 binary numbers.
                For example,
                [ [1, 0, 0], [0, 1, 1], [1, 1, 0], ...]
        """"""
        output_wsr = []
        for i in range(num_circuits):
            output_wsr.append(
                [int(initial_wsr[3*i]), int(initial_wsr[3*i+1]), int(initial_wsr[3*i+2])])

        return output_wsr

    def _generate_circuit(self, label: Tuple[int, int, int]) -> QuantumCircuit:
        """"""Generate a circuit based on the input label.

        The size of the input label determines the number of qubits.
        An ``sdg`` is added to the circuit for the qubit if the corresponding
        label value is a ``1``.

        Args:
            label: Label used to determine how the circuit is to be constructed.
                A tuple of 1s and 0s.

        Returns:
            Constructed circuit.
        """"""
        num_qubit = len(label)
        qc = QuantumCircuit(num_qubit, num_qubit)
        qc.h(0)
        for i in range(1, num_qubit):
            qc.cx(0, i)
        qc.s(0)
        qc.barrier()
        for i in range(num_qubit):
            if label[i] == 1:
                qc.sdg(i)
        for i in range(num_qubit):
            qc.h(i)
        qc.measure(qc.qregs[0], qc.cregs[0])
        return qc

    def _generate_all_circuits(self, num_circuits: int, wsr_bits: List) -> List[QuantumCircuit]:
        """"""Generate all circuits based on input WSR bits.

        Args:
            num_circuits: Number of circuits to generate.
            wsr_bits: WSR bits used to determine which circuits to use.

        Returns:
            A list of generated circuits.
        """"""
        # Generate 3-qubit circuits for each of the 8 permutations.
        num_qubits = 3
        labels = list(product([0, 1], repeat=num_qubits))

        # Generate base circuits.
        circuits = []
        for label in labels:
            circuits.append(self._generate_circuit(label))

        # Construct final circuits using input WSR bits.
        final_circuits = []
        for i in range(num_circuits):
            wsr_set = wsr_bits[i]    # Get the 3-bit value.
            final_circuits.append(circuits[labels.index(tuple(wsr_set))])

        return final_circuits

    def _save_local(
            self,
            num_raw_bits: int,
            wsr_bits: List,
            job: Union[ManagedJobSet, BaseJob],
            shots: int
    ) -> str:
        """"""Save context information for the sampling.

        Args:
            num_raw_bits: Number of raw bits requested.
            wsr_bits: WSR bits to save.
            job: Job whose ID is to be saved.
            shots: Number of shots.

        Returns:
            Name of the file with saved data.
        """"""
        file_prefix = ""{}_{}_{}_"".format(
            self._file_prefix, self.backend.name(), num_raw_bits)
        file_name = file_prefix + str(uuid.uuid4())[:4]
        while os.path.exists(file_name):
            file_name = file_prefix + str(uuid.uuid4())[:4]

        data = {""wsr"": wsr_bits, ""shots"": shots}
        if isinstance(job, ManagedJobSet):
            data[""job_id""] = job.job_set_id()
            data[""job_type""] = ""jobset""
        else:
            data[""job_id""] = job.job_id()
            data[""job_type""] = ""job""
        with open(file_name, 'wb') as file:
            pickle.dump(data, file)
        return file_name

    @classmethod
    def recover(cls, file_name: str, provider: AccountProvider) -> GeneratorJob:
        """"""Recover a previously saved sampling run.

        Args:
            file_name: Name of the file containing saved context.
            provider: Provider used to do the sampling.

        Returns:
            Recovered output of the original :meth:`sample` call.
        """"""
        with open(file_name, 'rb') as file:
            data = pickle.load(file)
        job_id = data['job_id']
        job_type = data['job_type']
        if job_type == ""jobset"":
            job = IBMQJobManager().retrieve_job_set(job_id, provider)
        else:
            job = provider.backends.retrieve_job(job_id)

        return GeneratorJob(
            initial_wsr=[],
            wsr=data['wsr'],
            job=job,
            shots=data[""shots""],
            saved_fn=file_name
        )
"
https://github.com/Qiskit/qiskit-qasm3-import,Qiskit,"import qiskit_qasm3_import

project = 'Qiskit OpenQASM 3 Importer'
copyright = '2022, Jake Lishman'
author = 'Jake Lishman'
version = qiskit_qasm3_import.__version__
release = qiskit_qasm3_import.__version__

extensions = [
    ""sphinx.ext.autodoc"",
    ""sphinx.ext.intersphinx"",
    ""reno.sphinxext"",
    'qiskit_sphinx_theme',
]
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']

# Document the docstring for the class and the __init__ method together.
autoclass_content = ""both""

html_theme = ""qiskit-ecosystem""
html_title = f""{project} {release}""

intersphinx_mapping = {
    ""qiskit-terra"": (""https://docs.quantum.ibm.com/api/qiskit/"", None),
}
"
https://github.com/Qiskit/qiskit-qasm3-import,Qiskit,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2024.
#
# This code is licensed under the Apache License, Version 2.0. You may obtain a copy of this license
# in the LICENSE.txt file in the root directory of this source tree or at
# http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this copyright notice, and modified
# files need to carry a notice indicating that they have been altered from the originals.

import openqasm3
from qiskit import QuantumCircuit

from .converter import ConvertVisitor


def convert(node: openqasm3.ast.Program) -> QuantumCircuit:
    """"""Convert a parsed OpenQASM 3 program in AST form, into a Qiskit
    :class:`~qiskit.circuit.QuantumCircuit`.""""""
    return ConvertVisitor().convert(node).circuit


def parse(string: str, /) -> QuantumCircuit:
    """"""Wrapper around :func:`.convert`, which first parses the OpenQASM 3 program into AST form, and
    then converts the output to Qiskit format.""""""
    return convert(openqasm3.parse(string))
"
https://github.com/qiskit-community/prototype-zne,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022-2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

from collections.abc import Sequence
from itertools import count, product
from unittest.mock import Mock

from numpy import array
from pytest import fixture, mark, raises, warns
from qiskit import QuantumCircuit
from qiskit.circuit.random import random_circuit
from qiskit.primitives import EstimatorResult

from zne.extrapolation import Extrapolator, LinearExtrapolator
from zne.noise_amplification import NoiseAmplifier
from zne.noise_amplification.folding_amplifier import MultiQubitAmplifier
from zne.zne_strategy import ZNEStrategy

from . import NO_ITERS_NONE, NO_NONE


################################################################################
## FIXTURES
################################################################################
@fixture(scope=""function"")
def amplifier_mock():
    """"""NoiseAmplifier mock object.""""""
    amplifier = Mock(NoiseAmplifier)
    amplifier.amplify_circuit_noise.side_effect = count()
    return amplifier


@fixture(scope=""function"")
def extrapolator_mock():
    """"""Extrapolator mock object.""""""

    def infer(target, data):
        _, y, _ = zip(*data)
        return 1, 0, {}

    extrapolator = Mock(Extrapolator)
    extrapolator.infer.side_effect = infer
    return extrapolator


################################################################################
## TESTS
################################################################################
def test_definition():
    assert ZNEStrategy._DEFINING_ATTRS == (
        ""noise_factors"",
        ""noise_amplifier"",
        ""extrapolator"",
    )


class TestInit:
    """"""Test ZNEStrategy initialization logic.""""""

    def test_defaults(self):
        """"""Test default configuration.""""""
        assert ZNEStrategy().noise_amplifier == MultiQubitAmplifier()
        assert ZNEStrategy().noise_factors == (1,)
        assert ZNEStrategy().extrapolator == LinearExtrapolator()

    @mark.parametrize(
        ""noise_factors"",
        [(1,), (1, 3), (1, 3, 5)],
    )
    def test_custom(
        self,
        noise_factors,
    ):
        """"""Test custom configuration.

        Proper inputs can be assumed since validation is tested separately.
        """"""
        noise_amplifier = Mock(NoiseAmplifier)
        extrapolator = Mock(Extrapolator)
        zne_strategy = ZNEStrategy(
            noise_factors=noise_factors,
            noise_amplifier=noise_amplifier,
            extrapolator=extrapolator,
        )
        assert zne_strategy.noise_factors == noise_factors
        assert zne_strategy.noise_amplifier is noise_amplifier
        assert zne_strategy.extrapolator is extrapolator


@mark.parametrize(
    ""noise_factors"",
    [(1,), (1, 3), (1, 3, 5)],
)
class TestMagic:
    """"""Test generic ZNEStrategy magic methods.""""""

    def test_repr(self, noise_factors):
        """"""Test ZNEStrategy.__repr__() magic method.""""""
        noise_amplifier = Mock(NoiseAmplifier)
        extrapolator = Mock(Extrapolator)
        zne_strategy = ZNEStrategy(
            noise_factors=noise_factors,
            noise_amplifier=noise_amplifier,
            extrapolator=extrapolator,
        )
        expected = ""ZNEStrategy(""
        expected += f""noise_factors={repr(noise_factors)}, ""
        expected += f""noise_amplifier={repr(noise_amplifier)}, ""
        expected += f""extrapolator={repr(extrapolator)})""
        assert repr(zne_strategy) == expected

    def test_eq(self, noise_factors):
        """"""Test ZNEStrategy.__eq__() magic method.""""""
        noise_amplifier = Mock(NoiseAmplifier)
        extrapolator = Mock(Extrapolator)
        zne_strategy = ZNEStrategy(
            noise_factors=noise_factors,
            noise_amplifier=noise_amplifier,
            extrapolator=extrapolator,
        )
        assert zne_strategy == ZNEStrategy(
            noise_factors=noise_factors,
            noise_amplifier=noise_amplifier,
            extrapolator=extrapolator,
        )
        assert zne_strategy != ZNEStrategy(
            noise_factors=(*noise_factors, 707),
            noise_amplifier=noise_amplifier,
            extrapolator=extrapolator,
        )
        assert zne_strategy != ZNEStrategy(
            noise_factors=noise_factors,
            noise_amplifier=Mock(NoiseAmplifier),
            extrapolator=extrapolator,
        )
        assert zne_strategy != ZNEStrategy(
            noise_factors=noise_factors,
            noise_amplifier=noise_amplifier,
            extrapolator=Mock(Extrapolator),
        )
        assert zne_strategy != ""zne_strategy""

    def test_bool(self, noise_factors):
        noise_amplifier = Mock(NoiseAmplifier)
        extrapolator = Mock(Extrapolator)
        zne_strategy = ZNEStrategy(
            noise_factors=noise_factors,
            noise_amplifier=noise_amplifier,
            extrapolator=extrapolator,
        )
        truth_value = not zne_strategy.is_noop
        assert bool(zne_strategy) is truth_value


class TestConstructors:
    """"""Test ZNEStrategy constructors.""""""

    def test_noop(self):
        zne_strategy = ZNEStrategy.noop()
        assert zne_strategy.is_noop


class TestNoiseFactors:
    """"""Test ZNEStrategy `noise_factors` property.""""""

    def test_default(self):
        zne_strategy = ZNEStrategy()
        zne_strategy.noise_factors = None
        assert zne_strategy.noise_factors == (1,)

    @mark.parametrize(
        ""noise_factors"",
        cases := [(1,), (3,), (1, 3), (1, 3, 5), [1, 3, 5], [1.2, 3, 5.4]],
        ids=[f""{nf}"" for nf in cases],
    )
    def test_dispatch(self, noise_factors):
        """"""Test proper noise factors of different types.""""""
        zne_strategy = ZNEStrategy()
        zne_strategy.noise_factors = noise_factors
        assert zne_strategy.noise_factors == tuple(noise_factors)

    @mark.parametrize(
        ""noise_factors, expected"",
        cases := list(
            zip(
                [(1, 5, 3), (3.3, 1.2, 5.4)],
                [(1, 3, 5), (1.2, 3.3, 5.4)],
            )
        ),
        ids=[f""{nf}"" for nf, _ in cases],
    )
    def test_sort(self, noise_factors, expected):
        """"""Test unsorted noise factors.""""""
        zne_strategy = ZNEStrategy()
        with warns(UserWarning):
            zne_strategy.noise_factors = noise_factors
        assert zne_strategy.noise_factors == expected

    @mark.parametrize(
        ""noise_factors, expected"",
        cases := list(
            zip(
                [(1, 1), (1, 3, 1, 5), (5, 5, 3), (2.4, 2.4)],
                [(1,), (1, 3, 5), (3, 5), (2.4,)],
            )
        ),
        ids=[f""{nf}"" for nf, _ in cases],
    )
    def test_duplicates(self, noise_factors, expected):
        """"""Test duplicate noise factors.""""""
        zne_strategy = ZNEStrategy()
        with warns(UserWarning):
            zne_strategy.noise_factors = noise_factors
        assert zne_strategy.noise_factors == expected

    @mark.parametrize(
        ""noise_factors"",
        cases := NO_ITERS_NONE,
        ids=[f""{type(c)}"" for c in cases],
    )
    def test_sequence(self, noise_factors):
        """"""Test type error is raised if noise factors are not Sequence.""""""
        zne_strategy = ZNEStrategy()
        with raises(TypeError):
            zne_strategy.noise_factors = noise_factors

    @mark.parametrize(
        ""noise_factors"",
        cases := [(), []],
        ids=[f""{type(c)}"" for c in cases],
    )
    def test_empty(self, noise_factors):
        """"""Test value error is raised for empty lists of noise factors.""""""
        zne_strategy = ZNEStrategy()
        with raises(ValueError):
            zne_strategy.noise_factors = noise_factors

    @mark.parametrize(
        ""noise_factors"",
        cases := [""1"", True, False, float(""NaN""), [1, 3, ""5""]],
        ids=[f""{type(c)}"" for c in cases],
    )
    def test_real(self, noise_factors):
        """"""Test type error is raised if noise factors are not real numbers.""""""
        if not isinstance(noise_factors, Sequence):
            noise_factors = [noise_factors]
        zne_strategy = ZNEStrategy()
        with raises(TypeError):
            zne_strategy.noise_factors = noise_factors

    @mark.parametrize(
        ""noise_factors"",
        cases := [0, 0.9999, -1, -0.5, (1, 0), (0.9, 1.2)],
        ids=[f""{c}"" for c in cases],
    )
    def test_geq_one(self, noise_factors):
        """"""Test value error is raised if any noise factor is less than one.""""""
        if not isinstance(noise_factors, Sequence):
            noise_factors = [noise_factors]
        zne_strategy = ZNEStrategy()
        with raises(ValueError):
            zne_strategy.noise_factors = noise_factors


class TestNoiseAmplifier:
    """"""Test ZNEStrategy `noise_amplifier` property.""""""

    def test_default(self):
        zne_strategy = ZNEStrategy()
        zne_strategy.noise_amplifier = None
        assert zne_strategy.noise_amplifier == MultiQubitAmplifier()

    @mark.parametrize(
        ""noise_amplifier"",
        cases := NO_NONE,
        ids=[f""{type(c)}"" for c in cases],
    )
    def test_type_error(self, noise_amplifier):
        """"""Test type error is raised if not `NoiseAmplifier`.""""""
        zne_strategy = ZNEStrategy()
        with raises(TypeError):
            zne_strategy.noise_amplifier = noise_amplifier


class TestExtrapolator:
    """"""Test ZNEStrategy `extrapolator` property.""""""

    def test_default(self):
        zne_strategy = ZNEStrategy()
        zne_strategy.extrapolator = None
        assert zne_strategy.extrapolator == LinearExtrapolator()

    @mark.parametrize(
        ""extrapolator"",
        cases := NO_NONE,
        ids=[f""{type(c)}"" for c in cases],
    )
    def test_type_error(self, extrapolator):
        """"""Test type error is raised if not `NoiseAmplifier`.""""""
        zne_strategy = ZNEStrategy()
        with raises(TypeError):
            zne_strategy.extrapolator = extrapolator


class TestProperties:
    """"""Test generic ZNEStrategy properties.""""""

    @mark.parametrize(""noise_factors"", [(1,), (1, 3), (1.2,), (2.1, 4.5)])
    def test_performs_noise_amplification(self, noise_factors):
        """"""Test if ZNEStrategy performs noise amplification.""""""
        zne_strategy = ZNEStrategy(noise_factors=noise_factors)
        truth_value = any(nf > 1 for nf in noise_factors)
        if truth_value:
            assert zne_strategy.performs_noise_amplification
        else:
            assert not zne_strategy.performs_noise_amplification

    @mark.parametrize(""noise_factors"", [(1,), (1, 3), (1.2,), (2.1, 4.5)])
    def test_performs_zne(self, noise_factors):
        """"""Test if ZNEStrategy performs zero noise extrapolation.""""""
        zne_strategy = ZNEStrategy(noise_factors=noise_factors)
        truth_value = any(nf > 1 for nf in noise_factors) and len(noise_factors) > 1
        if truth_value:
            assert zne_strategy.performs_zne
        else:
            assert not zne_strategy.performs_zne

    @mark.parametrize(""noise_factors"", [(1,), (1, 3), (1.2,), (2.1, 4.5)])
    def test_is_noop(self, noise_factors):
        """"""Test if ZNEStrategy is no-op.""""""
        zne_strategy = ZNEStrategy(noise_factors=noise_factors)
        truth_value = tuple(noise_factors) == (1,)
        if truth_value:
            assert zne_strategy.is_noop
        else:
            assert not zne_strategy.is_noop


class TestNoiseAmplification:
    """"""Test ZNEStrategy noise amplification logic.""""""

    def test_amplify_circuit_noise(self, amplifier_mock):
        noise_factors = (1, 2, 3)
        zne_strategy = ZNEStrategy(noise_factors=noise_factors, noise_amplifier=amplifier_mock)
        circuit = QuantumCircuit(2)
        assert zne_strategy.amplify_circuit_noise(circuit, 1) == 0
        amplifier_mock.amplify_circuit_noise.assert_called_once_with(circuit, 1)
        amplifier_mock.amplify_circuit_noise.reset_mock()
        assert zne_strategy.amplify_circuit_noise(circuit, 1.2) == 1
        amplifier_mock.amplify_circuit_noise.assert_called_once_with(circuit, 1.2)
        circuit.h(0)
        amplifier_mock.amplify_circuit_noise.reset_mock()
        assert zne_strategy.amplify_circuit_noise(circuit, 2.4) == 2
        amplifier_mock.amplify_circuit_noise.assert_called_once_with(circuit, 2.4)

    @mark.parametrize(
        ""circuits, noise_factors"",
        cases := tuple(
            product(
                [
                    random_circuit(1, 1, seed=0),
                    [],
                    [random_circuit(2, 2, seed=5)],
                    [random_circuit(2, 2, seed=66), random_circuit(2, 2, seed=1081)],
                ],
                [[1], [1, 3], [1, 3, 5]],
            )
        ),
        ids=[f""{type(c).__name__}<{len(c)}>-{nf}"" for c, nf in cases],
    )
    def test_build_noisy_circuits(self, amplifier_mock, circuits, noise_factors):
        zne_strategy = ZNEStrategy(noise_factors=noise_factors, noise_amplifier=amplifier_mock)
        _ = zne_strategy.build_noisy_circuits(circuits)
        if isinstance(circuits, QuantumCircuit):
            circuits = [circuits]
        assert amplifier_mock.amplify_circuit_noise.call_count == len(circuits) * len(noise_factors)
        for circuit in circuits:
            for noise_factor in noise_factors:
                amplifier_mock.amplify_circuit_noise.assert_any_call(circuit, noise_factor)

    @mark.parametrize(
        ""num_noise_factors, arg, expected"",
        cases := [
            (1, None, None),
            (1, 0, (0,)),
            (1, [0], (0,)),
            (1, [1], (1,)),
            (1, [2], (2,)),
            (1, [0, 1], (0, 1)),
            (1, [0, 2], (0, 2)),
            (1, [1, 2], (1, 2)),
            (1, [0, 1, 2], (0, 1, 2)),
            (2, None, None),
            (2, 0, (0, 0)),
            (2, [0], (0, 0)),
            (2, [1], (1, 1)),
            (2, [2], (2, 2)),
            (2, [0, 1], (0, 0, 1, 1)),
            (2, [0, 2], (0, 0, 2, 2)),
            (2, [1, 2], (1, 1, 2, 2)),
            (2, [0, 1, 2], (0, 0, 1, 1, 2, 2)),
            (3, None, None),
            (3, 0, (0, 0, 0)),
            (3, [0], (0, 0, 0)),
            (3, [1], (1, 1, 1)),
            (3, [2], (2, 2, 2)),
            (3, [0, 1], (0, 0, 0, 1, 1, 1)),
            (3, [0, 2], (0, 0, 0, 2, 2, 2)),
            (3, [1, 2], (1, 1, 1, 2, 2, 2)),
            (3, [0, 1, 2], (0, 0, 0, 1, 1, 1, 2, 2, 2)),
        ],
        ids=[f""noise<{nnf}>-{id}"" for nnf, id, _ in cases],
    )
    def test_map_to_noisy_circuits(self, num_noise_factors, arg, expected):
        zne_strategy = ZNEStrategy(noise_factors=[n for n in range(1, num_noise_factors + 1)])
        assert zne_strategy.map_to_noisy_circuits(arg) == expected


class TestExtrapolation:
    """"""Test ZNEStrategy extrapolation logic.""""""

    @mark.parametrize(
        ""noise_factors, values, variances, num_results, extrapolate_return"",
        [
            ([1, 2, 3], [1, 2, 3], [0, 0, 0], 1, [0, 1, {}]),
            ([1, 2, 3], [1, 2, 3], [0, 0, 0], 1, [0, 1, {""R2"": 0.1}]),
            ([1, 2, 3], [1, 2, 3], [0, 0, 0], 2, [0, 1, {}]),
            ([1, 2, 3], [1, 2, 3], [0, 0, 0], 3, [0, 1, {""R2"": 0.1, ""P"": 6.5}]),
        ],
    )
    def test_mitigate_noisy_result(
        self, noise_factors, values, variances, num_results, extrapolate_return
    ):
        val, err, meta = extrapolate_return
        extrapolator = Mock(Extrapolator)
        extrapolator.extrapolate_zero = Mock(return_value=tuple(extrapolate_return))
        zne_strategy = ZNEStrategy(noise_factors=noise_factors)
        zne_strategy.extrapolator = extrapolator
        metadata = [{""variance"": var, ""shots"": 1024} for var in variances]
        noisy_result = EstimatorResult(
            values=array(values * num_results), metadata=list(metadata * num_results)
        )
        result = zne_strategy.mitigate_noisy_result(noisy_result)
        assert result.values.tolist() == [val] * num_results
        metadatum = {
            ""noise_amplification"": {
                ""noise_amplifier"": zne_strategy.noise_amplifier,
                ""noise_factors"": tuple(noise_factors),
                ""values"": tuple(values),
                ""variance"": tuple(variances),
                ""shots"": tuple([md[""shots""] for md in metadata]),
            },
            ""extrapolation"": {
                ""extrapolator"": zne_strategy.extrapolator,
                **meta,
            },
        }
        assert result.metadata == [{""std_error"": err, ""zne"": metadatum} for _ in range(num_results)]

    @mark.parametrize(
        ""num_noise_factors, values, variances"",
        cases := [
            (1, [0], [0]),
            (1, [0, 1], [0, 1]),
            (2, [0, 0], [0, 0]),
            (2, [0, 0, 1, 1], [0, 0, 1, 1]),
            (3, [0, 0, 0], [0, 0, 0]),
            (3, [0, 0, 0, 1, 1, 1], [0, 0, 0, 1, 1, 1]),
        ],
        ids=[f""nf<{nnf}>-val<{len(val)}>"" for nnf, val, _ in cases],
    )
    def test_generate_noisy_result_groups(self, num_noise_factors, values, variances):
        zne_strategy = ZNEStrategy(noise_factors=range(1, num_noise_factors + 1))
        metadata = [{""variance"": var} for var in variances]
        result = EstimatorResult(values=array(values), metadata=metadata)
        assert (
            len(tuple(zne_strategy._generate_noisy_result_groups(result)))
            == len(values) / num_noise_factors
        )
        for i, group in enumerate(zne_strategy._generate_noisy_result_groups(result)):
            lower = num_noise_factors * i
            upper = num_noise_factors * (i + 1)
            assert group.values.tolist() == values[lower:upper]
            assert group.metadata == metadata[lower:upper]

    @mark.parametrize(
        ""num_noise_factors, num_experiments"",
        cases := [(2, 1), (2, 3), (3, 2), (3, 4)],
        ids=[f""nf{nnf}-val{ne}"" for nnf, ne in cases],
    )
    def test_generate_noisy_result_groups_value_error(self, num_noise_factors, num_experiments):
        zne_strategy = ZNEStrategy(noise_factors=range(1, num_noise_factors + 1))
        values = array([0] * num_experiments)
        metadata = [{""variance"": 0.0}] * num_experiments
        result = EstimatorResult(values=values, metadata=metadata)
        with raises(ValueError):
            generator = zne_strategy._generate_noisy_result_groups(result)
            assert next(generator)

    @mark.parametrize(
        ""noise_factors, values, std_errors"",
        [
            ([1, 2], [0, 1], [0, 0]),
            ([1, 2.0], [0.4, 1.2], [0, None]),
        ],
    )
    def test_regression_data_from_result_group(self, noise_factors, values, std_errors):
        zne_strategy = ZNEStrategy(noise_factors=noise_factors)
        metadatum = {""shots"": 1024}
        metadata = [
            {""variance"": err**2, **metadatum} if err is not None else metadatum
            for err in std_errors
        ]
        result_group = EstimatorResult(values=array(values), metadata=list(metadata))
        data = zne_strategy._regression_data_from_result_group(result_group)
        expected = (
            noise_factors,
            values,
            [1 for _ in noise_factors],
            [1 if err is None else err for err in std_errors],
        )
        for dat, exp in zip(data, expected):
            assert dat == exp

    @mark.parametrize(
        ""num_noise_factors, num_experiments"",
        cases := [(1, 2), (2, 1), (3, 1), (2, 3)],
        ids=[f""nf<{nnf}>-experiments<{ne}>"" for nnf, ne in cases],
    )
    def test_regression_data_from_result_group_value_error(
        self, num_noise_factors, num_experiments
    ):
        zne_strategy = ZNEStrategy(noise_factors=range(1, num_noise_factors + 1))
        values = [1] * num_experiments
        metadata = [{""variance"": 0}] * num_experiments
        result_group = EstimatorResult(values=array(values), metadata=list(metadata))
        with raises(ValueError):
            zne_strategy._regression_data_from_result_group(result_group)

    @mark.parametrize(
        ""noise_factors, values, metadata, extrapolation, expected_na"",
        [
            (
                [1, 2],
                [1, 1],
                [{""variance"": 0}, {""variance"": 0}],
                {},
                {""noise_factors"": (1, 2), ""values"": (1, 1), ""variance"": (0, 0)},
            ),
            (
                [1, 2],
                [1, 0],
                [{""variance"": 0.1}, {""variance"": 0.4}],
                {""R2"": 0.98},
                {""noise_factors"": (1, 2), ""values"": (1, 0), ""variance"": (0.1, 0.4)},
            ),
            (
                [1, 2, 3],
                [0, 1.5, 2.4],
                [
                    {""variance"": 0.11, ""shots"": 2048},
                    {""variance"": 0.1, ""shots"": 1024},
                    {""variance"": 0.12, ""shots"": 4096},
                ],
                {""R2"": 0.44, ""P"": 6.5},
                {
                    ""noise_factors"": (1, 2, 3),
                    ""values"": (0, 1.5, 2.4),
                    ""variance"": (0.11, 0.1, 0.12),
                    ""shots"": (2048, 1024, 4096),
                },
            ),
            (
                [1, 2, 3],
                [0, 1.5, 2.4],
                [
                    {""variance"": 0.11, ""shots"": 2048},
                    {""variance"": 0.1, ""shots"": 1024, ""backend"": ""ibmq-nugget""},
                    {""variance"": 0.12, ""shots"": 4096, ""seconds"": 3600},
                ],
                {""R2"": 0.44, ""P"": 6.5},
                {
                    ""noise_factors"": (1, 2, 3),
                    ""values"": (0, 1.5, 2.4),
                    ""variance"": (0.11, 0.1, 0.12),
                    ""shots"": (2048, 1024, 4096),
                    ""backend"": (None, ""ibmq-nugget"", None),
                    ""seconds"": (None, None, 3600),
                },
            ),
        ],
    )
    def test_build_zne_metadata(self, noise_factors, values, metadata, extrapolation, expected_na):
        zne_strategy = ZNEStrategy(noise_factors=noise_factors)
        result_group = EstimatorResult(values=array(values), metadata=list(metadata))
        computed = zne_strategy.build_zne_metadata(result_group, extrapolation)
        expected_na = {
            ""noise_amplifier"": zne_strategy.noise_amplifier,
            **expected_na,
        }
        expected_ex = {
            ""extrapolator"": zne_strategy.extrapolator,
            **extrapolation,
        }
        assert computed.get(""noise_amplification"") == expected_na
        assert computed.get(""extrapolation"") == expected_ex

    @mark.parametrize(
        ""num_noise_factors, num_experiments"",
        cases := [(1, 2), (2, 1), (3, 1), (2, 3)],
        ids=[f""nf<{nnf}>-experiments<{ne}>"" for nnf, ne in cases],
    )
    def test_build_zne_metadata_value_error(self, num_noise_factors, num_experiments):
        zne_strategy = ZNEStrategy(noise_factors=range(1, num_noise_factors + 1))
        values = array([1] * num_experiments)
        metadata = [{""variance"": 0}] * num_experiments
        result_group = EstimatorResult(values=values, metadata=metadata)
        with raises(ValueError):
            zne_strategy.build_zne_metadata(result_group)
"
https://github.com/qiskit-community/prototype-zne,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022-2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

from test import NO_INTS, NO_REAL, TYPES
from unittest.mock import Mock, patch

from numpy.random import Generator, default_rng
from pytest import fixture, mark, raises, warns
from qiskit import QuantumCircuit

from zne.noise_amplification.folding_amplifier.global_folding_amplifier import (
    GlobalFoldingAmplifier,
)
from zne.noise_amplification.folding_amplifier.local_folding_amplifier import (
    LocalFoldingAmplifier,
)

MOCK_TARGET_PATH = ""zne.noise_amplification.folding_amplifier.folding_amplifier.FoldingAmplifier""


@fixture(scope=""module"")
def patch_amplifier_with_multiple_mocks():
    def factory_method(**kwargs):
        return patch.multiple(MOCK_TARGET_PATH, **kwargs)

    return factory_method


@mark.parametrize(
    ""NoiseAmplifier"",
    (GlobalFoldingAmplifier, LocalFoldingAmplifier),
    ids=(""GlobalFoldingAmplifier"", ""LocalFoldingAmplifier""),
)
class TestFoldingAmplifier:
    @fixture(scope=""function"")
    def setter_mocks(self):
        mocks = {
            ""_set_sub_folding_option"": Mock(),
            ""_set_barriers"": Mock(),
            ""_prepare_rng"": Mock(),
            ""_set_noise_factor_relative_tolerance"": Mock(),
        }
        return mocks

    ################################################################################
    ## INIT TESTS
    ################################################################################

    def test_init_default_kwargs(
        self, NoiseAmplifier, patch_amplifier_with_multiple_mocks, setter_mocks
    ):
        with patch_amplifier_with_multiple_mocks(**setter_mocks):
            NoiseAmplifier()
        setter_mocks[""_set_sub_folding_option""].assert_called_once_with(""from_first"")
        setter_mocks[""_set_barriers""].assert_called_once_with(True)
        setter_mocks[""_prepare_rng""].assert_called_once_with(None)
        setter_mocks[""_set_noise_factor_relative_tolerance""].assert_called_once_with(1e-2)

    def test_init_custom_kwargs(
        self, NoiseAmplifier, patch_amplifier_with_multiple_mocks, setter_mocks
    ):
        with patch_amplifier_with_multiple_mocks(**setter_mocks):
            NoiseAmplifier(
                sub_folding_option=""random"",
                barriers=False,
                random_seed=1,
                noise_factor_relative_tolerance=1e-1,
            )
        setter_mocks[""_set_sub_folding_option""].assert_called_once_with(""random"")
        setter_mocks[""_set_barriers""].assert_called_once_with(False)
        setter_mocks[""_prepare_rng""].assert_called_once_with(1)
        setter_mocks[""_set_noise_factor_relative_tolerance""].assert_called_once_with(1e-1)

    ################################################################################
    ## PROPERTIES and SETTER TESTS
    ################################################################################

    @mark.parametrize(
        ""sub_folding_option"",
        cases := [""from_last"", ""from_first"", ""random""],
        ids=[f""{c}"" for c in cases],
    )
    def test_set_sub_folding_option(self, NoiseAmplifier, sub_folding_option):
        noise_amplifier = NoiseAmplifier()
        noise_amplifier._set_sub_folding_option(sub_folding_option)
        assert noise_amplifier.sub_folding_option == sub_folding_option

    @mark.parametrize(
        ""sub_folding_option"", [(t,) for t in TYPES], ids=[str(type(i).__name__) for i in TYPES]
    )
    def test_set_sub_folding_option_value_error(self, NoiseAmplifier, sub_folding_option):
        with raises(ValueError):
            NoiseAmplifier()._set_sub_folding_option(sub_folding_option)

    @mark.parametrize(
        ""random_seed"",
        cases := [1, 2],
        ids=[f""{c}"" for c in cases],
    )
    def test_prepare_rng(self, NoiseAmplifier, random_seed):
        noise_amplifier = NoiseAmplifier()
        noise_amplifier._prepare_rng(random_seed)
        assert isinstance(noise_amplifier._rng, Generator)
        rng = default_rng(random_seed)
        assert noise_amplifier._rng.bit_generator.state == rng.bit_generator.state

    @mark.parametrize(
        ""random_seed"", [(t,) for t in NO_INTS], ids=[str(type(i).__name__) for i in NO_INTS]
    )
    def test_prepare_rng_type_error(self, NoiseAmplifier, random_seed):
        with raises(TypeError):
            NoiseAmplifier()._prepare_rng(random_seed)

    @mark.parametrize(
        ""tolerance"",
        cases := [0.1, 0.01],
        ids=[f""{c}"" for c in cases],
    )
    def test_set_noise_factor_relative_tolerance(self, NoiseAmplifier, tolerance):
        noise_amplifier = NoiseAmplifier()
        noise_amplifier._set_noise_factor_relative_tolerance(tolerance)
        assert noise_amplifier._noise_factor_relative_tolerance == tolerance

    @mark.parametrize(
        ""tolerance"", [(t,) for t in NO_REAL], ids=[str(type(i).__name__) for i in NO_REAL]
    )
    def test_set_noise_factor_relative_tolerance_type_error(self, NoiseAmplifier, tolerance):
        with raises(TypeError):
            NoiseAmplifier()._set_noise_factor_relative_tolerance(tolerance)

    @mark.parametrize(""warn_user"", cases := [True, False], ids=[f""{c}"" for c in cases])
    def test_set_warn_user(self, NoiseAmplifier, warn_user):
        noise_amplifier = NoiseAmplifier()
        noise_amplifier.warn_user = warn_user
        assert noise_amplifier.warn_user == warn_user

    @mark.parametrize(
        ""warn_user"",
        cases := [t for t in TYPES if not isinstance(t, bool)],
        ids=[str(type(c).__name__) for c in cases],
    )
    def test_set_warn_user_type_error(self, NoiseAmplifier, warn_user):
        noise_amplifier = NoiseAmplifier()
        with raises(TypeError):
            noise_amplifier.warn_user = warn_user

    @mark.parametrize(
        ""barriers"", cases := [True, False, 1, 0, """", ""|""], ids=[f""{c}"" for c in cases]
    )
    def test_set_barriers(self, NoiseAmplifier, barriers):
        noise_amplifier = NoiseAmplifier()
        noise_amplifier._set_barriers(barriers)
        assert noise_amplifier.barriers is bool(barriers)

    ################################################################################
    ## TESTS
    ################################################################################

    @mark.parametrize(
        ""noise_factor"",
        cases := [1, 1.2, 2, 3.5],
        ids=[f""{c}"" for c in cases],
    )
    def test_validate_noise_factor(self, NoiseAmplifier, noise_factor):
        NoiseAmplifier()._validate_noise_factor(noise_factor)

    @mark.parametrize(
        ""noise_factor"",
        cases := [0, 0.5, -1, -2.5],
        ids=[f""{c}"" for c in cases],
    )
    def test_validate_noise_factor_value_error(self, NoiseAmplifier, noise_factor):
        with raises(ValueError):
            NoiseAmplifier()._validate_noise_factor(noise_factor)

    @mark.parametrize(
        ""folding, expected"",
        cases := tuple(
            zip(
                [0, 1, 2],
                [1, 3, 5],
            )
        ),
        ids=[f""{f}-{e}"" for f, e in cases],
    )
    def test_folding_to_noise_factor(self, NoiseAmplifier, folding, expected):
        assert NoiseAmplifier().folding_to_noise_factor(folding) == expected

    def test_warn_user_true(self, NoiseAmplifier):
        with warns(UserWarning):
            NoiseAmplifier().warn(""warning"")

    def test_warn_user_false(self, NoiseAmplifier):
        NoiseAmplifier(warn_user=False).warn(""no warning"")

    @mark.parametrize(
        ""num_instructions, noise_factor, expected"",
        cases := [
            (9, 1.2, (0, 1)),
            (9, 2, (0, 4)),
            (9, 3.6, (1, 3)),
            (9, 4, (1, 5)),
            (9, 17 / 3.0, (2, 3)),
            (9, 100, (49, 5)),
            (17, 1.2, (0, 2)),
            (17, 2, (0, 8)),
            (17, 3.6, (1, 5)),
            (17, 4, (1, 9)),
            (17, 100, (49, 9)),
        ],
        ids=[f""{ni}-{nf}-{cd}"" for ni, nf, cd in cases],
    )
    @mark.filterwarnings(""ignore::UserWarning"")
    def test_compute_folding_nums(self, NoiseAmplifier, num_instructions, noise_factor, expected):
        assert NoiseAmplifier()._compute_folding_nums(noise_factor, num_instructions) == expected

    @mark.parametrize(
        ""noise_factor"",
        cases := [1.5, 3.05],
        ids=[f""{c}"" for c in cases],
    )
    def test_compute_folding_nums_warning(self, NoiseAmplifier, noise_factor):
        with warns(UserWarning):
            assert NoiseAmplifier()._compute_folding_nums(noise_factor, 3)

    def test_compute_folding_no_foldings(self, NoiseAmplifier):
        with warns(UserWarning):
            assert NoiseAmplifier()._compute_folding_nums(3, 0) == (0, 0)

    @mark.parametrize(""registers"", [(), (0,), (1,), (0, 1)])
    def test_apply_barrier_true(self, NoiseAmplifier, registers):
        circuit = QuantumCircuit(2)
        original = circuit.copy()
        noise_amplifier = NoiseAmplifier(barriers=True)
        circuit = noise_amplifier._apply_barrier(circuit, *registers)
        last_instruction = circuit.data.pop()
        assert last_instruction.operation.name == ""barrier""
        registers = [circuit.qubits[r] for r in registers] or circuit.qubits
        assert last_instruction.qubits == tuple(registers)
        assert circuit == original

    @mark.parametrize(""registers"", [(), (0,), (1,), (0, 1)])
    def test_apply_barrier_false(self, NoiseAmplifier, registers):
        circuit = QuantumCircuit(2)
        original = circuit.copy()
        noise_amplifier = NoiseAmplifier(barriers=False)
        circuit = noise_amplifier._apply_barrier(circuit, *registers)
        assert circuit == original
"
https://github.com/qiskit-community/prototype-zne,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022-2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Type definitions for the Zero Noise Extrapolation (ZNE) Estimator class.""""""

from typing import Any, Dict, Sequence, Tuple, Union

from qiskit import QuantumCircuit

Metadata = Dict[str, Any]
EstimatorResultData = Dict[str, Union[float, Metadata]]
ParameterVector = Sequence[float]  # TODO: qiskit.circuit::ParameterVector
CircuitKey = tuple
NoiseFactor = float
ZNECacheKey = Tuple[CircuitKey, NoiseFactor]
ZNECache = Dict[ZNECacheKey, QuantumCircuit]
"
https://github.com/qiskit-community/prototype-zne,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022-2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Zero Noise Extrapolation (ZNE) strategy configuration dataclass.""""""

from __future__ import annotations

from collections.abc import Iterable, Iterator, Sequence
from math import sqrt
from typing import Any
from warnings import warn

from numpy import array
from qiskit import QuantumCircuit
from qiskit.primitives import EstimatorResult

from .extrapolation import Extrapolator, LinearExtrapolator
from .noise_amplification import MultiQubitAmplifier, NoiseAmplifier
from .types import EstimatorResultData, Metadata  # noqa: F401
from .utils.grouping import from_common_key, group_elements_gen, merge_dicts
from .utils.typing import isreal, normalize_array
from .utils.validation import quality


class ZNEStrategy:
    """"""Zero Noise Extrapolation strategy.

    Args:
        noise_factors: An list of real valued noise factors that determine by what amount the
            circuits' noise is amplified.
        noise_amplifier: A noise amplification strategy implementing the :class:`NoiseAmplifier`
            interface. A dictionary of currently available options can be imported as
            ``NOISE_AMPLIFIER_LIBRARY``.
        extrapolator: An extrapolation strategy implementing the :class:`Extrapolator`
            interface. A dictionary of currently available options can be imported as
            ``EXTRAPOLATOR_LIBRARY``.

    Raises:
        TypeError: If input does not match the type specification.
        ValueError: If noise factors are empty or less than one.
    """"""

    _DEFINING_ATTRS = (
        ""noise_factors"",
        ""noise_amplifier"",
        ""extrapolator"",
    )

    def __init__(
        self,
        noise_factors: Sequence[float] | None = None,
        noise_amplifier: NoiseAmplifier | None = None,
        extrapolator: Extrapolator | None = None,
    ) -> None:
        self.noise_factors = noise_factors
        self.noise_amplifier = noise_amplifier
        self.extrapolator = extrapolator

    def __repr__(self) -> str:
        attrs_str = "", "".join(
            f""{attr}={repr(getattr(self, attr))}"" for attr in self._DEFINING_ATTRS
        )
        return f""ZNEStrategy({attrs_str})""

    def __eq__(self, __o: object) -> bool:
        if not isinstance(__o, self.__class__):
            return False
        return all(getattr(self, attr) == getattr(__o, attr) for attr in self._DEFINING_ATTRS)

    def __bool__(self) -> bool:
        return not self.is_noop

    ################################################################################
    ## CONSTRUCTORS
    ################################################################################
    @classmethod
    def noop(cls) -> ZNEStrategy:
        """"""Construct a no-op ZNE strategy object.""""""
        return cls(noise_factors=(1,))

    ################################################################################
    ## PROPERTIES
    ################################################################################
    @quality(default=(1,))
    def noise_factors(self, noise_factors: Sequence[float]) -> tuple[float, ...]:
        """"""Noise factors for ZNE.

        Validation logic defined as required by `quality`.
        """"""
        if not isinstance(noise_factors, Sequence):
            raise TypeError(
                f""Expected `Sequence` noise factors, received `{type(noise_factors)}` instead.""
            )
        noise_factors = tuple(noise_factors)
        if not noise_factors:
            raise ValueError(""Noise factors must not be empty."")
        if not all(isreal(nf) for nf in noise_factors):
            raise TypeError(""Noise factors must be real valued."")
        if any(nf < 1 for nf in noise_factors):
            raise ValueError(""Noise factors must be greater than or equal to one."")

        unsorted_noise_factors = noise_factors
        noise_factors = tuple(sorted(noise_factors))
        if noise_factors != unsorted_noise_factors:
            warn(""Unordered noise factors detected and rearranged."", UserWarning, stacklevel=3)

        duplicate_noise_factors = noise_factors
        noise_factors = tuple(sorted(set(noise_factors)))
        if noise_factors != duplicate_noise_factors:
            warn(""Duplicate noise factors detected and erased."", UserWarning, stacklevel=3)

        return noise_factors

    @quality(default=MultiQubitAmplifier())
    def noise_amplifier(self, noise_amplifier: NoiseAmplifier) -> NoiseAmplifier:
        """"""Noise amplifier strategy for ZNE.

        Validation logic defined as required by `quality`.
        """"""
        if not isinstance(noise_amplifier, NoiseAmplifier):
            raise TypeError(
                f""Expected `NoiseAmplifier` object, received `{type(noise_amplifier)}` instead.""
            )
        return noise_amplifier

    @quality(default=LinearExtrapolator())
    def extrapolator(self, extrapolator: Extrapolator) -> Extrapolator:
        """"""Extrapoaltor strategy for ZNE.

        Validation logic defined as required by `quality`.
        """"""
        if not isinstance(extrapolator, Extrapolator):
            raise TypeError(
                f""Expected `Extrapolator` object, received `{type(extrapolator)}` instead.""
            )
        return extrapolator

    @property
    def num_noise_factors(self) -> int:
        """"""Number of noise factors.""""""
        return len(self.noise_factors)

    @property
    def performs_noise_amplification(self) -> bool:
        """"""Checks if noise amplification is performed.""""""
        return any(nf > 1 for nf in self.noise_factors)

    @property
    def performs_zne(self) -> bool:
        """"""Checks if zero noise extrapolation is performed.""""""
        return self.performs_noise_amplification and self.num_noise_factors > 1

    @property
    def is_noop(self) -> bool:
        """"""Checks if strategy is no-op.""""""
        return not self.performs_noise_amplification and not self.performs_zne

    ################################################################################
    ## NOISE AMPLIFICATION
    ################################################################################
    def amplify_circuit_noise(self, circuit: QuantumCircuit, noise_factor: float) -> QuantumCircuit:
        """"""Noise amplification from :class:`~.noise_amplification.NoiseAmplifier`.

        Args:
            circuit: The original quantum circuit.
            noise_factor: The noise amplification factor by which to amplify the circuit noise.

        Returns:
            The noise amplified quantum circuit
        """"""
        # TODO: caching
        return self.noise_amplifier.amplify_circuit_noise(circuit, noise_factor)

    # TODO: decouple indexing logic depending on this method
    # TODO: add validation
    def build_noisy_circuits(
        self,
        original_circuits: Iterable[QuantumCircuit] | QuantumCircuit,
    ) -> tuple[QuantumCircuit, ...]:
        """"""Construct noisy circuits for all noise factors from original circuits.

        Args:
            original_circuits: a :class:`~qiskit.circuit.QuantumCircuit` or a collection of
                :class:`~qiskit.circuit.QuantumCircuit`.

        Returns:
            A tuple containing the noise amplified circuits.
        """"""

        def generate_noisy_circuits(
            original_circuits: Iterable[QuantumCircuit],
        ) -> Iterator[QuantumCircuit]:
            for circuit in original_circuits:  # type: QuantumCircuit
                for noise_factor in self.noise_factors:  # type: float
                    yield self.amplify_circuit_noise(circuit, noise_factor)

        if isinstance(original_circuits, QuantumCircuit):
            original_circuits = [original_circuits]
        return tuple(generate_noisy_circuits(original_circuits))

    # TODO: decouple indexing logic depending on this method
    def map_to_noisy_circuits(self, arg: Any) -> tuple | None:
        """"""Map arguments for original circuits to the corresponding arguments for noisy circuits.

        Args:
            arg: Additional non-circuit arguments such as observables or parameter values.

        Returns:
            A tuple of args corresponding to the noise amplified circuits or None.
        """"""
        if arg is None:
            return arg
        if not isinstance(arg, Iterable):
            arg = [arg]
        mapped_arg: list = []
        for element in arg:
            mapped_arg.extend(element for _ in range(self.num_noise_factors))
        return tuple(mapped_arg)

    ################################################################################
    ## EXTRAPOLATION
    ################################################################################
    # TODO: add validation
    def mitigate_noisy_result(self, noisy_result: EstimatorResult) -> EstimatorResult:
        """"""Parse results from noisy circuits to error mitigated results.

        Args:
            noisy_result: The unmitigated results.

        Returns:
            The mitigated results after performing zero-noise-extrapolation.
        """"""
        values: list[float] = []
        metadata: list[Metadata] = []
        for result_group in self._generate_noisy_result_groups(noisy_result):
            data = self._regression_data_from_result_group(result_group)
            val, err, meta = self.extrapolator.extrapolate_zero(*data)
            common_metadata: Metadata = {""std_error"": err}  # TODO: extract other common metadata
            zne_metadata: Metadata = self.build_zne_metadata(result_group, meta)
            values.append(val)
            metadata.append({**common_metadata, ""zne"": zne_metadata})
        return EstimatorResult(values=array(values), metadata=list(metadata))

    # TODO: decouple indexing logic depending on this method
    def _generate_noisy_result_groups(
        self, noisy_result: EstimatorResult
    ) -> Iterator[EstimatorResult]:
        """"""Generator function for grouping noisy results.

        Iteratively constructs an estimator result for each group of experiments containing
        the measurement results associated with every noise factor.

        Args:
            noisy_result: The estimator result with data from all the experiments performed.

        Yields:
            Estimator results grouping data for experiments with different noise factors,
            but same circuit-observable combinations.

        Raises:
            ValueError: If the number of performed experiments is not an integer multiple of
                the number of noise factors.
        """"""
        if len(noisy_result.values) % self.num_noise_factors != 0:
            raise ValueError(""Inconsistent number of noisy experiments and noise factors."")
        for group in group_elements_gen(
            [
                {""values"": v, ""metadata"": m}
                for v, m in zip(noisy_result.values, noisy_result.metadata)
            ],
            group_size=self.num_noise_factors,
        ):  # type: tuple[EstimatorResultData, ...]
            values, metadata = zip(*[data.values() for data in group])
            yield EstimatorResult(values=array(values), metadata=list(metadata))

    def _regression_data_from_result_group(
        self, result_group: EstimatorResult
    ) -> tuple[list[float], list[float], list[float], list[float]]:
        """"""Build regression data from noisy result group.

        Args:
            result_group: Estimator result grouping data for experiments with different
                noise factors, but same circuit-observable combinations.

        Returns:
            Regression data
        """"""
        if len(result_group.values) != self.num_noise_factors:
            raise ValueError(""Inconsistent number of noisy experiments and noise factors."")
        x_data = list(self.noise_factors)  # TODO: get actual noise factors achieved
        y_data = result_group.values.tolist()
        sigma_x = [1 for _ in x_data]
        sigma_y = [sqrt(md.get(""variance"", 1)) for md in result_group.metadata]
        return x_data, y_data, sigma_x, sigma_y  # type: ignore

    # TODO: add validation
    def build_zne_metadata(
        self, result_group: EstimatorResult, extrapolation: Metadata | None = None
    ) -> Metadata:
        """"""Build ZNE metadata from extrapolation data.

        Args:
            result_group: The grouped noisy results for a single mitigated result.
            extrapolation: extrapolation metadata entries to include (e.g. extrapolation).

        Returns:
            Dictionary containing ZNE metadata.

        Raises:
            ValueError: If the number of experiments does not match the number of noise factors.
        """"""
        if extrapolation is None:
            extrapolation = {}
        if len(result_group.values) != self.num_noise_factors:
            raise ValueError(""Inconsistent number of noisy experiments and noise factors."")
        noise_amplification: Metadata = {
            ""noise_amplifier"": self.noise_amplifier,
            ""noise_factors"": self.noise_factors,
            ""values"": normalize_array(result_group.values),  # TODO: simplify when tuple
        }
        for key in merge_dicts(result_group.metadata):
            value = from_common_key(result_group.metadata, key)
            noise_amplification.update({key: value})
        extrapolation = {
            ""extrapolator"": self.extrapolator,
            **extrapolation,
        }
        return {""noise_amplification"": noise_amplification, ""extrapolation"": extrapolation}
"
https://github.com/qiskit-community/prototype-zne,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022-2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Noise amplification strategy via unitary/inverse repetition.""""""

from __future__ import annotations

from warnings import warn

from numpy.random import Generator, default_rng
from qiskit import QuantumCircuit
from qiskit.dagcircuit import DAGCircuit

from ...utils.typing import isreal
from ..noise_amplifier import NoiseAmplifier


class FoldingAmplifier(NoiseAmplifier):
    """"""Interface for folding amplifier strategies.""""""

    def __init__(  # pylint: disable=super-init-not-called, duplicate-code, too-many-arguments
        self,
        sub_folding_option: str = ""from_first"",
        barriers: bool = True,
        random_seed: int | None = None,
        noise_factor_relative_tolerance: float = 1e-2,
        warn_user: bool = True,
    ) -> None:
        """"""
        Args:
            sub_folding_option: Specifies which gates are used for sub folding when
                ``noise_factor`` is not an odd integer. Can either be ""from_last"", ""from_first"", or
                ""random"".
            barriers: If True applies barriers when folding (e.g. to avoid simplification).
            random_seed: Random seed used for performing random sub-gate-folding.
            noise_factor_relative_tolerance: Relative allowed tolerance interval between
                ``noise_factor`` input and actual noise factor that was used for the amplification.
                If the discrepancy exceeds the tolerance, a warning is displayed.
            warn_user: Specifies whether user warnings are displayed.
        """"""
        self.warn_user: bool = warn_user
        self._set_sub_folding_option(sub_folding_option)
        self._set_barriers(barriers)
        self._prepare_rng(random_seed)
        self._set_noise_factor_relative_tolerance(noise_factor_relative_tolerance)

    ################################################################################
    ## PROPERTIES
    ################################################################################
    @property
    def options(self) -> dict:
        """"""Strategy options.""""""
        options: dict = self._init_options
        options.pop(""warn_user"", None)
        return options

    @property
    def warn_user(self) -> bool:
        """"""Option whether warnings are displayed.""""""
        return self._warn_user

    @warn_user.setter
    def warn_user(self, warn_user: bool) -> None:
        if not isinstance(warn_user, bool):
            raise TypeError(f""Expected boolean, received {type(warn_user)} instead."")
        self._warn_user: bool = warn_user

    @property
    def sub_folding_option(self) -> str:
        """"""Option for sub-gate-folding.

        Specifies which gates of the full circuit are used for sub folding when ``noise_factor`` is
        is not an odd integer. Can either be ""from_last"", ""from_first"", or ""random"".
        """"""
        return self._sub_folding_option

    def _set_sub_folding_option(self, sub_folding_option: str) -> None:
        if sub_folding_option not in [""from_last"", ""from_first"", ""random""]:
            raise ValueError(
                f""Sub-folding option must be a string of either 'from_last', 'from_first, or ""
                f""'random'. Received {sub_folding_option} instead.""
            )
        self._sub_folding_option: str = sub_folding_option

    @property
    def barriers(self) -> bool:
        """"""Option for whether to apply barriers when folding.""""""
        return self._barriers

    def _set_barriers(self, barriers: bool) -> None:
        self._barriers = bool(barriers)

    def _prepare_rng(self, seed: int | None = None) -> None:
        """"""Sets random number generator with seed.""""""
        if not isinstance(seed, (type(None), int)):
            raise TypeError(""Random seed must be an integer or None."")
        self._rng: Generator = default_rng(seed)

    # TODO: add property getter
    def _set_noise_factor_relative_tolerance(self, tolerance: float) -> None:
        """"""Sets noise factor relative tolerance.""""""
        if not isreal(tolerance):
            raise TypeError(""Noise factor relative tolerance must be real valued."")
        self._noise_factor_relative_tolerance: float = tolerance

    ################################################################################
    ## FOLDING METHODS
    ################################################################################
    @staticmethod
    def folding_to_noise_factor(folding: float) -> float:
        """"""Converts number of foldings to noise factor.

        Args:
            folding: The number of foldings.

        Returns:
            The corresponding noise factor.
        """"""
        return 2 * folding + 1

    def warn(self, *args, **kwargs):
        """"""Throws user warning if enabled.""""""
        if self.warn_user:
            warn(*args, **kwargs)

    def _validate_noise_factor(self, noise_factor):
        """"""Validates noise factor.

        Args:
            noise_factor: The noise amplification factor by which to amplify the circuit noise.

        Raises:
            ValueError: If the noise factor is smaller than 1.
        """"""
        if noise_factor < 1:
            raise ValueError(
                f""{self.name} expects a positive float noise_factor >= 1.""
                f""Received {noise_factor} instead.""
            )

    def _apply_barrier(self, circuit: QuantumCircuit, *registers) -> QuantumCircuit:
        """"""Apply barrier to specified registers if option is set.""""""
        if self._barriers:
            circuit.barrier(*registers)
        return circuit

    def _compute_folding_nums(self, noise_factor: float, num_instructions: int) -> tuple[int, int]:
        """"""Returns required number of full foldings and sub foldings.

        Args:
            noise_factor: The noise amplification factor by which to fold the circuit.
            num_instructions: The number of instructions to fold.

        Returns:
            A tuple containing the number of full-and sub-foldings.
        """"""
        if num_instructions == 0:
            self.warn(""Noise amplification is not performed since none of the gates are folded."")
            return 0, 0
        num_foldings = round(num_instructions * (noise_factor - 1) / 2.0)
        closest_noise_factor: float = self.folding_to_noise_factor(num_foldings / num_instructions)
        relative_error = abs(closest_noise_factor - noise_factor) / noise_factor
        if relative_error > self._noise_factor_relative_tolerance:
            warn(
                ""Rounding of noise factor: Foldings are performed with noise factor ""
                f""{closest_noise_factor:.2f} instead of specified noise factor ""
                f""{noise_factor:.2f} which amounts to a relative error of ""
                f""{relative_error * 100:.2f}%.""
            )
        num_full_foldings, num_sub_foldings = divmod(num_foldings, num_instructions)
        return num_full_foldings, num_sub_foldings

    ################################################################################
    ## IMPLEMENTATION
    ################################################################################
    # pylint: disable=useless-parent-delegation
    def amplify_dag_noise(
        self, dag: DAGCircuit, noise_factor: float
    ) -> DAGCircuit:  # pragma: no cover
        return super().amplify_dag_noise(dag, noise_factor)
"
https://github.com/qiskit-community/prototype-qrao,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2019, 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Quantum Random Access Encoding module.

Contains code dealing with QRACs (quantum random access codes) and preparation
of such states.

.. autosummary::
   :toctree: ../stubs/

   z_to_31p_qrac_basis_circuit
   z_to_21p_qrac_basis_circuit
   qrac_state_prep_1q
   qrac_state_prep_multiqubit
   QuantumRandomAccessEncoding

""""""

from typing import Tuple, List, Dict, Optional, Union
from collections import defaultdict
from functools import reduce
from itertools import chain

import numpy as np
import rustworkx as rx

from qiskit import QuantumCircuit
from qiskit.opflow import (
    I,
    X,
    Y,
    Z,
    PauliSumOp,
    PrimitiveOp,
    CircuitOp,
    Zero,
    One,
    StateFn,
    CircuitStateFn,
)
from qiskit.quantum_info import SparsePauliOp

from qiskit_optimization.problems.quadratic_program import QuadraticProgram


def _ceildiv(n: int, d: int) -> int:
    """"""Perform ceiling division in integer arithmetic

    >>> _ceildiv(0, 3)
    0
    >>> _ceildiv(1, 3)
    1
    >>> _ceildiv(3, 3)
    1
    >>> _ceildiv(4, 3)
    2
    """"""
    return (n - 1) // d + 1


def z_to_31p_qrac_basis_circuit(basis: List[int]) -> QuantumCircuit:
    """"""Return the basis rotation corresponding to the (3,1,p)-QRAC

    Args:

        basis: 0, 1, 2, or 3 for each qubit

    Returns:
        The ``QuantumCircuit`` implementing the rotation.
    """"""
    circ = QuantumCircuit(len(basis))
    BETA = np.arccos(1 / np.sqrt(3))
    for i, base in enumerate(reversed(basis)):
        if base == 0:
            circ.r(-BETA, -np.pi / 4, i)
        elif base == 1:
            circ.r(np.pi - BETA, np.pi / 4, i)
        elif base == 2:
            circ.r(np.pi + BETA, np.pi / 4, i)
        elif base == 3:
            circ.r(BETA, -np.pi / 4, i)
        else:
            raise ValueError(f""Unknown base: {base}"")
    return circ


def z_to_21p_qrac_basis_circuit(basis: List[int]) -> QuantumCircuit:
    """"""Return the basis rotation corresponding to the (2,1,p)-QRAC

    Args:

        basis: 0 or 1 for each qubit

    Returns:
        The ``QuantumCircuit`` implementing the rotation.
    """"""
    circ = QuantumCircuit(len(basis))
    for i, base in enumerate(reversed(basis)):
        if base == 0:
            circ.r(-1 * np.pi / 4, -np.pi / 2, i)
        elif base == 1:
            circ.r(-3 * np.pi / 4, -np.pi / 2, i)
        else:
            raise ValueError(f""Unknown base: {base}"")
    return circ


def qrac_state_prep_1q(*m: int) -> CircuitStateFn:
    """"""Prepare a single qubit QRAC state

      This function accepts 1, 2, or 3 arguments, in which case it generates a
      1-QRAC, 2-QRAC, or 3-QRAC, respectively.

    Args:

        m: The data to be encoded. Each argument must be 0 or 1.

    Returns:

        The circuit state function.

    """"""
    if len(m) not in (1, 2, 3):
        raise TypeError(
            f""qrac_state_prep_1q requires 1, 2, or 3 arguments, not {len(m)}.""
        )
    if not all(mi in (0, 1) for mi in m):
        raise ValueError(""Each argument to qrac_state_prep_1q must be 0 or 1."")

    if len(m) == 3:
        # Prepare (3,1,p)-qrac

        # In the following lines, the input bits are XOR'd to match the
        # conventions used in the paper.

        # To understand why this transformation happens,
        # observe that the two states that define each magic basis
        # correspond to the same bitstrings but with a global bitflip.

        # Thus the three bits of information we use to construct these states are:
        # c0,c1 : two bits to pick one of four magic bases
        # c2: one bit to indicate which magic basis projector we are interested in.

        c0 = m[0] ^ m[1] ^ m[2]
        c1 = m[1] ^ m[2]
        c2 = m[0] ^ m[2]

        base = [2 * c1 + c2]
        cob = z_to_31p_qrac_basis_circuit(base)
        # This is a convention chosen to be consistent with https://arxiv.org/pdf/2111.03167v2.pdf
        # See SI:4 second paragraph and observe that π+ = |0X0|, π- = |1X1|
        sf = One if (c0) else Zero
        # Apply the z_to_magic_basis circuit to either |0> or |1>
        logical = CircuitOp(cob) @ sf
    elif len(m) == 2:
        # Prepare (2,1,p)-qrac
        # (00,01) or (10,11)
        c0 = m[0]
        # (00,11) or (01,10)
        c1 = m[0] ^ m[1]

        base = [c1]
        cob = z_to_21p_qrac_basis_circuit(base)
        # This is a convention chosen to be consistent with https://arxiv.org/pdf/2111.03167v2.pdf
        # See SI:4 second paragraph and observe that π+ = |0X0|, π- = |1X1|
        sf = One if (c0) else Zero
        # Apply the z_to_magic_basis circuit to either |0> or |1>
        logical = CircuitOp(cob) @ sf
    else:
        assert len(m) == 1
        c0 = m[0]
        sf = One if (c0) else Zero

        logical = sf

    return logical.to_circuit_op()


def qrac_state_prep_multiqubit(
    dvars: Union[Dict[int, int], List[int]],
    q2vars: List[List[int]],
    max_vars_per_qubit: int,
) -> CircuitStateFn:
    """"""
    Prepare a multiqubit QRAC state.

    Args:
        dvars: state of each decision variable (0 or 1)
    """"""
    remaining_dvars = set(dvars if isinstance(dvars, dict) else range(len(dvars)))
    ordered_bits = []
    for qi_vars in q2vars:
        if len(qi_vars) > max_vars_per_qubit:
            raise ValueError(
                ""Each qubit is expected to be associated with at most ""
                f""`max_vars_per_qubit` ({max_vars_per_qubit}) variables, ""
                f""not {len(qi_vars)} variables.""
            )
        if not qi_vars:
            # This probably actually doesn't cause any issues, but why support
            # it (and test this edge case) if we don't have to?
            raise ValueError(
                ""There is a qubit without any decision variables assigned to it.""
            )
        qi_bits: List[int] = []
        for dv in qi_vars:
            try:
                qi_bits.append(dvars[dv])
            except (KeyError, IndexError):
                raise ValueError(
                    f""Decision variable not included in dvars: {dv}""
                ) from None
            try:
                remaining_dvars.remove(dv)
            except KeyError:
                raise ValueError(
                    f""Unused decision variable(s) in dvars: {remaining_dvars}""
                ) from None
        # Pad with zeros if there are fewer than `max_vars_per_qubit`.
        # NOTE: This results in everything being encoded as an n-QRAC,
        # even if there are fewer than n decision variables encoded in the qubit.
        # In the future, we plan to make the encoding ""adaptive"" so that the
        # optimal encoding is used on each qubit, based on the number of
        # decision variables assigned to that specific qubit.
        # However, we cannot do this until magic state rounding supports 2-QRACs.
        while len(qi_bits) < max_vars_per_qubit:
            qi_bits.append(0)

        ordered_bits.append(qi_bits)

    if remaining_dvars:
        raise ValueError(f""Not all dvars were included in q2vars: {remaining_dvars}"")

    qracs = [qrac_state_prep_1q(*qi_bits) for qi_bits in ordered_bits]
    logical = reduce(lambda x, y: x ^ y, qracs)
    return logical


def q2vars_from_var2op(var2op: Dict[int, Tuple[int, PrimitiveOp]]) -> List[List[int]]:
    """"""Calculate q2vars given var2op""""""
    num_qubits = max(qubit_index for qubit_index, _ in var2op.values()) + 1
    q2vars: List[List[int]] = [[] for i in range(num_qubits)]
    for var, (q, _) in var2op.items():
        q2vars[q].append(var)
    return q2vars


class QuantumRandomAccessEncoding:
    """"""This class specifies a Quantum Random Access Code that can be used to encode
    the binary variables of a QUBO (quadratic unconstrained binary optimization
    problem).

    Args:
        max_vars_per_qubit: maximum possible compression ratio.
            Supported values are 1, 2, or 3.

    """"""

    # This defines the convention of the Pauli operators (and their ordering)
    # for each encoding.
    OPERATORS = (
        (Z,),  # (1,1,1) QRAC
        (X, Z),  # (2,1,p) QRAC, p ≈ 0.85
        (X, Y, Z),  # (3,1,p) QRAC, p ≈ 0.79
    )

    def __init__(self, max_vars_per_qubit: int = 3):
        if max_vars_per_qubit not in (1, 2, 3):
            raise ValueError(""max_vars_per_qubit must be 1, 2, or 3"")
        self._ops = self.OPERATORS[max_vars_per_qubit - 1]

        self._qubit_op: Optional[PauliSumOp] = None
        self._offset: Optional[float] = None
        self._problem: Optional[QuadraticProgram] = None
        self._var2op: Dict[int, Tuple[int, PrimitiveOp]] = {}
        self._q2vars: List[List[int]] = []
        self._frozen = False

    @property
    def num_qubits(self) -> int:
        """"""Number of qubits""""""
        return len(self._q2vars)

    @property
    def num_vars(self) -> int:
        """"""Number of decision variables""""""
        return len(self._var2op)

    @property
    def max_vars_per_qubit(self) -> int:
        """"""Maximum number of variables per qubit

        This is set in the constructor and controls the maximum compression ratio
        """"""

        return len(self._ops)

    @property
    def var2op(self) -> Dict[int, Tuple[int, PrimitiveOp]]:
        """"""Maps each decision variable to ``(qubit_index, operator)``""""""
        return self._var2op

    @property
    def q2vars(self) -> List[List[int]]:
        """"""Each element contains the list of decision variable indice(s) encoded on that qubit""""""
        return self._q2vars

    @property
    def compression_ratio(self) -> float:
        """"""Compression ratio

        Number of decision variables divided by number of qubits
        """"""
        return self.num_vars / self.num_qubits

    @property
    def minimum_recovery_probability(self) -> float:
        """"""Minimum recovery probability, as set by ``max_vars_per_qubit``""""""
        n = self.max_vars_per_qubit
        return (1 + 1 / np.sqrt(n)) / 2

    @property
    def qubit_op(self) -> PauliSumOp:
        """"""Relaxed Hamiltonian operator""""""
        if self._qubit_op is None:
            raise AttributeError(
                ""No objective function has been provided from which a ""
                ""qubit Hamiltonian can be constructed. Please use the ""
                ""encode method if you wish to manually compile ""
                ""this field.""
            )
        return self._qubit_op

    @property
    def offset(self) -> float:
        """"""Relaxed Hamiltonian offset""""""
        if self._offset is None:
            raise AttributeError(
                ""No objective function has been provided from which a ""
                ""qubit Hamiltonian can be constructed. Please use the ""
                ""encode method if you wish to manually compile ""
                ""this field.""
            )
        return self._offset

    @property
    def problem(self) -> QuadraticProgram:
        """"""The ``QuadraticProgram`` used as basis for the encoding""""""
        if self._problem is None:
            raise AttributeError(
                ""No quadratic program has been associated with this object. ""
                ""Please use the encode method if you wish to do so.""
            )
        return self._problem

    def _add_variables(self, variables: List[int]) -> None:
        self.ensure_thawed()
        # NOTE: If this is called multiple times, it *always* adds an
        # additional qubit (see final line), even if aggregating them into a
        # single call would have resulted in fewer qubits.
        if self._qubit_op is not None:
            raise RuntimeError(
                ""_add_variables() cannot be called once terms have been added ""
                ""to the operator, as the number of qubits must thereafter ""
                ""remain fixed.""
            )
        if not variables:
            return
        if len(variables) != len(set(variables)):
            raise ValueError(""Added variables must be unique"")
        for v in variables:
            if v in self._var2op:
                raise ValueError(""Added variables cannot collide with existing ones"")
        # Modify the object now that error checking is complete.
        n = len(self._ops)
        old_num_qubits = len(self._q2vars)
        num_new_qubits = _ceildiv(len(variables), n)
        # Populate self._var2op and self._q2vars
        for _ in range(num_new_qubits):
            self._q2vars.append([])
        for i, v in enumerate(variables):
            qubit, op = divmod(i, n)
            qubit_index = old_num_qubits + qubit
            assert v not in self._var2op  # was checked above
            self._var2op[v] = (qubit_index, self._ops[op])
            self._q2vars[qubit_index].append(v)

    def _add_term(self, w: float, *variables: int) -> None:
        self.ensure_thawed()
        # Eq. (31) in https://arxiv.org/abs/2111.03167v2 assumes a weight-2
        # Pauli operator.  To generalize, we replace the `d` in that equation
        # with `d_prime`, defined as follows:
        d_prime = np.sqrt(self.max_vars_per_qubit) ** len(variables)
        op = self.term2op(*variables).mul(w * d_prime)
        # We perform the following short-circuit *after* calling term2op so at
        # least we have confirmed that the user provided a valid variables list.
        if w == 0.0:
            return
        if self._qubit_op is None:
            self._qubit_op = op
        else:
            self._qubit_op += op

    def term2op(self, *variables: int) -> PauliSumOp:
        """"""Construct a ``PauliSumOp`` that is a product of encoded decision ``variable``\\(s).

        The decision variables provided must all be encoded on different qubits.
        """"""
        ops = [I] * self.num_qubits
        done = set()
        for x in variables:
            pos, op = self._var2op[x]
            if pos in done:
                raise RuntimeError(f""Collision of variables: {variables}"")
            ops[pos] = op
            done.add(pos)
        pauli_op = reduce(lambda x, y: x ^ y, ops)
        # Convert from PauliOp to PauliSumOp
        return PauliSumOp(SparsePauliOp(pauli_op.primitive, coeffs=[pauli_op.coeff]))

    @staticmethod
    def _generate_ising_terms(
        problem: QuadraticProgram,
    ) -> Tuple[float, np.ndarray, np.ndarray]:
        num_vars = problem.get_num_vars()

        # set a sign corresponding to a maximized or minimized problem:
        # 1 is for minimized problem, -1 is for maximized problem.
        sense = problem.objective.sense.value

        # convert a constant part of the objective function into Hamiltonian.
        offset = problem.objective.constant * sense

        # convert linear parts of the objective function into Hamiltonian.
        linear = np.zeros(num_vars)
        for idx, coef in problem.objective.linear.to_dict().items():
            assert isinstance(idx, int)  # hint for mypy
            weight = coef * sense / 2
            linear[idx] -= weight
            offset += weight

        # convert quadratic parts of the objective function into Hamiltonian.
        quad = np.zeros((num_vars, num_vars))
        for (i, j), coef in problem.objective.quadratic.to_dict().items():
            assert isinstance(i, int)  # hint for mypy
            assert isinstance(j, int)  # hint for mypy
            weight = coef * sense / 4
            if i == j:
                linear[i] -= 2 * weight
                offset += 2 * weight
            else:
                quad[i, j] += weight
                linear[i] -= weight
                linear[j] -= weight
                offset += weight

        return offset, linear, quad

    @staticmethod
    def _find_variable_partition(quad: np.ndarray) -> Dict[int, List[int]]:
        num_nodes = quad.shape[0]
        assert quad.shape == (num_nodes, num_nodes)
        graph = rx.PyGraph()  # type: ignore
        graph.add_nodes_from(range(num_nodes))
        graph.add_edges_from_no_data(list(zip(*np.where(quad != 0))))  # type: ignore
        node2color = rx.graph_greedy_color(graph)  # type: ignore
        color2node: Dict[int, List[int]] = defaultdict(list)
        for node, color in sorted(node2color.items()):
            color2node[color].append(node)
        return color2node

    def encode(self, problem: QuadraticProgram) -> None:
        """"""Encode the (n,1,p) QRAC relaxed Hamiltonian of this problem.

            We associate to each binary decision variable one bit of a
            (n,1,p) Quantum Random Access Code. This is done in such a way that the
            given problem's objective function commutes with the encoding.

        After being called, the object will have the following attributes:
            qubit_op: The qubit operator encoding the input QuadraticProgram.
            offset: The constant value in the encoded Hamiltonian.
            problem: The ``problem`` used for encoding.

        Inputs:
            problem: A QuadraticProgram object encoding a QUBO optimization problem

        Raises:
            RuntimeError: if the ``problem`` isn't a QUBO or if the current
                object has been used already

        """"""
        # Ensure fresh object
        if self.num_qubits > 0:
            raise RuntimeError(
                ""Must call encode() on an Encoding that has not been used already""
            )

        # if problem has variables that are not binary, raise an error
        if problem.get_num_vars() > problem.get_num_binary_vars():
            raise RuntimeError(
                ""The type of all variables must be binary. ""
                ""You can use `QuadraticProgramToQubo` converter ""
                ""to convert integer variables to binary variables. ""
                ""If the problem contains continuous variables, `qrao` ""
                ""cannot handle it.""
            )

        # if constraints exist, raise an error
        if problem.linear_constraints or problem.quadratic_constraints:
            raise RuntimeError(
                ""There must be no constraint in the problem. ""
                ""You can use `QuadraticProgramToQubo` converter to convert ""
                ""constraints to penalty terms of the objective function.""
            )

        num_vars = problem.get_num_vars()

        # Generate the decision variable terms in terms of Ising variables (+1 or -1)
        offset, linear, quad = self._generate_ising_terms(problem)

        # Find variable partition (a graph coloring is sufficient)
        variable_partition = self._find_variable_partition(quad)

        # The other methods of the current class allow for the variables to
        # have arbitrary integer indices [i.e., they need not correspond to
        # range(num_vars)], and the tests corresponding to this file ensure
        # that this works.  However, the current method is a high-level one
        # that takes a QuadraticProgram, which always has its variables
        # numbered sequentially.  Furthermore, other portions of the QRAO code
        # base [most notably the assignment of variable_ops in solve_relaxed()
        # and the corresponding result objects] assume that the variables are
        # numbered from 0 to (num_vars - 1).  So we enforce that assumption
        # here, both as a way of documenting it and to make sure
        # _find_variable_partition() returns a sensible result (in case the
        # user overrides it).
        assert sorted(chain.from_iterable(variable_partition.values())) == list(
            range(num_vars)
        )

        # generate a Hamiltonian
        for _, v in sorted(variable_partition.items()):
            self._add_variables(sorted(v))
        for i in range(num_vars):
            w = linear[i]
            if w != 0:
                self._add_term(w, i)
        for i in range(num_vars):
            for j in range(num_vars):
                w = quad[i, j]
                if w != 0:
                    self._add_term(w, i, j)

        self._offset = offset
        self._problem = problem

        # This is technically optional and can wait until the optimizer is
        # constructed, but there's really no reason not to freeze
        # immediately.
        self.freeze()

    def freeze(self):
        """"""Freeze the object to prevent further modification.

        Once an instance of this class is frozen, ``_add_variables`` and ``_add_term``
        can no longer be called.

        This operation is idempotent.  There is no way to undo it, as it exists
        to allow another object to rely on this one not changing its state
        going forward without having to make a copy as a distinct object.
        """"""
        if self._frozen is False:
            self._qubit_op = self._qubit_op.reduce()
        self._frozen = True

    @property
    def frozen(self) -> bool:
        """"""``True`` if the object can no longer be modified, ``False`` otherwise.""""""
        return self._frozen

    def ensure_thawed(self) -> None:
        """"""Raise a ``RuntimeError`` if the object is frozen and thus cannot be modified.""""""
        if self._frozen:
            raise RuntimeError(""Cannot modify an encoding that has been frozen"")

    def state_prep(self, dvars: Union[Dict[int, int], List[int]]) -> CircuitStateFn:
        """"""Prepare a multiqubit QRAC state.""""""
        return qrac_state_prep_multiqubit(dvars, self.q2vars, self.max_vars_per_qubit)


class EncodingCommutationVerifier:
    """"""Class for verifying that the relaxation commutes with the objective function

    See also the ""check encoding problem commutation"" how-to notebook.
    """"""

    def __init__(self, encoding: QuantumRandomAccessEncoding):
        self._encoding = encoding

    def __len__(self) -> int:
        return 2**self._encoding.num_vars

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

    def __getitem__(self, i: int) -> Tuple[str, float, float]:
        if i not in range(len(self)):
            raise IndexError(f""Index out of range: {i}"")

        encoding = self._encoding
        str_dvars = (""{0:0"" + str(encoding.num_vars) + ""b}"").format(i)
        dvars = [int(b) for b in str_dvars]
        encoded_bitstr = encoding.state_prep(dvars)

        # Offset accounts for the value of the encoded Hamiltonian's
        # identity coefficient. This term need not be evaluated directly as
        # Tr[I•rho] is always 1.
        offset = encoding.offset

        # Evaluate Un-encoded Problem
        # ========================
        # `sense` accounts for sign flips depending on whether
        # we are minimizing or maximizing the objective function
        problem = encoding.problem
        sense = problem.objective.sense.value
        obj_val = problem.objective.evaluate(dvars) * sense

        # Evaluate Encoded Problem
        # ========================
        encoded_problem = encoding.qubit_op  # H
        encoded_obj_val = (
            np.real((~StateFn(encoded_problem) @ encoded_bitstr).eval()) + offset
        )

        return (str_dvars, obj_val, encoded_obj_val)
"
https://github.com/qiskit-community/prototype-qrao,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Magic bases rounding""""""

from typing import List, Dict, Tuple, Optional
from collections import defaultdict
import numbers
import time
import warnings

import numpy as np

from qiskit import QuantumCircuit
from qiskit.providers import Backend
from qiskit.opflow import PrimitiveOp
from qiskit.utils import QuantumInstance

from .encoding import z_to_31p_qrac_basis_circuit, z_to_21p_qrac_basis_circuit
from .rounding_common import (
    RoundingSolutionSample,
    RoundingScheme,
    RoundingContext,
    RoundingResult,
)


_invalid_backend_names = [
    ""aer_simulator_unitary"",
    ""aer_simulator_superop"",
    ""unitary_simulator"",
    ""pulse_simulator"",
]


def _backend_name(backend: Backend) -> str:
    """"""Return the backend name in a way that is agnostic to Backend version""""""
    # See qiskit.utils.backend_utils in qiskit-terra for similar examples
    if backend.version <= 1:
        return backend.name()
    return backend.name


def _is_original_statevector_simulator(backend: Backend) -> bool:
    """"""Return True if the original statevector simulator""""""
    return _backend_name(backend) == ""statevector_simulator""


class MagicRoundingResult(RoundingResult):
    """"""Result of magic rounding""""""

    def __init__(
        self,
        samples: List[RoundingSolutionSample],
        *,
        bases=None,
        basis_shots=None,
        basis_counts=None,
        time_taken=None,
    ):
        self._bases = bases
        self._basis_shots = basis_shots
        self._basis_counts = basis_counts
        super().__init__(samples, time_taken=time_taken)

    @property
    def bases(self):
        return self._bases

    @property
    def basis_shots(self):
        return self._basis_shots

    @property
    def basis_counts(self):
        return self._basis_counts


class MagicRounding(RoundingScheme):
    """""" ""Magic rounding"" method

    This method is described in https://arxiv.org/abs/2111.03167v2.

    """"""

    _DECODING = {
        3: (  # Eq. (8)
            {""0"": [0, 0, 0], ""1"": [1, 1, 1]},  # I mu+ I, I mu- I
            {""0"": [0, 1, 1], ""1"": [1, 0, 0]},  # X mu+ X, X mu- X
            {""0"": [1, 0, 1], ""1"": [0, 1, 0]},  # Y mu+ Y, Y mu- Y
            {""0"": [1, 1, 0], ""1"": [0, 0, 1]},  # Z mu+ Z, Z mu- Z
        ),
        2: (  # Sec. VII
            {""0"": [0, 0], ""1"": [1, 1]},  # I xi+ I, I xi- I
            {""0"": [0, 1], ""1"": [1, 0]},  # X xi+ X, X xi- X
        ),
        1: ({""0"": [0], ""1"": [1]},),
    }

    # Pauli op string to label index in ops
    _OP_INDICES = {1: {""Z"": 0}, 2: {""X"": 0, ""Z"": 1}, 3: {""X"": 0, ""Y"": 1, ""Z"": 2}}

    def __init__(
        self,
        quantum_instance: QuantumInstance,
        *,
        basis_sampling: str = ""uniform"",
        seed: Optional[int] = None,
    ):
        """"""
        Args:

            quantum_instance: Provides the ``Backend`` for quantum execution
                and the ``shots`` count (i.e., the number of samples to collect
                from the magic bases).

            basis_sampling: Method to use for sampling the magic bases.  Must
                be either ``""uniform""`` (default) or ``""weighted""``.
                ``""uniform""`` samples all magic bases uniformly, and is the
                method described in https://arxiv.org/abs/2111.03167v2.
                ``""weighted""`` attempts to choose bases strategically using the
                Pauli expectation values from the minimum eigensolver.
                However, the approximation bounds given in
                https://arxiv.org/abs/2111.03167v2 apply only to ``""uniform""``
                sampling.

            seed: Seed for random number generator, which is used to sample the
                magic bases.

        """"""
        if basis_sampling not in (""uniform"", ""weighted""):
            raise ValueError(
                f""'{basis_sampling}' is not an implemented sampling method. ""
                ""Please choose either 'uniform' or 'weighted'.""
            )
        self.quantum_instance = quantum_instance
        self.rng = np.random.RandomState(seed)
        self._basis_sampling = basis_sampling
        super().__init__()

    @property
    def shots(self) -> int:
        """"""Shots count as configured by the given ``quantum_instance``.""""""
        return self.quantum_instance.run_config.shots

    @property
    def basis_sampling(self):
        """"""Basis sampling method (either ``""uniform""`` or ``""weighted""``).""""""
        return self._basis_sampling

    @property
    def quantum_instance(self) -> QuantumInstance:
        """"""Provides the ``Backend`` and the ``shots`` (samples) count.""""""
        return self._quantum_instance

    @quantum_instance.setter
    def quantum_instance(self, quantum_instance: QuantumInstance) -> None:
        backend_name = _backend_name(quantum_instance.backend)
        if backend_name in _invalid_backend_names:
            raise ValueError(f""{backend_name} is not supported."")
        if _is_original_statevector_simulator(quantum_instance.backend):
            warnings.warn(
                'Use of ""statevector_simulator"" is discouraged because it effectively '
                ""brute-forces all possible solutions.  We suggest using the newer ""
                '""aer_simulator_statevector"" instead.'
            )
        self._quantum_instance = quantum_instance

    def _unpack_measurement_outcome(
        self,
        bits: str,
        basis: List[int],
        var2op: Dict[int, Tuple[int, PrimitiveOp]],
        vars_per_qubit: int,
    ) -> List[int]:
        output_bits = []
        # iterate in order over decision variables
        # (assumes variables are numbered consecutively beginning with 0)
        for var in range(len(var2op)):  # pylint: disable=consider-using-enumerate
            q, op = var2op[var]
            # get the decoding outcome index for the variable
            # corresponding to this Pauli op.
            op_index = self._OP_INDICES[vars_per_qubit][str(op)]
            # get the bits associated to this magic basis'
            # measurement outcomes
            bit_outcomes = self._DECODING[vars_per_qubit][basis[q]]
            # select which measurement outcome we observed
            # this gives up to 3 bits of information
            magic_bits = bit_outcomes[bits[q]]
            # Assign our variable's value depending on
            # which pauli our variable was associated to
            variable_value = magic_bits[op_index]
            output_bits.append(variable_value)
        return output_bits

    @staticmethod
    def _make_circuits(
        circ: QuantumCircuit, bases: List[List[int]], measure: bool, vars_per_qubit: int
    ) -> List[QuantumCircuit]:
        circuits = []
        for basis in bases:
            if vars_per_qubit == 3:
                qc = circ.compose(
                    z_to_31p_qrac_basis_circuit(basis).inverse(), inplace=False
                )
            elif vars_per_qubit == 2:
                qc = circ.compose(
                    z_to_21p_qrac_basis_circuit(basis).inverse(), inplace=False
                )
            elif vars_per_qubit == 1:
                qc = circ.copy()
            if measure:
                qc.measure_all()
            circuits.append(qc)
        return circuits

    def _evaluate_magic_bases(self, circuit, bases, basis_shots, vars_per_qubit):
        """"""
        Given a circuit you wish to measure, a list of magic bases to measure,
        and a list of the shots to use for each magic basis configuration.

        Measure the provided circuit in the magic bases given and return the counts
        dictionaries associated with each basis measurement.

        len(bases) == len(basis_shots) == len(basis_counts)
        """"""
        measure = not _is_original_statevector_simulator(self.quantum_instance.backend)
        circuits = self._make_circuits(circuit, bases, measure, vars_per_qubit)

        # Execute each of the rotated circuits and collect the results

        # Batch the circuits into jobs where each group has the same number of
        # shots, so that you can wait for the queue as few times as possible if
        # using hardware.
        circuit_indices_by_shots: Dict[int, List[int]] = defaultdict(list)
        assert len(circuits) == len(basis_shots)
        for i, shots in enumerate(basis_shots):
            circuit_indices_by_shots[shots].append(i)

        basis_counts: List[Optional[Dict[str, int]]] = [None] * len(circuits)
        overall_shots = self.quantum_instance.run_config.shots
        try:
            for shots, indices in sorted(
                circuit_indices_by_shots.items(), reverse=True
            ):
                self.quantum_instance.set_config(shots=shots)
                result = self.quantum_instance.execute([circuits[i] for i in indices])
                counts_list = result.get_counts()
                if not isinstance(counts_list, List):
                    # This is the only case where this should happen, and that
                    # it does at all (namely, when a single-element circuit
                    # list is provided) is a weird API quirk of Qiskit.
                    # https://github.com/Qiskit/qiskit-terra/issues/8103
                    assert len(indices) == 1
                    counts_list = [counts_list]
                assert len(indices) == len(counts_list)
                for i, counts in zip(indices, counts_list):
                    basis_counts[i] = counts
        finally:
            # We've temporarily modified quantum_instance; now we restore it to
            # its initial state.
            self.quantum_instance.set_config(shots=overall_shots)
        assert None not in basis_counts

        # Process the outcomes and extract expectation of decision vars

        # The ""statevector_simulator"", unlike all the others, returns
        # probabilities instead of integer counts.  So if probabilities are
        # detected, we rescale them.
        if any(
            any(not isinstance(x, numbers.Integral) for x in counts.values())
            for counts in basis_counts
        ):
            basis_counts = [
                {key: val * basis_shots[i] for key, val in counts.items()}
                for i, counts in enumerate(basis_counts)
            ]

        return basis_counts

    def _compute_dv_counts(self, basis_counts, bases, var2op, vars_per_qubit):
        """"""
        Given a list of bases, basis_shots, and basis_counts, convert
        each observed bitstrings to its corresponding decision variable
        configuration. Return the counts of each decision variable configuration.
        """"""
        dv_counts = {}
        for i, counts in enumerate(basis_counts):
            base = bases[i]
            # For each measurement outcome...
            for bitstr, count in counts.items():

                # For each bit in the observed bitstring...
                soln = self._unpack_measurement_outcome(
                    bitstr, base, var2op, vars_per_qubit
                )
                soln = """".join([str(int(bit)) for bit in soln])
                if soln in dv_counts:
                    dv_counts[soln] += count
                else:
                    dv_counts[soln] = count
        return dv_counts

    def _sample_bases_uniform(self, q2vars, vars_per_qubit):
        bases = [
            self.rng.choice(2 ** (vars_per_qubit - 1), size=len(q2vars)).tolist()
            for _ in range(self.shots)
        ]
        bases, basis_shots = np.unique(bases, axis=0, return_counts=True)
        return bases, basis_shots

    def _sample_bases_weighted(self, q2vars, trace_values, vars_per_qubit):
        """"""Perform weighted sampling from the expectation values.

        The goal is to make smarter choices about which bases to measure in
        using the trace values.
        """"""
        # First, we make sure all Pauli expectation values have absolute value
        # at most 1.  Otherwise, some of the probabilities computed below might
        # be negative.
        tv = np.clip(trace_values, -1, 1)
        # basis_probs will have num_qubits number of elements.
        # Each element will be a list of length 4 specifying the
        # probability of picking the corresponding magic basis on that qubit.
        basis_probs = []
        for dvars in q2vars:
            if vars_per_qubit == 3:
                x = 0.5 * (1 - tv[dvars[0]])
                y = 0.5 * (1 - tv[dvars[1]]) if (len(dvars) > 1) else 0
                z = 0.5 * (1 - tv[dvars[2]]) if (len(dvars) > 2) else 0
                # ppp:   mu±   = .5(I ± 1/sqrt(3)( X + Y + Z))
                # pmm: X mu± X = .5(I ± 1/sqrt(3)( X - Y - Z))
                # mpm: Y mu± Y = .5(I ± 1/sqrt(3)(-X + Y - Z))
                # mmp: Z mu± Z = .5(I ± 1/sqrt(3)(-X - Y + Z))
                # fmt: off
                ppp_mmm =   x   *   y   *   z   + (1-x) * (1-y) * (1-z)
                pmm_mpp =   x   * (1-y) * (1-z) + (1-x) *   y   *   z
                mpm_pmp = (1-x) *   y   * (1-z) +   x   * (1-y) *   z
                ppm_mmp =   x   *   y   * (1-z) + (1-x) * (1-y) *   z
                # fmt: on
                basis_probs.append([ppp_mmm, pmm_mpp, mpm_pmp, ppm_mmp])
            elif vars_per_qubit == 2:
                x = 0.5 * (1 - tv[dvars[0]])
                z = 0.5 * (1 - tv[dvars[1]]) if (len(dvars) > 1) else 0
                # pp:   xi±   = .5(I ± 1/sqrt(2)( X + Z ))
                # pm: X xi± X = .5(I ± 1/sqrt(2)( X - Z ))
                # fmt: off
                pp_mm =   x   *   z   + (1-x) * (1-z)
                pm_mp =   x   * (1-z) + (1-x) *   z
                # fmt: on
                basis_probs.append([pp_mm, pm_mp])
            elif vars_per_qubit == 1:
                basis_probs.append([1.0])
        bases = [
            [
                self.rng.choice(2 ** (vars_per_qubit - 1), p=probs)
                for probs in basis_probs
            ]
            for _ in range(self.shots)
        ]
        bases, basis_shots = np.unique(bases, axis=0, return_counts=True)
        return bases, basis_shots

    def round(self, ctx: RoundingContext) -> MagicRoundingResult:
        """"""Perform magic rounding""""""

        start_time = time.time()
        trace_values = ctx.trace_values
        circuit = ctx.circuit

        if circuit is None:
            raise NotImplementedError(
                ""Magic rounding requires a circuit to be available.  Perhaps try ""
                ""semideterministic rounding instead.""
            )

        # We've already checked that it is one of these two in the constructor
        if self.basis_sampling == ""uniform"":
            bases, basis_shots = self._sample_bases_uniform(
                ctx.q2vars, ctx._vars_per_qubit
            )
        elif self.basis_sampling == ""weighted"":
            if trace_values is None:
                raise NotImplementedError(
                    ""Magic rounding with weighted sampling requires the trace values ""
                    ""to be available, but they are not.""
                )
            bases, basis_shots = self._sample_bases_weighted(
                ctx.q2vars, trace_values, ctx._vars_per_qubit
            )
        else:  # pragma: no cover
            raise NotImplementedError(
                f'No such basis sampling method: ""{self.basis_sampling}"".'
            )

        assert self.shots == np.sum(basis_shots)
        # For each of the Magic Bases sampled above, measure
        # the appropriate number of times (given by basis_shots)
        # and return the circuit results

        basis_counts = self._evaluate_magic_bases(
            circuit, bases, basis_shots, ctx._vars_per_qubit
        )
        # keys will be configurations of decision variables
        # values will be total number of observations.
        soln_counts = self._compute_dv_counts(
            basis_counts, bases, ctx.var2op, ctx._vars_per_qubit
        )

        soln_samples = [
            RoundingSolutionSample(
                x=np.asarray([int(bit) for bit in soln]),
                probability=count / self.shots,
            )
            for soln, count in soln_counts.items()
        ]

        assert np.isclose(
            sum(soln_counts.values()), self.shots
        ), f""{sum(soln_counts.values())} != {self.shots}""
        assert len(bases) == len(basis_shots) == len(basis_counts)
        stop_time = time.time()

        return MagicRoundingResult(
            samples=soln_samples,
            bases=bases,
            basis_shots=basis_shots,
            basis_counts=basis_counts,
            time_taken=stop_time - start_time,
        )
"
https://github.com/qiskit-community/prototype-qrao,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2020, 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Quantum Random Access Optimizer.""""""

from typing import Union, List, Tuple, Optional
import time

import numpy as np

from qiskit import QuantumCircuit
from qiskit.algorithms.minimum_eigensolvers import (
    MinimumEigensolver,
    MinimumEigensolverResult,
    NumPyMinimumEigensolver,
)
from qiskit.algorithms.minimum_eigen_solvers import (
    MinimumEigensolver as LegacyMinimumEigensolver,
    MinimumEigensolverResult as LegacyMinimumEigensolverResult,
    NumPyMinimumEigensolver as LegacyNumPyMinimumEigensolver,
)

from qiskit_optimization.algorithms import (
    OptimizationAlgorithm,
    OptimizationResult,
    OptimizationResultStatus,
    SolutionSample,
)
from qiskit_optimization.problems import QuadraticProgram, Variable

from .encoding import QuantumRandomAccessEncoding
from .rounding_common import RoundingScheme, RoundingContext, RoundingResult
from .semideterministic_rounding import SemideterministicRounding


def _get_aux_operators_evaluated(relaxed_results):
    try:
        # Must be using the new ""minimum_eigensolvers""
        # https://github.com/Qiskit/qiskit-terra/blob/main/releasenotes/notes/0.22/add-eigensolvers-with-primitives-8b3a9f55f5fd285f.yaml
        return relaxed_results.aux_operators_evaluated
    except AttributeError:
        # Must be using the old (deprecated) ""minimum_eigen_solvers""
        return relaxed_results.aux_operator_eigenvalues


class QuantumRandomAccessOptimizationResult(OptimizationResult):
    """"""Result of Quantum Random Access Optimization procedure.""""""

    def __init__(
        self,
        *,
        x: Optional[Union[List[float], np.ndarray]],
        fval: Optional[float],
        variables: List[Variable],
        status: OptimizationResultStatus,
        samples: Optional[List[SolutionSample]],
        relaxed_results: Union[
            MinimumEigensolverResult, LegacyMinimumEigensolverResult
        ],
        rounding_results: RoundingResult,
        relaxed_results_offset: float,
        sense: int,
    ) -> None:
        """"""
        Args:
            x: the optimal value found by ``MinimumEigensolver``.
            fval: the optimal function value.
            variables: the list of variables of the optimization problem.
            status: the termination status of the optimization algorithm.
            min_eigen_solver_result: the result obtained from the underlying algorithm.
            samples: the x values of the QUBO, the objective function value of the QUBO,
                and the probability, and the status of sampling.
        """"""
        super().__init__(
            x=x,
            fval=fval,
            variables=variables,
            status=status,
            raw_results=None,
            samples=samples,
        )
        self._relaxed_results = relaxed_results
        self._rounding_results = rounding_results
        self._relaxed_results_offset = relaxed_results_offset
        assert sense in (-1, 1)
        self._sense = sense

    @property
    def relaxed_results(
        self,
    ) -> Union[MinimumEigensolverResult, LegacyMinimumEigensolverResult]:
        """"""Variationally obtained ground state of the relaxed Hamiltonian""""""
        return self._relaxed_results

    @property
    def rounding_results(self) -> RoundingResult:
        """"""Rounding results""""""
        return self._rounding_results

    @property
    def trace_values(self):
        """"""List of expectation values, one corresponding to each decision variable""""""
        trace_values = [
            v[0] for v in _get_aux_operators_evaluated(self._relaxed_results)
        ]
        return trace_values

    @property
    def relaxed_fval(self) -> float:
        """"""Relaxed function value, in the conventions of the original ``QuadraticProgram``

        Restoring convertions may be necessary, for instance, if the provided
        ``QuadraticProgram`` represents a maximization problem, as it will be
        converted to a minimization problem when phrased as a Hamiltonian.
        """"""
        return self._sense * (
            self._relaxed_results_offset + self.relaxed_results.eigenvalue.real
        )

    def __repr__(self) -> str:
        lines = (
            ""QRAO Result"",
            ""-----------"",
            f""relaxed function value: {self.relaxed_fval}"",
            super().__repr__(),
        )
        return ""\n"".join(lines)


class QuantumRandomAccessOptimizer(OptimizationAlgorithm):
    """"""Quantum Random Access Optimizer.""""""

    def __init__(
        self,
        min_eigen_solver: Union[MinimumEigensolver, LegacyMinimumEigensolver],
        encoding: QuantumRandomAccessEncoding,
        rounding_scheme: Optional[RoundingScheme] = None,
    ):
        """"""
        Args:

            min_eigen_solver: The minimum eigensolver to use for solving the
                relaxed problem (typically an instance of ``VQE`` or ``QAOA``).

            encoding: The ``QuantumRandomAccessEncoding``, which must have
                already been ``encode()``ed with a ``QuadraticProgram``.

            rounding_scheme: The rounding scheme.  If ``None`` is provided,
                ``SemideterministicRounding()`` will be used.

        """"""
        self.min_eigen_solver = min_eigen_solver
        self.encoding = encoding
        if rounding_scheme is None:
            rounding_scheme = SemideterministicRounding()
        self.rounding_scheme = rounding_scheme

    @property
    def min_eigen_solver(self) -> Union[MinimumEigensolver, LegacyMinimumEigensolver]:
        """"""The minimum eigensolver.""""""
        return self._min_eigen_solver

    @min_eigen_solver.setter
    def min_eigen_solver(
        self, min_eigen_solver: Union[MinimumEigensolver, LegacyMinimumEigensolver]
    ) -> None:
        """"""Set the minimum eigensolver.""""""
        if not min_eigen_solver.supports_aux_operators():
            raise TypeError(
                f""The provided MinimumEigensolver ({type(min_eigen_solver)}) ""
                ""does not support auxiliary operators.""
            )
        self._min_eigen_solver = min_eigen_solver

    @property
    def encoding(self) -> QuantumRandomAccessEncoding:
        """"""The encoding.""""""
        return self._encoding

    @encoding.setter
    def encoding(self, encoding: QuantumRandomAccessEncoding) -> None:
        """"""Set the encoding""""""
        if encoding.num_qubits == 0:
            raise ValueError(
                ""The passed encoder has no variables associated with it; you probably ""
                ""need to call `encode()` to encode it with a `QuadraticProgram`.""
            )
        # Instead of copying, we ""freeze"" the encoding to ensure it is not
        # modified going forward.
        encoding.freeze()
        self._encoding = encoding

    def get_compatibility_msg(self, problem: QuadraticProgram) -> str:
        if problem != self.encoding.problem:
            return (
                ""The problem passed does not match the problem used ""
                ""to construct the QuantumRandomAccessEncoding.""
            )
        return """"

    def solve_relaxed(
        self,
    ) -> Tuple[
        Union[MinimumEigensolverResult, LegacyMinimumEigensolverResult], RoundingContext
    ]:
        """"""Solve the relaxed Hamiltonian given the ``encoding`` provided to the constructor.""""""
        # Get the ordered list of operators that correspond to each decision
        # variable.  This line assumes the variables are numbered consecutively
        # starting with 0.  Note that under this assumption, the following
        # range is equivalent to `sorted(self.encoding.var2op.keys())`.  See
        # encoding.py for more commentary on this assumption, which always
        # holds when starting from a `QuadraticProgram`.
        variable_ops = [self.encoding.term2op(i) for i in range(self.encoding.num_vars)]

        # solve relaxed problem
        start_time_relaxed = time.time()
        relaxed_results = self.min_eigen_solver.compute_minimum_eigenvalue(
            self.encoding.qubit_op, aux_operators=variable_ops
        )
        stop_time_relaxed = time.time()
        relaxed_results.time_taken = stop_time_relaxed - start_time_relaxed

        trace_values = [v[0] for v in _get_aux_operators_evaluated(relaxed_results)]

        # Collect inputs for rounding
        # double check later that there's no funny business with the
        # parameter ordering.

        # If the relaxed solution can be expressed as an explicit circuit
        # then always express it that way - even if a statevector simulator
        # was used and the actual wavefunction could be used. The only exception
        # is the numpy eigensolver. If you wish to round the an explicit statevector,
        # you must do so by manually rounding and passing in a QuantumCircuit
        # initialized to the desired state.
        if hasattr(self.min_eigen_solver, ""ansatz""):
            circuit = self.min_eigen_solver.ansatz.bind_parameters(
                relaxed_results.optimal_point
            )
        elif isinstance(
            self.min_eigen_solver,
            (NumPyMinimumEigensolver, LegacyNumPyMinimumEigensolver),
        ):
            statevector = relaxed_results.eigenstate
            if isinstance(self.min_eigen_solver, LegacyNumPyMinimumEigensolver):
                # statevector is a StateFn in this case, so we must convert it
                # to a Statevector
                statevector = statevector.primitive
            circuit = QuantumCircuit(self.encoding.num_qubits)
            circuit.initialize(statevector)
        else:
            circuit = None

        rounding_context = RoundingContext(
            encoding=self.encoding,
            trace_values=trace_values,
            circuit=circuit,
        )

        return relaxed_results, rounding_context

    def solve(self, problem: Optional[QuadraticProgram] = None) -> OptimizationResult:
        if problem is None:
            problem = self.encoding.problem
        else:
            if problem != self.encoding.problem:
                raise ValueError(
                    ""The problem given must exactly match the problem ""
                    ""used to generate the encoded operator. Alternatively, ""
                    ""the argument to `solve` can be left blank.""
                )

        # Solve relaxed problem
        # ============================
        (relaxed_results, rounding_context) = self.solve_relaxed()

        # Round relaxed solution
        # ============================
        rounding_results = self.rounding_scheme.round(rounding_context)

        # Process rounding results
        # ============================
        # The rounding classes don't have enough information to evaluate the
        # objective function, so they return a RoundingSolutionSample, which
        # contains only part of the information in the SolutionSample.  Here we
        # fill in the rest.
        samples: List[SolutionSample] = []
        for sample in rounding_results.samples:
            samples.append(
                SolutionSample(
                    x=sample.x,
                    fval=problem.objective.evaluate(sample.x),
                    probability=sample.probability,
                    status=self._get_feasibility_status(problem, sample.x),
                )
            )

        # TODO: rewrite this logic once the converters are integrated.
        # we need to be very careful about ensuring that the problem
        # sense is taken into account in the relaxed solution and the rounding
        # this is likely only a temporary patch while we are sticking to a
        # maximization problem.
        fsense = {""MINIMIZE"": min, ""MAXIMIZE"": max}[problem.objective.sense.name]
        best_sample = fsense(samples, key=lambda x: x.fval)

        return QuantumRandomAccessOptimizationResult(
            samples=samples,
            x=best_sample.x,
            fval=best_sample.fval,
            variables=problem.variables,
            status=OptimizationResultStatus.SUCCESS,
            relaxed_results=relaxed_results,
            rounding_results=rounding_results,
            relaxed_results_offset=self.encoding.offset,
            sense=problem.objective.sense.value,
        )
"
https://github.com/qiskit-community/prototype-qrao,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Test QRAO steps on various hardware and simulator backends""""""

import pytest

from docplex.mp.model import Model

from qiskit.utils import QuantumInstance
from qiskit.algorithms.minimum_eigen_solvers import VQE
from qiskit.circuit.library import RealAmplitudes
from qiskit.algorithms.optimizers import SPSA
from qiskit import BasicAer
from qiskit_aer import Aer
from qiskit_optimization.algorithms import OptimizationResultStatus
from qiskit_optimization.translators import from_docplex_mp
from qiskit_ibm_provider import IBMProvider, least_busy, IBMAccountError

from qrao import (
    QuantumRandomAccessOptimizer,
    QuantumRandomAccessEncoding,
    MagicRounding,
)

# pylint: disable=redefined-outer-name

# TODO:
# - update these tests to include solution checking once behavior can be made
# - deterministic.
#    - This might just require us to set seeds in the QuantumInstance and
#    - remove that as an argument altogether.

backends = [
    (BasicAer.get_backend, ""qasm_simulator""),
    (Aer.get_backend, ""qasm_simulator""),
    (Aer.get_backend, ""statevector_simulator""),
    (Aer.get_backend, ""aer_simulator""),
    (Aer.get_backend, ""aer_simulator_statevector""),
    (Aer.get_backend, ""aer_simulator_density_matrix""),
    (Aer.get_backend, ""aer_simulator_matrix_product_state""),
    # The following takes forever, haven't yet waited long enough to know the
    # real timescale
    # (Aer.get_backend, ""aer_simulator_extended_stabilizer""),
]


@pytest.fixture(scope=""module"")
def my_encoding():
    """"""Fixture to construct ``my_encoding`` for use in this file""""""
    # Load small reference problem
    elist = [(0, 1), (0, 4), (0, 3), (1, 2), (1, 5), (2, 3), (2, 4), (4, 5), (5, 3)]
    num_nodes = 6
    mod = Model(""maxcut"")
    nodes = list(range(num_nodes))
    var = [mod.binary_var(name=""x"" + str(i)) for i in nodes]
    mod.maximize(mod.sum((var[i] + var[j] - 2 * var[i] * var[j]) for i, j in elist))
    problem = from_docplex_mp(mod)
    encoding = QuantumRandomAccessEncoding(max_vars_per_qubit=3)
    encoding.encode(problem)
    return encoding


@pytest.fixture(scope=""module"")
def my_ansatz(my_encoding):
    """"""Fixture to construct ``my_ansatz`` for use in this file""""""
    return RealAmplitudes(my_encoding.num_qubits)


@pytest.mark.parametrize(""relaxed_backend"", backends)
@pytest.mark.parametrize(""rounding_backend"", backends)
@pytest.mark.filterwarnings(""ignore::PendingDeprecationWarning"")
@pytest.mark.filterwarnings(
    ""ignore:.*statevector_simulator.*:UserWarning""
)  # ignore magic rounding's UserWarning when using statevector_simulator
@pytest.mark.backend
def test_backend(relaxed_backend, rounding_backend, my_encoding, my_ansatz, shots=3):
    """"""Smoke test of each backend combination""""""

    def cb(f, *args):
        ""Construct backend""
        return f(*args)

    relaxed_qi = QuantumInstance(backend=cb(*relaxed_backend), shots=shots)
    rounding_qi = QuantumInstance(backend=cb(*rounding_backend), shots=shots)
    vqe = VQE(
        ansatz=my_ansatz,
        optimizer=SPSA(maxiter=1, learning_rate=0.01, perturbation=0.1),
        quantum_instance=relaxed_qi,
    )
    rounding_scheme = MagicRounding(rounding_qi)
    qrao = QuantumRandomAccessOptimizer(
        encoding=my_encoding, min_eigen_solver=vqe, rounding_scheme=rounding_scheme
    )
    result = qrao.solve()
    assert result.status == OptimizationResultStatus.SUCCESS


@pytest.mark.backend
def test_magic_rounding_on_hardware_backend(my_encoding, my_ansatz):
    """"""Test *magic rounding* on a hardware backend, if available.""""""
    try:
        provider = IBMProvider()
    except IBMAccountError:
        pytest.skip(""No hardware backend available"")
    print(f""Encoding requires {my_encoding.num_qubits} qubits"")
    backend = least_busy(
        provider.backends(
            min_num_qubits=my_encoding.num_qubits,
            simulator=False,
            operational=True,
        )
    )
    print(f""Using backend: {backend}"")
    relaxed_qi = QuantumInstance(backend=Aer.get_backend(""aer_simulator""), shots=100)
    rounding_qi = QuantumInstance(backend=backend, shots=32)
    vqe = VQE(
        ansatz=my_ansatz,
        optimizer=SPSA(maxiter=1, learning_rate=0.01, perturbation=0.1),
        quantum_instance=relaxed_qi,
    )
    rounding_scheme = MagicRounding(quantum_instance=rounding_qi)
    qrao = QuantumRandomAccessOptimizer(
        encoding=my_encoding, min_eigen_solver=vqe, rounding_scheme=rounding_scheme
    )
    result = qrao.solve()
    assert result.status == OptimizationResultStatus.SUCCESS
"
https://github.com/qiskit-community/prototype-qrao,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021, 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Tests for MagicRounding.""""""

import itertools

import unittest
import pytest

import numpy as np
from docplex.mp.model import Model

from qiskit import QuantumCircuit
from qiskit.utils import QuantumInstance
from qiskit.opflow import (
    StateFn,
    X,
    Y,
    Z,
)
from qiskit_aer import Aer, noise

from qiskit_optimization.translators import from_docplex_mp

from qrao import (
    QuantumRandomAccessEncoding,
    RoundingContext,
    MagicRounding,
)
from qrao.encoding import qrac_state_prep_1q, q2vars_from_var2op

# pylint: disable=protected-access


class TestMagicRounding(unittest.TestCase):
    """"""Test MagicRounding Class""""""

    def setUp(self):
        # load problem, define encoding etc
        # instantiate MagicRounding
        # things here don't change (often)
        super().setUp()
        self.gate_circ = QuantumCircuit(2)
        self.gate_circ.h(0)
        self.gate_circ.h(1)
        self.gate_circ.z(1)
        self.gate_circ.cx(0, 1)
        self.gate_circ.s(0)
        self.gate_circ.save_statevector()

        self.deterministic_trace_vals = [
            [1, 1, 1],
            [1, -1, -1],
            [1, -1, 1],
            [1, 1, -1],
        ]

        elist = [(0, 1), (0, 4), (0, 3), (1, 2), (1, 5), (2, 3), (2, 4), (4, 5), (5, 3)]
        num_nodes = 6
        mod = Model(""maxcut"")
        nodes = list(range(num_nodes))
        var = [mod.binary_var(name=""x"" + str(i)) for i in nodes]
        mod.maximize(mod.sum((var[i] + var[j] - 2 * var[i] * var[j]) for i, j in elist))
        self.problem = from_docplex_mp(mod)
        self.rounding_qi = QuantumInstance(
            backend=Aer.get_backend(""aer_simulator""), shots=10
        )

    # Start test cases in order of increasing complexity
    # toy problems
    # harder problems w/ minimal inputs
    # harder problems w/ more inputs
    # negative test cases
    def test_round_on_gate_and_sv_circs(self):
        """"""Test MagicRounding""""""
        ops = [X, Y, Z]
        var2op = {i: (i // 3, ops[i % 3]) for i in range(3)}
        qi = QuantumInstance(backend=Aer.get_backend(""aer_simulator""), shots=1000)
        magic = MagicRounding(
            quantum_instance=qi,
            basis_sampling=""weighted"",
        )
        # subtest for gate based and sv based etc
        with self.subTest(""Gate Based Magic Uniform Rounding""):
            for m in itertools.product((0, 1), repeat=3):
                qrac_gate_circ = qrac_state_prep_1q(*m).to_circuit()
                magic_basis = 2 * (m[1] ^ m[2]) + (m[0] ^ m[2])
                tv = self.deterministic_trace_vals[magic_basis]
                rounding_context = RoundingContext(
                    trace_values=tv,
                    circuit=qrac_gate_circ,
                    var2op=var2op,
                    _vars_per_qubit=3,
                )
                rounding_res = magic.round(rounding_context)
                self.assertEqual(rounding_res.samples[0].x.tolist(), list(m))
                self.assertEqual(rounding_res.samples[0].probability, 1)

        with self.subTest(""SV Based Magic Uniform Rounding""):
            for m in itertools.product((0, 1), repeat=3):
                qrac_gate_circ = qrac_state_prep_1q(*m).to_circuit()
                sv = StateFn(qrac_gate_circ).eval().primitive
                qrac_sv_circ = QuantumCircuit(1)
                qrac_sv_circ.initialize(sv)
                magic_basis = 2 * (m[1] ^ m[2]) + (m[0] ^ m[2])
                tv = self.deterministic_trace_vals[magic_basis]
                rounding_context = RoundingContext(
                    trace_values=tv,
                    circuit=qrac_sv_circ,
                    var2op=var2op,
                    _vars_per_qubit=3,
                )
                rounding_res = magic.round(rounding_context)
                self.assertEqual(rounding_res.samples[0].x.tolist(), list(m))
                self.assertEqual(rounding_res.samples[0].probability, 1)

    def test_evaluate_magic_bases(self):
        qi = QuantumInstance(backend=Aer.get_backend(""aer_simulator""), shots=1000)
        magic = MagicRounding(
            quantum_instance=qi,
            basis_sampling=""weighted"",
        )
        for m in itertools.product((0, 1), repeat=3):
            qrac_state = qrac_state_prep_1q(*m).to_circuit()
            bases = [[2 * (m[1] ^ m[2]) + (m[0] ^ m[2])]]
            basis_counts = magic._evaluate_magic_bases(
                qrac_state, bases=bases, basis_shots=[10], vars_per_qubit=3
            )
            self.assertEqual(len(basis_counts), 1)
            self.assertEqual(int(list(basis_counts[0].keys())[0]), m[0] ^ m[1] ^ m[2])

    def test_dv_counts(self):
        """"""
        Checks that the dv_counts method unpacks these measurement outcomes
        properly. This also effectively tests `unpack_measurement_outcome`.
        """"""
        ops = [X, Y, Z]
        var2op = {i: (i // 3, ops[i % 3]) for i in range(6)}
        magic = MagicRounding(self.rounding_qi)
        compute_dv_counts = magic._compute_dv_counts
        solns = []
        for b0 in range(4):
            for b1 in range(4):
                for outcome in range(4):
                    bases = [[b0, b1]]
                    basis_counts = [{f""{outcome:02b}"": 1}]
                    dv_counts = compute_dv_counts(basis_counts, bases, var2op, 3)
                    solns.append(list(dv_counts.keys())[0])
        ref = [
            ""000000"",
            ""000111"",
            ""111000"",
            ""111111"",
            ""000011"",
            ""000100"",
            ""111011"",
            ""111100"",
            ""000101"",
            ""000010"",
            ""111101"",
            ""111010"",
            ""000110"",
            ""000001"",
            ""111110"",
            ""111001"",
            ""011000"",
            ""011111"",
            ""100000"",
            ""100111"",
            ""011011"",
            ""011100"",
            ""100011"",
            ""100100"",
            ""011101"",
            ""011010"",
            ""100101"",
            ""100010"",
            ""011110"",
            ""011001"",
            ""100110"",
            ""100001"",
            ""101000"",
            ""101111"",
            ""010000"",
            ""010111"",
            ""101011"",
            ""101100"",
            ""010011"",
            ""010100"",
            ""101101"",
            ""101010"",
            ""010101"",
            ""010010"",
            ""101110"",
            ""101001"",
            ""010110"",
            ""010001"",
            ""110000"",
            ""110111"",
            ""001000"",
            ""001111"",
            ""110011"",
            ""110100"",
            ""001011"",
            ""001100"",
            ""110101"",
            ""110010"",
            ""001101"",
            ""001010"",
            ""110110"",
            ""110001"",
            ""001110"",
            ""001001"",
        ]
        self.assertTrue(np.all(np.array(ref) == np.array(solns)))

    def test_sample_bases_weighted(self):  # pylint: disable=too-many-locals
        """"""
        There are a few settings of the trace values which
        cause the magic basis sampling probabilities to be deterministic.
        I pass these through (for a 2 qubit, 6 var example) and verify
        that the outputs are correctly shaped and are deterministic.

        Note that these input trace values are non-physical
        """"""
        shots = 10
        num_nodes = 6
        num_qubits = 2
        rounding_qi = QuantumInstance(
            backend=Aer.get_backend(""aer_simulator""), shots=shots
        )
        ops = [X, Y, Z]
        var2op = {i: (i // 3, ops[i % 3]) for i in range(num_nodes)}
        q2vars = q2vars_from_var2op(var2op)
        magic = MagicRounding(quantum_instance=rounding_qi, basis_sampling=""weighted"")
        sample_bases_weighted = magic._sample_bases_weighted

        for b0, tv0 in enumerate(self.deterministic_trace_vals):
            for b1, tv1 in enumerate(self.deterministic_trace_vals):
                tv = tv0 + tv1
                bases, basis_shots = sample_bases_weighted(q2vars, tv, 3)
                self.assertTrue(np.all(np.array([b0, b1]) == bases))
                self.assertEqual(basis_shots, (shots,))
                self.assertEqual(bases.shape, (1, num_qubits))  # 1 == deterministic

        # Both trace values and a circuit must be provided
        with self.assertRaises(NotImplementedError):
            magic.round(
                RoundingContext(trace_values=[1.0], var2op=var2op, _vars_per_qubit=3)
            )
        with self.assertRaises(NotImplementedError):
            magic.round(
                RoundingContext(
                    circuit=self.gate_circ, var2op=var2op, _vars_per_qubit=3
                )
            )

    def test_sample_bases_uniform(self):
        """"""
        Verify that the outputs of uniform sampling are correctly shaped.
        """"""
        num_nodes = 3
        num_qubits = 1
        ops = [X, Y, Z]
        var2op = {i: (i // 3, ops[i % 3]) for i in range(num_nodes)}
        q2vars = q2vars_from_var2op(var2op)
        shots = 1000  # set high enough to ""always"" have four distinct results
        qi = QuantumInstance(backend=Aer.get_backend(""aer_simulator""), shots=shots)
        magic = MagicRounding(
            quantum_instance=qi,
            basis_sampling=""uniform"",
        )
        bases, basis_shots = magic._sample_bases_uniform(q2vars, 3)
        self.assertEqual(basis_shots.shape, (4,))
        self.assertEqual(np.sum(basis_shots), shots)
        self.assertEqual(bases.shape, (4, num_qubits))

        # A circuit must be provided, but trace values need not be
        circuit = QuantumCircuit(1)
        circuit.h(0)
        magic.round(RoundingContext(circuit=circuit, var2op=var2op, _vars_per_qubit=3))
        with self.assertRaises(NotImplementedError):
            magic.round(RoundingContext(var2op=var2op, _vars_per_qubit=3))


def test_unsupported_backend():
    qi = QuantumInstance(Aer.get_backend(""aer_simulator_unitary""), shots=100)
    with pytest.raises(ValueError):
        MagicRounding(quantum_instance=qi)


def test_unsupported_basis_sampling_method():
    qi = QuantumInstance(Aer.get_backend(""aer_simulator""), shots=100)
    with pytest.raises(ValueError):
        MagicRounding(quantum_instance=qi, basis_sampling=""foo"")


@pytest.mark.filterwarnings(""ignore::PendingDeprecationWarning"")
def test_magic_rounding_statevector_simulator():
    """"""Test magic rounding on the statevector simulator

    ... which behaves unlike the others, as the ""counts"" are probabilities, not
    integers, and so special care is required.
    """"""
    qi = QuantumInstance(Aer.get_backend(""statevector_simulator""), shots=10)
    ops = [X, Y, Z]
    var2op = {i: (i // 3, ops[i % 3]) for i in range(3)}
    with pytest.warns(UserWarning):
        magic = MagicRounding(
            quantum_instance=qi,
            basis_sampling=""weighted"",
        )
    circ = QuantumCircuit(2)
    circ.h(0)
    circ.h(1)
    circ.cx(0, 1)
    ctx = RoundingContext(
        circuit=circ, trace_values=[1, 1, 1], var2op=var2op, _vars_per_qubit=3
    )
    res = magic.round(ctx)
    assert sum(s.probability for s in res.samples) == pytest.approx(1)


def test_noisy_quantuminstance():
    """"""Smoke test using a QuantumInstance with noise""""""
    noise_model = noise.NoiseModel()
    # 1-qubit gates
    noise_model.add_all_qubit_quantum_error(
        noise.depolarizing_error(0.001, 1), [""rz"", ""sx"", ""x""]
    )
    # 2-qubit gate
    noise_model.add_all_qubit_quantum_error(noise.depolarizing_error(0.01, 2), [""cx""])

    backend = Aer.get_backend(""aer_simulator"")
    qi = QuantumInstance(backend=backend, noise_model=noise_model, shots=100)
    magic = MagicRounding(quantum_instance=qi)

    ops = [X, Y, Z]
    var2op = {i: (i // 3, ops[i % 3]) for i in range(3)}
    circuit = qrac_state_prep_1q(0, 1, 0).to_circuit()
    magic.round(
        RoundingContext(
            trace_values=[1, 1, 1], var2op=var2op, circuit=circuit, _vars_per_qubit=3
        )
    )


def test_magic_rounding_statistical():
    """"""Statistical test for magic rounding

    to make sure each deterministic case rounds consistently
    """"""
    shots = 1024
    mr = MagicRounding(
        QuantumInstance(backend=Aer.get_backend(""aer_simulator""), shots=shots)
    )

    test_cases = (
        # 3 variables encoded as a (3,1,p) QRAC
        ((0, 0, 0), 0, 0),
        ((1, 1, 1), 0, 1),
        ((0, 1, 1), 1, 0),
        ((1, 0, 0), 1, 1),
        ((1, 0, 1), 2, 0),
        ((0, 1, 0), 2, 1),
        ((1, 1, 0), 3, 0),
        ((0, 0, 1), 3, 1),
        # 2 variables encoded as a (2,1,p) QRAC
        ((0, 0), 0, 0),
        ((1, 1), 0, 1),
        ((0, 1), 1, 0),
        ((1, 0), 1, 1),
        # 1 variable encoded as a (1,1,1) QRAC
        ((0,), 0, 0),
        ((1,), 0, 1),
    )

    for (m, basis, expected) in test_cases:
        encoding = QuantumRandomAccessEncoding(len(m))
        encoding._add_variables(list(range(len(m))))
        circuit = encoding.state_prep(m).to_circuit()
        result = mr.round(RoundingContext(encoding=encoding, circuit=circuit))
        deterministic_dict = result.basis_counts[basis]
        assert set(deterministic_dict) == set([str(expected)])


if __name__ == ""__main__"":
    import sys

    sys.exit(pytest.main([__file__]))
"
https://github.com/qiskit-community/qiskit-toqm,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import qiskit
from qiskit.transpiler import TranspilerError
import qiskit_toqm.native as toqm

from itertools import chain


def _calc_swap_durations(coupling_map, instruction_durations, basis_gates, backend_properties, target):
    """"""Calculates the durations of swap gates between each coupling on the target.""""""
    # Filter for couplings that don't already have a native swap.
    couplings = [
        c for c in coupling_map.get_edges()
        if (""swap"", c) not in instruction_durations.duration_by_name_qubits
    ]

    if not couplings:
        return

    backend_aware = target is not None or (basis_gates is not None and backend_properties is not None)
    if not backend_aware:
        raise TranspilerError(
            ""`target` must be specified, or both 'basis_gates' and 'backend_properties' must be specified unless""
            ""'instruction_durations' has durations for all swap gates.""
        )

    def gen_swap_circuit(s, t):
        # Generates a circuit with a single swap gate between src and tgt
        c = qiskit.QuantumCircuit(coupling_map.size())
        c.swap(s, t)
        return c

    # Batch transpile generated swap circuits
    swap_circuits = qiskit.transpile(
        [gen_swap_circuit(*pair) for pair in couplings],
        basis_gates=basis_gates,
        coupling_map=coupling_map,
        backend_properties=backend_properties if target is None else None,
        instruction_durations=instruction_durations,
        target=target,
        optimization_level=0,
        layout_method=""trivial"",
        scheduling_method=""asap""
    )

    for (src, tgt), qc in zip(couplings, swap_circuits):
        if instruction_durations.dt is None and qc.unit == ""dt"":
            # TODO: should be able to convert by looking up an op in both
            raise TranspilerError(""Incompatible units."")

        duration = qc.qubit_duration(src, tgt)
        yield src, tgt, duration


def latencies_from_target(
    coupling_map=None,
    instruction_durations=None,
    basis_gates=None,
    backend_properties=None,
    target=None,
    normalize_scale=2
):
    """"""
    Generate a list of native ``LatencyDescription`` objects for
    the specified target device.

    Args:
        coupling_map (Optional[CouplingMap]): CouplingMap of the target backend.
            Required unless ``target`` is specified.
        instruction_durations (Optional[InstructionDurations]): Durations for gates
            in the target's basis. Must include durations for all gates
            that appear in input DAGs other than ``swap`` (for which
            durations are calculated through decomposition if not supplied).
            Required unless ``target`` is specified.
        basis_gates (Optional[List[str]]): The list of basis gates for the
            target. Required unless ``instruction_durations``
            contains durations for all swap gates or ``target`` is specified.
        backend_properties (Optional[BackendProperties]): The backend
            properties of the target. Required unless
            ``instruction_durations`` contains durations for all swap gates
            or ``target`` is specified.
        target (Optional[Target]): The backend transpiler target. If specified,
            overrides ``coupling_map``, ``instruction_durations``, ``basis_gates``,
            and ``backend_properties``. All gates that appear in input DAG other
            than ``swap`` must be supported by the target and have duration
            information available therein.
        normalize_scale (int): Multiple by this factor when converting
            relative durations to cycle count. The conversion is:
            cycles = ceil(duration * NORMALIZE_SCALE / min_duration)
            where min_duration is the length of the fastest non-zero duration
            instruction on the target.
    """"""
    if target is not None:
        coupling_map = target.build_coupling_map()
        instruction_durations = target.durations()
        basis_gates = target.operation_names

    unit = ""dt"" if instruction_durations.dt else ""s""

    swap_durations = list(_calc_swap_durations(coupling_map, instruction_durations, basis_gates, backend_properties, target))
    default_op_durations = [
        (op_name, instruction_durations.get(op_name, [], unit))
        for op_name in instruction_durations.duration_by_name
    ]
    op_durations = [
        (op_name, bits, instruction_durations.get(op_name, bits, unit))
        for (op_name, bits) in instruction_durations.duration_by_name_qubits
    ]

    non_zero_durations = [d for d in chain(
        (d for (_, d) in default_op_durations),
        (d for (_, _, d) in op_durations),
        (d for (_, _, d) in swap_durations)
    ) if d > 0]

    if not non_zero_durations:
        raise TranspilerError(""Durations must be specified for the target."")

    min_duration = min(non_zero_durations)

    def normalize(d):
        return round(d * normalize_scale / min_duration)

    # Yield latency descriptions with durations interpolated to cycles.
    for op_name, duration in default_op_durations:
        # We don't know if the instruction is for 1 or 2 qubits, so emit
        # defaults for both.
        yield toqm.LatencyDescription(1, op_name, normalize(duration))
        yield toqm.LatencyDescription(2, op_name, normalize(duration))

    for op_name, qubits, duration in op_durations:
        yield toqm.LatencyDescription(op_name, *qubits, normalize(duration))

    for src, tgt, duration in swap_durations:
        yield toqm.LatencyDescription(""swap"", src, tgt, normalize(duration))


def latencies_from_simple(one_qubit_cycles, two_qubit_cycles, swap_cycles):
    """"""
    Generate a list of native ``LatencyDescription`` objects for
    the specified hard-coded cycle counts.

    The resulting latency descriptions describe a circuit in which
    all 1Q, 2Q, and SWAP gates execute in the corresponding number
    of cycles, irrespective of which qubits they execute on.

    Args:
        one_qubit_cycles (int): The number of cycles for all 1Q gates.
        two_qubit_cycles (int): The number of cycles for all 2Q gates.
        swap_cycles (int): The number of cycles for all swap gates.
    """"""
    return [
        toqm.LatencyDescription(1, one_qubit_cycles),
        toqm.LatencyDescription(2, two_qubit_cycles),
        toqm.LatencyDescription(2, ""swap"", swap_cycles)
    ]
"
https://github.com/qiskit-community/qiskit-toqm,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import qiskit_toqm.native as toqm


class ToqmHeuristicStrategy:
    def __init__(self, latency_descriptions, top_k, queue_target, queue_max, retain_popped=1):
        """"""
        Constructs a TOQM strategy that aims to minimize overall circuit duration.
        The priority queue used in the A* is configured to drop the worst nodes
        whenever it reaches the queue size limit. Node expansion is also limited
        to exploring the best ``K`` children.

        Args:
            latency_descriptions (List[toqm.LatencyDescription]): The latency descriptions
            for all gates that will appear in the circuit, including swaps.
            top_k (int): The maximum number of best child nodes that can be pushed to the
            queue during expansion of any given node.
            queue_target (int): When the priority queue reaches capacity, nodes are dropped
            until the size reaches this value.
            queue_max (int): The priority queue capacity.
            retain_popped (int): Final nodes to retain.

        Raises:
            RuntimeError: No routing was found.
        """"""
        # The following defaults are based on:
        # https://github.com/time-optimal-qmapper/TOQM/blob/main/code/README.txt
        self.mapper = toqm.ToqmMapper(
            toqm.TrimSlowNodes(queue_max, queue_target),
            toqm.GreedyTopK(top_k),
            toqm.CXFrontier(),
            toqm.Table(list(latency_descriptions)),
            [toqm.GreedyMapper()],
            [],
            0
        )

        self.mapper.setRetainPopped(retain_popped)

    def __call__(self, gates, num_qubits, coupling_map):
        """"""
        Run native ToqmMapper and return the native result.

        Args:
            gates (List[toqm.GateOp]): The topologically ordered list of gate operations.
            num_qubits (int): The number of virtual qubits used in the circuit.
            coupling_map (toqm.CouplingMap): The coupling map of the target.

        Returns:
            toqm.ToqmResult: The native result.
        """"""
        return self.mapper.run(gates, num_qubits, coupling_map)


class ToqmOptimalStrategy:
    def __init__(self, latency_descriptions, perform_layout=True, no_swaps=False):
        """"""
        Constructs a TOQM strategy that finds an optimal (minimal) routing
        in terms of overall circuit duration.

        Args:
            latency_descriptions (List[toqm.LatencyDescription]): The latency descriptions
            for all gates that will appear in the circuit, including swaps.
            perform_layout (Boolean): If true, permutes the initial layout rather than
            inserting swap gates at the start of the circuit.
            no_swaps (Boolean): If true, attempts to find a routing without inserting swaps.

        Raises:
            RuntimeError: No routing was found.
        """"""
        # The following defaults are based on:
        # https://github.com/time-optimal-qmapper/TOQM/blob/main/code/README.txt
        self.mapper = toqm.ToqmMapper(
            toqm.DefaultQueue(),
            toqm.NoSwaps() if no_swaps else toqm.DefaultExpander(),
            toqm.CXFrontier(),
            toqm.Table(latency_descriptions),
            [],
            [toqm.HashFilter(), toqm.HashFilter2()],
            -1 if perform_layout else 0
        )

    def __call__(self, gates, num_qubits, coupling_map):
        """"""
        Run native ToqmMapper and return the native result.

        Args:
            gates (List[toqm.GateOp]): The topologically ordered list of gate operations.
            num_qubits (int): The number of virtual qubits used in the circuit.
            coupling_map (toqm.CouplingMap): The coupling map of the target.

        Returns:
            toqm.ToqmResult: The native result.
        """"""
        return self.mapper.run(gates, num_qubits, coupling_map)
"
https://github.com/qiskit-community/qiskit-toqm,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
import logging

import qiskit_toqm.native as toqm

from qiskit.circuit.library.standard_gates import SwapGate
from qiskit.dagcircuit import DAGCircuit

from qiskit.transpiler.basepasses import TransformationPass
from qiskit.transpiler.exceptions import TranspilerError

logger = logging.getLogger(__name__)


class ToqmSwap(TransformationPass):
    r""""""Map input circuit onto a backend topology via insertion of SWAPs.
    Implementation of the SWAP-based approach from Time-Optimal Qubit
    Mapping paper [1].
    **References:**
    [1] Chi Zhang, Ari B. Hayes, Longfei Qiu, Yuwei Jin, Yanhao Chen, and Eddy Z. Zhang. 2021. Time-Optimal Qubit
    Mapping. In Proceedings of the 26th ACM International Conference on Architectural Support for Programming
    Languages and Operating Systems (ASPLOS ’21), April 19–23, 2021, Virtual, USA.
    ACM, New York, NY, USA, 14 pages.
    `<https://doi.org/10.1145/3445814.3446706>`_
    """"""

    def __init__(
            self,
            coupling_map,
            strategy):
        """"""
        ToqmSwap initializer.

        Args:
            coupling_map (CouplingMap): CouplingMap of the target backend.
            strategy (typing.Callable[[List[toqm.GateOp], int, toqm.CouplingMap], toqm.ToqmResult]):
                A callable responsible for running the native ``ToqmMapper`` and
                returning a native ``ToqmResult``.
        """"""
        super().__init__()

        if coupling_map is None:
            # We cannot construct a proper TOQM mapper without a coupling map,
            # but we gracefully handle construction without one, and then
            # assert that `run` is never called on this instance.
            return

        if coupling_map.size() > 127:
            raise TranspilerError(""ToqmSwap currently supports a max of 127 qubits."")

        self.coupling_map = coupling_map
        self.toqm_strategy = strategy
        self.toqm_result = None

    def run(self, dag: DAGCircuit):
        """"""Run the ToqmSwap pass on `dag`.
        Args:
            dag (DAGCircuit): the directed acyclic graph to be mapped.
        Returns:
            DAGCircuit: A dag mapped to be compatible with the coupling_map.
        Raises:
            TranspilerError: if the coupling map or the layout are not
            compatible with the DAG
        """"""
        if self.coupling_map is None:
            raise TranspilerError(""TOQM swap not properly initialized."")

        if len(dag.qregs) != 1 or dag.qregs.get(""q"", None) is None:
            raise TranspilerError(""TOQM swap runs on physical circuits only."")

        if len(dag.qubits) > self.coupling_map.size():
            raise TranspilerError(""More virtual qubits exist than physical."")

        reg = dag.qregs[""q""]

        # Generate UIDs for each gate node from the original circuit so we can
        # look them up later when rebuilding the circuit.
        # Note: this is still sorted by topological order from above.
        uid_to_op_node = {uid: op for uid, op in enumerate(dag.topological_op_nodes())}

        # Create TOQM topological gate list
        def gates():
            for uid, node in uid_to_op_node.items():
                if len(node.qargs) == 2:
                    yield toqm.GateOp(uid, node.op.name, reg.index(node.qargs[0]), reg.index(node.qargs[1]))
                elif len(node.qargs) == 1:
                    yield toqm.GateOp(uid, node.op.name, reg.index(node.qargs[0]))
                else:
                    raise TranspilerError(f""ToqmSwap only works with 1q and 2q gates! ""
                                          f""Bad gate: {node.op.name} {node.qargs}"")

        gate_ops = list(gates())
        edges = {e for e in self.coupling_map.get_edges()}
        couplings = toqm.CouplingMap(self.coupling_map.size(), edges)

        self.toqm_result = self.toqm_strategy(gate_ops, dag.num_qubits(), couplings)

        # Preserve input DAG's name, regs, wire_map, etc. but replace the graph.
        mapped_dag = dag.copy_empty_like()

        for g in self.toqm_result.scheduledGates:
            if g.gateOp.type.lower() == ""swap"":
                mapped_dag.apply_operation_back(SwapGate(), qargs=[reg[g.physicalControl], reg[g.physicalTarget]])
                continue

            original_op = uid_to_op_node[g.gateOp.uid]
            if g.physicalControl >= 0:
                mapped_dag.apply_operation_back(original_op.op, cargs=original_op.cargs, qargs=[
                    reg[g.physicalControl],
                    reg[g.physicalTarget]
                ])
            else:
                mapped_dag.apply_operation_back(original_op.op, cargs=original_op.cargs, qargs=[
                    reg[g.physicalTarget]
                ])

        self._update_layout()

        return mapped_dag

    def _update_layout(self):
        layout = self.property_set['layout']

        # Need to copy this mapping since layout updates
        # might overwrite original vbits we need to read!
        p2v = layout.get_physical_bits().copy()

        # Update the layout if TOQM made changes.
        ancilla_vbits = []
        for vidx in range(self.toqm_result.numPhysicalQubits):
            pidx = self.toqm_result.inferredLaq[vidx]

            if pidx == -1:
                # bit is not mapped to physical qubit
                ancilla_vbits.append(p2v[vidx])
                continue

            if pidx != vidx:
                # Bit was remapped!
                # First, we need to get the original virtual bit from the layout.
                vbit = p2v[vidx]

                # Then, map updated pidx from TOQM to original virtual bit.
                layout[pidx] = vbit

        # Map any unmapped physical bits to ancilla.
        for pidx, vidx in enumerate(self.toqm_result.inferredQal):
            if vidx < 0:
                # Current physical bit isn't mapped. Map it to an ancilla.
                layout[pidx] = ancilla_vbits.pop(0)
"
https://github.com/qiskit-community/qiskit-toqm,qiskit-community,"import unittest

import qiskit_toqm.native as toqm


class TestTOQM(unittest.TestCase):

    def test_version(self):
        self.assertEqual(toqm.__version__, ""0.1.0"")

    def test_basic(self):
        num_q = 4
        gates = [
            toqm.GateOp(0, ""cx"", 0, 1),
            toqm.GateOp(1, ""cx"", 0, 2),
            toqm.GateOp(2, ""cx"", 0, 3),
            toqm.GateOp(3, ""cx"", 1, 2),
            toqm.GateOp(4, ""cx"", 1, 3),
            toqm.GateOp(5, ""cx"", 2, 3)
        ]

        coupling = toqm.CouplingMap(5, {(0, 1), (0, 2), (1, 2), (2, 3), (2, 4), (3, 4)})

        q = toqm.DefaultQueue()
        exp = toqm.DefaultExpander()
        cf = toqm.CXFrontier()
        lat = toqm.Latency_1_2_6()
        fs = [toqm.HashFilter(), toqm.HashFilter2()]
        nms = []

        mapper = toqm.ToqmMapper(q, exp, cf, lat, nms, fs, -1)
        mapper.setRetainPopped(0)

        result = mapper.run(gates, num_q, coupling)

        # Print result
        for g in result.scheduledGates:
            print(f""{g.gateOp.type} "", end='')
            if g.physicalControl >= 0:
                print(f""q[{g.physicalControl}],"", end='')
            print(f""q[{g.physicalTarget}]; "", end='')

            print(f""//cycle: {g.cycle}"", end='')

            if (g.gateOp.type.lower() != ""swap""):
                print(f"" //{g.gateOp.type} "", end='')
                if g.gateOp.control >= 0:
                    print(f""q[{g.gateOp.control}],"", end='')
                print(f""q[{g.gateOp.target}]; "", end='')
            print()"
https://github.com/qiskit-community/prototype-quantum-kernel-training,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Create a new Covariant Feature Map circuit.""""""

import copy
from typing import Callable, Optional, Union, List, Dict, Any

import numpy as np

from qiskit import QuantumCircuit
from qiskit.circuit import ParameterVector


class CovariantFeatureMap(QuantumCircuit):
    """"""The Covariant Feature Map circuit.

    On 3 qubits and a linear entanglement,  the circuit is represented by:

    .. parsed-literal::


         ┌──────────────┐       ░ ┌─────────────────┐┌─────────────────┐
    q_0: ┤ Ry(θ_par[0]) ├─■─────░─┤ Rz(-2*x_par[1]) ├┤ Rx(-2*x_par[0]) ├
         ├──────────────┤ │     ░ ├─────────────────┤├─────────────────┤
    q_1: ┤ Ry(θ_par[1]) ├─■──■──░─┤ Rz(-2*x_par[3]) ├┤ Rx(-2*x_par[2]) ├
         ├──────────────┤    │  ░ ├─────────────────┤├─────────────────┤
    q_2: ┤ Ry(θ_par[2]) ├────■──░─┤ Rz(-2*x_par[5]) ├┤ Rx(-2*x_par[4]) ├
         └──────────────┘       ░ └─────────────────┘└─────────────────┘

    where θ_par is a vector of trainable feature map parameters and x_par is a
    vector of data-bound feature map parameters.
    """"""

    def __init__(
        self,
        feature_dimension: int,
        entanglement: Union[str, List[List[int]], Callable[[int], List[int]]] = None,
        single_training_parameter: bool = False,
        name: str = ""CovariantFeatureMap"",
    ) -> None:
        """"""Create a new Covariant Feature Map circuit.

        Args:
            feature_dimension: The number of features
            insert_barriers: If True, barriers are inserted around the entanglement layer

        """"""
        if (feature_dimension % 2) != 0:
            raise ValueError(
                """"""
            Covariant feature map requires an even number of input features.
                """"""
            )
        self.feature_dimension = feature_dimension
        self.entanglement = entanglement
        self.single_training_parameter = single_training_parameter
        self.training_parameters = None
        self.input_parameters = None

        num_qubits = feature_dimension / 2
        super().__init__(
            num_qubits,
            name=name,
        )

        self._generate_feature_map()

    @property
    def settings(self) -> Dict[str, Any]:
        training_parameters_list = [param for param in self.training_parameters]
        input_parameters_list = [param for param in self.input_parameters]
        return {
            ""feature_dimension"": self.feature_dimension,
            ""entanglement"": self.entanglement,
            ""single_training_parameter"": self.single_training_parameter,
            ""training_parameters"": training_parameters_list,
            ""input_parameters"": input_parameters_list,
        }

    def _generate_feature_map(self):
        # If no entanglement scheme specified, use linear entanglement
        if self.entanglement is None:
            self.entanglement = [[i, i + 1] for i in range(self.num_qubits - 1)]

        # Vector of data parameters
        input_params = ParameterVector(""x_par"", self.feature_dimension)

        # Use a single parameter to rotate each qubit if sharing is desired
        if self.single_training_parameter:
            training_params = ParameterVector(""\u03B8_par"", 1)
            # Create an initial rotation layer using a single Parameter
            for i in range(self.num_qubits):
                self.ry(training_params[0], self.qubits[i])

        # Train each qubit's initial rotation individually
        else:
            training_params = ParameterVector(""\u03B8_par"", self.num_qubits)
            # Create an initial rotation layer of trainable parameters
            for i in range(self.num_qubits):
                self.ry(training_params[i], self.qubits[i])

        self.training_parameters = training_params
        self.input_parameters = input_params

        # Create the entanglement layer
        for source, target in self.entanglement:
            self.cz(self.qubits[source], self.qubits[target])

        self.barrier()

        # Create a circuit representation of the data group
        for i in range(self.num_qubits):
            self.rz(-2 * input_params[2 * i + 1], self.qubits[i])
            self.rx(-2 * input_params[2 * i], self.qubits[i])
"
https://github.com/qiskit-community/prototype-entanglement-forging,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Ground state computation using a minimum eigensolver with entanglement forging.""""""

import time
import warnings
from typing import List, Iterable, Union, Dict, Optional, Tuple

import numpy as np
from qiskit import QuantumCircuit
from qiskit.algorithms import MinimumEigensolver
from qiskit.circuit import Instruction
from qiskit.opflow import OperatorBase, PauliSumOp
from qiskit.quantum_info import Statevector
from qiskit.result import Result
from qiskit_nature import ListOrDictType
from qiskit_nature.algorithms.ground_state_solvers import (
    GroundStateSolver,
    MinimumEigensolverFactory,
)
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.mappers.second_quantization import JordanWignerMapper
from qiskit_nature.operators.second_quantization import SecondQuantizedOp
from qiskit_nature.problems.second_quantization import BaseProblem
from qiskit_nature.problems.second_quantization.electronic import (
    ElectronicStructureProblem,
)

from entanglement_forging.core.classical_energies import ClassicalEnergies
from entanglement_forging.core.forged_operator import ForgedOperator
from entanglement_forging.core.entanglement_forged_config import (
    EntanglementForgedConfig,
)
from entanglement_forging.core.wrappers.entanglement_forged_vqe import (
    EntanglementForgedVQE,
)
from entanglement_forging.core.wrappers.entanglement_forged_vqe_result import (
    EntanglementForgedVQEResult,
    OptimalParams,
)
from entanglement_forging.utils.log import Log


# pylint: disable=too-many-arguments,protected-access
class EntanglementForgedGroundStateSolver(GroundStateSolver):
    """"""Ground state computation using a minimum solver with entanglement forging.

    Attr:
        transformation: Qubit Operator Transformation
        ansatz (Two):
        orbitals_to_reduce (list of int): Orbital list to be frozen or removed.
    """"""

    def __init__(
        self,
        qubit_converter: QubitConverter,
        ansatz: QuantumCircuit,
        bitstrings_u: Iterable[Iterable[int]],
        config: EntanglementForgedConfig,
        bitstrings_v: Iterable[Iterable[int]] = None,
        orbitals_to_reduce: bool = None,
    ):
        # Ensure the bitstrings are well formed
        if any(len(bitstrings_u[0]) != len(bitstr) for bitstr in bitstrings_u):
            raise ValueError(""All U bitstrings must be the same length."")

        if bitstrings_v:
            if len(bitstrings_u) != len(bitstrings_v):
                raise ValueError(
                    ""The same number of bitstrings should be passed for U and V.""
                )

            if len(bitstrings_u[0]) != len(bitstrings_v[0]):
                raise ValueError(""Bitstrings for U and V should be the same length."")

            if any(len(bitstrings_v[0]) != len(bitstr) for bitstr in bitstrings_v):
                raise ValueError(""All V bitstrings must be the same length."")

        # Initialize the GroundStateSolver
        super().__init__(qubit_converter)

        # Set which orbitals to ignore when calculating the Hamiltonian
        if orbitals_to_reduce is None:
            orbitals_to_reduce = []
        self.orbitals_to_reduce = orbitals_to_reduce

        # Set private class fields
        self._ansatz = ansatz
        self._bitstrings_u = bitstrings_u
        self._config = config  # pylint: disable=arguments-differ

        # Prevent unnecessary duplication of circuits if subsystems are identical
        if (bitstrings_v is None) or (bitstrings_u == bitstrings_v):
            self._bitstrings_v = []
        else:
            self._bitstrings_v = bitstrings_v

    # pylint: disable=arguments-differ
    def solve(
        self,
        problem: ElectronicStructureProblem,
    ) -> EntanglementForgedVQEResult:
        """"""Compute Ground State properties of chemical problem.

        Args:
            problem: a qiskit_nature.problems.second_quantization
                .electronic.electronic_structure_problem object.
            aux_operators: additional auxiliary operators to evaluate
            **kwargs: keyword args to pass to solver

        Raises:
            ValueError: If the transformation is not of the type FermionicTransformation.
            ValueError: If the qubit mapping is not of the type JORDAN_WIGNER.

        Returns:
            An eigenstate result.
        """"""

        if not isinstance(problem, ElectronicStructureProblem):
            raise ValueError(
                ""This version only supports an ElectronicStructureProblem.""
            )
        if not isinstance(self.qubit_converter.mapper, JordanWignerMapper):
            raise ValueError(""This version only supports the JordanWignerMapper."")

        start_time = time.time()

        problem.driver.run()

        # Decompose the Hamiltonian operators into a form appropraite for EF
        forged_operator = ForgedOperator(
            problem, self.orbitals_to_reduce, self._calculate_tensor_cross_terms()
        )

        # Calculate energies clasically using pySCF
        classical_energies = ClassicalEnergies(problem, self.orbitals_to_reduce)

        self._solver = EntanglementForgedVQE(
            ansatz=self._ansatz,
            bitstrings_u=self._bitstrings_u,
            bitstrings_v=self._bitstrings_v,
            config=self._config,
            forged_operator=forged_operator,
            classical_energies=classical_energies,
        )
        result = self._solver.compute_minimum_eigenvalue(forged_operator.h_1_op)

        elapsed_time = time.time() - start_time
        Log.log(f""VQE for this problem took {elapsed_time} seconds"")
        res = EntanglementForgedVQEResult(
            parameters_history=self._solver._paramsets_each_iteration,
            energies_history=self._solver._energy_each_iteration_each_paramset,
            schmidts_history=self._solver._schmidt_coeffs_each_iteration_each_paramset,
            energy_std_each_parameter_set=self._solver.energy_std_each_parameter_set,
            energy_offset=self._solver._add_this_to_energies_displayed,
            eval_count=self._solver._eval_count,
        )
        res.combine(result)
        return res

    def _calculate_tensor_cross_terms(self) -> bool:
        """"""
        Determine whether circuits should be generated to account for
        the special superposition terms needed when bn==bm for two
        bitstrings within a given subsystem's (U or V) bitstring list.
        """"""
        bsu = self._bitstrings_u
        bsv = self._bitstrings_u

        # Search for any duplicate bitstrings within the subsystem lists
        for i, bu1 in enumerate(bsu):
            for j, bu2 in enumerate(bsu):
                if i == j:
                    continue
                if bu1 == bu2:
                    return True
        for i, bv1 in enumerate(bsv):
            for j, bv2 in enumerate(bsv):
                if i == j:
                    continue
                if bv1 == bv2:
                    return True

        return False

    def returns_groundstate(self) -> bool:
        """"""Whether this class returns only the ground state energy or also the ground state itself.

        Returns:
            True, if this class also returns the ground state in the results object.
            False otherwise.
        """"""
        return True

    def evaluate_operators(
        self,
        state: Union[
            str,
            dict,
            Result,
            list,
            np.ndarray,
            Statevector,
            QuantumCircuit,
            Instruction,
            OperatorBase,
        ],
        operators: Union[PauliSumOp, OperatorBase, list, dict],
    ) -> Union[float, Iterable[float], Dict[str, Iterable[float]]]:
        """"""Evaluates additional operators at the given state.""""""
        warnings.warn(
            ""evaluate_operators not implemented for ""
            ""forged EntanglementForgedGroundStateSolver.""
        )
        return []

    @property
    def solver(self) -> Union[MinimumEigensolver, MinimumEigensolverFactory]:
        """"""Returns the minimum eigensolver or factory.""""""
        return self._solver

    def get_qubit_operators(
        self,
        problem: BaseProblem,
        aux_operators: Optional[
            ListOrDictType[Union[SecondQuantizedOp, PauliSumOp]]
        ] = None,
    ) -> Tuple[PauliSumOp, Optional[ListOrDictType[PauliSumOp]]]:
        """"""Gets the operator and auxiliary operators, and transforms the provided auxiliary operators""""""
        raise NotImplementedError(
            ""get_qubit_operators has not been implemented in EntanglementForgedGroundStateEigensolver""
        )
"
https://github.com/qiskit-community/prototype-entanglement-forging,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Entanglement forged VQE.""""""

import datetime
import time
import warnings
from typing import Iterable, Tuple, Callable, Union

import numpy as np
from qiskit import transpile, QuantumCircuit
from qiskit.algorithms import VQE
from qiskit.utils.mitigation import complete_meas_cal
from qiskit.quantum_info import Pauli
from qiskit.utils import QuantumInstance
from qiskit.opflow import OperatorBase

from entanglement_forging.core.entanglement_forged_config import (
    EntanglementForgedConfig,
)
from entanglement_forging.core.forged_operator import ForgedOperator
from entanglement_forging.core.classical_energies import ClassicalEnergies
from entanglement_forging.core.wrappers.entanglement_forged_vqe_result import (
    DataResults,
    Bootstrap,
    AuxiliaryResults,
)
from entanglement_forging.utils.bootstrap_result import resample_result
from entanglement_forging.utils.copysample_circuits import (
    copysample_circuits,
    combine_copysampled_results,
)
from entanglement_forging.utils.forging_subroutines import (
    prepare_circuits_to_execute,
    make_stateprep_circuits,
    eval_forged_op_with_result,
    get_optimizer_instance,
)
from entanglement_forging.utils.generic_execution_subroutines import execute_with_retry
from entanglement_forging.utils.legacy.op_converter import (
    to_tpb_grouped_weighted_pauli_operator,
)
from entanglement_forging.utils.legacy.tpb_grouped_weighted_pauli_operator import (
    TPBGroupedWeightedPauliOperator,
)
from entanglement_forging.utils.legacy.weighted_pauli_operator import (
    WeightedPauliOperator,
)
from entanglement_forging.utils.log import Log
from entanglement_forging.utils.meas_mit_fitters_faster import CompleteMeasFitter
from entanglement_forging.utils.pseudorichardson import make_pseudorichardson_circuits


# pylint: disable=too-many-branches,too-many-arguments,too-many-locals,too-many-instance-attributes,too-many-statements
class EntanglementForgedVQE(VQE):
    """"""A class for Entanglement Forged VQE <https://arxiv.org/abs/2104.10220>.""""""

    def __init__(
        self,
        ansatz: QuantumCircuit,
        bitstrings_u: Iterable[Iterable[int]],
        config: EntanglementForgedConfig,
        forged_operator: ForgedOperator,
        classical_energies: ClassicalEnergies,
        bitstrings_v: Iterable[Iterable[int]] = None,
    ):
        """"""Initialize the EntanglementForgedVQE class.""""""
        if ansatz.num_qubits != len(bitstrings_u[0]):
            raise ValueError(
                ""The number of qubits in ansatz does ""
                ""not match the number of bits in reduced_bitstrings.""
            )

        if any(len(bitstrings_u[0]) != len(bitstr) for bitstr in bitstrings_u):
            raise ValueError(""All U bitstrings must be the same length."")

        if bitstrings_v:
            if len(bitstrings_u) != len(bitstrings_v):
                raise ValueError(
                    ""The same number of bitstrings should be passed for U and V.""
                )

            if len(bitstrings_u[0]) != len(bitstrings_v[0]):
                raise ValueError(""Bitstrings for U and V should be the same length."")

            if any(len(bitstrings_v[0]) != len(bitstr) for bitstr in bitstrings_v):
                raise ValueError(""All V bitstrings must be the same length."")

        super().__init__(
            ansatz=ansatz,
            optimizer=get_optimizer_instance(config),
            initial_point=config.initial_params,
            max_evals_grouped=config.max_evals_grouped,
            callback=None,
        )

        # Prevent unnecessary duplication if subsystems are equivalent
        if (bitstrings_v is None) or (bitstrings_u == bitstrings_v):
            self.bitstrings_v = []
        else:
            self.bitstrings_v = bitstrings_v

        self.ansatz = ansatz
        self.config = config
        self._energy_each_iteration_each_paramset = []
        self._paramsets_each_iteration = []
        self._schmidt_coeffs_each_iteration_each_paramset = []
        self._zero_noise_extrap = config.zero_noise_extrap

        self.bitstrings_u = bitstrings_u
        self._bitstrings_s_u = np.asarray(bitstrings_u)

        # Make circuits which prepare states U|b_n_u> and U|phi^p_nm_u>
        (
            self._tensor_prep_circuits_u,
            self._superpos_prep_circuits_u,
            hybrid_superpos_coeffs_u,
        ) = make_stateprep_circuits(
            bitstrings_u, config.fix_first_bitstring, suffix=""u""
        )

        self._tensor_prep_circuits_v = []
        self._superpos_prep_circuits_v = []
        hybrid_superpos_coeffs_v = []
        self._bitstrings_s_v = np.array([])
        if self.bitstrings_v:
            # Make circuits which prepare states V|b_n_v> and V|phi^p_nm_v>
            # Where U = V but bitstring |b_n_v> does not necessarily equal |b_n_u>
            self._bitstrings_s_v = np.asarray(bitstrings_v)
            (
                self._tensor_prep_circuits_v,
                self._superpos_prep_circuits_v,
                hybrid_superpos_coeffs_v,
            ) = make_stateprep_circuits(
                bitstrings_v, config.fix_first_bitstring, suffix=""v""
            )

        hybrid_superpos_coeffs_u.update(hybrid_superpos_coeffs_v)
        self._hybrid_superpos_coeffs = hybrid_superpos_coeffs_u
        self._iteration_start_time = np.nan
        self._running_estimate_of_schmidts = np.array(
            [1.0] + [0.1] * (len(self._bitstrings_s_u) - 1)
        )
        self._running_estimate_of_schmidts /= np.linalg.norm(
            self._running_estimate_of_schmidts
        )
        self.copysample_job_size = config.copysample_job_size
        self._backend = config.backend
        self.quantum_instance = QuantumInstance(backend=self._backend)
        self._initial_layout = config.qubit_layout
        self._shots = config.shots
        self._meas_error_mit = config.meas_error_mit
        self._meas_error_shots = config.meas_error_shots
        self._meas_error_refresh_period_minutes = (
            config.meas_error_refresh_period_minutes
        )
        self._meas_error_refresh_timestamp = None
        self._coupling_map = self._backend.configuration().coupling_map
        self._meas_fitter = None
        self._bootstrap_trials = config.bootstrap_trials
        self._no_bs0_circuits = config.fix_first_bitstring
        self._rep_delay = config.rep_delay

        self.forged_operator = forged_operator
        self._add_this_to_energies_displayed = classical_energies.shift
        self._hf_energy = classical_energies.HF

        self.aux_results: Iterable[Tuple[str, AuxiliaryResults]] = []

        self.parameter_sets = []
        self.energy_mean_each_parameter_set = []
        self.energy_std_each_parameter_set = []

        # Paramters for get_energy_evaluation. Moved them here to match parent function signature
        self._shots_multiplier = 1
        self._bootstrap_trials = 0

        statevector_sims = [""aer_simulator_statevector"", ""statevector_simulator""]
        if self._backend.name() in statevector_sims:
            self._is_sv_sim = True
        else:
            self._is_sv_sim = False

        # Load the two circuit generation operations
        self._pauli_names_for_tensor_states = None
        self._pauli_names_for_superpos_states = None
        self._w_ij_tensor_states = None
        self._w_ab_superpos_states = None
        self._op_for_generating_tensor_circuits = None
        self._op_for_generating_superpos_circuits = None
        self._load_ops()

    @property
    def shots_multiplier(self):
        """"""Return the shots multiplier.""""""
        return self._shots_multiplier

    @shots_multiplier.setter
    def shots_multiplier(self, multiplier):
        """"""Set the shots multiplier.""""""
        self._shots_multiplier = multiplier

    @property
    def bootstrap_trials(self):
        """"""Return the bootstrap trials.""""""
        return self._bootstrap_trials

    @bootstrap_trials.setter
    def bootstrap_trials(self, trials):
        """"""Set the bootstrap trials.""""""
        self._bootstrap_trials = trials

    def _load_ops(self):
        # Get the weighted Pauli deconstruction of the operator
        (
            pauli_names_for_tensor_states,
            pauli_names_for_superpos_states,
            w_ij_tensor_states,
            w_ab_superpos_states,
        ) = self.forged_operator.construct()

        self._pauli_names_for_tensor_states = pauli_names_for_tensor_states
        self._pauli_names_for_superpos_states = pauli_names_for_superpos_states
        self._w_ij_tensor_states = w_ij_tensor_states
        self._w_ab_superpos_states = w_ab_superpos_states

        op_for_generating_tensor_circuits = to_tpb_grouped_weighted_pauli_operator(
            WeightedPauliOperator(
                paulis=[
                    [1, Pauli(pname)] for pname in self._pauli_names_for_tensor_states
                ]
            ),
            TPBGroupedWeightedPauliOperator.sorted_grouping,
        )
        if len(self._pauli_names_for_superpos_states) > 0:
            op_for_generating_superpos_circuits = (
                to_tpb_grouped_weighted_pauli_operator(
                    WeightedPauliOperator(
                        paulis=[
                            [1, Pauli(pname)]
                            for pname in self._pauli_names_for_superpos_states
                        ]
                    ),
                    TPBGroupedWeightedPauliOperator.sorted_grouping,
                )
            )

        else:
            op_for_generating_superpos_circuits = None

        self._op_for_generating_tensor_circuits = op_for_generating_tensor_circuits
        self._op_for_generating_superpos_circuits = op_for_generating_superpos_circuits

    def get_energy_evaluation(
        self, operator: OperatorBase, return_expectation: bool = False
    ) -> Callable[[np.ndarray], Union[float, Iterable[float]]]:

        if self._is_sv_sim:
            self._shots_multiplier = 1

        ansatz_params = self.ansatz.parameters
        _, expectation = self.construct_expectation(
            ansatz_params, operator, return_expectation=True
        )

        def energy_evaluation(parameters):
            Log.log(""------ new iteration energy evaluation -----"")
            # num_parameter_sets = len(parameters) // self.ansatz.num_parameters
            # parameter_sets = np.split(parameters, num_parameter_sets)
            parameter_sets = np.reshape(parameters, (-1, self.ansatz.num_parameters))
            new_iteration_start_time = time.time()

            Log.log(
                ""duration of last iteration:"",
                new_iteration_start_time - self._iteration_start_time,
            )

            self._iteration_start_time = new_iteration_start_time

            Log.log(""Parameter sets:"", parameter_sets)

            # Compute the expectation value of the forged operator with respect
            # to the ansatz at the given parameters
            eval_forged_result = self._evaluate_forged_operator(
                parameter_sets=parameter_sets,
                hf_value=self._hf_energy,
                add_this_to_mean_values_displayed=self._add_this_to_energies_displayed,
                shots_multiplier=self._shots_multiplier,
                bootstrap_trials=self._bootstrap_trials,
            )

            (
                energy_mean_each_parameter_set,
                bootstrap_means_each_parameter_set,
                energy_mean_raw_each_parameter_set,
                energy_mean_sv_each_parameter_set,
                schmidt_coeffs_each_parameter_set,
                schmidt_coeffs_raw_each_parameter_set,
                schmidt_coeffs_sv_each_parameter_set,
            ) = eval_forged_result

            self._schmidt_coeffs_each_iteration_each_paramset.append(
                schmidt_coeffs_each_parameter_set
            )

            # TODO Not Implemented  # pylint: disable=fixme
            energy_std_each_parameter_set = [0] * len(energy_mean_each_parameter_set)
            # TODO Not Implemented  # pylint: disable=fixme
            energy_std_raw_each_parameter_set = [0] * len(
                energy_mean_each_parameter_set
            )
            energy_std_sv_each_parameter_set = [0] * len(energy_mean_each_parameter_set)

            self._energy_each_iteration_each_paramset.append(
                energy_mean_each_parameter_set
            )
            self._paramsets_each_iteration.append(parameter_sets)

            timestamp_string = datetime.datetime.now().strftime(""%Y%m%d%H%M%S%f"")

            # additional results
            for params, bootstrap_means in zip(
                parameter_sets, bootstrap_means_each_parameter_set
            ):
                self.aux_results.append(
                    (
                        ""bootstrap"",
                        Bootstrap(
                            eval_count=self._eval_count,
                            eval_timestamp=timestamp_string,
                            parameters=params,
                            bootstrap_values=[
                                v + self._add_this_to_energies_displayed
                                for v in bootstrap_means
                            ],
                        ),
                    )
                )

            data_titles = [""data"", ""data_noextrapolation"", ""data_statevec""][:-1]
            for (
                filename,
                energies_each_paramset,
                stds_each_paramset,
                schmidts_each_paramset,
            ) in zip(
                data_titles,
                [
                    energy_mean_each_parameter_set,
                    energy_mean_raw_each_parameter_set,
                    energy_mean_sv_each_parameter_set,
                ],
                [
                    energy_std_each_parameter_set,
                    energy_std_raw_each_parameter_set,
                    energy_std_sv_each_parameter_set,
                ],
                [
                    schmidt_coeffs_each_parameter_set,
                    schmidt_coeffs_raw_each_parameter_set,
                    schmidt_coeffs_sv_each_parameter_set,
                ],
            ):

                for params, energy_mean, energy_std, schmidts in zip(
                    parameter_sets,
                    energies_each_paramset,
                    stds_each_paramset,
                    schmidts_each_paramset,
                ):
                    self.aux_results.append(
                        (
                            filename,
                            DataResults(
                                eval_count=self._eval_count,
                                eval_timestamp=timestamp_string,
                                energy_hartree=(
                                    energy_mean + self._add_this_to_energies_displayed
                                ),
                                energy_std=energy_std,
                                parameters=parameters,
                                schmidts=schmidts,
                            ),
                        )
                    )

            for params, energy_mean, energy_std in zip(
                parameter_sets,
                energy_mean_each_parameter_set,
                energy_std_each_parameter_set,
            ):
                self._eval_count += 1
                if self._callback is not None:
                    self._callback(self._eval_count, params, energy_mean, energy_std)

            self.parameter_sets = parameter_sets
            self.energy_mean_each_parameter_set = energy_mean_each_parameter_set
            self.energy_std_each_parameter_set = energy_std_each_parameter_set
            return (
                np.array(energy_mean_each_parameter_set)
                if len(energy_mean_each_parameter_set) > 1
                else energy_mean_each_parameter_set[0]
            )

        if return_expectation:
            return energy_evaluation, expectation

        return energy_evaluation

    def _evaluate_forged_operator(
        self,
        parameter_sets,
        hf_value=0,
        add_this_to_mean_values_displayed=0,
        shots_multiplier=1,
        bootstrap_trials=0,
    ):
        """"""Computes the expectation value of the forged operator
        with respect to the ansatz at the given parameters.""""""
        # These calculations are parameter independent for
        # a given operator so could be moved outside the optimization loop:
        circuits_to_execute = []

        for params_idx, params in enumerate(parameter_sets):
            Log.log(""Constructing the circuits for parameter set"", params, ""..."")

            # Get all the tensor circuits associated with ansatz U
            tensor_circuits_to_execute_u = prepare_circuits_to_execute(
                params,
                self._tensor_prep_circuits_u,
                self._op_for_generating_tensor_circuits,
                self._ansatz,
                self._is_sv_sim,
            )

            # Get all tensor circuits associated with ansatz V
            tensor_circuits_to_execute_v = prepare_circuits_to_execute(
                params,
                self._tensor_prep_circuits_v,
                self._op_for_generating_tensor_circuits,
                self._ansatz,
                self._is_sv_sim,
            )

            # Combine all tensor circuits into a single list
            tensor_circuits_to_execute = (
                tensor_circuits_to_execute_u + tensor_circuits_to_execute_v
            )

            if len(self._pauli_names_for_superpos_states) > 0:
                # Get superposition circuits associated with ansatz U
                superpos_circuits_to_execute_u = prepare_circuits_to_execute(
                    params,
                    self._superpos_prep_circuits_u,
                    self._op_for_generating_superpos_circuits,
                    self._ansatz,
                    self._is_sv_sim,
                )
                # Get superposition circuits associated with ansatz V
                superpos_circuits_to_execute_v = prepare_circuits_to_execute(
                    params,
                    self._superpos_prep_circuits_v,
                    self._op_for_generating_superpos_circuits,
                    self._ansatz,
                    self._is_sv_sim,
                )

                # Combine all superposition circuits into a single list
                superpos_circuits_to_execute = (
                    superpos_circuits_to_execute_u + superpos_circuits_to_execute_v
                )

            else:
                superpos_circuits_to_execute_u = []
                superpos_circuits_to_execute_v = []
                superpos_circuits_to_execute = []

            if params_idx == 0:
                Log.log(
                    ""inferred number of pauli groups for tensor statepreps:"",
                    len(tensor_circuits_to_execute)
                    / (
                        len(self._tensor_prep_circuits_u)
                        + len(self._tensor_prep_circuits_v)
                    ),
                )
                if self._superpos_prep_circuits_u:
                    Log.log(
                        ""inferred number of pauli groups for superposition statepreps:"",
                        len(superpos_circuits_to_execute)
                        / (
                            len(self._superpos_prep_circuits_u)
                            + len(self._superpos_prep_circuits_v)
                        ),
                    )
            circuits_to_execute += (
                tensor_circuits_to_execute + superpos_circuits_to_execute
            )
        Log.log(""Transpiling circuits..."")
        Log.log(self._initial_layout)
        circuits_to_execute = transpile(
            circuits_to_execute,
            self._backend,
            initial_layout=self._initial_layout,
            coupling_map=self._coupling_map,
        )

        if not isinstance(circuits_to_execute, list):
            circuits_to_execute = [circuits_to_execute]
        Log.log(""Building pseudo-richardson circuits..."")
        circuits_to_execute = make_pseudorichardson_circuits(
            circuits_to_execute,
            simple_richardson_orders=[
                int(x) for x in (np.asarray(self._zero_noise_extrap) - 1) / 2
            ],
        )
        if self.copysample_job_size:
            Log.log(""Copysampling circuits..."")
            Log.log(
                ""num circuits to execute before copysampling:"", len(circuits_to_execute)
            )
            weight_each_stateprep = np.abs(
                np.array(self._running_estimate_of_schmidts)[:, np.newaxis]
                * np.array(self._running_estimate_of_schmidts)[np.newaxis, :]
            )
            if self._no_bs0_circuits:
                ## IMPORTANT: assumes special-case of NOT executing HF bitstring state-prep
                weight_each_stateprep[0, 0] = 0
            weight_each_circuit = []
            for qcirc in circuits_to_execute:
                name_parts = qcirc.name.split(""_"")
                stretch_factor = float(name_parts[-2].split(""richardson"")[1])
                indices_of_involved_bitstrings = [
                    int("""".join(c for c in x if c.isdigit()))
                    for x in name_parts[1].split(""bs"")[1:]
                ]
                if len(indices_of_involved_bitstrings) == 1:
                    i, j = (
                        indices_of_involved_bitstrings[0],
                        indices_of_involved_bitstrings[0],
                    )
                elif len(indices_of_involved_bitstrings) == 2:
                    i, j = indices_of_involved_bitstrings
                else:
                    raise ValueError(
                        ""Circuit name should be of form [params]_bs#_... ""
                        ""or [params]_bs#bs#_... indicating which 1 or 2 ""
                        ""bitstrings it involves, but instead name is:"",
                        qcirc.name,
                    )
                if len(self._zero_noise_extrap) <= 2:
                    weight_each_circuit.append(
                        weight_each_stateprep[i, j] / stretch_factor
                    )
                else:
                    warnings.warn(
                        ""Weighted sampling when more than 2 stretch factors are present ""
                        ""is not supported (may or may not just work, haven't ""
                        ""looked into it). Reverting to uniform sampling of stretch factors.""
                    )
                    weight_each_circuit.append(weight_each_stateprep[i, j] / 1)
            circuits_to_execute = copysample_circuits(
                circuits_to_execute,
                weights=weight_each_circuit,
                new_job_size=self.copysample_job_size * len(parameter_sets),
            )
            Log.log(
                ""num circuits to execute after copysampling:"", len(circuits_to_execute)
            )

        if self._meas_error_mit:
            if (not self._meas_fitter) or (
                (time.time() - self._meas_error_refresh_timestamp) / 60
                > self._meas_error_refresh_period_minutes
            ):
                Log.log(""Generating measurement fitter..."")
                physical_qubits = np.asarray(self._initial_layout).tolist()
                cal_circuits, state_labels = complete_meas_cal(
                    range(len(physical_qubits))
                )
                result = execute_with_retry(
                    cal_circuits, self._backend, self._meas_error_shots, self._rep_delay
                )
                self._meas_fitter = CompleteMeasFitter(result, state_labels)
                self._meas_error_refresh_timestamp = time.time()

        Log.log(""Executing"", len(circuits_to_execute), ""circuits..."")

        result = execute_with_retry(
            circuits_to_execute,
            self._backend,
            self._shots * shots_multiplier,
            self._rep_delay,
        )

        if self._meas_error_mit:
            Log.log(""Applying meas fitter/filter..."")
            result = self._meas_fitter.filter.apply(result)

        Log.log(""Done executing. Analyzing results..."")
        op_mean_each_parameter_set = [None] * len(parameter_sets)
        op_std_each_parameter_set = [None] * len(parameter_sets)
        schmidt_coeffs_each_parameter_set = [None] * len(parameter_sets)
        op_mean_raw_each_parameter_set = [None] * len(parameter_sets)
        op_std_raw_each_parameter_set = [None] * len(parameter_sets)
        schmidt_coeffs_raw_each_parameter_set = [None] * len(parameter_sets)
        op_mean_sv_each_parameter_set = [None] * len(parameter_sets)
        schmidt_coeffs_sv_each_parameter_set = [None] * len(parameter_sets)
        if self.copysample_job_size:
            result = combine_copysampled_results(result)
        if bootstrap_trials:
            Log.log(f""Bootstrap: resampling result {bootstrap_trials} times..."")
            bootstrap_results = [
                resample_result(result) for _ in range(bootstrap_trials)
            ]
            Log.log(
                ""Done bootstrapping new counts, starting analysis of bootstrapped data.""
            )
        else:
            bootstrap_results = []
        bootstrap_means_each_parameter_set = []
        for idx, params in enumerate(parameter_sets):
            bootstrap_means = []
            for is_bootstrap_index, res in enumerate([result] + bootstrap_results):
                results_extrap, results_raw = eval_forged_op_with_result(
                    res,
                    self._w_ij_tensor_states,
                    self._w_ab_superpos_states,
                    params,
                    self._bitstrings_s_u,
                    self._op_for_generating_tensor_circuits,
                    self._op_for_generating_superpos_circuits,
                    self._zero_noise_extrap,
                    bitstrings_s_v=self._bitstrings_s_v,
                    hf_value=hf_value,
                    statevector_mode=self._is_sv_sim,
                    hybrid_superpos_coeffs=self._hybrid_superpos_coeffs,
                    add_this_to_mean_values_displayed=add_this_to_mean_values_displayed,
                    no_bs0_circuits=self._no_bs0_circuits,
                )
                op_mean, op_std, schmidts = results_extrap
                op_mean_raw, op_std_raw, schmidts_raw = results_raw
                if not is_bootstrap_index:
                    op_mean_each_parameter_set[idx] = op_mean
                    op_std_each_parameter_set[idx] = op_std
                    op_mean_raw_each_parameter_set[idx] = op_mean_raw
                    op_std_raw_each_parameter_set[idx] = op_std_raw
                    schmidt_coeffs_raw_each_parameter_set[idx] = schmidts_raw
                    Log.log(""Optimal schmidt coeffs sqrt(p) ="", schmidts)
                    schmidt_coeffs_each_parameter_set[idx] = schmidts
                else:
                    bootstrap_means.append(op_mean)
            bootstrap_means_each_parameter_set.append(bootstrap_means)
        self._running_estimate_of_schmidts = np.mean(
            schmidt_coeffs_each_parameter_set, axis=0
        )
        return (
            op_mean_each_parameter_set,
            bootstrap_means_each_parameter_set,
            op_mean_raw_each_parameter_set,
            op_mean_sv_each_parameter_set,
            schmidt_coeffs_each_parameter_set,
            schmidt_coeffs_raw_each_parameter_set,
            schmidt_coeffs_sv_each_parameter_set,
        )

    def get_optimal_vector(self):
        """"""Prevents the VQE superclass version of this function from running.""""""
        warnings.warn(
            ""get_optimal_vector not implemented for forged VQE. Returning None.""
        )
"
https://github.com/qiskit-community/prototype-entanglement-forging,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""""" A set of subroutines that are used by the VQE_forged_entanglement class,
which is defined in the vqe_forged_entanglement module
""""""

import inspect
import warnings
import re
from typing import Iterable, Dict, Tuple

import numpy as np
from qiskit import QuantumCircuit
from qiskit.algorithms import optimizers
from qiskit.algorithms.optimizers import SPSA
from qiskit.algorithms.optimizers.spsa import powerseries
from qiskit_nature import QiskitNatureError

from .generic_execution_subroutines import compute_pauli_means_and_cov_for_one_basis
from .log import Log
from .prepare_bitstring import prepare_bitstring
from .pseudorichardson import richardson_extrapolate
from .legacy.weighted_pauli_operator import WeightedPauliOperator


Matrix = Iterable[Iterable[float]]

# pylint: disable=too-many-locals,too-many-arguments,too-many-branches,invalid-name
def make_stateprep_circuits(
    bitstrings: Iterable[Iterable[int]], no_bs0_circuits: bool = True, suffix: str = """"
):
    """"""Builds the circuits preparing states |b_n> and |phi^p_nm>
    as defined in <https://arxiv.org/abs/2104.10220>. Also returns
    a list of tuples which describe any superposition terms which
    carry a coefficient.

    Assumes that the operator amplitudes are real,
    thus does not construct superposition states with odd p.
    """"""

    # If empty, just return
    if len(bitstrings) == 0:
        return [], [], []

    # If the spin-up and spin-down spin orbitals are together a 2*N qubit system,
    # the bitstring should be N bits long.
    bitstrings = np.asarray(bitstrings)
    tensor_prep_circuits = [
        prepare_bitstring(bs, name=""bs"" + suffix + str(bs_idx))
        for bs_idx, bs in enumerate(bitstrings)
    ]

    if no_bs0_circuits:
        # Drops the HF bitstring, which is assumed to be first,
        # since hops in our ansatz are chosen to leave it unchanged! (IMPORTANT)
        tensor_prep_circuits = tensor_prep_circuits[1:]

    superpos_prep_circuits = []
    hybrid_superpos_coeffs = {}
    for bs1_idx, bs1 in enumerate(bitstrings):
        for bs2_relative_idx, bs2 in enumerate(bitstrings[bs1_idx + 1 :]):
            diffs = np.where(bs1 != bs2)[0]

            # TODO implement p -> -p as needed for problems with complex amplitudes  # pylint: disable=fixme
            if len(diffs) > 0:
                i = diffs[0]
                if bs1[i]:
                    x = bs2
                    y = bs1  # pylint: disable=unused-variable
                else:
                    x = bs1
                    y = bs2  # pylint: disable=unused-variable
                S = np.delete(diffs, 0)
                qcirc = prepare_bitstring(np.concatenate((x[:i], [0], x[i + 1 :])))
                qcirc.h(i)
                psi_xplus, psi_xmin = [
                    qcirc.copy(
                        name=f""bs{suffix}{bs1_idx}bs{suffix}{bs1_idx+1+bs2_relative_idx}{name}""
                    )
                    for name in [""xplus"", ""xmin""]
                ]
                psi_xmin.z(i)
                for psi in [psi_xplus, psi_xmin]:
                    for target in S:
                        psi.cx(i, target)
                    superpos_prep_circuits.append(psi)

            # If the two bitstrings are equivalent -- bn==bm
            else:
                qcirc = prepare_bitstring(bs1)
                psi_xplus, psi_xmin = [
                    qcirc.copy(
                        name=f""bs{suffix}{bs1_idx}bs{suffix}{bs1_idx+1+bs2_relative_idx}{name}""
                    )
                    for name in [""xplus"", ""xmin""]
                ]
                hybrid_superpos_coeffs[
                    (suffix, str(bs1_idx), str(bs1_idx + 1 + bs2_relative_idx))
                ] = True
                superpos_prep_circuits += [psi_xplus, psi_xmin]
    return tensor_prep_circuits, superpos_prep_circuits, hybrid_superpos_coeffs


def prepare_circuits_to_execute(
    params: Iterable[float],
    stateprep_circuits: Iterable[QuantumCircuit],
    op_for_generating_circuits: WeightedPauliOperator,
    var_form: QuantumCircuit,
    statevector_mode: bool,
):
    """"""Given a set of variational parameters and list of 6qb state-preps,
    this function returns all (unique) circuits that must be run to evaluate those samples.
    """"""
    # If circuits are empty, just return
    if len(stateprep_circuits) == 0:
        return []

    circuits_to_execute = []
    # Generate the requisite circuits:
    # pylint: disable=unidiomatic-typecheck
    param_bindings = dict(zip(var_form.parameters, params))
    u_circuit = var_form.bind_parameters(param_bindings)
    for prep_circ in [qc.copy() for qc in stateprep_circuits]:
        circuit_name_prefix = str(params) + ""_"" + str(prep_circ.name) + ""_""
        wavefn_circuit = prep_circ.compose(u_circuit)
        if statevector_mode:
            circuits_to_execute.append(
                wavefn_circuit.copy(name=circuit_name_prefix + ""psi"")
            )
        else:
            circuits_this_stateprep = (
                op_for_generating_circuits.construct_evaluation_circuit(
                    wave_function=wavefn_circuit.copy(),
                    statevector_mode=statevector_mode,  # <-- False, here.
                    use_simulator_snapshot_mode=False,
                    circuit_name_prefix=circuit_name_prefix,
                )
            )
            circuits_to_execute += circuits_this_stateprep
    return circuits_to_execute


# pylint: disable=unbalanced-tuple-unpacking
def eval_forged_op_with_result(
    result,
    w_ij_tensor_states: Matrix,
    w_ab_superpos_states: Matrix,
    params: Iterable[float],
    bitstrings_s_u: np.ndarray,
    op_for_generating_tensor_circuits: WeightedPauliOperator,
    op_for_generating_superpos_circuits: WeightedPauliOperator,
    richardson_stretch_factors: Iterable[float],
    statevector_mode: bool,
    hf_value: float,
    add_this_to_mean_values_displayed: float,
    bitstrings_s_v: np.ndarray = None,
    hybrid_superpos_coeffs: Dict[Tuple[int, int, str], bool] = None,
    no_bs0_circuits: bool = True,
    verbose: bool = False,
):
    """"""Evaluates the forged operator.

    Extracts necessary expectation values from the result object, then combines those pieces to
    compute the configuration-interaction Hamiltonian
    (Hamiltonian in the basis of determinants/bitstrings).
    For reference, also computes mean value obtained without Richardson
    """"""
    if bitstrings_s_v is None:
        bitstrings_s_v = []

    tensor_state_prefixes_u = [f""bsu{idx}"" for idx in range(len(bitstrings_s_u))]
    tensor_state_prefixes_v = []

    if len(bitstrings_s_v) > 0:
        tensor_state_prefixes_v = [f""bsv{idx}"" for idx in range(len(bitstrings_s_v))]

    tensor_state_prefixes = tensor_state_prefixes_u + tensor_state_prefixes_v
    tensor_expvals = _get_pauli_expectations_from_result(
        result,
        params,
        tensor_state_prefixes,
        op_for_generating_tensor_circuits,
        richardson_stretch_factors=richardson_stretch_factors,
        hybrid_superpos_coeffs=hybrid_superpos_coeffs,
        statevector_mode=statevector_mode,
        no_bs0_circuits=no_bs0_circuits,
    )
    tensor_expvals_extrap = richardson_extrapolate(
        tensor_expvals, richardson_stretch_factors, axis=2
    )

    superpos_state_prefixes_u = []
    superpos_state_prefixes_v = []
    lin_combos = [""xplus"", ""xmin""]  # ,'yplus','ymin']
    # num_bitstrings is the number of bitstring combos we have
    num_bitstrings = len(bitstrings_s_u)
    for x in range(num_bitstrings):
        for y in range(num_bitstrings):
            if x == y:
                continue
            bsu_string = f""bsu{min(x,y)}bsu{max(x,y)}""
            superpos_state_prefixes_u += [
                bsu_string + lin_combo for lin_combo in lin_combos
            ]

            # Determine whether we are handling the two subsystems separately
            asymmetric_bitstrings = False
            if len(bitstrings_s_v) > 0:
                asymmetric_bitstrings = True
                bsv_string = f""bsv{min(x,y)}bsv{max(x,y)}""
                superpos_state_prefixes_v += [
                    bsv_string + lin_combo for lin_combo in lin_combos
                ]

    superpos_state_prefixes = superpos_state_prefixes_u + superpos_state_prefixes_v

    superpos_expvals = _get_pauli_expectations_from_result(
        result,
        params,
        superpos_state_prefixes,
        op_for_generating_superpos_circuits,
        hybrid_superpos_coeffs=hybrid_superpos_coeffs,
        richardson_stretch_factors=richardson_stretch_factors,
        statevector_mode=statevector_mode,
        no_bs0_circuits=no_bs0_circuits,
    )

    superpos_expvals_extrap = richardson_extrapolate(
        superpos_expvals, richardson_stretch_factors, axis=2
    )

    forged_op_results_w_and_wo_extrapolation = []
    for (tensor_expvals_real, superpos_expvals_real) in [
        [tensor_expvals_extrap, superpos_expvals_extrap],
        [tensor_expvals[:, :, 0], superpos_expvals[:, :, 0]],
    ]:
        h_schmidt = compute_h_schmidt(
            tensor_expvals_real,
            superpos_expvals_real,
            w_ij_tensor_states,
            w_ab_superpos_states,
            asymmetric_bitstrings,
        )
        if no_bs0_circuits:
            # IMPORTANT: ASSUMING HOPGATES CHOSEN S.T. HF BITSTRING
            # (FIRST BITSTRING) IS UNAFFECTED, ALLOWING CORRESPONDING
            # ENERGY TO BE FIXED AT HF VALUE CALCULATED BY QISKIT/PYSCF.
            h_schmidt[0, 0] = hf_value - add_this_to_mean_values_displayed
        # Update Schmidt coefficients to minimize operator (presumably energy):
        if verbose:
            Log.log(
                ""Operator as Schmidt matrix: (diagonals have been shifted by given offset"",
                add_this_to_mean_values_displayed,
                "")"",
            )
            Log.log(
                h_schmidt + np.eye(len(h_schmidt)) * add_this_to_mean_values_displayed
            )
        evals, evecs = np.linalg.eigh(h_schmidt)
        schmidts = evecs[:, 0]
        op_mean = evals[0]
        op_std = None
        forged_op_results_w_and_wo_extrapolation.append([op_mean, op_std, schmidts])

    (
        forged_op_results_extrap,
        forged_op_results_raw,
    ) = forged_op_results_w_and_wo_extrapolation  # pylint: disable=unbalanced-tuple-unpacking

    return forged_op_results_extrap, forged_op_results_raw


def _get_pauli_expectations_from_result(
    result,
    params,
    stateprep_strings,
    op_for_generating_circuits,
    statevector_mode,
    hybrid_superpos_coeffs=None,
    richardson_stretch_factors=None,
    no_bs0_circuits=True,
):
    """"""Returns array containing ordered expectation values of
    Pauli strings evaluated for the various wavefunctions.

    Axes are [stateprep_idx, Pauli_idx, richardson_stretch_factor_idx, mean_or_variance]
    """"""
    if richardson_stretch_factors is None:
        richardson_stretch_factors = [1]
    if not op_for_generating_circuits:
        return np.empty((0, 0, len(richardson_stretch_factors), 2))
    params_string = str(params) + ""_""
    if statevector_mode:
        op_matrices = np.asarray(
            [op.to_matrix() for op in [p[1] for p in op_for_generating_circuits.paulis]]
        )
    pauli_vals = np.zeros(
        (
            len(stateprep_strings),
            len(op_for_generating_circuits._paulis),  # pylint: disable=protected-access
            len(richardson_stretch_factors),
            2,
        )
    )
    pauli_names_temp = [p[1].to_label() for p in op_for_generating_circuits.paulis]
    for prep_idx, prep_string in enumerate(stateprep_strings):
        suffix = prep_string[2]
        if suffix not in [""u"", ""v""]:
            raise ValueError(f""Invalid stateprep circuit name: {prep_string}"")
        bitstring_pair = [0, 0]
        tensor_circuit = True
        num_bs_terms = prep_string.count(""bs"")
        if (num_bs_terms > 2) or (num_bs_terms == 0):
            raise ValueError(f""Invalid stateprep circuit name: {prep_string}"")
        elif num_bs_terms == 2:
            tensor_circuit = False
            prep_string_digits = [
                int(float(s)) for s in re.findall(r""-?\d+\.?\d*"", prep_string)
            ]
            bitstring_pair = [prep_string_digits[0], prep_string_digits[1]]

        if no_bs0_circuits and (prep_string == ""bsu0"" or prep_string == ""bsv0""):
            # IMPORTANT: ASSUMING HOPGATES CHOSEN S.T.
            # HF BITSTRING (FIRST BITSTRING) IS UNAFFECTED,
            # ALLOWING CORRESPONDING ENERGY TO BE FIXED AT H
            # F VALUE CALCULATED BY QISKIT/PYSCF.
            pauli_vals[prep_idx, :, :, :] = np.nan
            continue
        circuit_prefix_prefix = """".join([params_string, prep_string])
        for rich_idx, stretch_factor in enumerate(richardson_stretch_factors):
            circuit_name_prefix = """".join(
                [circuit_prefix_prefix, f""_richardson{stretch_factor:.2f}"", ""_""]
            )
            if statevector_mode:
                psi = result.get_statevector(circuit_name_prefix + ""psi"")
                pauli_vals_temp = np.real(
                    np.einsum(""i,Mij,j->M"", np.conj(psi), op_matrices, psi)
                )
            else:
                pauli_vals_temp, _ = _eval_each_pauli_with_result(
                    tpbgwpo=op_for_generating_circuits,
                    result=result,
                    statevector_mode=statevector_mode,
                    use_simulator_snapshot_mode=False,
                    circuit_name_prefix=circuit_name_prefix,
                )

            pauli_vals_alphabetical = [
                x[1] for x in sorted(list(zip(pauli_names_temp, pauli_vals_temp)))
            ]
            if not np.all(np.isreal(pauli_vals_alphabetical)):
                warnings.warn(
                    ""Computed Pauli expectation value has nonzero ""
                    ""imaginary part which will be discarded.""
                )
            pauli_vals[prep_idx, :, rich_idx, 0] = np.real(pauli_vals_alphabetical)
        key = (suffix, str(bitstring_pair[0]), str(bitstring_pair[1]))
        if key in hybrid_superpos_coeffs.keys():
            if prep_string[-4:] == ""xmin"":
                pauli_vals[prep_idx] *= 0
            elif prep_string[-5:] == ""xplus"":
                pass
            else:
                raise ValueError(f""Invalid circuit name: {prep_string}"")
        elif not tensor_circuit:
            pauli_vals[prep_idx] *= 1 / 2

    return pauli_vals


# pylint: disable=protected-access
def _eval_each_pauli_with_result(
    tpbgwpo,
    result,
    statevector_mode,
    use_simulator_snapshot_mode=False,
    circuit_name_prefix="""",
):
    """"""Ignores the weights of each pauli operator.""""""
    if tpbgwpo.is_empty():
        raise QiskitNatureError(""Operator is empty, check the operator."")
    if statevector_mode or use_simulator_snapshot_mode:
        raise NotImplementedError()
    num_paulis = len(tpbgwpo._paulis)
    means = np.zeros(num_paulis)
    cov = np.zeros((num_paulis, num_paulis))
    for basis, p_indices in tpbgwpo._basis:
        counts = result.get_counts(circuit_name_prefix + basis.to_label())
        paulis = [tpbgwpo._paulis[idx] for idx in p_indices]
        paulis = [p[1] for p in paulis]  ## DISCARDING THE WEIGHTS
        means_this_basis, cov_this_basis = compute_pauli_means_and_cov_for_one_basis(
            paulis, counts
        )
        for p_idx, p_mean in zip(p_indices, means_this_basis):
            means[p_idx] = p_mean
        cov[np.ix_(p_indices, p_indices)] = cov_this_basis
    return means, cov


def compute_h_schmidt(
    tensor_expvals,
    superpos_expvals,
    w_ij_tensor_weights,
    w_ab_superpos_weights,
    asymmetric_bitstrings,
):
    """"""Computes the schmidt decomposition of the Hamiltonian. TODO checkthis.  # pylint: disable=fixme

    Pauli val arrays contain expectation values <x|P|x> and their standard deviations.
    Axes are [x_idx, P_idx, mean_or_variance]
    Coefficients w_ij/w_ab: Axes: [index of Pauli string for eta, index of Pauli string for tau].
    asymmetric_bitstrings: A boolean which signifies whether the U and V subsystems have
                            different ansatze.
    """"""
    # Number of tensor stateprep circuits
    num_tensor_terms = int(np.shape(tensor_expvals)[0])

    if asymmetric_bitstrings:
        num_tensor_terms = int(
            num_tensor_terms / 2
        )  # num_tensor_terms should always be even here
        tensor_exp_vals_u = tensor_expvals[:num_tensor_terms, :, 0]
        tensor_exp_vals_v = tensor_expvals[num_tensor_terms:, :, 0]
    else:
        # Use the same expectation values for both subsystem calculations
        tensor_exp_vals_u = tensor_expvals[:, :, 0]
        tensor_exp_vals_v = tensor_expvals[:, :, 0]

    # Calculate the schmidt summation over the U and V subsystems and diagonalize the values
    h_schmidt_diagonal = np.einsum(
        ""ij,xi,xj->x"",
        w_ij_tensor_weights,
        tensor_exp_vals_u,
        tensor_exp_vals_v,
    )
    h_schmidt = np.diag(h_schmidt_diagonal)

    # If including the +/-Y superpositions (omitted at time of writing
    # since they typically have 0 net contribution) would change this to 4 instead of 2.
    num_lin_combos = 2

    num_superpos_terms = int(np.shape(superpos_expvals)[0])
    if asymmetric_bitstrings:
        num_superpos_terms = int(
            num_superpos_terms / 2
        )  # num_superpos_terms should always be even here
        pvss_u = superpos_expvals[:num_superpos_terms, :, 0]
        pvss_v = superpos_expvals[num_superpos_terms:, :, 0]
    else:
        pvss_u = superpos_expvals[:, :, 0]
        pvss_v = superpos_expvals[:, :, 0]

    # Calculate delta for U subsystem
    p_plus_x_u = pvss_u[0::num_lin_combos, :]
    p_minus_x_u = pvss_u[1::num_lin_combos, :]
    p_delta_x_u = p_plus_x_u - p_minus_x_u

    # Calculate delta for V subsystem
    if asymmetric_bitstrings:
        p_plus_x_v = pvss_v[0::num_lin_combos, :]
        p_minus_x_v = pvss_v[1::num_lin_combos, :]
        p_delta_x_v = p_plus_x_v - p_minus_x_v
    else:
        p_delta_x_v = p_delta_x_u

    h_schmidt_off_diagonals = np.einsum(
        ""ab,xa,xb->x"", w_ab_superpos_weights, p_delta_x_u, p_delta_x_v
    )

    superpos_state_indices = [
        (x, y)
        for x in range(h_schmidt.shape[0])
        for y in range(h_schmidt.shape[0])
        if x != y
    ]
    for element, indices in zip(h_schmidt_off_diagonals, superpos_state_indices):
        h_schmidt[indices] = element
    return h_schmidt  # , H_schmidt_vars)


def get_optimizer_instance(config):
    """"""Returns optimizer instance based on config.""""""
    # Addressing some special cases for compatibility with various Qiskit optimizers:
    if config.optimizer_name == ""adaptive_SPSA"":
        optimizer = SPSA
    else:
        optimizer = getattr(optimizers, config.optimizer_name)
    optimizer_config = {}
    optimizer_arg_names = inspect.signature(optimizer).parameters.keys()
    iter_kw = [kw for kw in [""maxiter"", ""max_trials""] if kw in optimizer_arg_names][0]
    optimizer_config[iter_kw] = config.maxiter
    if ""skip_calibration"" in optimizer_arg_names:
        optimizer_config[""skip_calibration""] = config.skip_any_optimizer_cal
    if ""last_avg"" in optimizer_arg_names:
        optimizer_config[""last_avg""] = config.spsa_last_average
    if ""tol"" in optimizer_arg_names:
        optimizer_config[""tol""] = config.optimizer_tol
    if ""c0"" in optimizer_arg_names:
        optimizer_config[""c0""] = config.spsa_c0
    if ""c1"" in optimizer_arg_names:
        optimizer_config[""c1""] = config.spsa_c1
    if ""learning_rate"" in optimizer_arg_names:
        optimizer_config[""learning_rate""] = lambda: powerseries(
            config.spsa_c0, 0.602, 0
        )
    if ""perturbation"" in optimizer_arg_names:
        optimizer_config[""perturbation""] = lambda: powerseries(config.spsa_c1, 0.101, 0)

    if config.initial_spsa_iteration_idx:
        if ""int_iter"" in optimizer_arg_names:
            optimizer_config[""int_iter""] = config.initial_spsa_iteration_idx

    if ""bootstrap_trials"" in optimizer_arg_names:
        optimizer_config[""bootstrap_trials""] = config.bootstrap_trials

    Log.log(optimizer_config)
    optimizer_instance = optimizer(**optimizer_config)
    return optimizer_instance
"
https://github.com/qiskit-community/prototype-entanglement-forging,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Execution subroutines.""""""

import time

import numpy as np
from qiskit import assemble
from qiskit.providers.ibmq.job import (
    IBMQJobFailureError,
    IBMQJobApiError,
    IBMQJobInvalidStateError,
)

from entanglement_forging.utils.legacy.common import measure_pauli_z, covariance


def compute_pauli_means_and_cov_for_one_basis(paulis, counts):
    """"""Compute Pauli means and cov for one basis.""""""
    means = np.array([measure_pauli_z(counts, pauli) for pauli in paulis])
    cov = np.array(
        [
            [
                covariance(counts, pauli_1, pauli_2, avg_1, avg_2)
                for pauli_2, avg_2 in zip(paulis, means)
            ]
            for pauli_1, avg_1 in zip(paulis, means)
        ]
    )
    return means, cov


def execute_with_retry(circuits, backend, shots, rep_delay=None, noise_model=None):
    """"""Executes job with retry.""""""
    global result  # pylint: disable=global-variable-undefined,invalid-name
    trials = 0
    ran_job_ok = False
    while not ran_job_ok:
        try:
            if backend.name() in [
                ""statevector_simulator"",
                ""aer_simulator_statevector"",
            ]:
                job = backend.run(
                    circuits,
                    seed_simulator=42,
                )
            elif backend.name() == ""qasm_simulator"":
                job = backend.run(circuits, shots=shots, noise_model=noise_model)
            else:
                job = backend.run(circuits, shots=shots, rep_delay=rep_delay)

            result = job.result()
            ran_job_ok = True
        except (IBMQJobFailureError, IBMQJobApiError, IBMQJobInvalidStateError) as err:
            print(""Error running job, will retry in 5 mins."")
            print(""Error:"", err)
            # Wait 5 mins and try again. Hopefully this handles network outages etc,
            # and also if user cancels a (stuck) job through IQX.
            # Add more error types to the exception as new ones crop up (as appropriate).
            time.sleep(300)
            trials += 1
            # pylint: disable=raise-missing-from
            if trials > 100:
                raise RuntimeError(
                    ""Timed out trying to run job successfully (100 attempts)""
                )
    return result


def reduce_bitstrings(bitstrings, orbitals_to_reduce):
    """"""Returns reduced bitstrings.""""""
    return np.delete(bitstrings, orbitals_to_reduce, axis=-1).tolist()
"
https://github.com/qiskit-community/prototype-entanglement-forging,qiskit-community,"# -*- coding: utf-8 -*-

# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# pylint: disable=cell-var-from-loop,invalid-name


""""""
Measurement correction filters.

""""""
from copy import deepcopy

import numpy as np
import qiskit
import scipy.linalg as la
from qiskit import QiskitError
from qiskit.utils.mitigation.circuits import count_keys
from qiskit.tools import parallel_map
from scipy.optimize import minimize


# pylint: disable=too-many-locals,too-many-branches,too-many-nested-blocks,too-many-statements
class MeasurementFilter:
    """"""
    Measurement error mitigation filter.

    Produced from a measurement calibration fitter and can be applied
    to data.

    """"""

    def __init__(self, cal_matrix: np.matrix, state_labels: list):
        """"""
        Initialize a measurement error mitigation filter using the cal_matrix
        from a measurement calibration fitter.

        Args:
            cal_matrix: the calibration matrix for applying the correction
            state_labels: the states for the ordering of the cal matrix
        """"""

        self._cal_matrix = cal_matrix
        self._state_labels = state_labels

    @property
    def cal_matrix(self):
        """"""Return cal_matrix.""""""
        return self._cal_matrix

    @property
    def state_labels(self):
        """"""return the state label ordering of the cal matrix""""""
        return self._state_labels

    @state_labels.setter
    def state_labels(self, new_state_labels):
        """"""set the state label ordering of the cal matrix""""""
        self._state_labels = new_state_labels

    @cal_matrix.setter
    def cal_matrix(self, new_cal_matrix):
        """"""Set cal_matrix.""""""
        self._cal_matrix = new_cal_matrix

    def apply(self, raw_data, method=""least_squares""):
        """"""Apply the calibration matrix to results.

        Args:
            raw_data (dict or list): The data to be corrected. Can be in a number of forms:

                 Form 1: a counts dictionary from results.get_counts

                 Form 2: a list of counts of `length==len(state_labels)`

                 I have no idea what this is. I'm not supporting it here.
                    --> Form 3: a list of counts of `length==M*len(state_labels)` where M is an
                 integer (e.g. for use with the tomography data)

                 Form 4: a qiskit Result

            method (str): fitting method. If `None`, then least_squares is used.

                ``pseudo_inverse``: direct inversion of the A matrix

                ``least_squares``: constrained to have physical probabilities

        Returns:
            dict or list: The corrected data in the same form as `raw_data`

        Raises:
            QiskitError: if `raw_data` is not an integer multiple
                of the number of calibrated states.

        """"""

        raw_data = deepcopy(raw_data)

        output_type = None
        if isinstance(raw_data, qiskit.result.result.Result):
            output_Result = deepcopy(raw_data)
            output_type = ""result""
            raw_data = raw_data.get_counts()
            if isinstance(raw_data, dict):
                raw_data = [raw_data]

        elif isinstance(raw_data, list):
            output_type = ""list""

        elif isinstance(raw_data, dict):
            raw_data = [raw_data]
            output_type = ""dict""

        assert output_type

        unique_data_labels = {key for data_row in raw_data for key in data_row.keys()}
        if not unique_data_labels.issubset(set(self._state_labels)):
            raise QiskitError(
                ""Unexpected state label '""
                + unique_data_labels
                + ""', verify the fitter's state labels correpsond to the input data""
            )

        raw_data_array = np.zeros((len(raw_data), len(self._state_labels)), dtype=float)
        corrected_data_array = np.zeros(
            (len(raw_data), len(self._state_labels)), dtype=float
        )

        for expt_idx, data_row in enumerate(raw_data):
            for stateidx, state in enumerate(self._state_labels):
                raw_data_array[expt_idx][stateidx] = data_row.get(state, 0)

        if method == ""pseudo_inverse"":
            pinv_cal_mat = la.pinv(self._cal_matrix)

            # pylint: disable=unused-variable
            corrected_data = np.einsum(""ij,xj->xi"", pinv_cal_mat, raw_data_array)

        elif method == ""least_squares"":

            nshots_each_expt = np.sum(raw_data_array, axis=1)

            for expt_idx, (nshots, raw_data_row) in enumerate(
                zip(nshots_each_expt, raw_data_array)
            ):
                cal_mat = self._cal_matrix
                nlabels = len(raw_data_row)  # pylint: disable=unused-variable

                def fun(estimated_corrected_data):
                    return np.sum(
                        (raw_data_row - cal_mat.dot(estimated_corrected_data)) ** 2
                    )

                def gradient(estimated_corrected_data):
                    return 2 * (
                        cal_mat.dot(estimated_corrected_data) - raw_data_row
                    ).dot(cal_mat)

                cons = {
                    ""type"": ""eq"",
                    ""fun"": lambda x: nshots - np.sum(x),
                    ""jac"": lambda x: -1 * np.ones_like(x),
                }
                bnds = tuple((0, nshots) for x in raw_data_row)
                res = minimize(
                    fun,
                    raw_data_row,
                    method=""SLSQP"",
                    constraints=cons,
                    bounds=bnds,
                    tol=1e-6,
                    jac=gradient,
                )

                # def fun(angles):
                #     # for bounding between 0 and 1
                #     cos2 = np.cos(angles)**2
                #     # form should constrain so sum always = nshots.
                #     estimated_corrected_data = nshots * \
                #                                (1/nlabels + (nlabels*cos2 -
                #                                              np.sum(cos2))/(nlabels-1))
                #     return np.sum( (raw_data_row -
                #                     cal_mat.dot(estimated_corrected_data) )**2)
                #
                # def gradient(estimated_corrected_data):
                #     return 2 * (cal_mat.dot(estimated_corrected_data) -
                #                 raw_data_row).dot(cal_mat)
                #
                # bnds = tuple((0, nshots) for x in raw_data_this_idx)
                # res = minimize(fun, raw_data_row,
                #                method='SLSQP', constraints=cons,
                #                bounds=bnds, tol=1e-6, jac=gradient)

                corrected_data_array[expt_idx] = res.x

        else:
            raise QiskitError(""Unrecognized method."")

        #         time_finished_correction = time.time()

        # convert back into a counts dictionary

        corrected_dicts = []
        for corrected_data_row in corrected_data_array:
            new_count_dict = {}
            for stateidx, state in enumerate(self._state_labels):
                if corrected_data_row[stateidx] != 0:
                    new_count_dict[state] = corrected_data_row[stateidx]

            corrected_dicts.append(new_count_dict)

        if output_type == ""dict"":
            assert len(corrected_dicts) == 1
            # converting back to a single counts dict, to match input provided by user
            output = corrected_dicts[0]
        elif output_type == ""list"":
            output = corrected_dicts
        elif output_type == ""result"":
            for resultidx, new_counts in enumerate(corrected_dicts):
                output_Result.results[resultidx].data.counts = new_counts
            output = output_Result
        else:
            raise TypeError()

        return output


class TensoredFilter:
    """"""
    Tensored measurement error mitigation filter.

    Produced from a tensored measurement calibration fitter and can be applied
    to data.
    """"""

    def __init__(self, cal_matrices: np.matrix, substate_labels_list: list):
        """"""
        Initialize a tensored measurement error mitigation filter using
        the cal_matrices from a tensored measurement calibration fitter.

        Args:
            cal_matrices: the calibration matrices for applying the correction.
            substate_labels_list: for each calibration matrix
                a list of the states (as strings, states in the subspace)
        """"""

        self._cal_matrices = cal_matrices
        self._qubit_list_sizes = []
        self._indices_list = []
        self._substate_labels_list = []
        self.substate_labels_list = substate_labels_list

    @property
    def cal_matrices(self):
        """"""Return cal_matrices.""""""
        return self._cal_matrices

    @cal_matrices.setter
    def cal_matrices(self, new_cal_matrices):
        """"""Set cal_matrices.""""""
        self._cal_matrices = deepcopy(new_cal_matrices)

    @property
    def substate_labels_list(self):
        """"""Return _substate_labels_list""""""
        return self._substate_labels_list

    @substate_labels_list.setter
    def substate_labels_list(self, new_substate_labels_list):
        """"""Return _substate_labels_list""""""
        self._substate_labels_list = new_substate_labels_list

        # get the number of qubits in each subspace
        self._qubit_list_sizes = []
        for _, substate_label_list in enumerate(self._substate_labels_list):
            self._qubit_list_sizes.append(int(np.log2(len(substate_label_list))))

        # get the indices in the calibration matrix
        self._indices_list = []
        for _, sub_labels in enumerate(self._substate_labels_list):
            self._indices_list.append({lab: ind for ind, lab in enumerate(sub_labels)})

    @property
    def qubit_list_sizes(self):
        """"""Return _qubit_list_sizes.""""""
        return self._qubit_list_sizes

    @property
    def nqubits(self):
        """"""Return the number of qubits. See also MeasurementFilter.apply()""""""
        return sum(self._qubit_list_sizes)

    def apply(self, raw_data, method=""least_squares""):
        """"""
        Apply the calibration matrices to results.

        Args:
            raw_data (dict or Result): The data to be corrected. Can be in one of two forms:

                * A counts dictionary from results.get_counts

                * A Qiskit Result

            method (str): fitting method. The following methods are supported:

                * 'pseudo_inverse': direct inversion of the cal matrices.

                * 'least_squares': constrained to have physical probabilities.

                * If `None`, 'least_squares' is used.

        Returns:
            dict or Result: The corrected data in the same form as raw_data

        Raises:
            QiskitError: if raw_data is not in a one of the defined forms.
        """"""

        all_states = count_keys(self.nqubits)
        num_of_states = 2**self.nqubits

        # check forms of raw_data
        if isinstance(raw_data, dict):
            # counts dictionary
            # convert to list
            raw_data2 = [np.zeros(num_of_states, dtype=float)]
            for state, count in raw_data.items():
                stateidx = int(state, 2)
                raw_data2[0][stateidx] = count

        elif isinstance(raw_data, qiskit.result.result.Result):

            # extract out all the counts, re-call the function with the
            # counts and push back into the new result
            new_result = deepcopy(raw_data)

            new_counts_list = parallel_map(
                self._apply_correction,
                [resultidx for resultidx, _ in enumerate(raw_data.results)],
                task_args=(raw_data, method),
            )

            for resultidx, new_counts in new_counts_list:
                new_result.results[resultidx].data.counts = new_counts

            return new_result

        else:
            raise QiskitError(""Unrecognized type for raw_data."")

        if method == ""pseudo_inverse"":
            pinv_cal_matrices = []
            for cal_mat in self._cal_matrices:
                pinv_cal_matrices.append(la.pinv(cal_mat))

        # Apply the correction
        for data_idx, _ in enumerate(raw_data2):

            if method == ""pseudo_inverse"":
                inv_mat_dot_raw = np.zeros([num_of_states], dtype=float)
                for state1_idx, state1 in enumerate(all_states):
                    for state2_idx, state2 in enumerate(all_states):
                        if raw_data2[data_idx][state2_idx] == 0:
                            continue

                        product = 1.0
                        end_index = self.nqubits
                        for p_ind, pinv_mat in enumerate(pinv_cal_matrices):

                            start_index = end_index - self._qubit_list_sizes[p_ind]

                            state1_as_int = self._indices_list[p_ind][
                                state1[start_index:end_index]
                            ]

                            state2_as_int = self._indices_list[p_ind][
                                state2[start_index:end_index]
                            ]

                            end_index = start_index
                            product *= pinv_mat[state1_as_int][state2_as_int]
                            if product == 0:
                                break
                        inv_mat_dot_raw[state1_idx] += (
                            product * raw_data2[data_idx][state2_idx]
                        )
                raw_data2[data_idx] = inv_mat_dot_raw

            elif method == ""least_squares"":

                def fun(x):
                    mat_dot_x = np.zeros([num_of_states], dtype=float)
                    for state1_idx, state1 in enumerate(all_states):
                        mat_dot_x[state1_idx] = 0.0
                        for state2_idx, state2 in enumerate(all_states):
                            if x[state2_idx] != 0:
                                product = 1.0
                                end_index = self.nqubits
                                for c_ind, cal_mat in enumerate(self._cal_matrices):

                                    start_index = (
                                        end_index - self._qubit_list_sizes[c_ind]
                                    )

                                    state1_as_int = self._indices_list[c_ind][
                                        state1[start_index:end_index]
                                    ]

                                    state2_as_int = self._indices_list[c_ind][
                                        state2[start_index:end_index]
                                    ]

                                    end_index = start_index
                                    product *= cal_mat[state1_as_int][state2_as_int]
                                    if product == 0:
                                        break
                                mat_dot_x[state1_idx] += product * x[state2_idx]
                    return sum((raw_data2[data_idx] - mat_dot_x) ** 2)

                x0 = np.random.rand(num_of_states)
                x0 = x0 / sum(x0)
                nshots = sum(raw_data2[data_idx])
                cons = {""type"": ""eq"", ""fun"": lambda x: nshots - sum(x)}
                bnds = tuple((0, nshots) for x in x0)
                res = minimize(
                    fun, x0, method=""SLSQP"", constraints=cons, bounds=bnds, tol=1e-6
                )
                raw_data2[data_idx] = res.x

            else:
                raise QiskitError(""Unrecognized method."")

        # convert back into a counts dictionary
        new_count_dict = {}
        for state_idx, state in enumerate(all_states):
            if raw_data2[0][state_idx] != 0:
                new_count_dict[state] = raw_data2[0][state_idx]

        return new_count_dict

    def _apply_correction(self, resultidx, raw_data, method):
        """"""Wrapper to call apply with a counts dictionary.""""""
        new_counts = self.apply(raw_data.get_counts(resultidx), method=method)
        return resultidx, new_counts
"
https://github.com/qiskit-community/prototype-entanglement-forging,qiskit-community,"# -*- coding: utf-8 -*-

# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# pylint: disable=cell-var-from-loop


""""""
Measurement correction fitters.
""""""
import copy
import re
from typing import List, Union

import numpy as np
from qiskit import QiskitError
from qiskit.utils.mitigation.circuits import count_keys
from qiskit.result import Result

from entanglement_forging.utils.meas_mit_filters_faster import MeasurementFilter

try:
    from matplotlib import pyplot as plt

    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False


# pylint: disable=too-many-locals,too-many-branches
class CompleteMeasFitter:
    """"""
    Measurement correction fitter for a full calibration
    """"""

    def __init__(
        self,
        results: Union[Result, List[Result]],
        state_labels: List[str],
        qubit_list: List[int] = None,
        circlabel: str = """",
    ):
        """"""
        Initialize a measurement calibration matrix from the results of running
        the circuits returned by `measurement_calibration_circuits`

        A wrapper for the tensored fitter

        Args:
            results: the results of running the measurement calibration
                circuits. If this is `None` the user will set a calibration
                matrix later.
            state_labels: list of calibration state labels
                returned from `measurement_calibration_circuits`.
                The output matrix will obey this ordering.
            qubit_list: List of the qubits (for reference and if the
                subset is needed). If `None`, the qubit_list will be
                created according to the length of state_labels[0].
            circlabel: if the qubits were labeled.
        """"""
        if qubit_list is None:
            qubit_list = range(len(state_labels[0]))
        self._qubit_list = qubit_list

        self._tens_fitt = TensoredMeasFitter(
            results, [qubit_list], [state_labels], circlabel
        )

    @property
    def cal_matrix(self):
        """"""Return cal_matrix.""""""
        return self._tens_fitt.cal_matrices[0]

    @cal_matrix.setter
    def cal_matrix(self, new_cal_matrix):
        """"""set cal_matrix.""""""
        self._tens_fitt.cal_matrices = [copy.deepcopy(new_cal_matrix)]

    @property
    def state_labels(self):
        """"""Return state_labels.""""""
        return self._tens_fitt.substate_labels_list[0]

    @property
    def qubit_list(self):
        """"""Return list of qubits.""""""
        return self._qubit_list

    @state_labels.setter
    def state_labels(self, new_state_labels):
        """"""Set state label.""""""
        self._tens_fitt.substate_labels_list[0] = new_state_labels

    @property
    def filter(self):
        """"""Return a measurement filter using the cal matrix.""""""
        return MeasurementFilter(self.cal_matrix, self.state_labels)

    def add_data(self, new_results, rebuild_cal_matrix=True):
        """"""
        Add measurement calibration data

        Args:
            new_results (list or qiskit.result.Result): a single result or list
                of result objects.
            rebuild_cal_matrix (bool): rebuild the calibration matrix
        """"""

        self._tens_fitt.add_data(new_results, rebuild_cal_matrix)

    def subset_fitter(self, qubit_sublist=None):
        """"""
        Return a fitter object that is a subset of the qubits in the original
        list.

        Args:
            qubit_sublist (list): must be a subset of qubit_list

        Returns:
            CompleteMeasFitter: A new fitter that has the calibration for a
                subset of qubits

        Raises:
            QiskitError: If the calibration matrix is not initialized
        """"""

        if self._tens_fitt.cal_matrices is None:
            raise QiskitError(""Calibration matrix is not initialized"")

        if qubit_sublist is None:
            raise QiskitError(""Qubit sublist must be specified"")

        for qubit in qubit_sublist:
            if qubit not in self._qubit_list:
                raise QiskitError(""Qubit not in the original set of qubits"")

        # build state labels
        new_state_labels = count_keys(len(qubit_sublist))

        # mapping between indices in the state_labels and the qubits in
        # the sublist
        qubit_sublist_ind = []
        for sqb in qubit_sublist:
            for qbind, qubit in enumerate(self._qubit_list):
                if qubit == sqb:
                    qubit_sublist_ind.append(qbind)

        # states in the full calibration which correspond
        # to the reduced labels
        q_q_mapping = []
        state_labels_reduced = []
        for label in self.state_labels:
            tmplabel = [label[index] for index in qubit_sublist_ind]
            state_labels_reduced.append("""".join(tmplabel))

        for sub_lab_ind, _ in enumerate(new_state_labels):
            q_q_mapping.append([])
            for labelind, label in enumerate(state_labels_reduced):
                if label == new_state_labels[sub_lab_ind]:
                    q_q_mapping[-1].append(labelind)

        new_fitter = CompleteMeasFitter(
            results=None, state_labels=new_state_labels, qubit_list=qubit_sublist
        )

        new_cal_matrix = np.zeros([len(new_state_labels), len(new_state_labels)])

        # do a partial trace
        for i in range(len(new_state_labels)):
            for j in range(len(new_state_labels)):

                for q_q_i_map in q_q_mapping[i]:
                    for q_q_j_map in q_q_mapping[j]:
                        new_cal_matrix[i, j] += self.cal_matrix[q_q_i_map, q_q_j_map]

                new_cal_matrix[i, j] /= len(q_q_mapping[i])

        new_fitter.cal_matrix = new_cal_matrix

        return new_fitter

    def readout_fidelity(self, label_list=None):
        """"""
        Based on the results, output the readout fidelity which is the
        normalized trace of the calibration matrix

        Args:
            label_list (bool): If `None`, returns the average assignment fidelity
                of a single state. Otherwise it returns the assignment fidelity
                to be in any one of these states averaged over the second
                index.

        Returns:
            numpy.array: readout fidelity (assignment fidelity)

        Additional Information:
            The on-diagonal elements of the calibration matrix are the
            probabilities of measuring state 'x' given preparation of state
            'x' and so the normalized trace is the average assignment fidelity
        """"""
        return self._tens_fitt.readout_fidelity(0, label_list)

    def plot_calibration(self, ax=None, show_plot=True):  # pylint: disable=invalid-name
        """"""
        Plot the calibration matrix (2D color grid plot)

        Args:
            show_plot (bool): call plt.show()
            ax (matplotlib.axes.Axes): An optional Axes object to use for the
                plot
        """"""

        self._tens_fitt.plot_calibration(
            0, ax, show_plot
        )  # pylint: disable=invalid-name


class TensoredMeasFitter:
    """"""
    Measurement correction fitter for a tensored calibration.
    """"""

    def __init__(
        self,
        results: Union[Result, List[Result]],
        mit_pattern: List[List[int]],
        substate_labels_list: List[List[str]] = None,
        circlabel: str = """",
    ):
        """"""
        Initialize a measurement calibration matrix from the results of running
        the circuits returned by `measurement_calibration_circuits`.

        Args:
            results: the results of running the measurement calibration
                circuits. If this is `None`, the user will set calibration
                matrices later.

            mit_pattern: qubits to perform the
                measurement correction on, divided to groups according to
                tensors

            substate_labels_list: for each
                calibration matrix, the labels of its rows and columns.
                If `None`, the labels are ordered lexicographically

            circlabel: if the qubits were labeled

        Raises:
            ValueError: if the mit_pattern doesn't match the
                substate_labels_list
        """"""

        self._result_list = []
        self._cal_matrices = None
        self._circlabel = circlabel

        self._qubit_list_sizes = [len(qubit_list) for qubit_list in mit_pattern]

        self._indices_list = []
        if substate_labels_list is None:
            self._substate_labels_list = []
            for list_size in self._qubit_list_sizes:
                self._substate_labels_list.append(count_keys(list_size))
        else:
            self._substate_labels_list = substate_labels_list
            if len(self._qubit_list_sizes) != len(substate_labels_list):
                raise ValueError(
                    ""mit_pattern does not match \
                    substate_labels_list""
                )

        self._indices_list = []
        for _, sub_labels in enumerate(self._substate_labels_list):
            self._indices_list.append({lab: ind for ind, lab in enumerate(sub_labels)})

        self.add_data(results)

    @property
    def cal_matrices(self):
        """"""Returns cal_matrices.""""""
        return self._cal_matrices

    @cal_matrices.setter
    def cal_matrices(self, new_cal_mat):
        """"""Sets _cal_matrices.""""""
        self._cal_matrices = copy.deepcopy(new_cal_mat)

    @property
    def substate_labels_list(self):
        """"""Return _substate_labels_list.""""""
        return self._substate_labels_list

    @property
    def nqubits(self):
        """"""Return _qubit_list_sizes.""""""
        return sum(self._qubit_list_sizes)

    def add_data(self, new_results, rebuild_cal_matrix=True):
        """"""
        Add measurement calibration data

        Args:
            new_results (list or qiskit.result.Result): a single result or list
                of Result objects.
            rebuild_cal_matrix (bool): rebuild the calibration matrix
        """"""

        if new_results is None:
            return

        if not isinstance(new_results, list):
            new_results = [new_results]

        for result in new_results:
            self._result_list.append(result)

        if rebuild_cal_matrix:
            self._build_calibration_matrices()

    def readout_fidelity(self, cal_index=0, label_list=None):
        """"""
        Based on the results, output the readout fidelity, which is the average
        of the diagonal entries in the calibration matrices.

        Args:
            cal_index(integer): readout fidelity for this index in _cal_matrices
            label_list (list):  Returns the average fidelity over of the groups
                f states. In the form of a list of lists of states. If `None`,
                then each state used in the construction of the calibration
                matrices forms a group of size 1

        Returns:
            numpy.array: The readout fidelity (assignment fidelity)

        Raises:
            QiskitError: If the calibration matrix has not been set for the
                object.

        Additional Information:
            The on-diagonal elements of the calibration matrices are the
            probabilities of measuring state 'x' given preparation of state
            'x'.
        """"""

        if self._cal_matrices is None:
            raise QiskitError(""Cal matrix has not been set"")

        if label_list is None:
            label_list = [[label] for label in self._substate_labels_list[cal_index]]

        state_labels = self._substate_labels_list[cal_index]
        fidelity_label_list = []
        if label_list is None:
            fidelity_label_list = [[label] for label in state_labels]
        else:
            for fid_sublist in label_list:
                fidelity_label_list.append([])
                for fid_statelabl in fid_sublist:
                    for label_idx, label in enumerate(state_labels):
                        if fid_statelabl == label:
                            fidelity_label_list[-1].append(label_idx)
                            continue

        # fidelity_label_list is a 2D list of indices in the
        # cal_matrix, we find the assignment fidelity of each
        # row and average over the list
        assign_fid_list = []

        for fid_label_sublist in fidelity_label_list:
            assign_fid_list.append(0)
            for state_idx_i in fid_label_sublist:
                for state_idx_j in fid_label_sublist:
                    assign_fid_list[-1] += self._cal_matrices[cal_index][state_idx_i][
                        state_idx_j
                    ]
            assign_fid_list[-1] /= len(fid_label_sublist)

        return np.mean(assign_fid_list)

    def _build_calibration_matrices(self):
        """"""
        Build the measurement calibration matrices from the results of running
        the circuits returned by `measurement_calibration`.
        """"""

        # initialize the set of empty calibration matrices
        self._cal_matrices = []
        for list_size in self._qubit_list_sizes:
            self._cal_matrices.append(
                np.zeros([2**list_size, 2**list_size], dtype=float)
            )

        # go through for each calibration experiment
        for result in self._result_list:
            for experiment in result.results:
                circ_name = experiment.header.name
                # extract the state from the circuit name
                # this was the prepared state
                circ_search = re.search(
                    ""(?<="" + self._circlabel + ""cal_)\\w+"", circ_name
                )

                # this experiment is not one of the calcs so skip
                if circ_search is None:
                    continue

                state = circ_search.group(0)

                # get the counts from the result
                state_cnts = result.get_counts(circ_name)
                for measured_state, counts in state_cnts.items():
                    end_index = self.nqubits
                    for cal_ind, cal_mat in enumerate(self._cal_matrices):
                        start_index = end_index - self._qubit_list_sizes[cal_ind]

                        substate_index = self._indices_list[cal_ind][
                            state[start_index:end_index]
                        ]
                        measured_substate_index = self._indices_list[cal_ind][
                            measured_state[start_index:end_index]
                        ]
                        end_index = start_index

                        cal_mat[measured_substate_index][substate_index] += counts

        for mat_index, _ in enumerate(self._cal_matrices):
            sums_of_columns = np.sum(self._cal_matrices[mat_index], axis=0)
            # pylint: disable=assignment-from-no-return
            self._cal_matrices[mat_index] = np.divide(
                self._cal_matrices[mat_index],
                sums_of_columns,
                out=np.zeros_like(self._cal_matrices[mat_index]),
                where=sums_of_columns != 0,
            )

    def plot_calibration(self, cal_index=0, axes=None, show_plot=True):
        """"""
        Plot one of the calibration matrices (2D color grid plot).

        Args:
            cal_index(integer): calibration matrix to plot
            axes(matplotlib.axes): settings for the graph
            show_plot (bool): call plt.show()

        Raises:
            QiskitError: if _cal_matrices was not set.

            ImportError: if matplotlib was not installed.

        """"""

        if self._cal_matrices is None:
            raise QiskitError(""Cal matrix has not been set"")

        if not HAS_MATPLOTLIB:
            raise ImportError(
                ""The function plot_rb_data needs matplotlib. ""
                'Run ""pip install matplotlib"" before.'
            )

        if axes is None:
            plt.figure()
            axes = plt.gca()

        axim = axes.matshow(
            self.cal_matrices[cal_index],
            cmap=plt.cm.binary,  # pylint: disable=no-member
            clim=[0, 1],
        )
        axes.figure.colorbar(axim)
        axes.set_xlabel(""Prepared State"")
        axes.xaxis.set_label_position(""top"")
        axes.set_ylabel(""Measured State"")
        axes.set_xticks(np.arange(len(self._substate_labels_list[cal_index])))
        axes.set_yticks(np.arange(len(self._substate_labels_list[cal_index])))
        axes.set_xticklabels(self._substate_labels_list[cal_index])
        axes.set_yticklabels(self._substate_labels_list[cal_index])

        if show_plot:
            plt.show()
"
https://github.com/qiskit-community/prototype-entanglement-forging,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Bitstring functions.""""""
from qiskit import QuantumCircuit


def prepare_bitstring(bitstring, name=None):
    """"""Prepares bitstrings.""""""
    # First bit in bitstring is the first qubit in the circuit.
    qcirc = QuantumCircuit(len(bitstring), name=name)
    for qb_idx, bit in enumerate(bitstring):
        if bit:
            qcirc.x(qb_idx)
    return qcirc
"
https://github.com/qiskit-community/prototype-entanglement-forging,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""""" pauli common functions """"""

import logging

import numpy as np
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.algorithms import AlgorithmError
from qiskit.circuit import Parameter, ParameterExpression
from qiskit.qasm import pi
from qiskit.quantum_info import Pauli  # pylint: disable=unused-import

logger = logging.getLogger(__name__)


# pylint: disable=too-many-arguments,too-many-branches,too-many-locals
def pauli_measurement(circuit, pauli, qreg, creg, barrier=False):
    """"""
    Add the proper post-rotation gate on the circuit.

    Args:
        circuit (QuantumCircuit): the circuit to be modified.
        pauli (Pauli): the pauli will be added.
        qreg (QuantumRegister): the quantum register associated with the circuit.
        creg (ClassicalRegister): the classical register associated with the circuit.
        barrier (bool, optional): whether or not add barrier before measurement.

    Returns:
        QuantumCircuit: the original circuit object with post-rotation gate
    """"""
    num_qubits = pauli.num_qubits
    for qubit_idx in range(num_qubits):
        if pauli.x[qubit_idx]:
            if pauli.z[qubit_idx]:
                # Measure Y
                circuit.sdg(qreg[qubit_idx])  # sdg
                circuit.h(qreg[qubit_idx])  # h
            else:
                # Measure X
                circuit.h(qreg[qubit_idx])  # h
        if barrier:
            circuit.barrier(qreg[qubit_idx])
        circuit.measure(qreg[qubit_idx], creg[qubit_idx])

    return circuit


def measure_pauli_z(data, pauli):
    """"""
    Appropriate post-rotations on the state are assumed.

    Args:
        data (dict): a dictionary of the form data = {'00000': 10} ({str: int})
        pauli (Pauli): a Pauli object

    Returns:
        float: Expected value of paulis given data
    """"""
    observable = 0.0
    num_shots = sum(data.values())
    p_z_or_x = np.logical_or(pauli.z, pauli.x)
    for key, value in data.items():
        bitstr = np.asarray(list(key))[::-1].astype(int).astype(bool)
        # pylint: disable=no-member
        sign = -1.0 if np.logical_xor.reduce(np.logical_and(bitstr, p_z_or_x)) else 1.0
        observable += sign * value
    observable /= num_shots
    return observable


def covariance(data, pauli_1, pauli_2, avg_1, avg_2):
    """"""
    Compute the covariance matrix element between two
    Paulis, given the measurement outcome.
    Appropriate post-rotations on the state are assumed.

    Args:
        data (dict): a dictionary of the form data = {'00000': 10} ({str:int})
        pauli_1 (Pauli): a Pauli class member
        pauli_2 (Pauli): a Pauli class member
        avg_1 (float): expectation value of pauli_1 on `data`
        avg_2 (float): expectation value of pauli_2 on `data`

    Returns:
        float: the element of the covariance matrix between two Paulis
    """"""
    cov = 0.0
    num_shots = sum(data.values())

    if num_shots == 1:
        return cov

    p1_z_or_x = np.logical_or(pauli_1.z, pauli_1.x)
    p2_z_or_x = np.logical_or(pauli_2.z, pauli_2.x)
    for key, value in data.items():
        bitstr = np.asarray(list(key))[::-1].astype(int).astype(bool)
        # pylint: disable=no-member
        sign_1 = (
            -1.0 if np.logical_xor.reduce(np.logical_and(bitstr, p1_z_or_x)) else 1.0
        )
        sign_2 = (
            -1.0 if np.logical_xor.reduce(np.logical_and(bitstr, p2_z_or_x)) else 1.0
        )
        cov += (sign_1 - avg_1) * (sign_2 - avg_2) * value
    cov /= num_shots - 1
    return cov


# pylint: disable=invalid-name
def suzuki_expansion_slice_pauli_list(pauli_list, lam_coef, expansion_order):
    """"""
    Compute the list of pauli terms for a single slice of the suzuki expansion following the paper
    https://arxiv.org/pdf/quant-ph/0508139.pdf.

    Args:
        pauli_list (list[list[complex, Pauli]]): The slice's weighted Pauli list for the
                                                 suzuki expansion
        lam_coef (float): The parameter lambda as defined in said paper,
                          adjusted for the evolution time and the number of time slices
        expansion_order (int): The order for suzuki expansion

    Returns:
        list: slice pauli list
    """"""
    if expansion_order == 1:
        half = [[lam_coef / 2 * c, p] for c, p in pauli_list]
        res = half + list(reversed(half))
    else:
        p_k = (4 - 4 ** (1 / (2 * expansion_order - 1))) ** -1
        side_base = suzuki_expansion_slice_pauli_list(
            pauli_list, lam_coef * p_k, expansion_order - 1
        )
        side = side_base * 2
        middle = suzuki_expansion_slice_pauli_list(
            pauli_list, lam_coef * (1 - 4 * p_k), expansion_order - 1
        )
        res = side + middle + side
    return res


def check_commutativity(op_1, op_2, anti=False):
    """"""
    Check the (anti-)commutativity between two operators.

    Args:
        op_1 (WeightedPauliOperator): operator
        op_2 (WeightedPauliOperator): operator
        anti (bool): if True, check anti-commutativity, otherwise check commutativity.

    Returns:
        bool: whether or not two operators are commuted or anti-commuted.
    """"""
    com = op_1 * op_2 - op_2 * op_1 if not anti else op_1 * op_2 + op_2 * op_1
    com.simplify()
    return bool(com.is_empty())


# pylint: disable=too-many-statements
def evolution_instruction(
    pauli_list,
    evo_time,
    num_time_slices,
    controlled=False,
    power=1,
    use_basis_gates=True,
    shallow_slicing=False,
    barrier=False,
):
    """"""
    Construct the evolution circuit according to the supplied specification.

    Args:
        pauli_list (list([[complex, Pauli]])): The list of pauli terms corresponding
                                               to a single time slice to be evolved
        evo_time (Union(complex, float, Parameter, ParameterExpression)): The evolution time
        num_time_slices (int): The number of time slices for the expansion
        controlled (bool, optional): Controlled circuit or not
        power (int, optional): The power to which the unitary operator is to be raised
        use_basis_gates (bool, optional): boolean flag for indicating only using basis
                                          gates when building circuit.
        shallow_slicing (bool, optional): boolean flag for indicating using shallow
                                          qc.data reference repetition for slicing
        barrier (bool, optional): whether or not add barrier for every slice

    Returns:
        Instruction: The Instruction corresponding to specified evolution.

    Raises:
        AlgorithmError: power must be an integer and greater or equal to 1
        ValueError: Unrecognized pauli
    """"""

    if not isinstance(power, int) or power < 1:
        raise AlgorithmError(""power must be an integer and greater or equal to 1."")

    state_registers = QuantumRegister(pauli_list[0][1].num_qubits)
    if controlled:
        inst_name = f""Controlled-Evolution^{power}""
        ancillary_registers = QuantumRegister(1)
        qc_slice = QuantumCircuit(state_registers, ancillary_registers, name=inst_name)
    else:
        inst_name = f""Evolution^{power}""
        qc_slice = QuantumCircuit(state_registers, name=inst_name)

    # for each pauli [IXYZ]+, record the list of qubit pairs needing CX's
    cnot_qubit_pairs = [None] * len(pauli_list)
    # for each pauli [IXYZ]+, record the highest index of the nontrivial pauli gate (X,Y, or Z)
    top_xyz_pauli_indices = [-1] * len(pauli_list)

    for pauli_idx, pauli in enumerate(reversed(pauli_list)):
        n_qubits = pauli[1].num_qubits
        # changes bases if necessary
        nontrivial_pauli_indices = []
        for qubit_idx in range(n_qubits):
            # pauli I
            if not pauli[1].z[qubit_idx] and not pauli[1].x[qubit_idx]:
                continue

            if cnot_qubit_pairs[pauli_idx] is None:
                nontrivial_pauli_indices.append(qubit_idx)

            if pauli[1].x[qubit_idx]:
                # pauli X
                if not pauli[1].z[qubit_idx]:
                    if use_basis_gates:
                        qc_slice.h(state_registers[qubit_idx])
                    else:
                        qc_slice.h(state_registers[qubit_idx])
                # pauli Y
                elif pauli[1].z[qubit_idx]:
                    if use_basis_gates:
                        qc_slice.u(pi / 2, -pi / 2, pi / 2, state_registers[qubit_idx])
                    else:
                        qc_slice.rx(pi / 2, state_registers[qubit_idx])
            # pauli Z
            elif pauli[1].z[qubit_idx] and not pauli[1].x[qubit_idx]:
                pass
            else:
                raise ValueError(f""Unrecognized pauli: {pauli[1]}"")

        if nontrivial_pauli_indices:
            top_xyz_pauli_indices[pauli_idx] = nontrivial_pauli_indices[-1]

        # insert lhs cnot gates
        if cnot_qubit_pairs[pauli_idx] is None:
            cnot_qubit_pairs[pauli_idx] = list(
                zip(
                    sorted(nontrivial_pauli_indices)[:-1],
                    sorted(nontrivial_pauli_indices)[1:],
                )
            )

        for pair in cnot_qubit_pairs[pauli_idx]:
            qc_slice.cx(state_registers[pair[0]], state_registers[pair[1]])

        # insert Rz gate
        if top_xyz_pauli_indices[pauli_idx] >= 0:

            # Because Parameter does not support complexity number operation; thus, we do
            # the following tricks to generate parameterized instruction.
            # We assume the coefficient in the pauli is always real. and can not do imaginary time
            # evolution
            if isinstance(evo_time, (Parameter, ParameterExpression)):
                lam = 2.0 * pauli[0] / num_time_slices
                lam = lam.real if lam.imag == 0 else lam
                lam = lam * evo_time
            else:
                lam = (2.0 * pauli[0] * evo_time / num_time_slices).real

            if not controlled:
                if use_basis_gates:
                    qc_slice.p(lam, state_registers[top_xyz_pauli_indices[pauli_idx]])
                else:
                    qc_slice.rz(lam, state_registers[top_xyz_pauli_indices[pauli_idx]])
            else:
                if use_basis_gates:
                    qc_slice.p(
                        lam / 2, state_registers[top_xyz_pauli_indices[pauli_idx]]
                    )
                    qc_slice.cx(
                        ancillary_registers[0],
                        state_registers[top_xyz_pauli_indices[pauli_idx]],
                    )
                    qc_slice.p(
                        -lam / 2, state_registers[top_xyz_pauli_indices[pauli_idx]]
                    )
                    qc_slice.cx(
                        ancillary_registers[0],
                        state_registers[top_xyz_pauli_indices[pauli_idx]],
                    )
                else:
                    qc_slice.crz(
                        lam,
                        ancillary_registers[0],
                        state_registers[top_xyz_pauli_indices[pauli_idx]],
                    )

        # insert rhs cnot gates
        for pair in reversed(cnot_qubit_pairs[pauli_idx]):
            qc_slice.cx(state_registers[pair[0]], state_registers[pair[1]])

        # revert bases if necessary
        for qubit_idx in range(n_qubits):
            if pauli[1].x[qubit_idx]:
                # pauli X
                if not pauli[1].z[qubit_idx]:
                    if use_basis_gates:
                        qc_slice.h(state_registers[qubit_idx])
                    else:
                        qc_slice.h(state_registers[qubit_idx])
                # pauli Y
                elif pauli[1].z[qubit_idx]:
                    if use_basis_gates:
                        qc_slice.u(-pi / 2, -pi / 2, pi / 2, state_registers[qubit_idx])
                    else:
                        qc_slice.rx(-pi / 2, state_registers[qubit_idx])
    # repeat the slice
    if shallow_slicing:
        logger.info(
            ""Under shallow slicing mode, the qc.data reference is repeated shallowly. ""
            ""Thus, changing gates of one slice of the output circuit might affect ""
            ""other slices.""
        )
        if barrier:
            qc_slice.barrier(state_registers)
        qc_slice.data *= num_time_slices * power
        qc = qc_slice
    else:
        qc = QuantumCircuit(*qc_slice.qregs, name=inst_name)
        for _ in range(num_time_slices * power):
            qc.append(qc_slice, qc.qubits)
            if barrier:
                qc.barrier(state_registers)
    return qc.to_instruction()
"
https://github.com/qiskit-community/prototype-entanglement-forging,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""""" Weighted Pauli Operator """"""

import itertools
import json
import logging
import sys
from copy import deepcopy
from operator import add as op_add, sub as op_sub
from typing import List, Optional, Tuple, Union

import numpy as np
from qiskit import ClassicalRegister, QuantumCircuit, QuantumRegister
from qiskit.algorithms import AlgorithmError
from qiskit.quantum_info import Pauli
from qiskit.tools import parallel_map
from qiskit.tools.events import TextProgressBar
from qiskit.utils import algorithm_globals

from .base_operator import LegacyBaseOperator
from .common import (
    measure_pauli_z,
    covariance,
    pauli_measurement,
    suzuki_expansion_slice_pauli_list,
    check_commutativity,
    evolution_instruction,
)

logger = logging.getLogger(__name__)


# pylint: disable=invalid-name,too-many-lines,too-many-arguments,protected-access,no-else-return,too-many-locals
# pylint: disable=too-many-branches,too-many-public-methods
# pylint: disable=duplicate-code


class WeightedPauliOperator(LegacyBaseOperator):
    """"""Weighted Pauli Operator""""""

    def __init__(
        self,
        paulis: List[List[Union[complex, Pauli]]],
        basis: Optional[List[Tuple[object, List[int]]]] = None,
        z2_symmetries: ""Z2Symmetries"" = None,
        atol: float = 1e-12,
        name: Optional[str] = None,
    ) -> None:
        """"""
        Args:
            paulis: the list of weighted Paulis, where a weighted pauli is
                    composed of a length-2 list and the first item is the
                    weight and the second item is the Pauli object.
            basis: the grouping basis, each element is a tuple composed of the basis
                    and the indices to paulis which belong to that group.
                    e.g., if tpb basis is used, the object will be a pauli.
                    By default, the group is equal to non-grouping, each pauli is its own basis.
            z2_symmetries: recording the z2 symmetries info
            atol: the threshold used in truncating paulis
            name: the name of operator.
        """"""
        super().__init__(basis, z2_symmetries, name)
        # plain store the paulis, the group information is store in the basis
        self._paulis_table = None
        self._paulis = paulis
        self._basis = (
            [(pauli[1], [i]) for i, pauli in enumerate(paulis)]
            if basis is None
            else basis
        )
        # combine the paulis and remove those with zero weight
        self.simplify()
        self._atol = atol

    @classmethod
    def from_list(cls, paulis, weights=None, name=None):
        """"""
        Create a WeightedPauliOperator via a pair of list.

        Args:
            paulis (list[Pauli]): the list of Paulis
            weights (list[complex], optional): the list of weights,
                                               if it is None, all weights are 1.
            name (str, optional): name of the operator.

        Returns:
            WeightedPauliOperator: operator

        Raises:
            ValueError: The length of weights and paulis must be the same
        """"""
        if weights is not None and len(weights) != len(paulis):
            raise ValueError(""The length of weights and paulis must be the same."")
        if weights is None:
            weights = [1.0] * len(paulis)
        return cls(paulis=[[w, p] for w, p in zip(weights, paulis)], name=name)

    # pylint: disable=arguments-differ
    def to_opflow(self, reverse_endianness=False):
        """"""to op flow""""""
        # pylint: disable=import-outside-toplevel
        from qiskit.opflow import PrimitiveOp

        pauli_ops = []
        for [w, p] in self.paulis:
            pauli = Pauli(str(p)[::-1]) if reverse_endianness else p
            # This weighted pauli operator has the coeff stored as a complex type
            # irrespective of whether the value has any imaginary part or not.
            # For many operators the coeff will be real. Hence below the coeff is made real,
            # when creating the PrimitiveOp, since it can be stored then as a float, if its
            # value is real, i.e. has no imaginary part. This avoids any potential issues around
            # complex - but if there are complex coeffs then maybe that using the opflow
            # later will fail if it happens to be used where complex is not supported.
            # Now there are imaginary coefficients in UCCSD that would need to be handled
            # when this is converted to opflow (evolution of hopping operators) where currently
            # Terra does not handle complex.
            # TODO fix these or add support for them in Terra  # pylint: disable=fixme
            coeff = np.real(w) if np.isreal(w) else w
            pauli_ops += [PrimitiveOp(pauli, coeff=coeff)]
        return sum(pauli_ops)

    @property
    def paulis(self):
        """"""get paulis""""""
        return self._paulis

    @property
    def atol(self):
        """"""get atol""""""
        return self._atol

    @atol.setter
    def atol(self, new_value):
        """"""set atol""""""
        self._atol = new_value

    @property
    def num_qubits(self):
        """"""
        Number of qubits required for the operator.

        Returns:
            int: number of qubits
        """"""
        if not self.is_empty():
            res = self._paulis[0][1].num_qubits
        else:
            logger.warning(""Operator is empty, Return 0."")
            res = 0
        return res

    def __eq__(self, other):
        """"""Overload == operation""""""
        # need to clean up the zeros
        self.simplify()
        other.simplify()
        if len(self._paulis) != len(other.paulis):
            return False
        for weight, pauli in self._paulis:
            found_pauli = False
            other_weight = 0.0
            for weight2, pauli2 in other.paulis:
                if pauli == pauli2:
                    found_pauli = True
                    other_weight = weight2
                    break
            if (
                not found_pauli and other_weight != 0.0
            ):  # since we might have 0 weights of paulis.
                return False
            if weight != other_weight:
                return False
        return True

    def _add_or_sub(self, other, operation, copy=True):
        """"""
        Add two operators either extend (in-place) or combine (copy) them.
        The addition performs optimized combination of two operators.
        If `other` has identical basis, the coefficient are combined rather than
        appended.

        Args:
            other (WeightedPauliOperator): to-be-combined operator
            operation (callable or str): add or sub callable from operator
            copy (bool): working on a copy or self

        Returns:
            WeightedPauliOperator: operator

        Raises:
            AlgorithmError: two operators have different number of qubits.
        """"""

        if not self.is_empty() and not other.is_empty():
            if self.num_qubits != other.num_qubits:
                raise AlgorithmError(
                    ""Can not add/sub two operators "" ""with different number of qubits.""
                )

        ret_op = self.copy() if copy else self

        for pauli in other.paulis:
            pauli_label = pauli[1].to_label()
            idx = ret_op._paulis_table.get(pauli_label, None)
            if idx is not None:
                ret_op._paulis[idx][0] = operation(ret_op._paulis[idx][0], pauli[0])
            else:
                new_pauli = deepcopy(pauli)
                ret_op._paulis_table[pauli_label] = len(ret_op._paulis)
                ret_op._basis.append((new_pauli[1], [len(ret_op._paulis)]))
                new_pauli[0] = operation(0.0, pauli[0])
                ret_op._paulis.append(new_pauli)
        return ret_op

    def add(self, other, copy=False):
        """"""
        Perform self + other.

        Args:
            other (WeightedPauliOperator): to-be-combined operator
            copy (bool): working on a copy or self, if False, the results are written back to self.

        Returns:
            WeightedPauliOperator: operator
        """"""

        return self._add_or_sub(other, op_add, copy=copy)

    def sub(self, other, copy=False):
        """"""
        Perform self - other.

        Args:
            other (WeightedPauliOperator): to-be-combined operator
            copy (bool): working on a copy or self, if False, the results are written back to self.

        Returns:
            WeightedPauliOperator: operator
        """"""

        return self._add_or_sub(other, op_sub, copy=copy)

    def __add__(self, other):
        """"""Overload + operator""""""
        return self.add(other, copy=True)

    def __iadd__(self, other):
        """"""Overload += operator""""""
        return self.add(other, copy=False)

    def __sub__(self, other):
        """"""Overload - operator""""""
        return self.sub(other, copy=True)

    def __isub__(self, other):
        """"""Overload -= operator""""""
        return self.sub(other, copy=False)

    def _scaling_weight(self, scaling_factor, copy=False):
        """"""
        Constantly scaling all weights of paulis.

        Args:
            scaling_factor (complex): the scaling factor
            copy (bool): return a copy or modify in-place

        Returns:
            WeightedPauliOperator: a copy of the scaled one.

        Raises:
            ValueError: the scaling factor is not a valid type.
        """"""
        if not isinstance(scaling_factor, (int, float, complex)):
            raise ValueError(
                f""Type of scaling factor is a valid type. {scaling_factor.__class__} if given.""
            )
        ret = self.copy() if copy else self
        for idx in range(len(ret._paulis)):  # pylint: disable=consider-using-enumerate
            ret._paulis[idx] = [
                ret._paulis[idx][0] * scaling_factor,
                ret._paulis[idx][1],
            ]
        return ret

    def multiply(self, other):
        """"""
        Perform self * other, and the phases are tracked.

        Args:
            other (WeightedPauliOperator): an operator

        Returns:
            WeightedPauliOperator: the multiplied operator
        """"""
        ret_op = WeightedPauliOperator(paulis=[])
        for existed_weight, existed_pauli in self.paulis:
            for weight, pauli in other.paulis:
                p = existed_pauli.dot(pauli)
                new_pauli, sign = p[:], (-1j) ** p.phase
                new_weight = existed_weight * weight * sign
                pauli_term = [new_weight, new_pauli]
                ret_op += WeightedPauliOperator(paulis=[pauli_term])
        return ret_op

    def __rmul__(self, other):
        """"""Overload other * self""""""
        if isinstance(other, (int, float, complex)):
            return self._scaling_weight(other, copy=True)
        else:
            return other.multiply(self)

    def __mul__(self, other):
        """"""Overload self * other""""""
        if isinstance(other, (int, float, complex)):
            return self._scaling_weight(other, copy=True)
        else:
            return self.multiply(other)

    def __neg__(self):
        """"""Overload unary -""""""
        return self._scaling_weight(-1.0, copy=True)

    def __str__(self):
        """"""Overload str()""""""
        curr_repr = ""paulis""
        length = len(self._paulis)
        name = """" if self._name == """" else f""{self._name}: ""
        ret = f""{name}Representation: {curr_repr}, qubits: {self.num_qubits}, size: {length}""

        return ret

    def print_details(self):
        """"""
        Print out the operator in details.

        Returns:
            str: a formatted string describes the operator.
        """"""
        if self.is_empty():
            return ""Operator is empty.""
        ret = """"
        for weight, pauli in self._paulis:
            ret = """".join([ret, f""{pauli.to_label()}\t{weight}\n""])

        return ret

    def copy(self):
        """"""Get a copy of self""""""
        return deepcopy(self)

    def simplify(self, copy=False):
        """"""
        Merge the paulis whose bases are identical and the pauli with zero coefficient
        would be removed.

        Note:
            This behavior of this method is slightly changed,
            it will remove the paulis whose weights are zero.

        Args:
            copy (bool): simplify on a copy or self

        Returns:
            WeightedPauliOperator: the simplified operator
        """"""

        op = self.copy() if copy else self

        new_paulis = []
        new_paulis_table = {}
        old_to_new_indices = {}
        curr_idx = 0
        for curr_weight, curr_pauli in op.paulis:
            pauli_label = curr_pauli.to_label()
            new_idx = new_paulis_table.get(pauli_label, None)
            if new_idx is not None:
                new_paulis[new_idx][0] += curr_weight
                old_to_new_indices[curr_idx] = new_idx
            else:
                new_paulis_table[pauli_label] = len(new_paulis)
                old_to_new_indices[curr_idx] = len(new_paulis)
                new_paulis.append([curr_weight, curr_pauli])
            curr_idx += 1

        op._paulis = new_paulis
        op._paulis_table = new_paulis_table

        # update the grouping info, since this method only reduce the number
        # of paulis, we can handle it here for both
        # pauli and tpb grouped pauli
        # should have a better way to rebuild the basis here.
        new_basis = []
        for basis, indices in op.basis:
            new_indices = []
            found = False
            if new_basis:
                for b, ind in new_basis:
                    if b == basis:
                        new_indices = ind
                        found = True
                        break
            for idx in indices:
                new_idx = old_to_new_indices[idx]
                if new_idx is not None and new_idx not in new_indices:
                    new_indices.append(new_idx)
            if new_indices and not found:
                new_basis.append((basis, new_indices))
        op._basis = new_basis
        op.chop(0.0)
        return op

    def rounding(self, decimals, copy=False):
        """"""
        Rounding the weight.

        Args:
            decimals (int): rounding the weight to the decimals.
            copy (bool): chop on a copy or self

        Returns:
            WeightedPauliOperator: operator
        """"""
        op = self.copy() if copy else self

        op._paulis = [
            [np.around(weight, decimals=decimals), pauli] for weight, pauli in op.paulis
        ]

        return op

    def chop(self, threshold=None, copy=False):
        """"""
        Eliminate the real and imagine part of weight in each pauli by `threshold`.
        If pauli's weight is less then `threshold` in both real and imaginary parts,
        the pauli is removed.

        Note:
            If weight is real-only, the imaginary part is skipped.

        Args:
            threshold (float): the threshold is used to remove the paulis
            copy (bool): chop on a copy or self

        Returns:
            WeightedPauliOperator: if copy is True, the original operator is unchanged; otherwise,
                                   the operator is mutated.
        """"""
        threshold = self._atol if threshold is None else threshold

        def chop_real_imag(weight):
            temp_real = weight.real if np.absolute(weight.real) >= threshold else 0.0
            temp_imag = weight.imag if np.absolute(weight.imag) >= threshold else 0.0
            if temp_real == 0.0 and temp_imag == 0.0:
                return 0.0
            else:
                new_weight = temp_real + 1j * temp_imag
                return new_weight

        op = self.copy() if copy else self

        if op.is_empty():
            return op

        paulis = []
        old_to_new_indices = {}
        curr_idx = 0
        for idx, weighted_pauli in enumerate(op.paulis):
            weight, pauli = weighted_pauli
            new_weight = chop_real_imag(weight)
            if new_weight != 0.0:
                old_to_new_indices[idx] = curr_idx
                curr_idx += 1
                paulis.append([new_weight, pauli])

        op._paulis = paulis
        op._paulis_table = {
            weighted_pauli[1].to_label(): i for i, weighted_pauli in enumerate(paulis)
        }
        # update the grouping info, since this method only remove pauli,
        # we can handle it here for both
        # pauli and tpb grouped pauli
        new_basis = []
        for basis, indices in op.basis:
            new_indices = []
            for idx in indices:
                new_idx = old_to_new_indices.get(idx, None)
                if new_idx is not None:
                    new_indices.append(new_idx)
            if new_indices:
                new_basis.append((basis, new_indices))
        op._basis = new_basis
        return op

    def commute_with(self, other):
        """"""Commutes with""""""
        return check_commutativity(self, other)

    def anticommute_with(self, other):
        """"""Anti commutes with""""""
        return check_commutativity(self, other, anti=True)

    def is_empty(self):
        """"""
        Check Operator is empty or not.

        Returns:
            bool: True if empty, False otherwise
        """"""
        if not self._paulis:
            return True
        elif not self._paulis[0]:
            return True
        else:
            return False

    @classmethod
    def from_file(cls, file_name, before_04=False):
        """"""
        Load paulis in a file to construct an Operator.

        Args:
            file_name (str): path to the file, which contains a list of Paulis and coefficients.
            before_04 (bool): support the format before Aqua 0.4.

        Returns:
            WeightedPauliOperator: the loaded operator.
        """"""
        with open(file_name, ""r"", encoding=""UTF-8"") as file:
            return cls.from_dict(json.load(file), before_04=before_04)

    def to_file(self, file_name):
        """"""
        Save operator to a file in pauli representation.

        Args:
            file_name (str): path to the file

        """"""
        with open(file_name, ""w"", encoding=""UTF-8"") as file:
            json.dump(self.to_dict(), file)

    @classmethod
    def from_dict(cls, dictionary, before_04=False):
        """"""
        Load paulis from a dictionary to construct an Operator. The dictionary must
        comprise the key 'paulis' having a value which is an array of pauli dicts.
        Each dict in this array must be represented by label and coeff (real and imag)
        such as in the following example:

        .. code-block:: python

           {'paulis':
               [
                   {'label': 'IIII',
                    'coeff': {'real': -0.33562957575267038, 'imag': 0.0}},
                   {'label': 'ZIII',
                    'coeff': {'real': 0.28220597164664896, 'imag': 0.0}},
                    ...
               ]
            }

        Args:
            dictionary (dict): dictionary, which contains a list of Paulis and coefficients.
            before_04 (bool): support the format before Aqua 0.4.

        Returns:
            WeightedPauliOperator: the operator created from the input dictionary.

        Raises:
            AlgorithmError: Invalid dictionary
        """"""
        if ""paulis"" not in dictionary:
            raise AlgorithmError('Dictionary missing ""paulis"" key')

        paulis = []
        for op in dictionary[""paulis""]:
            if ""label"" not in op:
                raise AlgorithmError('Dictionary missing ""label"" key')

            pauli_label = op[""label""]
            if ""coeff"" not in op:
                raise AlgorithmError('Dictionary missing ""coeff"" key')

            pauli_coeff = op[""coeff""]
            if ""real"" not in pauli_coeff:
                raise AlgorithmError('Dictionary missing ""real"" key')

            coeff = pauli_coeff[""real""]
            if ""imag"" in pauli_coeff:
                coeff = complex(pauli_coeff[""real""], pauli_coeff[""imag""])

            pauli_label = pauli_label[::-1] if before_04 else pauli_label
            paulis.append([coeff, Pauli(pauli_label)])

        return cls(paulis=paulis)

    def to_dict(self):
        """"""
        Save operator to a dict in pauli representation.

        Returns:
            dict: a dictionary contains an operator with pauli representation.
        """"""
        ret_dict = {""paulis"": []}
        for coeff, pauli in self._paulis:
            op = {""label"": pauli.to_label()}
            if isinstance(coeff, complex):
                op[""coeff""] = {""real"": np.real(coeff), ""imag"": np.imag(coeff)}
            else:
                op[""coeff""] = {""real"": coeff}

            ret_dict[""paulis""].append(op)

        return ret_dict

    # pylint: disable=arguments-differ
    def construct_evaluation_circuit(
        self,
        wave_function,
        statevector_mode,
        qr=None,
        cr=None,
        use_simulator_snapshot_mode=False,
        circuit_name_prefix="""",
    ):
        r""""""
        Construct the circuits for evaluation, which calculating the expectation <psi\|H\|psi>.

        At statevector mode: to simplify the computation, we do not build the whole
        circuit for <psi|H|psi>, instead of
        that we construct an individual circuit <psi\|, and a bundle circuit for H\|psi>

        Args:
            wave_function (QuantumCircuit): the quantum circuit.
            statevector_mode (bool): indicate which type of simulator are going to use.
            qr (QuantumRegister, optional): the quantum register associated with the input_circuit
            cr (ClassicalRegister, optional): the classical register associated
                                              with the input_circuit
            use_simulator_snapshot_mode (bool, optional): if aer_provider is used, we can do faster
                                                          evaluation for pauli mode on
                                                          statevector simulation
            circuit_name_prefix (str, optional): a prefix of circuit name

        Returns:
            list[QuantumCircuit]: a list of quantum circuits and each circuit with a unique name:
                                  circuit_name_prefix + Pauli string

        Raises:
            AlgorithmError: if Operator is empty
            AlgorithmError: if quantum register is not provided explicitly and
                       cannot find quantum register with `q` as the name
            AlgorithmError: The provided qreg is not in the wave_function
        """"""
        if self.is_empty():
            raise AlgorithmError(""Operator is empty, check the operator."")
        # pylint: disable=import-outside-toplevel
        from qiskit.utils.run_circuits import find_regs_by_name

        if qr is None:
            qr = find_regs_by_name(wave_function, ""q"")
            if qr is None:
                raise AlgorithmError(
                    ""Either provide the quantum register ""
                    ""(qreg) explicitly or use `q` as the name ""
                    ""of the quantum register in the input circuit.""
                )
        else:
            if not wave_function.has_register(qr):
                raise AlgorithmError(
                    ""The provided QuantumRegister (qreg) is not in the circuit.""
                )

        n_qubits = self.num_qubits
        instructions = self.evaluation_instruction(
            statevector_mode, use_simulator_snapshot_mode
        )
        circuits = []
        if use_simulator_snapshot_mode:
            circuit = wave_function.copy(name=circuit_name_prefix + ""snapshot_mode"")
            # Add expectation value snapshot instruction
            instr = instructions.get(""expval_snapshot"", None)
            if instr is not None:
                circuit.append(instr, qr)
            circuits.append(circuit)
        elif statevector_mode:
            circuits.append(wave_function.copy(name=circuit_name_prefix + ""psi""))
            for _, pauli in self._paulis:
                inst = instructions.get(pauli.to_label(), None)
                if inst is not None:
                    circuit = wave_function.copy(
                        name=circuit_name_prefix + pauli.to_label()
                    )
                    circuit.append(inst, qr)
                    circuits.append(circuit)
        else:
            base_circuit = wave_function.copy()
            if cr is not None:
                if not base_circuit.has_register(cr):
                    base_circuit.add_register(cr)
            else:
                cr = find_regs_by_name(base_circuit, ""c"", qreg=False)
                if cr is None:
                    cr = ClassicalRegister(n_qubits, name=""c"")
                    base_circuit.add_register(cr)

            for basis, _ in self._basis:
                circuit = base_circuit.copy(name=circuit_name_prefix + basis.to_label())
                circuit.append(instructions[basis.to_label()], qargs=qr, cargs=cr)
                circuits.append(circuit)

        return circuits

    def evaluation_instruction(
        self, statevector_mode, use_simulator_snapshot_mode=False
    ):
        """"""
        Args:
            statevector_mode (bool): will it be run on statevector simulator or not
            use_simulator_snapshot_mode (bool): will it use qiskit aer simulator operator mode

        Returns:
            dict: Pauli-instruction pair.

        Raises:
            AlgorithmError: if Operator is empty
            MissingOptionalLibraryError: qiskit-aer not installed
        """"""
        if self.is_empty():
            raise AlgorithmError(""Operator is empty, check the operator."")
        instructions = {}
        qr = QuantumRegister(self.num_qubits)
        qc = QuantumCircuit(qr)
        if statevector_mode:
            for _, pauli in self._paulis:
                tmp_qc = qc.copy(name=""Pauli "" + pauli.to_label())
                if np.all(np.logical_not(pauli.z)) and np.all(
                    np.logical_not(pauli.x)
                ):  # all I
                    continue
                # This explicit barrier is needed for statevector simulator since Qiskit-terra
                # will remove global phase at default compilation level but the results here
                # rely on global phase.
                tmp_qc.barrier(list(range(self.num_qubits)))
                tmp_qc.append(pauli.to_instruction(), list(range(self.num_qubits)))
                instructions[pauli.to_label()] = tmp_qc.to_instruction()
        else:
            cr = ClassicalRegister(self.num_qubits)
            qc.add_register(cr)
            for basis, _ in self._basis:
                tmp_qc = qc.copy(name=""Pauli "" + basis.to_label())
                tmp_qc = pauli_measurement(tmp_qc, basis, qr, cr, barrier=True)
                instructions[basis.to_label()] = tmp_qc.to_instruction()
        return instructions

    # pylint: disable=arguments-differ
    def evaluate_with_result(
        self,
        result,
        statevector_mode,
        use_simulator_snapshot_mode=False,
        circuit_name_prefix="""",
    ):
        """"""
        This method can be only used with the circuits generated by the
        :meth:`construct_evaluation_circuit` method with the same `circuit_name_prefix`
        name since the circuit names are tied to some meanings.

        Calculate the evaluated value with the measurement results.

        Args:
            result (qiskit.Result): the result from the backend.
            statevector_mode (bool): indicate which type of simulator are used.
            use_simulator_snapshot_mode (bool): if aer_provider is used, we can do faster
                                                evaluation for pauli mode on
                                                statevector simulation
            circuit_name_prefix (str): a prefix of circuit name

        Returns:
            float: the mean value
            float: the standard deviation

        Raises:
            AlgorithmError: if Operator is empty
        """"""
        if self.is_empty():
            raise AlgorithmError(""Operator is empty, check the operator."")

        avg, std_dev, variance = 0.0, 0.0, 0.0
        if use_simulator_snapshot_mode:
            snapshot_data = result.data(circuit_name_prefix + ""snapshot_mode"")[
                ""snapshots""
            ]
            avg = snapshot_data[""expectation_value""][""expval""][0][""value""]
            if isinstance(avg, (list, tuple)):
                # Aer versions before 0.4 use a list snapshot format
                # which must be converted to a complex value.
                avg = avg[0] + 1j * avg[1]
        elif statevector_mode:
            quantum_state = np.asarray(
                result.get_statevector(circuit_name_prefix + ""psi"")
            )
            for weight, pauli in self._paulis:
                # all I
                if np.all(np.logical_not(pauli.z)) and np.all(np.logical_not(pauli.x)):
                    avg += weight
                else:
                    quantum_state_i = result.get_statevector(
                        circuit_name_prefix + pauli.to_label()
                    )
                    avg += weight * (np.vdot(quantum_state, quantum_state_i))
        else:
            if logger.isEnabledFor(logging.DEBUG):
                logger.debug(""Computing the expectation from measurement results:"")
                TextProgressBar(sys.stderr)
            # pick the first result to get the total number of shots
            num_shots = sum(list(result.get_counts(0).values()))
            results = parallel_map(
                WeightedPauliOperator._routine_compute_mean_and_var,
                [
                    (
                        [self._paulis[idx] for idx in indices],
                        result.get_counts(circuit_name_prefix + basis.to_label()),
                    )
                    for basis, indices in self._basis
                ],
                num_processes=algorithm_globals.num_processes,
            )
            for res in results:
                avg += res[0]
                variance += res[1]
            std_dev = np.sqrt(variance / num_shots)
        return avg, std_dev

    @staticmethod
    def _routine_compute_mean_and_var(args):
        paulis, measured_results = args
        avg_paulis = []
        avg = 0.0
        variance = 0.0
        for weight, pauli in paulis:
            observable = measure_pauli_z(measured_results, pauli)
            avg += weight * observable
            avg_paulis.append(observable)

        for idx_1, weighted_pauli_1 in enumerate(paulis):
            weight_1, pauli_1 = weighted_pauli_1
            for idx_2, weighted_pauli_2 in enumerate(paulis):
                weight_2, pauli_2 = weighted_pauli_2
                variance += (
                    weight_1
                    * weight_2
                    * covariance(
                        measured_results,
                        pauli_1,
                        pauli_2,
                        avg_paulis[idx_1],
                        avg_paulis[idx_2],
                    )
                )

        return avg, variance

    def reorder_paulis(self) -> List[List[Union[complex, Pauli]]]:
        """"""
        Reorder the paulis based on the basis and return the reordered paulis.

        Returns:
            the ordered paulis based on the basis.
        """"""

        # if each pauli belongs to its group, no reordering it needed.
        if len(self._basis) == len(self._paulis):
            return self._paulis

        paulis = []
        new_basis = []
        curr_count = 0
        for basis, indices in self._basis:
            sub_paulis = []
            for idx in indices:
                sub_paulis.append(self._paulis[idx])
            new_basis.append((basis, range(curr_count, curr_count + len(sub_paulis))))
            paulis.extend(sub_paulis)
            curr_count += len(sub_paulis)

        self._paulis = paulis
        self._basis = new_basis

        return self._paulis

    # pylint: disable=arguments-differ
    def evolve(
        self,
        state_in=None,
        evo_time=0,
        num_time_slices=1,
        quantum_registers=None,
        expansion_mode=""trotter"",
        expansion_order=1,
    ):
        """"""
        Carry out the eoh evolution for the operator under supplied specifications.

        Args:
            state_in (QuantumCircuit): a circuit describes the input state
            evo_time (Union(complex, float, Parameter, ParameterExpression)): The evolution time
            num_time_slices (int): The number of time slices for the expansion
            quantum_registers (QuantumRegister): The QuantumRegister to build
                                                 the QuantumCircuit off of
            expansion_mode (str): The mode under which the expansion is to be done.
                Currently support 'trotter', which follows the expansion as discussed in
                http://science.sciencemag.org/content/273/5278/1073,
                and 'suzuki', which corresponds to the discussion in
                https://arxiv.org/pdf/quant-ph/0508139.pdf
            expansion_order (int): The order for suzuki expansion

        Returns:
            QuantumCircuit: The constructed circuit.

        Raises:
            AlgorithmError: quantum_registers must be in the provided state_in circuit
            AlgorithmError: if operator is empty
        """"""
        if self.is_empty():
            raise AlgorithmError(""Operator is empty, can not evolve."")

        if state_in is not None and quantum_registers is not None:
            if not state_in.has_register(quantum_registers):
                raise AlgorithmError(
                    ""quantum_registers must be in the provided state_in circuit.""
                )
        elif state_in is None and quantum_registers is None:
            quantum_registers = QuantumRegister(self.num_qubits)
            qc = QuantumCircuit(quantum_registers)
        elif state_in is not None and quantum_registers is None:
            # assuming the first register is for evolve
            quantum_registers = state_in.qregs[0]
            qc = QuantumCircuit() + state_in
        else:
            qc = QuantumCircuit(quantum_registers)

        instruction = self.evolve_instruction(
            evo_time, num_time_slices, expansion_mode, expansion_order
        )
        qc.append(instruction, quantum_registers)
        return qc

    def evolve_instruction(
        self, evo_time=0, num_time_slices=1, expansion_mode=""trotter"", expansion_order=1
    ):
        """"""
        Carry out the eoh evolution for the operator under supplied specifications.

        Args:
            evo_time (Union(complex, float, Parameter, ParameterExpression)): The evolution time
            num_time_slices (int): The number of time slices for the expansion
            expansion_mode (str): The mode under which the expansion is to be done.
                Currently support 'trotter', which follows the expansion as discussed in
                http://science.sciencemag.org/content/273/5278/1073,
                and 'suzuki', which corresponds to the discussion in
                https://arxiv.org/pdf/quant-ph/0508139.pdf
            expansion_order (int): The order for suzuki expansion

        Returns:
            QuantumCircuit: The constructed QuantumCircuit.

        Raises:
            ValueError: Number of time slices should be a non-negative integer
            NotImplementedError: expansion mode not supported
            AlgorithmError: if operator is empty
        """"""
        if self.is_empty():
            raise AlgorithmError(""Operator is empty, can not build evolve instruction."")
        # pylint: disable=no-member
        if num_time_slices <= 0 or not isinstance(num_time_slices, int):
            raise ValueError(""Number of time slices should be a non-negative integer."")
        if expansion_mode not in [""trotter"", ""suzuki""]:
            raise NotImplementedError(f""Expansion mode {expansion_mode} not supported."")

        pauli_list = self.reorder_paulis()

        if len(pauli_list) == 1:
            slice_pauli_list = pauli_list
        else:
            if expansion_mode == ""trotter"":
                slice_pauli_list = pauli_list
            # suzuki expansion
            else:
                slice_pauli_list = suzuki_expansion_slice_pauli_list(
                    pauli_list, 1, expansion_order
                )
        instruction = evolution_instruction(slice_pauli_list, evo_time, num_time_slices)
        return instruction


class Z2Symmetries:
    """"""Z2 Symmetries""""""

    def __init__(self, symmetries, sq_paulis, sq_list, tapering_values=None):
        """"""
        Args:
            symmetries (list[Pauli]): the list of Pauli objects representing the Z_2 symmetries
            sq_paulis (list[Pauli]): the list of single - qubit Pauli objects to construct the
                                     Clifford operators
            sq_list (list[int]): the list of support of the single-qubit Pauli objects used to build
                                 the Clifford operators
            tapering_values (list[int], optional): values determines the sector.

        Raises:
            AlgorithmError: Invalid paulis
        """"""
        if len(symmetries) != len(sq_paulis):
            raise AlgorithmError(
                ""Number of Z2 symmetries has to be the same as number ""
                ""of single-qubit pauli x.""
            )

        if len(sq_paulis) != len(sq_list):
            raise AlgorithmError(
                ""Number of single-qubit pauli x has to be the same ""
                ""as length of single-qubit list.""
            )

        if tapering_values is not None:
            if len(sq_list) != len(tapering_values):
                raise AlgorithmError(
                    ""The length of single-qubit list has ""
                    ""to be the same as length of tapering values.""
                )

        self._symmetries = symmetries
        self._sq_paulis = sq_paulis
        self._sq_list = sq_list
        self._tapering_values = tapering_values

    @property
    def symmetries(self):
        """"""return symmetries""""""
        return self._symmetries

    @property
    def sq_paulis(self):
        """"""returns sq paulis""""""
        return self._sq_paulis

    @property
    def cliffords(self):
        """"""
        Get clifford operators, build based on symmetries and single-qubit X.

        Returns:
            list[WeightedPauliOperator]: a list of unitaries used to diagonalize the Hamiltonian.
        """"""
        cliffords = [
            WeightedPauliOperator(
                paulis=[[1 / np.sqrt(2), pauli_symm], [1 / np.sqrt(2), sq_pauli]]
            )
            for pauli_symm, sq_pauli in zip(self._symmetries, self._sq_paulis)
        ]
        return cliffords

    @property
    def sq_list(self):
        """"""returns sq list""""""
        return self._sq_list

    @property
    def tapering_values(self):
        """"""returns tapering values""""""
        return self._tapering_values

    @tapering_values.setter
    def tapering_values(self, new_value):
        """"""set tapering values""""""
        self._tapering_values = new_value

    def __str__(self):
        ret = [""Z2 symmetries:""]
        ret.append(""Symmetries:"")
        for symmetry in self._symmetries:
            ret.append(symmetry.to_label())
        ret.append(""Single-Qubit Pauli X:"")
        for x in self._sq_paulis:
            ret.append(x.to_label())
        ret.append(""Cliffords:"")
        for c in self.cliffords:
            ret.append(c.print_details())
        ret.append(""Qubit index:"")
        ret.append(str(self._sq_list))
        ret.append(""Tapering values:"")
        if self._tapering_values is None:
            possible_values = [
                str(list(coeff))
                for coeff in itertools.product([1, -1], repeat=len(self._sq_list))
            ]
            possible_values = "", "".join(x for x in possible_values)
            ret.append(""  - Possible values: "" + possible_values)
        else:
            ret.append(str(self._tapering_values))

        ret = ""\n"".join(ret)
        return ret

    def copy(self) -> ""Z2Symmetries"":
        """"""
        Get a copy of self.

        Returns:
            copy
        """"""
        return deepcopy(self)

    def is_empty(self):
        """"""
        Check the z2_symmetries is empty or not.

        Returns:
            bool: empty
        """"""
        if self._symmetries != [] and self._sq_paulis != [] and self._sq_list != []:
            return False
        else:
            return True

    def taper(self, operator, tapering_values=None):
        """"""
        Taper an operator based on the z2_symmetries info and sector defined by `tapering_values`.
        The `tapering_values` will be stored into the resulted operator for a record.

        Args:
            operator (WeightedPauliOperator): the to-be-tapered operator.
            tapering_values (list[int], optional): if None, returns operators at each sector;
                                                   otherwise, returns
                                                   the operator located in that sector.
        Returns:
            list[WeightedPauliOperator] or WeightedPauliOperator: If
                tapering_values is None: [:class`WeightedPauliOperator`];
                otherwise, :class:`WeightedPauliOperator`

        Raises:
            AlgorithmError: Z2 symmetries, single qubit pauli and single qubit list cannot be empty
        """"""
        if not self._symmetries or not self._sq_paulis or not self._sq_list:
            raise AlgorithmError(
                ""Z2 symmetries, single qubit pauli and ""
                ""single qubit list cannot be empty.""
            )

        if operator.is_empty():
            logger.warning(""The operator is empty, return the empty operator directly."")
            return operator

        for clifford in self.cliffords:
            operator = clifford * operator * clifford

        tapering_values = (
            tapering_values if tapering_values is not None else self._tapering_values
        )

        def _taper(op, curr_tapering_values):
            z2_symmetries = self.copy()
            z2_symmetries.tapering_values = curr_tapering_values
            operator_out = WeightedPauliOperator(
                paulis=[], z2_symmetries=z2_symmetries, name=operator.name
            )
            for pauli_term in op.paulis:
                coeff_out = pauli_term[0]
                for idx, qubit_idx in enumerate(self._sq_list):
                    if not (
                        not pauli_term[1].z[qubit_idx]
                        and not pauli_term[1].x[qubit_idx]
                    ):
                        coeff_out = curr_tapering_values[idx] * coeff_out
                z_temp = np.delete(pauli_term[1].z.copy(), np.asarray(self._sq_list))
                x_temp = np.delete(pauli_term[1].x.copy(), np.asarray(self._sq_list))
                pauli_term_out = WeightedPauliOperator(
                    paulis=[[coeff_out, Pauli((z_temp, x_temp))]]
                )
                operator_out += pauli_term_out
            operator_out.chop(0.0)
            return operator_out

        if tapering_values is None:
            tapered_ops = []
            for coeff in itertools.product([1, -1], repeat=len(self._sq_list)):
                tapered_ops.append(_taper(operator, list(coeff)))
        else:
            tapered_ops = _taper(operator, tapering_values)

        return tapered_ops

    @staticmethod
    def two_qubit_reduction(operator, num_particles):
        """"""
        Eliminates the central and last qubit in a list of Pauli that has
        diagonal operators (Z,I) at those positions

        Chemistry specific method:
        It can be used to taper two qubits in parity and binary-tree mapped
        fermionic Hamiltonians when the spin orbitals are ordered in two spin
        sectors, (block spin order) according to the number of particles in the system.

        Args:
            operator (WeightedPauliOperator): the operator
            num_particles (Union(list, int)): number of particles, if it is a list,
                                              the first number is alpha
                                              and the second number if beta.

        Returns:
            WeightedPauliOperator: a new operator whose qubit number is reduced by 2.

        """"""
        if operator.is_empty():
            logger.info(
                ""Operator is empty, can not do two qubit reduction. ""
                ""Return the empty operator back.""
            )
            return operator

        if isinstance(num_particles, (tuple, list)):
            num_alpha = num_particles[0]
            num_beta = num_particles[1]
        else:
            num_alpha = num_particles // 2
            num_beta = num_particles // 2

        par_1 = 1 if (num_alpha + num_beta) % 2 == 0 else -1
        par_2 = 1 if num_alpha % 2 == 0 else -1
        tapering_values = [par_2, par_1]

        num_qubits = operator.num_qubits
        last_idx = num_qubits - 1
        mid_idx = num_qubits // 2 - 1
        sq_list = [mid_idx, last_idx]

        # build symmetries, sq_paulis:
        symmetries, sq_paulis = [], []
        for idx in sq_list:
            pauli_str = [""I""] * num_qubits

            pauli_str[idx] = ""Z""
            z_sym = Pauli("""".join(pauli_str)[::-1])
            symmetries.append(z_sym)

            pauli_str[idx] = ""X""
            sq_pauli = Pauli("""".join(pauli_str)[::-1])
            sq_paulis.append(sq_pauli)

        z2_symmetries = Z2Symmetries(symmetries, sq_paulis, sq_list, tapering_values)
        return z2_symmetries.taper(operator)

    def consistent_tapering(self, operator):
        """"""
        Tapering the `operator` with the same manner of how this tapered operator
        is created. i.e., using the same Cliffords and tapering values.

        Args:
            operator (WeightedPauliOperator): the to-be-tapered operator

        Returns:
            TaperedWeightedPauliOperator: the tapered operator

        Raises:
            AlgorithmError: The given operator does not commute with the symmetry
        """"""
        if operator.is_empty():
            raise AlgorithmError(""Can not taper an empty operator."")

        for symmetry in self._symmetries:
            if not operator.commute_with(symmetry):
                raise AlgorithmError(
                    ""The given operator does not commute with ""
                    ""the symmetry, can not taper it.""
                )

        return self.taper(operator)
"
https://github.com/qiskit-community/prototype-entanglement-forging,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Integration tests for EntanglementForgedVQE module.""""""
# pylint: disable=wrong-import-position
import unittest
import os

import numpy as np
from qiskit import BasicAer
from qiskit.circuit import Parameter, QuantumCircuit
from qiskit.circuit.library import TwoLocal
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.drivers import Molecule
from qiskit_nature.drivers.second_quantization import PySCFDriver
from qiskit_nature.mappers.second_quantization import JordanWignerMapper
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
from qiskit_nature.algorithms.ground_state_solvers import (
    GroundStateEigensolver,
    NumPyMinimumEigensolverFactory,
)
from qiskit_nature.transformers.second_quantization.electronic.active_space_transformer import (
    ActiveSpaceTransformer,
)
from qiskit_nature import settings

settings.dict_aux_operators = True

from entanglement_forging import reduce_bitstrings
from entanglement_forging import (
    EntanglementForgedConfig,
    EntanglementForgedDriver,
    EntanglementForgedGroundStateSolver,
)


class TestEntanglementForgedGroundStateEigensolver(unittest.TestCase):
    """"""EntanglementForgedGroundStateEigensolver tests.""""""

    def setUp(self):
        np.random.seed(42)
        self.backend = BasicAer.get_backend(""statevector_simulator"")
        self.config = EntanglementForgedConfig(
            backend=self.backend,
            maxiter=0,
            initial_params=[0.0],
            optimizer_name=""COBYLA"",
        )

        # TS
        self.mock_ts_ansatz = self.create_mock_ansatz(4)
        self.hcore_ts = np.load(
            os.path.join(os.path.dirname(__file__), ""test_data"", ""TS_one_body.npy"")
        )
        self.eri_ts = np.load(
            os.path.join(os.path.dirname(__file__), ""test_data"", ""TS_two_body.npy"")
        )
        self.energy_shift_ts = -264.7518219120776

        # O2
        self.mock_o2_ansatz = self.create_mock_ansatz(8)
        self.hcore_o2 = np.load(
            os.path.join(os.path.dirname(__file__), ""test_data"", ""O2_one_body.npy"")
        )
        self.eri_o2 = np.load(
            os.path.join(os.path.dirname(__file__), ""test_data"", ""O2_two_body.npy"")
        )
        self.energy_shift_o2 = -99.83894101027317

        # CH3
        self.mock_ch3_ansatz = self.create_mock_ansatz(6)
        self.hcore_ch3 = np.load(
            os.path.join(os.path.dirname(__file__), ""test_data"", ""CH3_one_body.npy"")
        )
        self.eri_ch3 = np.load(
            os.path.join(os.path.dirname(__file__), ""test_data"", ""CH3_two_body.npy"")
        )
        self.energy_shift_ch3 = -31.90914780401554

    def create_mock_ansatz(self, num_qubits):
        n_theta = 1
        theta = Parameter(""θ"")
        mock_gate = QuantumCircuit(1, name=""mock gate"")
        mock_gate.rz(theta, 0)

        theta_vec = [Parameter(""θ%d"" % i) for i in range(1)]
        ansatz = QuantumCircuit(num_qubits)
        ansatz.append(mock_gate.to_gate({theta: theta_vec[0]}), [0])

        return ansatz

    def test_forged_vqe_H2(self):
        """"""Test of applying Entanglement Forged VQE to to compute the energy of a H2 molecule.""""""
        # setup problem
        molecule = Molecule(
            geometry=[(""H"", [0.0, 0.0, 0.0]), (""H"", [0.0, 0.0, 0.735])],
            charge=0,
            multiplicity=1,
        )
        driver = PySCFDriver.from_molecule(molecule)
        problem = ElectronicStructureProblem(driver)
        problem.second_q_ops()

        # solution
        bitstrings = [[1, 0], [0, 1]]
        ansatz = TwoLocal(2, [], ""cry"", [[0, 1], [1, 0]], reps=1)

        config = EntanglementForgedConfig(
            backend=self.backend, maxiter=0, initial_params=[0, 0.5 * np.pi]
        )

        converter = QubitConverter(JordanWignerMapper())

        forged_ground_state_solver = EntanglementForgedGroundStateSolver(
            converter, ansatz, bitstrings, config
        )

        forged_result = forged_ground_state_solver.solve(problem)

        self.assertAlmostEqual(forged_result.ground_state_energy, -1.1219365445030705)

    def test_forged_vqe_H2O(self):  # pylint: disable=too-many-locals
        """"""Test of applying Entanglement Forged VQE to to compute the energy of a H20 molecule.""""""
        # setup problem
        radius_1 = 0.958  # position for the first H atom
        radius_2 = 0.958  # position for the second H atom
        thetas_in_deg = 104.478  # bond angles.

        h1_x = radius_1
        h2_x = radius_2 * np.cos(np.pi / 180 * thetas_in_deg)
        h2_y = radius_2 * np.sin(np.pi / 180 * thetas_in_deg)

        molecule = Molecule(
            geometry=[
                (""O"", [0.0, 0.0, 0.0]),
                (""H"", [h1_x, 0.0, 0.0]),
                (""H"", [h2_x, h2_y, 0.0]),
            ],
            charge=0,
            multiplicity=1,
        )
        driver = PySCFDriver.from_molecule(molecule, basis=""sto6g"")
        problem = ElectronicStructureProblem(driver)
        problem.second_q_ops()

        # solution
        orbitals_to_reduce = [0, 3]
        bitstrings = [
            [1, 1, 1, 1, 1, 0, 0],
            [1, 0, 1, 1, 1, 0, 1],
            [1, 0, 1, 1, 1, 1, 0],
        ]
        reduced_bitstrings = reduce_bitstrings(bitstrings, orbitals_to_reduce)

        theta = Parameter(""θ"")
        theta_1, theta_2, theta_3, theta_4 = (
            Parameter(""θ1""),
            Parameter(""θ2""),
            Parameter(""θ3""),
            Parameter(""θ4""),
        )

        hop_gate = QuantumCircuit(2, name=""Hop gate"")
        hop_gate.h(0)
        hop_gate.cx(1, 0)
        hop_gate.cx(0, 1)
        hop_gate.ry(-theta, 0)
        hop_gate.ry(-theta, 1)
        hop_gate.cx(0, 1)
        hop_gate.h(0)

        ansatz = QuantumCircuit(5)
        ansatz.append(hop_gate.to_gate({theta: theta_1}), [0, 1])
        ansatz.append(hop_gate.to_gate({theta: theta_2}), [3, 4])
        ansatz.append(hop_gate.to_gate({theta: 0}), [1, 4])
        ansatz.append(hop_gate.to_gate({theta: theta_3}), [0, 2])
        ansatz.append(hop_gate.to_gate({theta: theta_4}), [3, 4])

        config = EntanglementForgedConfig(
            backend=self.backend,
            maxiter=0,
            spsa_c0=20 * np.pi,
            initial_params=[0, 0, 0, 0],
        )

        converter = QubitConverter(JordanWignerMapper())

        solver = EntanglementForgedGroundStateSolver(
            converter,
            ansatz,
            reduced_bitstrings,
            config,
            orbitals_to_reduce=orbitals_to_reduce,
        )
        forged_result = solver.solve(problem)
        self.assertAlmostEqual(forged_result.ground_state_energy, -75.68366174497027)

    def test_ef_driver(self):
        """"""Test for entanglement forging driver.""""""
        hcore = np.array([[-1.12421758, -0.9652574], [-0.9652574, -1.12421758]])
        mo_coeff = np.array([[0.54830202, 1.21832731], [0.54830202, -1.21832731]])
        eri = np.array(
            [
                [
                    [[0.77460594, 0.44744572], [0.44744572, 0.57187698]],
                    [[0.44744572, 0.3009177], [0.3009177, 0.44744572]],
                ],
                [
                    [[0.44744572, 0.3009177], [0.3009177, 0.44744572]],
                    [[0.57187698, 0.44744572], [0.44744572, 0.77460594]],
                ],
            ]
        )

        driver = EntanglementForgedDriver(
            hcore=hcore,
            mo_coeff=mo_coeff,
            eri=eri,
            num_alpha=1,
            num_beta=1,
            nuclear_repulsion_energy=0.7199689944489797,
        )
        problem = ElectronicStructureProblem(driver)
        problem.second_q_ops()

        bitstrings = [[1, 0], [0, 1]]
        ansatz = TwoLocal(2, [], ""cry"", [[0, 1], [1, 0]], reps=1)

        config = EntanglementForgedConfig(
            backend=self.backend, maxiter=0, initial_params=[0, 0.5 * np.pi]
        )
        converter = QubitConverter(JordanWignerMapper())
        forged_ground_state_solver = EntanglementForgedGroundStateSolver(
            converter, ansatz, bitstrings, config
        )
        forged_result = forged_ground_state_solver.solve(problem)
        self.assertAlmostEqual(forged_result.ground_state_energy, -1.1219365445030705)

    def test_ground_state_eigensolver_with_ef_driver(self):
        """"""Tests standard qiskit nature solver.""""""
        hcore = np.array([[-1.12421758, -0.9652574], [-0.9652574, -1.12421758]])
        mo_coeff = np.array([[0.54830202, 1.21832731], [0.54830202, -1.21832731]])
        eri = np.array(
            [
                [
                    [[0.77460594, 0.44744572], [0.44744572, 0.57187698]],
                    [[0.44744572, 0.3009177], [0.3009177, 0.44744572]],
                ],
                [
                    [[0.44744572, 0.3009177], [0.3009177, 0.44744572]],
                    [[0.57187698, 0.44744572], [0.44744572, 0.77460594]],
                ],
            ]
        )

        repulsion_energy = 0.7199689944489797
        driver = EntanglementForgedDriver(
            hcore=hcore,
            mo_coeff=mo_coeff,
            eri=eri,
            num_alpha=1,
            num_beta=1,
            nuclear_repulsion_energy=repulsion_energy,
        )
        problem = ElectronicStructureProblem(driver)
        problem.second_q_ops()

        converter = QubitConverter(JordanWignerMapper())
        solver = GroundStateEigensolver(
            converter,
            NumPyMinimumEigensolverFactory(use_default_filter_criterion=False),
        )
        result = solver.solve(problem)
        self.assertAlmostEqual(
            -1.137306026563, np.real(result.eigenenergies[0]) + repulsion_energy
        )

    def test_O2_1(self):
        driver = EntanglementForgedDriver(
            hcore=self.hcore_o2,
            mo_coeff=np.eye(8, 8),
            eri=self.eri_o2,
            num_alpha=6,
            num_beta=6,
            nuclear_repulsion_energy=self.energy_shift_o2,
        )
        problem = ElectronicStructureProblem(driver)
        problem.second_q_ops()

        converter = QubitConverter(JordanWignerMapper())

        bitstrings_u = [
            [1, 1, 1, 1, 1, 1, 0, 0],
            [1, 1, 1, 1, 1, 0, 1, 0],
            [1, 1, 1, 1, 0, 1, 1, 0],
            [1, 1, 0, 1, 1, 1, 1, 0],
        ]
        bitstrings_v = [
            [1, 1, 1, 1, 1, 0, 1, 0],
            [1, 1, 1, 1, 1, 1, 0, 0],
            [1, 1, 0, 1, 1, 1, 1, 0],
            [1, 1, 1, 1, 0, 1, 1, 0],
        ]

        calc = EntanglementForgedGroundStateSolver(
            converter,
            self.mock_o2_ansatz,
            bitstrings_u=bitstrings_u,
            bitstrings_v=bitstrings_v,
            config=self.config,
            orbitals_to_reduce=[],
        )
        res = calc.solve(problem)
        self.assertAlmostEqual(-147.63645235088566, res.ground_state_energy)

    def test_CH3(self):
        driver = EntanglementForgedDriver(
            hcore=self.hcore_ch3,
            mo_coeff=np.eye(6, 6),
            eri=self.eri_ch3,
            num_alpha=3,
            num_beta=2,
            nuclear_repulsion_energy=self.energy_shift_ch3,
        )

        problem = ElectronicStructureProblem(driver)
        problem.second_q_ops()

        converter = QubitConverter(JordanWignerMapper())

        bitstrings_u = [
            [1, 1, 1, 0, 0, 0],
            [0, 1, 1, 0, 0, 1],
            [1, 0, 1, 0, 1, 0],
            [1, 0, 1, 1, 0, 0],
            [0, 1, 1, 1, 0, 0],
        ]
        bitstrings_v = [
            [1, 1, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 1],
            [1, 0, 0, 0, 1, 0],
            [1, 0, 0, 1, 0, 0],
            [0, 1, 0, 1, 0, 0],
        ]

        calc = EntanglementForgedGroundStateSolver(
            converter,
            self.mock_ch3_ansatz,
            bitstrings_u=bitstrings_u,
            bitstrings_v=bitstrings_v,
            config=self.config,
            orbitals_to_reduce=[],
        )
        res = calc.solve(problem)
        self.assertAlmostEqual(-39.09031477502881, res.ground_state_energy)
"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"import subprocess

def python_commands(commands):
    try:
        result = subprocess.run(
            ['python', '-c', commands], check=True, capture_output=True, encoding='utf8'
        )
    except subprocess.CalledProcessError as err:
        return err
    return result


def basic_inits():
    all_coms = []
    for _compile in (""False"", ""True""):
        for calljulia in (""pyjulia"", ""juliacall""):
            for depot in (""False"", ""True""):
                args = f""compile={_compile}, calljulia='{calljulia}', depot={depot}""
                coms = f""import qiskit_alt; qiskit_alt.project.ensure_init({args})""
                all_coms.append(coms)
                if calljulia == ""pyjulia"":
                    other_calljulia = ""juliacall""
                else:
                    other_calljulia = ""pyjulia""
                args = f""compile={_compile}, calljulia='{other_calljulia}', depot={depot}""
                coms = f""import qiskit_alt; qiskit_alt.project.ensure_init({args}); qiskit_alt.project.clean_all()""
                all_coms.append(coms)
    return all_coms

# def basic_inits():
#     all_coms = [""import sys"", ""import os"", ""import sdsdff"", ""import sdsdff"", ""import shutil""]
#     return all_coms


def run_tests(all_commands=None, verbose=False):
    num_passed = 0
    if all_commands is None:
        all_commands = basic_inits()
    for commands in all_commands:
        print(f""running '{commands}'"")
        result = python_commands(commands)
        if isinstance(result, subprocess.CalledProcessError):
            print(f""**** Commands '{commands}' failed with error code {result}"")
            print(result.stderr)
        else:
            num_passed += 1
            if verbose:
                print(result)
    msg = f""{num_passed} of {len(all_commands)} installation tests passed""
    if num_passed < len(all_commands):
        print(""**** "" + msg)
    else:
        print(msg)


if __name__ == '__main__':
    run_tests()
"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"# Benchmark qiskit_alt constructing Fermionic operators from pyscf integrals.
import qiskit_alt
qiskit_alt.project.ensure_init()

import timeit

def make_setup_code(basis, geometry):
    return f""""""
import qiskit_alt

h2_geometry = [['H', [0., 0., 0.]], ['H', [0., 0., 0.7414]]]

h2o_geometry = [['O', [0., 0., 0.]],
            ['H', [0.757, 0.586, 0.]],
            ['H', [-0.757, 0.586, 0.]]]

from qiskit_alt.electronic_structure import fermionic_hamiltonian
fermionic_hamiltonian({geometry}, {basis})
#qiskit_alt.fermionic_hamiltonian({geometry}, {basis})
""""""

def run_one_basis(basis, geometry, num_repetitions):
    setup_code = make_setup_code(basis, geometry)
    bench_code = f""fermionic_hamiltonian({geometry}, {basis})""
    time = timeit.timeit(stmt=bench_code, setup=setup_code, number=num_repetitions)
    t = 1000 * time / num_repetitions
    print(f""geometry={geometry}, basis={basis} {t:0.2f}"", ""ms"")
    return t


def run_benchmarks():
    alt_times = []

    for basis, geometry, num_repetitions in ((""'sto3g'"", ""h2_geometry"", 10), (""'631g'"", ""h2_geometry"", 10),
                                             (""'631++g'"", ""h2_geometry"", 10),
                                             (""'sto3g'"", ""h2o_geometry"", 10), (""'631g'"", ""h2o_geometry"", 5)):
        t = run_one_basis(basis, geometry, num_repetitions)
        alt_times.append(t)

    return alt_times


if __name__ == '__main__':
    alt_times = run_benchmarks()
"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"# Benchmark qiskit_alt transforming an operator from the computational- to the Pauli basis.
import qiskit_alt
qiskit_alt.project.ensure_init()

import timeit

Main = qiskit_alt.project.julia.Main

def make_setup_code(nqubits):
    return f""""""
import qiskit_alt
from qiskit_alt.pauli_operators import PauliSum_to_SparsePauliOp
QuantumOps = qiskit_alt.project.simple_import(""QuantumOps"")
import numpy as np
Main = qiskit_alt.project.julia.Main

m = np.random.rand(2**{nqubits}, 2**{nqubits})
""""""

def run_one(nqubits, num_repetitions):
    setup_code = make_setup_code(nqubits)
    if qiskit_alt.project._calljulia_name == 'juliacall':
        bench_code = ""PauliSum_to_SparsePauliOp(QuantumOps.PauliSum(Main.convert(Main.Matrix, m)))""
    else:
        bench_code = ""PauliSum_to_SparsePauliOp(QuantumOps.PauliSum(m))""
    time = timeit.timeit(stmt=bench_code, setup=setup_code, number=num_repetitions)
    t = 1000 * time / num_repetitions
    print(f""nqubits={nqubits}, {t:0.2f}"", ""ms"")
    return t


def run_benchmarks():
    qk_alt_times = []

    for nqubits, num_repetitions in ((2, 50), (3, 50), (4, 10), (5, 10), (6, 10),
                                     (7, 10),
                                     (8, 3)):
        t = run_one(nqubits, num_repetitions)
        qk_alt_times.append(t)
    return qk_alt_times


if __name__ == '__main__':
    qk_alt_times = run_benchmarks()
"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"# Benchmark qiskit_alt peforming the Jordan-Wigner transform on a Fermi operator.
import qiskit_alt
qiskit_alt.project.ensure_init()

import timeit

def make_setup_code(basis, geometry):
    return f""""""
import qiskit_alt.electronic_structure

h2_geometry = [['H', [0., 0., 0.]], ['H', [0., 0., 0.7414]]]

h2o_geometry = [['O', [0., 0., 0.]],
            ['H', [0.757, 0.586, 0.]],
            ['H', [-0.757, 0.586, 0.]]]

basis = {basis}
fermi_op = qiskit_alt.electronic_structure.fermionic_hamiltonian({geometry}, basis)
qiskit_alt.electronic_structure.jordan_wigner(fermi_op);
""""""

def run_one_basis(basis, geometry, num_repetitions):
    setup_code = make_setup_code(basis, geometry)
    bench_code = ""qiskit_alt.electronic_structure.jordan_wigner(fermi_op)""
    time = timeit.timeit(stmt=bench_code, setup=setup_code, number=num_repetitions)
    t = 1000 * time / num_repetitions
    print(f""geometry={geometry}, basis={basis} {t:0.2f}"", ""ms"")
    return t


def run_benchmarks():
    alt_times = []

    for basis, geometry, num_repetitions in ((""'sto3g'"", ""h2_geometry"", 10), (""'631g'"", ""h2_geometry"", 10),
                                             (""'631++g'"", ""h2_geometry"", 10),
                                             (""'sto3g'"", ""h2o_geometry"", 10), (""'631g'"", ""h2o_geometry"", 5)):
        t = run_one_basis(basis, geometry, num_repetitions)
        alt_times.append(t)

    return alt_times


if __name__ == '__main__':
    alt_times = run_benchmarks()
"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"# Benchmark qiskit_alt creating a SparsePauliOp from a list of strings.
import sys
import qiskit_alt
qiskit_alt.project.ensure_init()

import random
from timeit import timeit

Main = qiskit_alt.project.julia.Main

QuantumOps = qiskit_alt.project.simple_import(""QuantumOps"")
from qiskit_alt.pauli_operators import PauliSum_to_SparsePauliOp

random.seed(123)

def rand_label(k, n):
    return ["""".join(random.choices(""IXYZ"", k=k)) for _ in range(n)]


def run_benchmarks():
    qkalt_times = []

    for k in (10, 100):
        for n in (10, 100, 1000, 5000, 10_000, 100_000):
            label = rand_label(k, n)
            if qiskit_alt.project._calljulia_name == 'juliacall':
                label = Main.pyconvert_list(Main.String, label)
            PauliSum_to_SparsePauliOp(QuantumOps.PauliSum(label))
            number = 20
            t = timeit(lambda: PauliSum_to_SparsePauliOp(QuantumOps.PauliSum(label)), number=number)
            t = t * 1000 / number
            qkalt_times.append(t)
            print(f'k={k}, n={n}, {t} ms')
    return qkalt_times


if __name__ == '__main__':
    qkalt_times = run_benchmarks()

"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"import subprocess
import shutil
import os

# Include these lines if we run all files in one process
import qiskit_alt
qiskit_alt.project.ensure_init()


bench_scripts = [
    ""fermionic_alt_time.py"",
    ""fermionic_nature_time.py"",
    ""from_matrix_alt.py"",
    ""from_matrix_quantum_info.py"",
    ""jordan_wigner_alt_time.py"",
    ""jordan_wigner_nature_time.py"",
    ""pauli_from_list_alt.py"",
    ""pauli_from_list_qinfo.py"",
    ]


_python = shutil.which(""python"")

## Run each benchmark script in a separate process
def run_bench(fname):
    dirname = os.path.dirname(os.path.abspath(__file__))
    full = os.path.join(dirname, fname)
    res = subprocess.run(
        [_python, full], check=True, capture_output=True, encoding='utf8'
    ).stdout
    print(res)


def exec_full_dir(fname):
    dirname = os.path.dirname(os.path.abspath(__file__))
    filepath = os.path.join(dirname, fname)
    exec_full(filepath)


def exec_full(filepath):
    global_namespace = {
        ""__file__"": filepath,
        ""__name__"": ""__main__"",
    }
    with open(filepath, 'rb') as file:
        exec(compile(file.read(), filepath, 'exec'), global_namespace)


for fname in bench_scripts:
    print(fname)
    exec_full_dir(fname)
    print()
"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"import subprocess
import shutil
import os

# Include these lines if we run all files in one process
import qiskit_alt
qiskit_alt.project.ensure_init()


bench_scripts = [
    ""fermionic_alt_time.py"",
    ""from_matrix_alt.py"",
    ""jordan_wigner_alt_time.py"",
    ""pauli_from_list_alt.py""
    ]


_python = shutil.which(""python"")

## Run each benchmark script in a separate process
def run_bench(fname):
    dirname = os.path.dirname(os.path.abspath(__file__))
    full = os.path.join(dirname, fname)
    res = subprocess.run(
        [_python, full], check=True, capture_output=True, encoding='utf8'
    ).stdout
    print(res)


def exec_full_dir(fname):
    dirname = os.path.dirname(os.path.abspath(__file__))
    filepath = os.path.join(dirname, fname)
    exec_full(filepath)


def exec_full(filepath):
    global_namespace = {
        ""__file__"": filepath,
        ""__name__"": ""__main__"",
    }
    with open(filepath, 'rb') as file:
        exec(compile(file.read(), filepath, 'exec'), global_namespace)


def run_all():
    for fname in bench_scripts:
        print(fname)
        exec_full_dir(fname)
        print()


if __name__ == '__main__':
    run_all()
"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"import qiskit_alt
geometry = [['H', [0., 0., 0.]], ['H', [0., 0., 0.7414]]]
#basis = 'sto3g'
basis = '631++g'

fermi_op = qiskit_alt.fermionic_hamiltonian(geometry, basis)
pauli_op = qiskit_alt.jordan_wigner(fermi_op)

#basis = '631g'
#basis = 'dzvp'

# Too big
#basis = 'dzp'
#basis = 'dzvp2'


"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"import qiskit_alt

def do_jw_problem():
#    qiskit_alt.Main.eval('include(""examples/jw_example.jl"")')
    qiskit_alt.Main.eval('include(""jw_example.jl"")')
    pauli_op = qiskit_alt.Main.eval(""pauli_op"")
    spop_jl = qiskit_alt.QiskitQuantumInfo.SparsePauliOp(pauli_op)
    spop = qiskit_alt.jlSparsePauliOp(spop_jl)
    return spop
"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"import qiskit_alt

#geometry = [['H', [0., 0., 0.]], ['H', [0., 0., 0.7414]]]

geometry = [['O', [0., 0., 0.]],
            ['H', [0.757, 0.586, 0.]],
            ['H', [-0.757, 0.586, 0.]]]

#basis = 'sto3g'
#basis = '631g'
basis = 'dzvp2'

pauli_op = qiskit_alt.jordan_wigner(geometry, basis)
"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"import pytest
import qiskit_alt
project = qiskit_alt.project
project.ensure_init() # calljulia=""pyjulia""
import qiskit_alt.electronic_structure

Main = project.julia.Main

def test_always_passes():
    assert True


def test_interface_lib():
    assert qiskit_alt.project.julia.__name__ == 'julia'


def test_import_QuantumOps():
    project.simple_import(""QuantumOps"")
    assert True


def test_import_ElectronicStructure():
    project.simple_import(""ElectronicStructure"")
    assert True


def test_import_QiskitQuantumInfo():
    project.simple_import(""QiskitQuantumInfo"")
    assert True


@pytest.fixture
def conv_geometry():
    geometry = [['H', [0., 0., 0.]], ['H', [0., 0., 0.7414]]]
    # geometry = [['O', [0., 0., 0.]],
    #             ['H', [0.757, 0.586, 0.]],
    #             ['H', [-0.757, 0.586, 0.]]]
    return qiskit_alt.electronic_structure.Geometry(geometry)


def test_Geometry_length(conv_geometry):
    assert Main.length(conv_geometry) == 2


def test_Geometry_atom(conv_geometry):
    atom = Main.getindex(conv_geometry, 1)
    assert atom.coords == (0.0, 0.0, 0.0)


def test_fermionic_hamiltonian(conv_geometry):
    fermi_op = Main.fermionic_hamiltonian(conv_geometry, ""sto3g"")
    assert Main.length(fermi_op) == 25
"
https://github.com/qiskit-community/qiskit-alt,qiskit-community,"import pytest
import qiskit_alt
project = qiskit_alt.project
project.ensure_init(calljulia=""juliacall"")

def test_always_passes():
    assert True

def test_interface_lib():
    assert qiskit_alt.project.julia.__name__ == 'juliacall'

def test_Main():
    Main = qiskit_alt.project.julia.Main
    assert Main.sind(90) == 1.0
"
https://github.com/Qiskit/feedback,Qiskit,"# Step 1: setup

from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator

backend = AerSimulator(method=""statevector"")



# Step 2: conditional initialisation

qc = QuantumCircuit(1, 2)
qc.h(0)  # This is just a stand-in for more complex real-world setup.
qc.measure(0, 0)

# Unlike c_if, we can have more than one instruction in the block, and it only
# requires a single evaluation of the condition.  That's especially important if
# the bit is written to part way through the block.
with qc.if_test((0, True)):
    qc.reset(0)
    qc.x(0)
qc.measure(0, 1)

qc.draw()
backend.run(qc).result().get_counts()  # {'00': 0.5, '11': 0.5}



# Step 3: repeat until success.

# Previously this wasn't representable in Qiskit at all, because we didn't have
# any concept of a run-time loop.

qc = QuantumCircuit(1, 2)
qc.h(0)
qc.measure(0, 0)
with qc.while_loop((0, False)):
    qc.reset(0)
    qc.h(0)
    qc.measure(0, 0)
qc.measure(0, 1)

qc.draw()
backend.run(qc).result().get_counts()  # {'11': 1}



# Step 4: repeat until success, with limits on the number of iterations.

qc = QuantumCircuit(1, 2)
with qc.for_loop(range(2)):
    qc.reset(0)
    qc.h(0)
    qc.measure(0, 0)
    with qc.if_test((0, True)):
        # 'break' (and 'continue') is also supported by Aer, but won't be part
        # of the initial transpiler support for swap routing.
        qc.break_loop()
qc.measure(0, 1)
backend.run(qc).result().get_counts()  # {'00': 0.25, '11': 0.75}



# Step 5: converting old-style c_if to IfElseOp.

# This transpiler pass is available in Terra 0.22 for backends to use in their
# injected pass-manager stages, so they can begin transitioning to the new forms
# immediately, and can start deprecating support for handling old-style
# `condition`.
from qiskit.transpiler.passes import ConvertConditionsToIfOps

qc = QuantumCircuit(1, 1)
qc.h(0)
qc.measure(0, 0)
qc.x(0).c_if(0, False)
qc.draw()

pass_ = ConvertConditionsToIfOps()
pass_(qc).draw()



# Other things mentioned:
#
# - The `QuantumCircuit.for_loop` context manager returns a `Parameter` object
#   that can be used in angle expressions in the loop body's gates.  The
#   OpenQASM 3 exporter understands this.
#
# - The `QuantumCircuit.if_test` context manager returns a context-manager
#   object that can be entered immediately on termination of the ""true"" body, to
#   make an ""else"" body.  For example:
#
#       with qc.if_test((0, False)) as else_:
#           qc.x(0)
#       with else_:
#           qc.z(0)
#
# - The OpenQASM 3 exporter supports all these constructs.  The easiest path to
#   access that is `qiskit.qasm3.dumps`.
"
https://github.com/Qiskit/feedback,Qiskit,"# Cell 1: simple representation

from qiskit import QuantumCircuit
from qiskit.circuit import QuantumRegister, ClassicalRegister, Clbit
from qiskit.circuit.classical import expr

cr1 = ClassicalRegister(3, ""cr1"")
cr2 = ClassicalRegister(3, ""cr2"")

expr.equal(expr.bit_and(cr1, cr2), 5)


# Cell 2: where can I use these?

qc1 = QuantumCircuit(QuantumRegister(3), cr1, cr2)

with qc1.if_test((cr1, 5)):
    qc1.x(0)

with qc1.if_test(expr.equal(cr1, 5)):
    qc1.x(0)

# But we're not limited to equality relations!

with qc1.if_test(expr.less_equal(cr1, 5)):
    qc1.z(0)

qc1.data[-1].operation.condition



# Cell 3: where else?

qc2 = QuantumCircuit(QuantumRegister(3), cr1, cr2)
with qc2.while_loop(expr.logic_or(expr.equal(cr1, 5), cr2[0])):
    qc2.x(0)

with qc2.switch(expr.bit_and(cr1, cr2)) as case:
    with case(0):
        qc2.x(0)
    with case(1):
        qc2.z(0)
    with case(2):
        qc2.x(1)
    with case(case.DEFAULT):
        qc2.z(1)



# Cell 4: integration testing

import io
from qiskit import transpile, qasm3, qpy
from qiskit_aer import AerSimulator

backend = AerSimulator(method=""statevector"")

transpiled = transpile(qc1, backend)
with io.BytesIO() as fptr:
    qpy.dump(transpiled, fptr)
    fptr.seek(0)
    loaded = qpy.load(fptr)[0]

print(qasm3.dumps(loaded))
"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"#!/usr/bin/env python
# coding: utf-8

# In[1]:


from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram

# Use Aer's AerSimulator
simulator = AerSimulator()

# Create a Quantum Circuit acting on the q register
circuit = QuantumCircuit(2, 2)

# Add a H gate on qubit 0
circuit.h(0)

# Add a CX (CNOT) gate on control qubit 0 and target qubit 1
circuit.cx(0, 1)

# Map the quantum measurement to the classical bits
circuit.measure([0, 1], [0, 1])

# Compile the circuit for the support instruction set (basis_gates)
# and topology (coupling_map) of the backend
compiled_circuit = transpile(circuit, simulator)

# Execute the circuit on the aer simulator
job = simulator.run(compiled_circuit, shots=1000)

# Grab results from the job
result = job.result()

# Returns counts
counts = result.get_counts(compiled_circuit)
print(""\nTotal count for 00 and 11 are:"", counts)

# Draw the circuit
circuit.draw()


# In[2]:


# Plot a histogram
plot_histogram(counts)


# In[3]:


circuit.draw()


# In[4]:


simulator = AerSimulator()
compiled_circuit = transpile(circuit, simulator)
job = simulator.run(compiled_circuit, shots=1000)
result = job.result()
counts = result.get_counts(circuit)
print(""\nTotal count for 00 and 11 are:"",counts)


# In[5]:


plot_histogram(counts)

"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"#!/usr/bin/env python
# coding: utf-8

# In[1]:


from qiskit import *


# In[2]:


qr = QuantumRegister(3, 'q')
cr = ClassicalRegister(2, 'zx_meas')
qc = QuantumCircuit(qr,cr)
qc.reset(range(3))
qc.barrier()
qc.h(1)
qc.cx([1,0],[2,1])
qc.h(0)
qc.barrier()
qc.measure([0,1], [0,1])
qc.barrier()
qc.z(2).c_if(cr, 1)
qc.x(2).c_if(cr, 2)

"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"#!/usr/bin/env python
# coding: utf-8

# In[1]:


from qiskit.test.ibmq_mock import mock_get_backend
mock_get_backend('FakeVigo')


# In[2]:


from qiskit import IBMQ
from qiskit.providers.ibmq.visualization import iplot_error_map

IBMQ.load_account()

provider = IBMQ.get_provider(group='open', project='main')
backend = provider.get_backend('ibmq_vigo')

iplot_error_map(backend, as_widget=True)

"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"#!/usr/bin/env python
# coding: utf-8

# In[1]:


from qiskit.test.ibmq_mock import mock_get_backend
mock_get_backend('FakeVigo')


# In[2]:


from qiskit import IBMQ
from qiskit.providers.ibmq.visualization import iplot_gate_map

IBMQ.load_account()

provider = IBMQ.get_provider(group='open', project='main')
backend = provider.get_backend('ibmq_vigo')

iplot_gate_map(backend, as_widget=True)

"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.circuit.library import MCXGate
gate = MCXGate(4)

from qiskit import QuantumCircuit
circuit = QuantumCircuit(5)
circuit.append(gate, [0, 1, 4, 2, 3])
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
d1 = pulse.DriveChannel(1)

with pulse.build() as pulse_prog:
    with pulse.align_right():
        # this pulse will start at t=0
        pulse.play(pulse.Constant(100, 1.0), d0)
        # this pulse will start at t=80
        pulse.play(pulse.Constant(20, 1.0), d1)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_circuit_layout
from qiskit.tools.monitor import job_monitor
from qiskit.providers.fake_provider import FakeVigoV2
import matplotlib.pyplot as plt

ghz = QuantumCircuit(3, 3)
ghz.h(0)
for idx in range(1,3):
    ghz.cx(0,idx)
ghz.measure(range(3), range(3))

backend = FakeVigoV2()
new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

# Virtual -> physical
#    0    ->    3
#    1    ->    4
#    2    ->    2

my_ghz = transpile(ghz, backend, initial_layout=[3, 4, 2])
plot_circuit_layout(my_ghz, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

# You can reverse the order of the qubits.

from qiskit.quantum_info import DensityMatrix

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.t(1)
qc.s(0)
qc.cx(0,1)

matrix = DensityMatrix(qc)
plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
plot_circuit_layout(new_circ_lv0, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can choose different colors for the real and imaginary parts of the density matrix.

from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = DensityMatrix(qc)
plot_state_city(state, color=['midnightblue', 'crimson'], title=""New State City"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
qc = QuantumCircuit(12)
for idx in range(5):
   qc.h(idx)
   qc.cx(idx, idx+5)

qc.cx(1, 7)
qc.x(8)
qc.cx(1, 9)
qc.x(7)
qc.cx(1, 11)
qc.swap(6, 11)
qc.swap(6, 9)
qc.swap(6, 10)
qc.x(6)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXSimple())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import qiskit.qasm3

program = """"""
    OPENQASM 3.0;
    include ""stdgates.inc"";

    input float[64] a;
    qubit[3] q;
    bit[2] mid;
    bit[3] out;

    let aliased = q[0:1];

    gate my_gate(a) c, t {
      gphase(a / 2);
      ry(a) c;
      cx c, t;
    }
    gate my_phase(a) c {
      ctrl @ inv @ gphase(a) c;
    }

    my_gate(a * 2) aliased[0], q[{1, 2}][0];
    measure q[0] -> mid[0];
    measure q[1] -> mid[1];

    while (mid == ""00"") {
      reset q[0];
      reset q[1];
      my_gate(a) q[0], q[1];
      my_phase(a - pi/2) q[1];
      mid[0] = measure q[0];
      mid[1] = measure q[1];
    }

    if (mid[0]) {
      let inner_alias = q[{0, 1}];
      reset inner_alias;
    }

    out = measure q;
""""""
circuit = qiskit.qasm3.loads(program)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
pw_approximation._build()
qc = QuantumCircuit(pw_approximation.num_qubits)
qc.h(list(range(num_state_qubits)))
qc.append(pw_approximation.to_instruction(), qc.qubits)
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
gate_counts = []
non_local_gate_counts = []
levels = [str(x) for x in range(4)]
for level in range(4):
     circ = transpile(ghz, backend, optimization_level=level)
     depths.append(circ.depth())
     gate_counts.append(sum(circ.count_ops().values()))
     non_local_gate_counts.append(circ.num_nonlocal_gates())
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.bar(levels, depths, label='Depth')
ax1.set_xlabel(""Optimization Level"")
ax1.set_ylabel(""Depth"")
ax1.set_title(""Output Circuit Depth"")
ax2.bar(levels, gate_counts, label='Number of Circuit Operations')
ax2.bar(levels, non_local_gate_counts, label='Number of non-local gates')
ax2.set_xlabel(""Optimization Level"")
ax2.set_ylabel(""Number of gates"")
ax2.legend()
ax2.set_title(""Number of output circuit gates"")
fig.tight_layout()
plt.show()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeManilaV2
from qiskit import transpile
from qiskit.tools.visualization import plot_histogram


# Get a fake backend from the fake provider
backend = FakeManilaV2()

# Create a simple circuit
circuit = QuantumCircuit(3)
circuit.h(0)
circuit.cx(0,1)
circuit.cx(0,2)
circuit.measure_all()
circuit.draw('mpl')

# Transpile the ideal circuit to a circuit that can be directly executed by the backend
transpiled_circuit = transpile(circuit, backend)
transpiled_circuit.draw('mpl')

# Run the transpiled circuit using the simulated fake backend
job = backend.run(transpiled_circuit)
counts = job.result().get_counts()
plot_histogram(counts)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))

new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
plot_circuit_layout(new_circ_lv3, backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qc1 = QuantumCircuit(2)
qc1.x(0)
qc1.h(1)
custom = qc1.to_gate().control(2)

qc2 = QuantumCircuit(4)
qc2.append(custom, [0, 3, 1, 2])
qc2.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))

depths = []
for _ in range(100):
    depths.append(
        transpile(
            ghz,
            backend,
            layout_method='trivial'  # Fixed layout mapped in circuit order
        ).depth()
    )

plt.figure(figsize=(8, 6))
plt.hist(depths, align='left', color='#AC557C')
plt.xlabel('Depth', fontsize=14)
plt.ylabel('Counts', fontsize=14);"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a Statevector
state = Statevector(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can show the phase of each state and use
# degrees instead of radians

from qiskit.quantum_info import DensityMatrix
import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)
qc.z(1)

matrix = DensityMatrix(qc)
plot_state_qsphere(matrix,
     show_state_phases = True, use_degrees = True)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

def udd10_pos(j):
    return np.sin(np.pi*j/(2*10 + 2))**2

with pulse.build() as udd_sched:
    pulse.play(x90, d0)
    with pulse.align_func(duration=300, func=udd10_pos):
        for _ in range(10):
            pulse.play(x180, d0)
    pulse.play(x90, d0)

udd_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw, IQXDebugging
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc, style=IQXDebugging())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# If you introduce a list with less colors than bars, the color of the bars will
# alternate following the sequence from the list.

import numpy as np
from qiskit.quantum_info import DensityMatrix
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0, 1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

matrix = DensityMatrix(qc)
plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.visualization import plot_error_map
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()
plot_error_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_hinton

qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3 , 0)
qc.rx(np.pi/5, 1)

state = DensityMatrix(qc)
plot_state_hinton(state, title=""New Hinton Plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate
from qiskit.converters import dag_to_circuit

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)
dag = circuit_to_dag(circ)
circuit = dag_to_circuit(dag)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can make the bars more transparent to better see the ones that are behind
# if they overlap.

import numpy as np
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_city
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)


qc = QuantumCircuit(2)
qc.h([0, 1])
qc.cz(0,1)
qc.ry(np.pi/3, 0)
qc.rx(np.pi/5, 1)

state = Statevector(qc)
plot_state_city(state, alpha=0.6)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
# Create a circuit with a register of three qubits
circ = QuantumCircuit(3)
# H gate on qubit 0, putting this qubit in a superposition of |0> + |1>.
circ.h(0)
# A CX (CNOT) gate on control qubit 0 and target qubit 1 generating a Bell state.
circ.cx(0, 1)
# CX (CNOT) gate on control qubit 0 and target qubit 2 resulting in a GHZ state.
circ.cx(0, 2)
# Draw the circuit
circ.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, execute
from qiskit.providers.fake_provider import FakeVigoV2
from qiskit.visualization import plot_gate_map

backend = FakeVigoV2()

plot_gate_map(backend)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford

qc = QuantumCircuit(3)
cliff = random_clifford(2)
qc.append(cliff, [0, 1])
qc.ccx(0, 1, 2)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.timeline import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')
draw(qc)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)

state = Statevector(qc)
plot_bloch_multivector(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"# You can set a color for all the bars.

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_paulivec

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_paulivec(state, color='midnightblue', title=""New PauliVec plot"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse
from qiskit.providers.fake_provider import FakeArmonk

backend = FakeArmonk()

with pulse.build(backend) as drive_sched:
    d0 = pulse.drive_channel(0)
    a0 = pulse.acquire_channel(0)

    pulse.play(pulse.library.Constant(10, 1.0), d0)
    pulse.delay(20, d0)
    pulse.shift_phase(3.14/2, d0)
    pulse.set_phase(3.14, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

drive_sched.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import execute, pulse

d0 = pulse.DriveChannel(0)

with pulse.build() as pulse_prog:
    pulse.play(pulse.Constant(100, 1.0), d0)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit.visualization.timeline import draw as timeline_draw

from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")

timeline_draw(circ)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

# plot using a DensityMatrix
state = DensityMatrix(qc)
plot_state_city(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import transpile
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])

qc_basis = transpile(qc, backend)
qc_basis.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

dc = pulse.DriveChannel
d0, d1, d2, d3, d4 = dc(0), dc(1), dc(2), dc(3), dc(4)

with pulse.build(name='pulse_programming_in') as pulse_prog:
    pulse.play([1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], d0)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d1)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], d2)
    pulse.play([1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], d3)
    pulse.play([1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], d4)

pulse_prog.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import math

from qiskit import pulse
from qiskit.providers.fake_provider import FakeOpenPulse3Q

# TODO: This example should use a real mock backend.
backend = FakeOpenPulse3Q()

d2 = pulse.DriveChannel(2)

with pulse.build(backend) as bell_prep:
    pulse.u2(0, math.pi, 0)
    pulse.cx(0, 1)

with pulse.build(backend) as decoupled_bell_prep_and_measure:
    # We call our bell state preparation schedule constructed above.
    with pulse.align_right():
        pulse.call(bell_prep)
        pulse.play(pulse.Constant(bell_prep.duration, 0.02), d2)
        pulse.barrier(0, 1, 2)
        registers = pulse.measure_all()

decoupled_bell_prep_and_measure.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_circuit_layout
from qiskit.providers.fake_provider import FakeVigo
backend = FakeVigo()

ghz = QuantumCircuit(3, 3)
ghz.h(0)
ghz.cx(0,range(1,3))
ghz.barrier()
ghz.measure(range(3), range(3))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.transpiler.passes import RemoveBarriers

circuit = QuantumCircuit(1)
circuit.x(0)
circuit.barrier()
circuit.h(0)

circuit = RemoveBarriers()(circuit)
circuit.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw, IQXSimple
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, style=IQXSimple(), backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit

qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile, schedule
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeBoeblingen

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')
sched = schedule(qc, FakeBoeblingen())

draw(sched, backend=FakeBoeblingen())"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeBoeblingen

backend = FakeBoeblingen()

ghz = QuantumCircuit(5)
ghz.h(0)
ghz.cx(0,range(1,5))

circ = transpile(ghz, backend, scheduling_method=""asap"")
circ.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)

state = Statevector(qc)
plot_state_qsphere(state)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(3, 'q')
anc = QuantumRegister(1, 'ancilla')
cr = ClassicalRegister(3, 'c')
qc = QuantumCircuit(qr, anc, cr)

qc.x(anc[0])
qc.h(anc[0])
qc.h(qr[0:3])
qc.cx(qr[0:3], anc[0])
qc.h(qr[0:3])
qc.barrier(qr)
qc.measure(qr, cr)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import BasicAer, transpile, QuantumRegister, ClassicalRegister, QuantumCircuit

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
qc = QuantumCircuit(qr, cr)
qc.h(0)
qc.measure(0, 0)

qc.x(0).c_if(cr, 0)
qc.measure(0, 0)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)
qc.h(q)
qc.measure(q, c)
qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.transpiler.passes import UnitarySynthesis

circuit = QuantumCircuit(1)
circuit.rx(0.8, 0)
unitary = Operator(circuit).data

unitary_circ = QuantumCircuit(1)
unitary_circ.unitary(unitary, [0])

synth = UnitarySynthesis(basis_gates=[""h"", ""s""], method=""sk"")
out = synth(unitary_circ)

out.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit
top = QuantumCircuit(1)
top.x(0);
bottom = QuantumCircuit(2)
bottom.cry(0.2, 0, 1);
tensored = bottom.tensor(top)
tensored.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.providers.fake_provider import FakeAuckland
backend = FakeAuckland()

ghz = QuantumCircuit(15)
ghz.h(0)
ghz.cx(0, range(1, 15))
ghz.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit.quantumcircuitdata import CircuitInstruction
from qiskit.circuit import Measure
from qiskit.circuit.library import HGate, CXGate


qr = QuantumRegister(2)
cr = ClassicalRegister(2)
instructions = [
    CircuitInstruction(HGate(), [qr[0]], []),
    CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
    CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
    CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
]
circuit = QuantumCircuit.from_instructions(instructions)
circuit.draw(""mpl"")"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"import numpy as np
from qiskit import QuantumCircuit
from qiskit.providers.fake_provider import FakeVigoV2

backend = FakeVigoV2()

qc = QuantumCircuit(2, 1)

qc.h(0)
qc.x(1)
qc.cp(np.pi/4, 0, 1)
qc.h(0)
qc.measure([0], [0])
qc.draw(output='mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library.standard_gates import HGate

qr = QuantumRegister(3)
qc = QuantumCircuit(qr)
c3h_gate = HGate().control(2)
qc.append(c3h_gate, qr)
qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.visualization import dag_drawer

q = QuantumRegister(3, 'q')
c = ClassicalRegister(3, 'c')
circ = QuantumCircuit(q, c)
circ.h(q[0])
circ.cx(q[0], q[1])
circ.measure(q[0], c[0])
circ.rz(0.5, q[1]).c_if(c, 2)

dag = circuit_to_dag(circ)
dag_drawer(dag)"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import pulse

d0 = pulse.DriveChannel(0)
x90 = pulse.Gaussian(10, 0.1, 3)
x180 = pulse.Gaussian(10, 0.2, 3)

with pulse.build() as hahn_echo:
    with pulse.align_equispaced(duration=100):
        pulse.play(x90, d0)
        pulse.play(x180, d0)
        pulse.play(x90, d0)

hahn_echo.draw()"
https://github.com/qiskit-community/qiskit-translations-staging,qiskit-community,"from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
qc = QuantumCircuit(qr, cr)
qc.h(range(2))
qc.measure(range(2), range(2))

# apply x gate if the classical register has the value 2 (10 in binary)
qc.x(0).c_if(cr, 2)

# apply y gate if bit 0 is set to 1
qc.y(1).c_if(0, 1)

qc.draw('mpl')"
https://github.com/qiskit-community/qiskit-bip-mapper,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Test the BIPMapping pass.""""""

import unittest

from qiskit import QuantumRegister, QuantumCircuit, ClassicalRegister
from qiskit.circuit import Barrier
from qiskit.circuit.library.standard_gates import SwapGate
from qiskit.converters import circuit_to_dag
from qiskit.providers.fake_provider import FakeLima
from qiskit.transpiler import CouplingMap, Layout, PassManager
from qiskit.transpiler.exceptions import TranspilerError
from qiskit.transpiler.passes import CheckMap, Collect2qBlocks, ConsolidateBlocks, UnitarySynthesis

from qiskit_bip_mapper.bip_mapping import BIPMapping


class TestBIPMapping(unittest.TestCase):
    """"""Tests the BIPMapping pass.""""""

    def test_empty(self):
        """"""Returns the original circuit if the circuit is empty.""""""
        coupling = CouplingMap([[0, 1]])
        circuit = QuantumCircuit(2)
        actual = BIPMapping(coupling)(circuit)
        self.assertEqual(circuit, actual)

    def test_no_two_qubit_gates(self):
        """"""Returns the original circuit if the circuit has no 2q-gates.

        q0:--[H]--
        q1:-------

        CouplingMap map: [0]--[1]
        """"""
        coupling = CouplingMap([[0, 1]])

        circuit = QuantumCircuit(2)
        circuit.h(0)

        actual = BIPMapping(coupling)(circuit)

        self.assertEqual(circuit, actual)

    def test_trivial_case(self):
        """"""No need to have any swap, the CX are distance 1 to each other.

        q0:--(+)-[H]-(+)-
              |       |
        q1:---.-------|--
                      |
        q2:-----------.--

        CouplingMap map: [1]--[0]--[2]
        """"""
        coupling = CouplingMap([[0, 1], [0, 2]])

        circuit = QuantumCircuit(3)
        circuit.cx(1, 0)
        circuit.h(0)
        circuit.cx(2, 0)

        actual = BIPMapping(coupling)(circuit)
        self.assertEqual(3, len(actual))
        for inst, _, _ in actual.data:  # there are no swaps
            self.assertFalse(isinstance(inst, SwapGate))

    def test_no_swap(self):
        """"""Adding no swap if not giving initial layout.""""""
        coupling = CouplingMap([[0, 1], [0, 2]])

        circuit = QuantumCircuit(3)
        circuit.cx(1, 2)

        actual = BIPMapping(coupling)(circuit)

        q = QuantumRegister(3, name=""q"")
        expected = QuantumCircuit(q)
        expected.cx(q[0], q[1])

        self.assertEqual(expected, actual)

    def test_ignore_initial_layout(self):
        """"""Ignoring initial layout even when it is supplied.""""""
        coupling = CouplingMap([[0, 1], [0, 2]])

        circuit = QuantumCircuit(3)
        circuit.cx(1, 2)

        property_set = {""layout"": Layout.generate_trivial_layout(*circuit.qubits)}
        actual = BIPMapping(coupling)(circuit, property_set)

        q = QuantumRegister(3, name=""q"")
        expected = QuantumCircuit(q)
        expected.cx(q[0], q[1])

        self.assertEqual(expected, actual)

    def test_can_map_measurements_correctly(self):
        """"""Verify measurement nodes are updated to map correct cregs to re-mapped qregs.""""""
        coupling = CouplingMap([[0, 1], [0, 2]])

        qr = QuantumRegister(3, ""qr"")
        cr = ClassicalRegister(2)
        circuit = QuantumCircuit(qr, cr)
        circuit.cx(qr[1], qr[2])
        circuit.measure(qr[1], cr[0])
        circuit.measure(qr[2], cr[1])

        actual = BIPMapping(coupling)(circuit)

        q = QuantumRegister(3, ""q"")
        expected = QuantumCircuit(q, cr)
        expected.cx(q[0], q[1])
        expected.measure(q[0], cr[0])  # <- changed due to initial layout change
        expected.measure(q[1], cr[1])  # <- changed due to initial layout change

        self.assertEqual(expected, actual)

    def test_never_modify_mapped_circuit(self):
        """"""Test that the mapping is idempotent.

        It should not modify a circuit which is already compatible with the
        coupling map, and can be applied repeatedly without modifying the circuit.
        """"""
        coupling = CouplingMap([[0, 1], [0, 2]])

        circuit = QuantumCircuit(3, 2)
        circuit.cx(1, 2)
        circuit.measure(1, 0)
        circuit.measure(2, 1)
        dag = circuit_to_dag(circuit)

        mapped_dag = BIPMapping(coupling).run(dag)
        remapped_dag = BIPMapping(coupling).run(mapped_dag)

        self.assertEqual(mapped_dag, remapped_dag)

    def test_no_swap_multi_layer(self):
        """"""Can find the best layout for a circuit with multiple layers.""""""
        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])

        qr = QuantumRegister(4, name=""qr"")
        circuit = QuantumCircuit(qr)
        circuit.cx(qr[1], qr[0])
        circuit.cx(qr[0], qr[3])

        property_set = {}
        actual = BIPMapping(coupling, objective=""depth"")(circuit, property_set)
        self.assertEqual(2, actual.depth())

        CheckMap(coupling)(actual, property_set)
        self.assertTrue(property_set[""is_swap_mapped""])

    def test_unmappable_cnots_in_a_layer(self):
        """"""Test mapping of a circuit with 2 cnots in a layer which BIPMapping cannot map.""""""
        qr = QuantumRegister(4, ""q"")
        cr = ClassicalRegister(4, ""c"")
        circuit = QuantumCircuit(qr, cr)
        circuit.cx(qr[0], qr[1])
        circuit.cx(qr[2], qr[3])
        circuit.measure(qr, cr)

        coupling = CouplingMap([[0, 1], [1, 2], [1, 3]])  # {0: [1], 1: [2, 3]}
        actual = BIPMapping(coupling)(circuit)

        # Fails to map and returns the original circuit
        self.assertEqual(circuit, actual)

    def test_multi_cregs(self):
        """"""Test for multiple ClassicalRegisters.""""""
        #                      ┌───┐ ░ ┌─┐
        # qr_0: ──■────────────┤ X ├─░─┤M├─────────
        #       ┌─┴─┐     ┌───┐└─┬─┘ ░ └╥┘┌─┐
        # qr_1: ┤ X ├──■──┤ H ├──■───░──╫─┤M├──────
        #       └───┘┌─┴─┐└───┘      ░  ║ └╥┘┌─┐
        # qr_2: ──■──┤ X ├───────────░──╫──╫─┤M├───
        #       ┌─┴─┐└───┘           ░  ║  ║ └╥┘┌─┐
        # qr_3: ┤ X ├────────────────░──╫──╫──╫─┤M├
        #       └───┘                ░  ║  ║  ║ └╥┘
        #  c: 2/════════════════════════╩══╬══╩══╬═
        #                               0  ║  1  ║
        #                                  ║     ║
        #  d: 2/═══════════════════════════╩═════╩═
        #                                  0     1
        qr = QuantumRegister(4, ""qr"")
        cr1 = ClassicalRegister(2, ""c"")
        cr2 = ClassicalRegister(2, ""d"")
        circuit = QuantumCircuit(qr, cr1, cr2)
        circuit.cx(qr[0], qr[1])
        circuit.cx(qr[2], qr[3])
        circuit.cx(qr[1], qr[2])
        circuit.h(qr[1])
        circuit.cx(qr[1], qr[0])
        circuit.barrier(qr)
        circuit.measure(qr[0], cr1[0])
        circuit.measure(qr[1], cr2[0])
        circuit.measure(qr[2], cr1[1])
        circuit.measure(qr[3], cr2[1])

        coupling = CouplingMap([[0, 1], [0, 2], [2, 3]])  # linear [1, 0, 2, 3]
        property_set = {}
        actual = BIPMapping(coupling, objective=""depth"")(circuit, property_set)
        self.assertEqual(5, actual.depth())

        CheckMap(coupling)(actual, property_set)
        self.assertTrue(property_set[""is_swap_mapped""])

    def test_swaps_in_dummy_steps(self):
        """"""Test the case when swaps are inserted in dummy steps.""""""
        #           ┌───┐ ░            ░
        # q_0: ──■──┤ H ├─░───■────────░───■───────
        #      ┌─┴─┐├───┤ ░   │        ░   │
        # q_1: ┤ X ├┤ H ├─░───┼────■───░───┼────■──
        #      └───┘├───┤ ░   │  ┌─┴─┐ ░ ┌─┴─┐  │
        # q_2: ──■──┤ H ├─░───┼──┤ X ├─░─┤ X ├──┼──
        #      ┌─┴─┐├───┤ ░ ┌─┴─┐└───┘ ░ └───┘┌─┴─┐
        # q_3: ┤ X ├┤ H ├─░─┤ X ├──────░──────┤ X ├
        #      └───┘└───┘ ░ └───┘      ░      └───┘
        circuit = QuantumCircuit(4)
        circuit.cx(0, 1)
        circuit.cx(2, 3)
        circuit.h([0, 1, 2, 3])
        circuit.barrier()
        circuit.cx(0, 3)
        circuit.cx(1, 2)
        circuit.barrier()
        circuit.cx(0, 2)
        circuit.cx(1, 3)

        coupling = CouplingMap.from_line(4)
        property_set = {}
        actual = BIPMapping(coupling, objective=""depth"")(circuit, property_set)
        self.assertEqual(7, actual.depth())

        CheckMap(coupling)(actual, property_set)
        self.assertTrue(property_set[""is_swap_mapped""])

        # no swaps before the first barrier
        for inst, _, _ in actual.data:
            if isinstance(inst, Barrier):
                break
            self.assertFalse(isinstance(inst, SwapGate))

    def test_different_number_of_virtual_and_physical_qubits(self):
        """"""Test the case when number of virtual and physical qubits are different.""""""
        # q_0: ──■────■───────
        #      ┌─┴─┐  │
        # q_1: ┤ X ├──┼────■──
        #      └───┘  │  ┌─┴─┐
        # q_2: ──■────┼──┤ X ├
        #      ┌─┴─┐┌─┴─┐└───┘
        # q_3: ┤ X ├┤ X ├─────
        #      └───┘└───┘
        circuit = QuantumCircuit(4)
        circuit.cx(0, 1)
        circuit.cx(2, 3)
        circuit.cx(0, 3)

        property_set = {}
        coupling = CouplingMap.from_line(5)
        actual = BIPMapping(coupling, objective=""depth"")(circuit, property_set)
        self.assertEqual(2, actual.depth())

    def test_qubit_subset(self):
        """"""Test if `qubit_subset` option works as expected.""""""
        circuit = QuantumCircuit(3)
        circuit.cx(0, 1)
        circuit.cx(1, 2)
        circuit.cx(0, 2)

        coupling = CouplingMap([(0, 1), (1, 3), (3, 2)])
        qubit_subset = [0, 1, 3]
        actual = BIPMapping(coupling, qubit_subset=qubit_subset)(circuit)
        # all used qubits are in qubit_subset
        bit_indices = {bit: index for index, bit in enumerate(actual.qubits)}
        for _, qargs, _ in actual.data:
            for q in qargs:
                self.assertTrue(bit_indices[q] in qubit_subset)
        # ancilla qubits are set in the resulting qubit
        idle = QuantumRegister(1, name=""ancilla"")
        self.assertEqual(idle[0], actual._layout.initial_layout[2])

    def test_unconnected_qubit_subset(self):
        """"""Fails if qubits in `qubit_subset` are not connected.""""""
        circuit = QuantumCircuit(3)
        circuit.cx(0, 1)

        coupling = CouplingMap([(0, 1), (1, 3), (3, 2)])
        with self.assertRaises(TranspilerError):
            BIPMapping(coupling, qubit_subset=[0, 1, 2])(circuit)

    def test_objective_function(self):
        """"""Test if ``objective`` functions prioritize metrics correctly.""""""
        #      ┌──────┐┌──────┐     ┌──────┐
        # q_0: ┤0     ├┤0     ├─────┤0     ├
        #      │  Dcx ││      │     │  Dcx │
        # q_1: ┤1     ├┤  Dcx ├──■──┤1     ├
        #      └──────┘│      │  │  └──────┘
        # q_2: ───■────┤1     ├──┼─────■────
        #       ┌─┴─┐  └──────┘┌─┴─┐ ┌─┴─┐
        # q_3: ─┤ X ├──────────┤ X ├─┤ X ├──
        #       └───┘          └───┘ └───┘
        qc = QuantumCircuit(4)
        qc.dcx(0, 1)
        qc.cx(2, 3)
        qc.dcx(0, 2)
        qc.cx(1, 3)
        qc.dcx(0, 1)
        qc.cx(2, 3)
        coupling = CouplingMap(FakeLima().configuration().coupling_map)
        dep_opt = BIPMapping(coupling, objective=""depth"", qubit_subset=[0, 1, 3, 4])(qc)
        err_opt = BIPMapping(
            coupling,
            objective=""gate_error"",
            qubit_subset=[0, 1, 3, 4],
            backend_prop=FakeLima().properties(),
        )(qc)
        # depth = number of su4 layers (mirrored gates have to be consolidated as single su4 gates)
        pm_ = PassManager([Collect2qBlocks(), ConsolidateBlocks(basis_gates=[""cx"", ""u""])])
        dep_opt = pm_.run(dep_opt)
        err_opt = pm_.run(err_opt)
        self.assertLessEqual(dep_opt.depth(), err_opt.depth())
        # count CNOTs after synthesized
        dep_opt = UnitarySynthesis(basis_gates=[""cx"", ""u""])(dep_opt)
        err_opt = UnitarySynthesis(basis_gates=[""cx"", ""u""])(err_opt)
        self.assertGreater(dep_opt.count_ops()[""cx""], err_opt.count_ops()[""cx""])
"
https://github.com/qiskit-community/qiskit-bip-mapper,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Test the BIPMapping pass.""""""

import unittest

from qiskit import QuantumCircuit
from qiskit.circuit.library.standard_gates import SwapGate
from qiskit.compiler.transpiler import transpile
from qiskit.transpiler.coupling import CouplingMap
from qiskit.transpiler.preset_passmanagers.plugin import list_stage_plugins


class TestBIPMapping(unittest.TestCase):
    """"""Tests the BIPMapping plugin.""""""

    def test_plugin_in_list(self):
        """"""Test bip plugin is installed.""""""
        self.assertIn(""bip"", list_stage_plugins(""routing""))

    def test_trivial_case(self):
        """"""No need to have any swap, the CX are distance 1 to each other.

        q0:--(+)-[H]-(+)-
              |       |
        q1:---.-------|--
                      |
        q2:-----------.--

        CouplingMap map: [1]--[0]--[2]
        """"""
        coupling = CouplingMap([[0, 1], [0, 2]])

        circuit = QuantumCircuit(3)
        circuit.cx(1, 0)
        circuit.h(0)
        circuit.cx(2, 0)
        actual = transpile(
            circuit, coupling_map=coupling, routing_method=""bip"", optimization_level=0
        )
        self.assertEqual(11, len(actual))
        for inst, _, _ in actual.data:  # there are no swaps
            self.assertFalse(isinstance(inst, SwapGate))
"
https://github.com/qiskit-community/archiver4qiskit,qiskit-community,"import os
import qiskit
from qiskit import IBMQ, Aer
import uuid
import pickle

try:
    IBMQ.load_account()
except:
    print('Unable to load IBMQ account')

def _prep():
    if 'archive' not in os.listdir():
        os.mkdir('archive')     
_prep()
                    
class Archive():
    '''
    A serializable equivalent to the Qiskit job object.
    '''
    def __init__(self, job, path='', note='', circuits=None):
        
        if 'job_id' in dir(job):
            self.archive_id = job.job_id() + '@' + job.backend().name()
        else:
            self.archive_id = uuid.uuid4().hex + '@' + job.backend().name()

        self.path = path
        
        self.note = note
        self._job_id = job.job_id()
        self._backend = job.backend()
        self._backend.properties() # just needs to be called to load
        self._metadata = job.metadata
        self.version = job.version
        if 'circuits' in dir(job):
            self._circuits = job.circuits()
        else:
            self._circuits = circuits
        if 'qobj' in dir(job):
            self._qobj = job.qobj()
        if 'aer' in self.backend().name():
            self._result = job.result()
        else:
            self._result = None
            
        self.save()
            
    def save(self):
        with open(self.path + 'archive/'+self.archive_id, 'wb') as file:
            pickle.dump(self, file)
        
    def job_id(self):
        return self._job_id
    
    def backend(self):
        return self._backend
    
    def metadata(self):
        return self._job_id
    
    def circuits(self):
        return self._circuits
    
    def qobj(self):
        return self._qobj
        
    def result(self):
        if self._result==None:
            backend = get_backend(self.backend().name())
            job = backend.retrieve_job(self.job_id())
            self._result = job.result()
            self.save()
        return self._result
        
            
def get_backend(backend_name):
    '''
    Given a string that specifies a backend, returns the backend object
    '''
    if type(backend_name) is str:
        if 'aer' in backend_name:
            backend = Aer.get_backend(backend_name)
        else:
            providers = IBMQ.providers()
            p = 0
            no_backend = True
            for provider in providers:
                if no_backend:
                    backends = provider.backends()
                    for potential_backend in backends:
                        if potential_backend.name()==backend_name:
                            backend = potential_backend
                            no_backend = False
            if no_backend:
                print('No backend was found matching '+backend_name+' with your providers.')
    else:
        backend = backend_name
    return backend


def submit_job(circuits, backend_name, path='', note='',
               job_name=None, job_share_level=None, job_tags=None, experiment_id=None, header=None,
               shots=None, memory=None, qubit_lo_freq=None, meas_lo_freq=None, schedule_los=None,
               meas_level=None, meas_return=None, memory_slots=None, memory_slot_size=None,
               rep_time=None, rep_delay=None, init_qubits=None, parameter_binds=None, use_measure_esp=None,
               **run_config):
    '''
    Given a backend name and the arguments for the `run` method of the backend object, submits the job
    and returns the archive id.
    '''
    
    # get backend
    backend = get_backend(backend_name)

    backend_name = backend.name()
    
    # submit job
    job = backend.run(circuits, job_name=job_name, job_share_level=job_share_level, job_tags=job_tags,
                      experiment_id=experiment_id, header=header, shots=shots, memory=memory,
                      qubit_lo_freq=qubit_lo_freq, meas_lo_freq=meas_lo_freq, schedule_los=schedule_los,
                      meas_level=meas_level, meas_return=meas_return, memory_slots=memory_slots,
                      memory_slot_size=memory_slot_size, rep_time=rep_time, rep_delay=rep_delay, init_qubits=init_qubits,
                      parameter_binds=parameter_binds, use_measure_esp=use_measure_esp,
                      **run_config)

    # create archive
    archive = Archive(job, note=note, circuits=circuits)
    
    # if an Aer job, get the results
    if 'aer' in job.backend().name():
        archive.result()
        
    # return the id
    return archive.archive_id


def get_job(archive_id):
    '''
    Returns the Qiskit job object corresponding to a given archive_id
    '''
    job_id, backend_name = archive_id.split('@')
    backend = get_backend(backend_name)
    job = backend.retrieve_job(job_id)
    return job


def get_archive(archive_id, path=''):
    '''
    Returns the saved archive object corresponding to a given archive_id
    '''
    with open(path + 'archive/'+archive_id, 'rb') as file:
        archive = pickle.load(file)
    return archive


def jobid2archive(job_id, backend_name):
    
    backend = get_backend(backend_name)
    job = backend.retrieve_job(job_id)
    
    archive = Archive(job)
    archive.result()
    
    return archive.archive_id"
https://github.com/qiskit-community/qopt-best-practices,qiskit-community,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import logging
from typing import Dict, List, Union, Literal

import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, qasm2, qasm3
from qiskit.circuit import QuantumCircuit, QuantumRegister, Qubit
from qiskit.qasm2 import QASM2ExportError, QASM2ParseError
from qiskit.transpiler import TranspileLayout
from qiskit.transpiler.layout import Layout

from qiskit_transpiler_service.wrappers import QiskitTranspilerService

# setting backoff logger to error level to avoid too much logging
logging.getLogger(""backoff"").setLevel(logging.ERROR)
logger = logging.getLogger(__name__)


class TranspileAPI(QiskitTranspilerService):
    """"""A helper class that covers some basic funcionality from the Qiskit Transpiler API""""""

    def __init__(self):
        super().__init__()

    def transpile(
        self,
        circuits: Union[
            Union[List[str], str], Union[List[QuantumCircuit], QuantumCircuit]
        ],
        optimization_level: int = 1,
        backend: Union[str, None] = None,
        coupling_map: Union[List[List[int]], None] = None,
        ai: Literal[""true"", ""false"", ""auto""] = ""true"",
        qiskit_transpile_options: Dict = None,
        ai_layout_mode: str = None,
    ):
        circuits = circuits if isinstance(circuits, list) else [circuits]

        qasm_circuits = [_input_to_qasm(circ) for circ in circuits]

        json_args = {
            ""qasm_circuits"": qasm_circuits,
        }

        if qiskit_transpile_options is not None:
            json_args[""qiskit_transpile_options""] = qiskit_transpile_options
        if coupling_map is not None:
            json_args[""backend_coupling_map""] = coupling_map

        params = {
            ""backend"": backend,
            ""optimization_level"": optimization_level,
            ""ai"": ai,
        }

        if ai_layout_mode is not None:
            params[""ai_layout_mode""] = ai_layout_mode

        transpile_resp = self.request_and_wait(
            endpoint=""transpile"", body=json_args, params=params
        )

        logger.debug(f""transpile_resp={transpile_resp}"")

        transpiled_circuits = []

        for res, orig_circ in zip(transpile_resp, circuits):
            try:
                transpiled_circuits.append(_get_circuit_from_result(res, orig_circ))
            except Exception as ex:
                logger.error(""Error transforming the result to a QuantumCircuit object"")
                raise

        return (
            transpiled_circuits
            if len(transpiled_circuits) > 1
            else transpiled_circuits[0]
        )

    def benchmark(
        self,
        circuits: Union[
            Union[List[str], str], Union[List[QuantumCircuit], QuantumCircuit]
        ],
        backend: str,
        optimization_level: int = 1,
        qiskit_transpile_options: Dict = None,
    ):
        raise Exception(""Not implemented"")


def _input_to_qasm(input_circ: Union[QuantumCircuit, str]):
    if isinstance(input_circ, QuantumCircuit):
        try:
            qasm = qasm2.dumps(input_circ).replace(""\n"", "" "")
        except QASM2ExportError:
            qasm = qasm3.dumps(input_circ).replace(""\n"", "" "")
    elif isinstance(input_circ, str):
        qasm = input_circ.replace(""\n"", "" "")
    else:
        raise TypeError(""Input circuits must be QuantumCircuit or qasm string."")
    return qasm


def _get_circuit_from_result(transpile_resp, orig_circuit):
    transpiled_circuit = _get_circuit_from_qasm(transpile_resp[""qasm""])

    init_layout = transpile_resp[""layout""][""initial""]
    final_layout = transpile_resp[""layout""][""final""]

    orig_circuit = (
        _get_circuit_from_qasm(orig_circuit)
        if isinstance(orig_circuit, str)
        else orig_circuit
    )

    transpiled_circuit = QuantumCircuit(len(init_layout)).compose(transpiled_circuit)
    transpiled_circuit._layout = _create_transpile_layout(
        init_layout, final_layout, transpiled_circuit, orig_circuit
    )
    return transpiled_circuit


def _create_initial_layout(initial, n_used_qubits):
    """"""Create initial layout using the initial index layout and the number of active qubits.""""""
    total_qubits = len(initial)
    q_total = n_used_qubits
    a_total = total_qubits - q_total
    initial_layout = Layout()
    for q in range(q_total):
        initial_layout.add(initial[q], Qubit(QuantumRegister(q_total, ""q""), q))
    for a in range(q_total, total_qubits):
        initial_layout.add(
            initial[a], Qubit(QuantumRegister(a_total, ""ancilla""), a - q_total)
        )
    return initial_layout


def _create_input_qubit_mapping(qubits_used, total_qubits):
    """"""Create input qubit mapping with the number of active qubits and the total number of qubits.""""""
    input_qubit_mapping = {
        Qubit(QuantumRegister(qubits_used, ""q""), q): q for q in range(qubits_used)
    }
    input_ancilla_mapping = {
        Qubit(
            QuantumRegister(total_qubits - qubits_used, ""ancilla""), q - qubits_used
        ): q
        for q in range(qubits_used, total_qubits)
    }
    input_qubit_mapping.update(input_ancilla_mapping)
    return input_qubit_mapping


def _create_final_layout(initial, final, circuit):
    """"""Create final layout with the initial and final index layout and the circuit.""""""
    final_layout = Layout()
    q_total = len(initial)
    q_reg = QuantumRegister(q_total, ""q"")
    for i, j in zip(final, initial):
        q_index = circuit.find_bit(Qubit(q_reg, j)).index
        qubit = circuit.qubits[q_index]
        final_layout.add(i, qubit)

    return final_layout


def _create_transpile_layout(initial, final, circuit, orig_circuit):
    """"""Build the full transpile layout.""""""
    n_used_qubits = orig_circuit.num_qubits
    return TranspileLayout(
        initial_layout=_create_initial_layout(
            initial=initial, n_used_qubits=n_used_qubits
        ),  # final=final),
        input_qubit_mapping=_create_input_qubit_mapping(
            qubits_used=n_used_qubits, total_qubits=len(initial)
        ),
        final_layout=_create_final_layout(
            initial=initial, final=final, circuit=circuit
        ),
        _input_qubit_count=n_used_qubits,
        _output_qubit_list=circuit.qubits,
    )


def _get_circuit_from_qasm(qasm_string):
    try:
        return qasm2.loads(
            qasm_string,
            custom_instructions=qasm2.LEGACY_CUSTOM_INSTRUCTIONS,
        )
    except QASM2ParseError:
        return qasm3.loads(qasm_string)
"
https://github.com/qiskit-community/qopt-best-practices,qiskit-community,"import json

file = ""data/hardware_native_127.json""
data = json.load(open(file, ""r""))
paulis = data[""paulis""]
num_qubits = len(paulis[0][0])
print(num_qubits)

from qiskit.quantum_info import SparsePauliOp

# define a qiskit SparsePauliOp from the list of paulis
hamiltonian = SparsePauliOp.from_list(paulis)
print(hamiltonian)

from qiskit.circuit.library import QAOAAnsatz

qaoa_circ = QAOAAnsatz(hamiltonian, reps=3)
qaoa_circ.measure_all()
print(qaoa_circ.num_parameters)

from qiskit import transpile

basis_gates = [""rz"", ""sx"", ""x"", ""ecr""]
# Now transpile to sx, rz, x, cx basis
qaoa_circ = transpile(qaoa_circ, basis_gates=basis_gates)
print(""transpilation done"")

from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Options

service = QiskitRuntimeService(channel=""ibm_quantum"")
backend = service.get_backend(""ibm_nazca"")
options = Options()
options.transpilation.skip_transpilation = True
options.execution.shots = 100000

sampler = Sampler(backend=backend, options=options)

import numpy as np

# TQA initialization parameters
dt = 0.75
p = 3  #  3 qaoa layers
grid = np.arange(1, p + 1) - 0.5
init_params = np.concatenate((1 - grid * dt / p, grid * dt / p))
print(init_params)

job = sampler.run(qaoa_circ, init_params)

print(job.job_id())
print(job.result())
"
https://github.com/qiskit-community/qiskit-metriq,qiskit-community,"import os
import pandas as pd
from pyzx import routing
from qiskit import QuantumCircuit, transpile
from qiskit.transpiler import CouplingMap, TranspilerError
from qiskit_versions import *

VERSION = get_installed_version()
PACKAGE_NAME = ""qiskit"" if VERSION == compare_versions(VERSION, ""0.25.3"") else ""qiskit-terra""
SAMPLE_SIZE = 100
ARCHITECTURES = [""ibm_rochester"", ""rigetti_16q_aspen""]
OPTIMIZATION_LEVEL = 3
DATE = get_version_date(PACKAGE_NAME, VERSION)
METHOD = f""{PACKAGE_NAME} {VERSION} compilation""

def run_experiment(qasm_id: str):
  print(f""\nRunning {METHOD} for circuit {qasm_id}\n"")

  qasm_file_path = os.path.abspath(os.path.join( os.path.dirname( __file__ ),"".."", ""benchmarking"",f""{qasm_id}.qasm""))
  circuit = QuantumCircuit.from_qasm_file(qasm_file_path)
  # Transpile for each architecture using pyzx
  for arch in ARCHITECTURES:
    architecture = routing.create_architecture(arch)
    coupling_map = CouplingMap(architecture.graph.edges())
    df = pd.DataFrame(columns=[""Qasm file"",""Method"",""Date"",""Opt level"",""Platform"",""Seed"",""Circuit depth"",""Gate count""])

    for i in range(SAMPLE_SIZE):
      result = None
      while result is None:
          try:
              result = transpile(circuit, coupling_map=coupling_map, optimization_level=OPTIMIZATION_LEVEL,
                                  seed_transpiler=i)
          except TranspilerError:
              i += SAMPLE_SIZE
      results = [f""{qasm_id}.qasm"", METHOD, DATE, OPTIMIZATION_LEVEL,arch,i,result.depth(),sum(result.count_ops().values())]
      df.loc[len(df)] = results

    output_path = os.path.abspath(os.path.join(os.path.dirname( __file__ ),"".."",""benchmarking"",""results"",f""{qasm_id}-qiskit{VERSION}-{arch}.csv""))
    df.to_csv(output_path, sep=""|"")

    print(f""{arch}\n"",
          f""- Circuit depth - ave: {df['Circuit depth'].mean()} | stdev: {df['Circuit depth'].std()}\n"",
          f""- Gate count - ave: {df['Gate count'].mean()} | stdev: {df['Gate count'].std()}"")

run_experiment(""ex1_226"")"
https://github.com/qiskit-community/qiskit-metriq,qiskit-community,"import os
import json
import qiskit
import requests
from datetime import datetime

def get_installed_version():
    try:
        # Starting with qiskit v0.45, qiskit and qiskit-terra will have the same version
        return qiskit.__version__
    except ImportError:
        return qiskit.__qiskit_version__[""qiskit""]

def get_qiskit_releases_data(package_name: str) -> dict:
    response = requests.get(f""https://pypi.org/pypi/{package_name}/json"")
    if response.status_code == 200:
        data = response.json()
        return data[""releases""].items()
    return None

def get_qiskit_versions_info() -> []:
    data_items = get_qiskit_releases_data(""qiskit"")

    # Filter releases starting from 2023-11
    # Starting with qiskit 0.45, qiskit and qiskit-terra will have the same version
    return filter_by_date(data_items, [2023,11], [])

def get_qiskit_terra_versions_info() -> []:
    data_items = get_qiskit_releases_data(""qiskit-terra"")

    # Filter releases from 2020-03 (terra v0.13.x) to 2023-10 (terra v.0.25.x)
    return filter_by_date(data_items,[2020,3], [2023,10])

def get_qiskit_versions_list(package_name: str) -> []:
    qiskit_versions_info = get_qiskit_terra_versions_info() if ""terra"" in package_name else get_qiskit_versions_info()
    versions_only = []
    for item in qiskit_versions_info:
        for key, value in item.items():
            if key == ""version"":
                versions_only.append(value)
    return versions_only

def find_latest_version(versions: []) -> str:
  if not versions:
    return """"
  
  # Split each version string into a tuple of integers
  version_tuples = [tuple(map(int, v.split("".""))) for v in versions]

  # Sort
  sorted_versions = sorted(version_tuples, reverse=True)

  # Convert the latest version tuple back to string
  latest_version = ""."".join(map(str, sorted_versions[0]))
  return latest_version

# Compare versions in string format and return the highest
def compare_versions(version_1:str, version_2: str) -> str:
    # Split version strings into lists of ints
    # Split version strings into lists of ints
    v1_parts = list(map(int, version_1.split(""."")))
    v2_parts = list(map(int, version_2.split(""."")))

    # Compare
    for v1, v2 in zip(v1_parts, v2_parts):
        if v1 > int(v2):
            return version_1
        elif v1 < int(v2):
            return version_2
    return version_1 # if they are the same

def same_minor(version_1: str, version_2: str) -> bool:
    # Split version strings into lists of ints
    v1 = list(map(int, version_1.split(""."")))
    v2 = list(map(int, version_2.split(""."")))

    return v1[:2] == v2[:2]

def filter_by_date(data_items: dict, min_date: [], max_date: []) -> []:
    # Temporary control dictionary for package release info for version, date and python version
    temp = {}

    for release, release_info in data_items:

        # Skip RCs and pre-releases
        if ""rc"" in release or ""b"" in release:
            print(""Skipping version "", release)
            continue
        
        date_str = release_info[0][""upload_time""]
        dt = datetime.strptime(date_str, ""%Y-%m-%dT%H:%M:%S"")
        year = dt.year
        month = dt.month

        if max_date:
            max_y, max_m = max_date
            # Ignore above max_date
            if (year == max_y and month > max_m) or year > max_y:
                continue
    
        min_y, min_m = min_date
        # Ignore below min_date
        if (year == min_y and month < min_m) or year < min_y:
            continue 

        python_version = release_info[0][""requires_python""]

        # Parse the release string of format ""x.y.z"" into a list of ""x"",""y"",""z""
        major_minor_patch_list = release.split(""."")
        major_minor = ""."".join(major_minor_patch_list[:2])

        # Get latest patch
        patch_number = int(major_minor_patch_list[2])
        temp_info = temp.get(major_minor)
        previous_patch_number = -1 if not temp_info else temp_info[0]

        if previous_patch_number < patch_number:
            # Replace to latest patch version found
            temp[major_minor] = (patch_number, {""version"":release, ""date"": dt.strftime(""%Y-%m-%d""), ""python_version"": python_version})
            continue

    filtered_releases = []
    for _, value in temp.items():
        filtered_releases.append(value[1])

    return filtered_releases

def write_versions_to_file(versions: [], filename: str):
    file_path = os.path.abspath(os.path.join( os.path.dirname( __file__ ),"".."", ""benchmarking"", filename))
    with open(file_path,""w"") as file:
        json.dump(versions, file, indent=4)

def get_version_date(package_name: str, input_version:str) -> str:
    data_items = data_items = get_qiskit_releases_data(package_name)
    for release, release_info in data_items:
        if release == input_version:
            # Remove time from date format ""%Y-%m-%dT%H:%M:%S""
            date_time= release_info[0][""upload_time""]
            return date_time.split('T', 1)[0]
    return ""Invalid version""

###
# qiskit_info = get_qiskit_versions_info()
# print(""qiskit versions:"", sep='\n')
# print(*qiskit_info, sep='\n')
""""""
qiskit versions:
{'version': '0.45.0', 'date': '2023-11-03', 'python_version': '>=3.8'}
""""""

# qiskit_terra_info = get_qiskit_terra_versions_info()
# print(""qiskit-terra versions:"", sep='\n')
# print(*qiskit_terra_info, sep='\n')
""""""
qiskit-terra versions:
{'version': '0.13.0', 'date': '2020-04-09', 'python_version': '>=3.5'}
{'version': '0.14.2', 'date': '2020-06-15', 'python_version': '>=3.5'}
{'version': '0.15.2', 'date': '2020-09-08', 'python_version': '>=3.5'}
{'version': '0.16.4', 'date': '2021-02-08', 'python_version': '>=3.6'}
{'version': '0.17.4', 'date': '2021-05-18', 'python_version': '>=3.6'}
{'version': '0.18.3', 'date': '2021-09-29', 'python_version': '>=3.6'}
{'version': '0.19.2', 'date': '2022-02-02', 'python_version': '>=3.6'}
{'version': '0.20.2', 'date': '2022-05-18', 'python_version': '>=3.7'}
{'version': '0.21.2', 'date': '2022-08-23', 'python_version': '>=3.7'}
{'version': '0.22.4', 'date': '2023-01-17', 'python_version': '>=3.7'}
{'version': '0.23.3', 'date': '2023-03-21', 'python_version': '>=3.7'}
{'version': '0.24.2', 'date': '2023-07-19', 'python_version': '>=3.7'}
{'version': '0.25.3', 'date': '2023-10-25', 'python_version': '>=3.8'}
"""""""
https://github.com/qiskit-community/qiskit-device-benchmarking,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
""""""
Mirror RB analysis class.
""""""
from typing import List, Union
import numpy as np
from uncertainties import unumpy as unp
from scipy.spatial.distance import hamming

import qiskit_experiments.curve_analysis as curve
from qiskit_experiments.framework import AnalysisResultData, ExperimentData
from qiskit_experiments.data_processing import DataProcessor
from qiskit_experiments.data_processing.data_action import DataAction
from qiskit_experiments.library.randomized_benchmarking.rb_analysis import RBAnalysis


class MirrorRBAnalysis(RBAnalysis):
    r""""""A class to analyze mirror randomized benchmarking experiment.

    # section: overview
        This analysis takes a series for Mirror RB curve fitting.
        From the fit :math:`\alpha` value this analysis estimates the mean entanglement infidelity (EI)
        and the error per Clifford (EPC), also known as the average gate infidelity (AGI).

        The EPC (AGI) estimate is obtained using the equation

        .. math::

            EPC = \frac{2^n - 1}{2^n}\left(1 - \alpha\right)

        where :math:`n` is the number of qubits (width of the circuit).

        The EI is obtained using the equation

        .. math::

            EI = \frac{4^n - 1}{4^n}\left(1 - \alpha\right)

        The fit :math:`\alpha` parameter can be fit using one of the following three quantities
        plotted on the y-axis:

        Success Probabilities (:math:`p`): The proportion of shots that return the correct bitstring

        Adjusted Success Probabilities (:math:`p_0`):

        .. math::

            p_0 = \sum_{k = 0}^n \left(-\frac{1}{2}\right)^k h_k

        where :math:`h_k` is the probability of observing a bitstring of Hamming distance of k from the
        correct bitstring

        Effective Polarizations (:math:`S`):

        .. math::

            S = \frac{4^n}{4^n-1}\left(\sum_{k=0}^n\left(-\frac{1}{2}\right)^k h_k\right)-\frac{1}{4^n-1}

    # section: fit_model
        The fit is based on the following decay functions:

        .. math::

            F(x) = a \alpha^{x} + b

    # section: fit_parameters
        defpar a:
            desc: Height of decay curve.
            init_guess: Determined by :math:`1 - b`.
            bounds: [0, 1]
        defpar b:
            desc: Base line.
            init_guess: Determined by :math:`(1/2)^n` (for success probability) or :math:`(1/4)^n`
            (for adjusted success probability and effective polarization).
            bounds: [0, 1]
        defpar \alpha:
            desc: Depolarizing parameter.
            init_guess: Determined by :func:`~rb_decay` with standard RB curve.
            bounds: [0, 1]

    # section: reference
        .. ref_arxiv:: 1 2112.09853

    """"""

    @classmethod
    def _default_options(cls):
        """"""Default analysis options.

        Analysis Options:
            analyzed_quantity (str): Set the metric to plot on the y-axis. Must be one of
                ""Effective Polarization"" (default), ""Success Probability"", or ""Adjusted
                Success Probability"".
            gate_error_ratio (Optional[Dict[str, float]]): A dictionary with gate name keys
                and error ratio values used when calculating EPG from the estimated EPC.
                The default value will use standard gate error ratios.
                If you don't know accurate error ratio between your basis gates,
                you can skip analysis of EPGs by setting this options to ``None``.
            epg_1_qubit (List[AnalysisResult]): Analysis results from previous RB experiments
                for individual single qubit gates. If this is provided, EPC of
                2Q RB is corrected to exclude the depolarization of underlying 1Q channels.
        """"""
        default_options = super()._default_options()

        # Set labels of axes
        default_options.plotter.set_figure_options(
            xlabel=""Clifford Length"",
            ylabel=""Effective Polarization"",
        )

        # Plot all (adjusted) success probabilities
        default_options.plot_raw_data = True

        # Exponential decay parameter
        default_options.result_parameters = [""alpha""]

        # Default gate error ratio for calculating EPG
        default_options.gate_error_ratio = ""default""

        # By default, EPG for single qubits aren't set
        default_options.epg_1_qubit = None

        # By default, effective polarization is plotted (see arXiv:2112.09853). We can
        # also plot success probability or adjusted success probability (see PyGSTi).
        # Do this by setting options to ""Success Probability"" or ""Adjusted Success Probability""
        default_options.analyzed_quantity = ""Effective Polarization""

        default_options.set_validator(
            field=""analyzed_quantity"",
            validator_value=[
                ""Success Probability"",
                ""Adjusted Success Probability"",
                ""Effective Polarization"",
            ],
        )

        return default_options

    def _generate_fit_guesses(
        self,
        user_opt: curve.FitOptions,
        curve_data: curve.ScatterTable,
    ) -> Union[curve.FitOptions, List[curve.FitOptions]]:
        """"""Create algorithmic guess with analysis options and curve data.

        Args:
            user_opt: Fit options filled with user provided guess and bounds.
            curve_data: Formatted data collection to fit.

        Returns:
            List of fit options that are passed to the fitter function.
        """"""

        user_opt.bounds.set_if_empty(a=(0, 1), alpha=(0, 1), b=(0, 1))
        num_qubits = len(self._physical_qubits)

        # Initialize guess for baseline and amplitude based on infidelity type
        b_guess = 1 / 4**num_qubits
        if self.options.analyzed_quantity == ""Success Probability"":
            b_guess = 1 / 2**num_qubits

        mirror_curve = curve_data.get_subset_of(""rb_decay"")
        alpha_mirror = curve.guess.rb_decay(mirror_curve.x, mirror_curve.y, b=b_guess)
        a_guess = (curve_data.y[0] - b_guess) / (alpha_mirror ** curve_data.x[0])

        user_opt.p0.set_if_empty(b=b_guess, a=a_guess, alpha=alpha_mirror)

        return user_opt

    def _create_analysis_results(
        self,
        fit_data: curve.CurveFitResult,
        quality: str,
        **metadata,
    ) -> List[AnalysisResultData]:
        """"""Create analysis results for important fit parameters. Besides the
        default standard RB parameters, Entanglement Infidelity (EI) is also calculated.

        Args:
            fit_data: Fit outcome.
            quality: Quality of fit outcome.

        Returns:
            List of analysis result data.
        """"""

        outcomes = super()._create_analysis_results(fit_data, quality, **metadata)
        num_qubits = len(self._physical_qubits)

        # nrb is calculated for both EPC and EI per the equations in the docstring
        ei_nrb = 4**num_qubits
        ei_scale = (ei_nrb - 1) / ei_nrb
        ei = ei_scale * (1 - fit_data.ufloat_params[""alpha""])

        outcomes.append(
            AnalysisResultData(
                name=""EI"", value=ei, chisq=fit_data.reduced_chisq, quality=quality, extra=metadata
            )
        )

        return outcomes

    def _initialize(self, experiment_data: ExperimentData):
        """"""Initialize curve analysis by setting up the data processor for Mirror
        RB data.

        Args:
            experiment_data: Experiment data to analyze.
        """"""
        super()._initialize(experiment_data)

        num_qubits = len(self._physical_qubits)
        target_bs = []
        for circ_result in experiment_data.data():
            if circ_result[""metadata""][""inverting_pauli_layer""] is True:
                target_bs.append(""0"" * num_qubits)
            else:
                target_bs.append(circ_result[""metadata""][""target""])

        self.set_options(
            data_processor=DataProcessor(
                input_key=""counts"",
                data_actions=[
                    _ComputeQuantities(
                        analyzed_quantity=self.options.analyzed_quantity,
                        num_qubits=num_qubits,
                        target_bs=target_bs,
                    )
                ],
            )
        )


class _ComputeQuantities(DataAction):
    """"""Data processing node for computing useful mirror RB quantities from raw results.""""""

    def __init__(
        self,
        num_qubits,
        target_bs,
        analyzed_quantity: str = ""Effective Polarization"",
        validate: bool = True,
    ):
        """"""
        Args:
            num_qubits: Number of qubits.
            quantity: The quantity to calculate.
            validate: If set to False the DataAction will not validate its input.
        """"""
        super().__init__(validate)
        self._num_qubits = num_qubits
        self._analyzed_quantity = analyzed_quantity
        self._target_bs = target_bs

    def _process(self, data: np.ndarray):
        # Arrays to store the y-axis data and uncertainties
        y_data = []
        y_data_unc = []

        for i, circ_result in enumerate(data):
            target_bs = self._target_bs[i]

            # h[k] = proportion of shots that are Hamming distance k away from target bitstring
            hamming_dists = np.zeros(self._num_qubits + 1)
            success_prob = 0.0
            success_prob_unc = 0.0
            for bitstring, count in circ_result.items():
                # Compute success probability
                if self._analyzed_quantity == ""Success Probability"":
                    if bitstring == target_bs:
                        success_prob = count / sum(circ_result.values())
                        success_prob_unc = np.sqrt(success_prob * (1 - success_prob))
                        break
                else:  
                    # Compute hamming distance proportions
                    target_bs_to_list = [int(char) for char in target_bs]
                    actual_bs_to_list = [int(char) for char in bitstring]
                    k = int(round(hamming(target_bs_to_list, actual_bs_to_list) * self._num_qubits))
                    hamming_dists[k] += count / sum(circ_result.values())

            if self._analyzed_quantity == ""Success Probability"":
                y_data.append(success_prob)
                y_data_unc.append(success_prob_unc)
                continue

            # Compute hamming distance uncertainties
            hamming_dist_unc = np.sqrt(hamming_dists * (1 - hamming_dists))

            # Compute adjusted success probability and standard deviation
            adjusted_success_prob = 0.0
            adjusted_success_prob_unc = 0.0
            for k in range(self._num_qubits + 1):
                adjusted_success_prob += (-0.5) ** k * hamming_dists[k]
                adjusted_success_prob_unc += (0.5) ** k * hamming_dist_unc[k] ** 2
            adjusted_success_prob_unc = np.sqrt(adjusted_success_prob_unc)
            if self._analyzed_quantity == ""Adjusted Success Probability"":
                y_data.append(adjusted_success_prob)
                y_data_unc.append(adjusted_success_prob_unc)

            # Compute effective polarization and standard deviation (arXiv:2112.09853v1)
            pol_factor = 4**self._num_qubits
            pol = pol_factor / (pol_factor - 1) * adjusted_success_prob - 1 / (pol_factor - 1)
            pol_unc = np.sqrt(pol_factor / (pol_factor - 1)) * adjusted_success_prob_unc
            if self._analyzed_quantity == ""Effective Polarization"":
                y_data.append(pol)
                y_data_unc.append(pol_unc)

        return unp.uarray(y_data, y_data_unc)
"
https://github.com/qiskit-community/qiskit-device-benchmarking,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2024.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
""""""
Purity RB analysis class.
""""""

from typing import List, Dict, Union

from qiskit.result import sampled_expectation_value

from qiskit_experiments.curve_analysis import ScatterTable
import qiskit_experiments.curve_analysis as curve
from qiskit_experiments.framework import AnalysisResultData
from qiskit_experiments.library.randomized_benchmarking import RBAnalysis
from qiskit_experiments.library.randomized_benchmarking.rb_analysis import (_calculate_epg, 
                                                                            _exclude_1q_error)


class PurityRBAnalysis(RBAnalysis):
    r""""""A class to analyze purity randomized benchmarking experiments. 

    # section: overview
        This analysis takes only single series.
        This series is fit by the exponential decay function.
        From the fit :math:`\alpha` value this analysis estimates the error per Clifford (EPC).

        When analysis option ``gate_error_ratio`` is provided, this analysis also estimates
        errors of individual gates assembling a Clifford gate.
        In computation of two-qubit EPC, this analysis can also decompose
        the contribution from the underlying single qubit depolarizing channels when
        ``epg_1_qubit`` analysis option is provided [1].

    # section: fit_model
        .. math::

            F(x) = a \alpha^x + b

    # section: fit_parameters
        defpar a:
            desc: Height of decay curve.
            init_guess: Determined by :math:`1 - b`.
            bounds: [0, 1]
        defpar b:
            desc: Base line.
            init_guess: Determined by :math:`(1/2)^n` where :math:`n` is number of qubit.
            bounds: [0, 1]
        defpar \alpha:
            desc: Depolarizing parameter.
            init_guess: Determined by :func:`~.guess.rb_decay`.
            bounds: [0, 1]

    # section: reference
        .. ref_arxiv:: 1 1712.06550

    """"""

    def __init__(self):
        super().__init__()


    def _run_data_processing(
        self,
        raw_data: List[Dict],
        category: str = ""raw"",
    ) -> ScatterTable:
        """"""Perform data processing from the experiment result payload.

        For purity this converts the counts into Trace(rho^2) and then runs the 
        rest of the standard RB fitters

        For now this does it by spoofing a new counts dictionary and then
        calling the super _run_data_processing

        Args:
            raw_data: Payload in the experiment data.
            category: Category string of the output dataset.

        Returns:
            Processed data that will be sent to the formatter method.

        Raises:
            DataProcessorError: When key for x values is not found in the metadata.
            ValueError: When data processor is not provided.
        """"""

        #figure out the number of qubits... has to be 1 or 2 for now
        if self.options.outcome=='0':
            nq=1
        elif self.options.outcome=='00':
            nq=2
        else:
            raise ValueError(""Only supporting 1 or 2Q purity"")

        ntrials = int(len(raw_data)/3**nq)
        raw_data2 = []
        nshots = int(sum(raw_data[0]['counts'].values()))

        for i in range(ntrials):
            trial_raw = [d for d in raw_data if d[""metadata""][""trial""]==i]

            raw_data2.append(trial_raw[0])

            purity = 1/2**nq
            if nq==1:
                for ii in range(3):
                    purity += sampled_expectation_value(trial_raw[ii]['counts'],'Z')**2/2**nq
            else:
                for ii in range(9):
                    purity += sampled_expectation_value(trial_raw[ii]['counts'],'ZZ')**2/2**nq
                    purity += sampled_expectation_value(trial_raw[ii]['counts'],'IZ')**2/2**nq/3**(nq-1)
                    purity += sampled_expectation_value(trial_raw[ii]['counts'],'ZI')**2/2**nq/3**(nq-1)

            raw_data2[-1]['counts'] = {'0'*nq: int(purity*nshots*10),'1'*nq: int((1-purity)*nshots*10)} 
                        
        return super()._run_data_processing(raw_data2,category)


    def _create_analysis_results(
        self,
        fit_data: curve.CurveFitResult,
        quality: str,
        **metadata,
    ) -> List[AnalysisResultData]:
        """"""Create analysis results for important fit parameters.

        Args:
            fit_data: Fit outcome.
            quality: Quality of fit outcome.

        Returns:
            List of analysis result data.
        """"""
        outcomes = curve.CurveAnalysis._create_analysis_results(self, fit_data, quality, **metadata)
        num_qubits = len(self._physical_qubits)

        # Calculate EPC
        # For purity we need to correct by 
        alpha = fit_data.ufloat_params[""alpha""]**0.5
        scale = (2**num_qubits - 1) / (2**num_qubits)
        epc = scale * (1 - alpha)

        outcomes.append(
            AnalysisResultData(
                name=""EPC"",
                value=epc,
                chisq=fit_data.reduced_chisq,
                quality=quality,
                extra=metadata,
            )
        )

        # Correction for 1Q depolarizing channel if EPGs are provided
        if self.options.epg_1_qubit and num_qubits == 2:
            epc = _exclude_1q_error(
                epc=epc,
                qubits=self._physical_qubits,
                gate_counts_per_clifford=self._gate_counts_per_clifford,
                extra_analyses=self.options.epg_1_qubit,
            )
            outcomes.append(
                AnalysisResultData(
                    name=""EPC_corrected"",
                    value=epc,
                    chisq=fit_data.reduced_chisq,
                    quality=quality,
                    extra=metadata,
                )
            )

        # Calculate EPG
        if self._gate_counts_per_clifford is not None and self.options.gate_error_ratio:
            epg_dict = _calculate_epg(
                epc=epc,
                qubits=self._physical_qubits,
                gate_error_ratio=self.options.gate_error_ratio,
                gate_counts_per_clifford=self._gate_counts_per_clifford,
            )
            if epg_dict:
                for gate, epg_val in epg_dict.items():
                    outcomes.append(
                        AnalysisResultData(
                            name=f""EPG_{gate}"",
                            value=epg_val,
                            chisq=fit_data.reduced_chisq,
                            quality=quality,
                            extra=metadata,
                        )
                    )

        return outcomes
    
    def _generate_fit_guesses(
        self,
        user_opt: curve.FitOptions,
        curve_data: curve.ScatterTable,
    ) -> Union[curve.FitOptions, List[curve.FitOptions]]:
        """"""Create algorithmic initial fit guess from analysis options and curve data.

        Args:
            user_opt: Fit options filled with user provided guess and bounds.
            curve_data: Formatted data collection to fit.

        Returns:
            List of fit options that are passed to the fitter function.
        """"""
        user_opt.bounds.set_if_empty(
            a=(0, 1),
            alpha=(0, 1),
            b=(0, 1),
        )

        b_guess = 1 / 2 ** len(self._physical_qubits)
        if len(curve_data.x)>3:
            alpha_guess = curve.guess.rb_decay(curve_data.x[0:3], curve_data.y[0:3], b=b_guess)
        else:
            alpha_guess = curve.guess.rb_decay(curve_data.x, curve_data.y, b=b_guess)
            
        alpha_guess = alpha_guess**2
        
        if alpha_guess < 0.6:
            a_guess = (curve_data.y[0] - b_guess)
        else:
            a_guess = (curve_data.y[0] - b_guess) / (alpha_guess ** curve_data.x[0])
            
        user_opt.p0.set_if_empty(
            b=b_guess,
            a=a_guess,
            alpha=alpha_guess,
        )

        return user_opt
"
https://github.com/qiskit-community/qiskit-device-benchmarking,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2024.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
""""""
Purity RB Experiment class.
""""""

import numpy as np
from numpy.random import Generator
from numpy.random.bit_generator import BitGenerator, SeedSequence
from numbers import Integral
from typing import Union, Iterable, Optional, List, Sequence

from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford
from qiskit.providers.backend import Backend
from qiskit.circuit import CircuitInstruction, Barrier
from qiskit_experiments.library.randomized_benchmarking import StandardRB

SequenceElementType = Union[Clifford, Integral, QuantumCircuit]

from .purrb_analysis import PurityRBAnalysis

class PurityRB(StandardRB):
    """"""An experiment to characterize the error rate of a gate set on a device.
    using purity RB

    # section: overview

    Randomized Benchmarking (RB) is an efficient and robust method
    for estimating the average error rate of a set of quantum gate operations.
    See `Qiskit Textbook
    <https://github.com/Qiskit/textbook/blob/main/notebooks/quantum-hardware/randomized-benchmarking.ipynb>`_
    for an explanation on the RB method.

    A standard RB experiment generates sequences of random Cliffords
    such that the unitary computed by the sequences is the identity.
    After running the sequences on a backend, it calculates the probabilities to get back to
    the ground state, fits an exponentially decaying curve, and estimates
    the Error Per Clifford (EPC), as described in Refs. [1, 2].

    .. note::
        In 0.5.0, the default value of ``optimization_level`` in ``transpile_options`` changed
        from ``0`` to ``1`` for RB experiments. That may result in shorter RB circuits
        hence slower decay curves than before.

    # section: analysis_ref
        :class:`RBAnalysis`

    # section: manual
        :doc:`/manuals/verification/randomized_benchmarking`

    # section: reference
        .. ref_arxiv:: 1 1009.3639
        .. ref_arxiv:: 2 1109.6887
    """"""

    def __init__(
        self,
        physical_qubits: Sequence[int],
        lengths: Iterable[int],
        backend: Optional[Backend] = None,
        num_samples: int = 3,
        seed: Optional[Union[int, SeedSequence, BitGenerator, Generator]] = None,
        full_sampling: Optional[bool] = False,
    ):
        """"""Initialize a standard randomized benchmarking experiment.

        Args:
            physical_qubits: List of physical qubits for the experiment.
            lengths: A list of RB sequences lengths.
            backend: The backend to run the experiment on.
            num_samples: Number of samples to generate for each sequence length.
            seed: Optional, seed used to initialize ``numpy.random.default_rng``.
                  when generating circuits. The ``default_rng`` will be initialized
                  with this seed value every time :meth:`circuits` is called.
            full_sampling: If True all Cliffords are independently sampled for all lengths.
                           If False for sample of lengths longer sequences are constructed
                           by appending additional samples to shorter sequences.
                           The default is False.

        Raises:
            QiskitError: If any invalid argument is supplied.
        """"""
        # Initialize base experiment (RB)
        super().__init__(physical_qubits, lengths, backend, num_samples, seed, full_sampling)

        #override the analysis
        self.analysis = PurityRBAnalysis()
        self.analysis.set_options(outcome=""0"" * self.num_qubits)
        self.analysis.plotter.set_figure_options(
                    xlabel=""Clifford Length"",
                    ylabel=""Purity"",
                )


    def circuits(self) -> List[QuantumCircuit]:
        """"""Return a list of RB circuits.

        Returns:
            A list of :class:`QuantumCircuit`.
        """"""
        # Sample random Clifford sequences
        sequences = self._sample_sequences()
        # Convert each sequence into circuit and append the inverse to the end.
        # and the post-rotations
        circuits = self._sequences_to_circuits(sequences)
        # Add metadata for each circuit
        # trial links all from the same trial
        # needed for post processing the purity RB 
        for circ_i, circ in enumerate(circuits):
            circ.metadata = {
                ""xval"": len(sequences[int(circ_i/3**self.num_qubits)]),
                ""trial"": int(circ_i/3**self.num_qubits),
                ""group"": ""Clifford"",
            }
        return circuits


    def _sequences_to_circuits(
        self, sequences: List[Sequence[SequenceElementType]]
    ) -> List[QuantumCircuit]:
        """"""Convert an RB sequence into circuit and append the inverse to the end and
        then the post rotations for purity RB

        Returns:
            A list of purity RB circuits.
        """"""
        synthesis_opts = self._get_synthesis_options()

        #post rotations as cliffords
        post_rot = []
        for i in range(3**self.num_qubits):
            ##find clifford
            qc = QuantumCircuit(self.num_qubits)
            for j in range(self.num_qubits):
                qg_ind = np.mod(int(i/3**j),3)
                if qg_ind==1:
                    qc.sx(j)
                elif qg_ind==2:
                    qc.sdg(j)
                    qc.sx(j)
                    qc.s(j)
                    
            post_rot.append(self._to_instruction(Clifford(qc), synthesis_opts))
        
        # Circuit generation
        circuits = []
        for i, seq in enumerate(sequences):
            if (
                self.experiment_options.full_sampling
                or i % len(self.experiment_options.lengths) == 0
            ):
                prev_elem, prev_seq = self._StandardRB__identity_clifford(), []

            circ = QuantumCircuit(self.num_qubits)
            for elem in seq:
                circ.append(self._to_instruction(elem, synthesis_opts), circ.qubits)
                circ._append(CircuitInstruction(Barrier(self.num_qubits), circ.qubits))

            # Compute inverse, compute only the difference from the previous shorter sequence
            prev_elem = self._StandardRB__compose_clifford_seq(prev_elem, seq[len(prev_seq) :])
            prev_seq = seq
            inv = self._StandardRB__adjoint_clifford(prev_elem)

            circ.append(self._to_instruction(inv, synthesis_opts), circ.qubits)

            #copy the circuit and apply post rotations
            for j in range(3**self.num_qubits):
                circ2 = circ.copy()
                circ2.append(post_rot[j], circ.qubits)
                circ2.measure_all()  # includes insertion of the barrier before measurement
                circuits.append(circ2)
                
        return circuits"
https://github.com/qiskit-community/qiskit-device-benchmarking,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2024.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
""""""
Analyze the benchmarking results
""""""

import argparse
import numpy as np
import qiskit_device_benchmarking.utilities.file_utils as fu
import matplotlib.pyplot as plt


def generate_plot(out_data, config_data, args):
    
    """"""Generate a plot from the fast_bench data
    
    Generates a plot of the name result_plot_<XXX>.pdf where XXX is the 
    current date and time

    Args:
        out_data: data from the run
        config_data: configuration data from the run
        args: arguments passed to the parser

    Returns:
        None
    """"""
    
    markers = ['o','x','.','s','^','v','*']
    
    for i, backend in enumerate(out_data):
        plt.semilogy(out_data[backend][0],out_data[backend][1], label=backend, marker=markers[np.mod(i,len(markers))])
        
    plt.legend()
    plt.xlabel('Depth')
    plt.ylabel('Success Probability (%s over sets)'%args.value)
    plt.ylim(top=1.0)
    plt.title('Running Mirror - HE: %s, DD: %s, Trials: %d'%(config_data['he'],
                                                             config_data['dd'],
                                                             config_data['trials']))
    plt.grid(True)
    plt.savefig('result_plot_%s.pdf'%fu.timestamp_name())
    plt.close()
    
    return


if __name__ == '__main__':
    
    """"""Analyze a benchmarking run from `fast_bench.py`

    Args:
        Call -h for arguments

    """"""
    
    parser = argparse.ArgumentParser(description = 'Analyze the results of a '
                                     + 'benchmarking run.')
    parser.add_argument('-f', '--files', help='Comma separated list of files')
    parser.add_argument('-b', '--backends', help='Comma separated list of '
                        + 'backends to plot. If empty plot all.')
    parser.add_argument('-v', '--value', help='Statistical value to compute', 
                        choices=['mean','median', 'max', 'min'], default='mean')
    parser.add_argument('--plot', help='Generate a plot', action='store_true')
    args = parser.parse_args()
    
    #import from results files and concatenate into a larger results
    results_dict = {}
    for file in args.files.split(','):
        results_dict_new = fu.import_yaml(file)
        
        for backend in results_dict_new:
            
            if backend not in results_dict:
                results_dict[backend] = results_dict_new[backend]
            elif backend!='config':
                #backend in the results dict but maybe not that depth
                for depth in results_dict_new[backend]:
                    if depth in results_dict[backend]:
                        err_str = 'Depth %s already exists for backend %s, duplicate results'%(depth,backend)
                        raise ValueError(err_str)
                    else:
                        
                        #check the metadata is the same
                        #TO DO
                        
                        results_dict[backend][depth] = results_dict_new[backend][depth]
                        
                        
    if args.backends is not None:                    
        backends_filt = args.backends.split(',')
    else:
        backends_filt = []
    
    out_data = {}
    
    
    for backend in results_dict:
            
        if len(backends_filt)>0:
            if backend not in backends_filt:
                continue
        
        if backend=='config':
            continue
        print(backend)
        depth_list = []
        depth_list_i = []
        
        out_data[backend] = []
        
        for depth in results_dict[backend]:
            if depth=='job_ids':
                continue
            depth_list_i.append(depth)
            if args.value=='mean':
                depth_list.append(np.mean(results_dict[backend][depth]['mean']))
            elif args.value=='max':
                depth_list.append(np.max(results_dict[backend][depth]['mean']))
            elif args.value=='min':
                depth_list.append(np.min(results_dict[backend][depth]['mean']))
            else:
                depth_list.append(np.median(results_dict[backend][depth]['mean']))
            
        print('Backend %s'%backend)
        print('Depths: %s'%depth_list_i)
        
        if args.value=='mean':
            print('Means: %s'%depth_list)
        elif args.value=='max':
            print('Max: %s'%depth_list)
        elif args.value=='min':
            print('Min: %s'%depth_list)
        else:
            print('Median: %s'%depth_list)
        
        out_data[backend].append(depth_list_i)
        out_data[backend].append(depth_list)
            
            
    if args.plot:
        
        generate_plot(out_data, results_dict['config'], args)
        
    elif args.plot:
        print('Need to run mean/max also')
            
            
            
    
    
"
https://github.com/qiskit-community/qiskit-device-benchmarking,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2024.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
""""""
Analyze the fast_count results
""""""

import argparse
import numpy as np
import qiskit_device_benchmarking.utilities.file_utils as fu
import matplotlib.pyplot as plt


def generate_plot(out_data, degree_data, args):
    
    """"""Generate a bar plot of the qubit numbers of each backend
    
    Generates a plot of the name count_plot_<XXX>.pdf where XXX is the 
    current date and time

    Args:
        out_data: data from the run (count data)
        degree_data: average degree
        args: arguments passed to the parser

    Returns:
        None
    """"""
    
    count_data = np.array([out_data[i] for i in out_data])
    degree_data = np.array([degree_data[i] for i in out_data])
    backend_lbls = np.array([i for i in out_data])
    sortinds = np.argsort(count_data)
    
    plt.bar(backend_lbls[sortinds], count_data[sortinds])
    plt.xticks(rotation=45, ha='right')
    
    ax1 = plt.gca()
    ax2 = ax1.twinx()
    ax2.plot(range(len(sortinds)),degree_data[sortinds],marker='x', color='black')
    
    
        
    plt.xlabel('Backend')
    plt.grid(axis='y')
    ax1.set_ylabel('Largest Connected Region')
    ax2.set_ylabel('Average Degree')
    plt.title('CHSH Test on Each Edge to Determine Qubit Count')
    plt.savefig('count_plot_%s.pdf'%fu.timestamp_name(),bbox_inches='tight')
    plt.close()
    
    return


if __name__ == '__main__':
    
    """"""Analyze a benchmarking run from `fast_bench.py`

    Args:
        Call -h for arguments

    """"""
    
    parser = argparse.ArgumentParser(description = 'Analyze the results of a '
                                     + 'benchmarking run.')
    parser.add_argument('-f', '--files', help='Comma separated list of files')
    parser.add_argument('-b', '--backends', help='Comma separated list of '
                        + 'backends to plot. If empty plot all.')
    parser.add_argument('--plot', help='Generate a plot', action='store_true')
    args = parser.parse_args()
    
    #import from results files and concatenate into a larger results
    results_dict = {}
    for file in args.files.split(','):
        results_dict_new = fu.import_yaml(file)
        
        for backend in results_dict_new:
            
            if backend not in results_dict:
                results_dict[backend] = results_dict_new[backend]
            elif backend!='config':
                #backend in the results dict but maybe not that depth
                
                err_str = 'Backend %s already exists, duplicate results'%(backend)
                raise ValueError(err_str)
                    
                        
                        
    if args.backends is not None:                    
        backends_filt = args.backends.split(',')
    else:
        backends_filt = []
    
    count_data = {}
    degree_data = {}
    
    
    for backend in results_dict:
            
        if len(backends_filt)>0:
            if backend not in backends_filt:
                continue
        
        if backend=='config':
            continue
        
        
       
        count_data[backend] = results_dict[backend]['largest_region']
        degree_data[backend] = results_dict[backend]['average_degree']
        print('Backend %s, Largest Connected Region: %d'%(backend,count_data[backend]))
        print('Backend %s, Average Degree: %f'%(backend,degree_data[backend]))
    
    
    
    if args.plot:
        
        generate_plot(count_data, degree_data, args)
        
    elif args.plot:
        print('Need to run mean/max also')
            
            
            
    
    
"
https://github.com/qiskit-community/qiskit-device-benchmarking,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2024.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
""""""
Fast benchmark via mirror circuits
""""""

import argparse
import numpy as np
import rustworkx as rx
from qiskit_ibm_provider import IBMProvider
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.transpiler import Target, CouplingMap
from qiskit_experiments.framework import (ParallelExperiment, BatchExperiment)


import qiskit_device_benchmarking.utilities.file_utils as fu
import qiskit_device_benchmarking.utilities.graph_utils as gu
from  qiskit_device_benchmarking.bench_code.mrb import MirrorQuantumVolume

def run_bench(hgp, backends, depths=[8], trials=10, 
              nshots=100, he=True, dd=True, opt_level=3, act_name=''):
    
    """"""Run a benchmarking test (mirror QV) on a set of devices

    Args:
        hgp: hub/group/project
        backends: list of backends
        depths: list of mirror depths (square circuits)
        trials: number of randomizations
        nshots: number of shots
        he: hardware efficient True/False (False is original QV circ all to all,
                                           True assumes a line)
        dd: add dynamic decoupling
        opt_level: optimization level of the transpiler
        act_name: account name to be passed to the runtime service

    Returns:
        flat list of lists of qubit chains
    """"""
    
    #load the service
    service = QiskitRuntimeService(name=act_name)
    job_list = []
    result_dict = {}
    result_dict['config'] = {'hgp': hgp, 'depths': depths, 
                             'trials': trials, 
                             'nshots': nshots, 
                             'dd': dd,
                             'he': he,
                              'pregenerated': False,
                              'opt_level': opt_level,
                              'act_name': act_name}
    
    
    print('Running Fast Bench with options %s'%result_dict['config'])
    
    #run all the circuits
    for backend in backends:
        print('Loading backend %s'%backend)
        result_dict[backend] = {}
        backend_real=service.backend(backend,instance=hgp)
        mqv_exp_list_d = []
        for depth in depths:
    
            print('Generating Depth %d Circuits for Backend %s'%(depth, backend))
            
            result_dict[backend][depth] = {}
            
    
            #compute the sets for this 
            #NOTE: I want to replace this with fixed sets from 
            #a config file!!!
            nq = backend_real.configuration().n_qubits
            coupling_map = backend_real.configuration().coupling_map
            G = gu.build_sys_graph(nq, coupling_map)
            paths = rx.all_pairs_all_simple_paths(G,depth,depth)
            paths = gu.paths_flatten(paths)
            new_sets = gu.get_separated_sets(G,paths,min_sep=2,nsets=1)
    
            mqv_exp_list = []
            
            result_dict[backend][depth]['sets'] = new_sets[0]
            
            
            #Construct mirror QV circuits on each parallel set
            for qset in new_sets[0]:
                
                #generate the circuits
                mqv_exp = MirrorQuantumVolume(qubits=qset,backend=backend_real,trials=trials,
                                      pauli_randomize=True, he = he)
        
    
                mqv_exp.analysis.set_options(plot=False, 
                                             calc_hop=False,
                                             analyzed_quantity='Success Probability')
                
                #Do this so it won't compile outside the qubit sets
                cust_map = []
                for i in coupling_map:
                    if i[0] in qset and i[1] in qset:
                        cust_map.append(i)
                
                cust_target = Target.from_configuration(basis_gates = backend_real.configuration().basis_gates,
                                                       num_qubits=nq,
                                                       coupling_map=CouplingMap(cust_map))
                
                mqv_exp.set_transpile_options(target=cust_target, optimization_level=opt_level)
                mqv_exp_list.append(mqv_exp)
            
                
            new_exp_mqv = ParallelExperiment(mqv_exp_list, backend=backend_real, flatten_results=False)
            if dd:
                #this forces the circuits to have DD on them
                print('Transpiling and DD')
                for i in mqv_exp_list:
                    i.dd_circuits()
                
            
            mqv_exp_list_d.append(new_exp_mqv)
            
        new_exp_mqv = BatchExperiment(mqv_exp_list_d, backend=backend_real, flatten_results=False)
        new_exp_mqv.set_run_options(shots=nshots)
        job_list.append(new_exp_mqv.run())
        result_dict[backend]['job_ids'] = job_list[-1].job_ids
        
        
    #get the jobs back
    for i, backend in enumerate(backends):
        
        print('Loading results for backend: %s'%backend)
        
        expdata = job_list[i]
        try:
            expdata.block_for_results()
        except:
            #remove backend from results
            print('Error loading backend %s results'%backend)
            result_dict.pop(backend)
            continue
        
        for j, depth in enumerate(depths):
    
            result_dict[backend][depth]['data'] = []
            result_dict[backend][depth]['mean'] = []
            result_dict[backend][depth]['std'] = []
    
            for k in range(len(result_dict[backend][depth]['sets'])):
    
                result_dict[backend][depth]['data'].append([float(probi) for probi in list(expdata.child_data()[j].child_data()[k].artifacts()[0].data)])
                result_dict[backend][depth]['mean'].append(float(np.mean(result_dict[backend][depth]['data'][-1])))
                result_dict[backend][depth]['std'].append(float(np.std(result_dict[backend][depth]['data'][-1])))

    fu.export_yaml('MQV_' + fu.timestamp_name() + '.yaml', result_dict)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description = 'Run fast benchmark of '
                                     + 'devices using mirror. Specify a config '
                                     +' yaml and override settings on the command line')
    parser.add_argument('-c', '--config', help='config file name', 
                        default='config.yaml')
    parser.add_argument('-b', '--backend', help='Specify backend and override '
                        + 'backend_group')
    parser.add_argument('-bg', '--backend_group', 
                        help='specify backend group in config file', 
                        default='backends')
    parser.add_argument('--hgp', help='specify hgp')
    parser.add_argument('--he', help='Hardware efficient', action='store_true')
    parser.add_argument('--name', help='Account name', default='')
    args = parser.parse_args()
    
    #import from config
    config_dict = fu.import_yaml(args.config)
    print('Config File Found')
    print(config_dict)
    
    #override from the command line
    if args.backend is not None:
        backends = [args.backend]
    else:
        backends = config_dict[args.backend_group]
        
    if args.hgp is not None:
        hgp = args.hgp
    else:
        hgp = config_dict['hgp']
        
    if args.he is True:
        he = True
    else:
        he = config_dict['he']
        
    opt_level = config_dict['opt_level']
    dd = config_dict['dd']
    depths = config_dict['depths']
    trials = config_dict['trials']
    nshots = config_dict['shots']
        
    #print(hgp, backends, he, opt_level, dd, depths, trials, nshots)
    
    run_bench(hgp, backends, depths=depths, trials=trials, 
              nshots=nshots, he=he, dd=dd, opt_level=opt_level, act_name=args.name)
"
https://github.com/qiskit-community/qiskit-device-benchmarking,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2024.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
""""""
Fast benchmark of qubit count using the CHSH inequality
""""""

import argparse
import rustworkx as rx
import networkx as nx
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_experiments.framework import (ParallelExperiment, BatchExperiment)

import qiskit_device_benchmarking.utilities.file_utils as fu
import qiskit_device_benchmarking.utilities.graph_utils as gu
from  qiskit_device_benchmarking.bench_code.bell import CHSHExperiment

def run_count(hgp, backends, nshots=100, act_name=''):
    
    """"""Run a chsh inequality on a number of devices

    Args:
        hgp: hub/group/project
        backends: list of backends
        nshots: number of shots
        act_name: account name to be passed to the runtime service

    Returns:
        flat list of all the edges
    """"""
    
    #load the service
    service = QiskitRuntimeService(name=act_name)
    job_list = []
    result_dict = {}
    result_dict['config'] = {'hgp': hgp,  
                             'nshots': nshots, 
                              'act_name': act_name}
    
    
    print('Running Fast Count with options %s'%result_dict['config'])
    
    #run all the circuits
    for backend in backends:
        print('Loading backend %s'%backend)
        result_dict[backend] = {}
        backend_real=service.backend(backend,instance=hgp)
        chsh_exp_list_b = []
        

        #compute the sets for this 
        #NOTE: I want to replace this with fixed sets from 
        #a config file!!!
        nq = backend_real.configuration().n_qubits
        coupling_map = backend_real.configuration().coupling_map
        #build a set of gates
        G = gu.build_sys_graph(nq, coupling_map)
        #get all length 2 paths in the device
        paths = rx.all_pairs_all_simple_paths(G,2,2)
        #flatten those paths into a list from the rustwork x iterator
        paths = gu.paths_flatten(paths)
        #remove permutations
        paths = gu.remove_permutations(paths)
        #convert to the coupling map of the device
        paths = gu.path_to_edges(paths,coupling_map)
        #make into separate sets
        sep_sets = gu.get_separated_sets(G, paths, min_sep=2)

        
        
        result_dict[backend]['sets'] = sep_sets
        
        
        #Construct mirror QV circuits on each parallel set
        for qsets in sep_sets:
            
            chsh_exp_list = []
            
            for qset in qsets:    
                
                #generate the circuits
                chsh_exp = CHSHExperiment(physical_qubits=qset,backend=backend_real)
        
    
                chsh_exp.set_transpile_options(optimization_level=1)
                chsh_exp_list.append(chsh_exp)
        
            
            new_exp_chsh = ParallelExperiment(chsh_exp_list, 
                                             backend=backend_real, 
                                             flatten_results=False)
            
            chsh_exp_list_b.append(new_exp_chsh)
        
        new_exp_chsh = BatchExperiment(chsh_exp_list_b, backend=backend_real, 
                                      flatten_results=False)
        
        new_exp_chsh.set_run_options(shots=nshots)
        job_list.append(new_exp_chsh.run())
        result_dict[backend]['job_ids'] = job_list[-1].job_ids
        
        
    #get the jobs back
    for i, backend in enumerate(backends):
        
        print('Loading results for backend: %s'%backend)
        
        expdata = job_list[i]
        try:
            expdata.block_for_results()
        except:
            #remove backend from results
            print('Error loading backend %s results'%backend)
            result_dict.pop(backend)
            continue
        
        result_dict[backend]['chsh_values'] = {}
        
        for qsets_i, qsets in enumerate(result_dict[backend]['sets']):
                        
            for qset_i, qset in enumerate(qsets): 
                
                
                anal_res = expdata.child_data()[qsets_i].child_data()[qset_i].analysis_results()[0]
                qedge = '%d_%d'%(anal_res.device_components[0].index,anal_res.device_components[1].index)
                result_dict[backend]['chsh_values'][qedge] = anal_res.value
            
    
        #calculate number of connected qubits
        G = nx.Graph()

        #add all possible edges
        for i in result_dict[backend]['chsh_values']:
            if result_dict[backend]['chsh_values'][i]>=2:
                G.add_edge(int(i.split('_')[0]),int(i.split('_')[1]))
                
                
        #catch error if the graph is empty
        try:
            largest_cc = max(nx.connected_components(G), key=len)
            
            #look at the average degree of the largest region
            avg_degree = 0
            for i in largest_cc:
                avg_degree += nx.degree(G,i)
            
            avg_degree = avg_degree/len(largest_cc)
            
        except:
            
            largest_cc = {}
            avg_degree = 1
            
        

        result_dict[backend]['largest_region'] = len(largest_cc)
        result_dict[backend]['average_degree'] = avg_degree


        

      
    fu.export_yaml('CHSH_' + fu.timestamp_name() + '.yaml', result_dict)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description = 'Run fast benchmark of '
                                     + 'qubit count using chsh. Specify a config '
                                     +' yaml and override settings on the command line')
    parser.add_argument('-c', '--config', help='config file name', 
                        default='config.yaml')
    parser.add_argument('-b', '--backend', help='Specify backend and override '
                        + 'backend_group')
    parser.add_argument('-bg', '--backend_group', 
                        help='specify backend group in config file', 
                        default='backends')
    parser.add_argument('--hgp', help='specify hgp')
    parser.add_argument('--shots', help='specify number of shots')
    parser.add_argument('--name', help='Account name', default='')
    args = parser.parse_args()
    
    #import from config
    config_dict = fu.import_yaml(args.config)
    print('Config File Found')
    print(config_dict)
    
    #override from the command line
    if args.backend is not None:
        backends = [args.backend]
    else:
        backends = config_dict[args.backend_group]
        
    if args.hgp is not None:
        hgp = args.hgp
    else:
        hgp = config_dict['hgp']
        
    if args.shots is not None:
        nshots = int(args.shots)
    else:
        nshots = config_dict['shots']
        
    
        
    #print(hgp, backends, he, opt_level, dd, depths, trials, nshots)
    
    run_count(hgp, backends, nshots=nshots, act_name=args.name)
"
https://github.com/qiskit-community/qiskit-benchmarks,qiskit-community,"import sys
import site
import os
import importlib
import json
from datetime import datetime
from pprint import pprint
from itertools import chain
from dataclasses import dataclass, asdict
from json import dumps, load, JSONEncoder
from contextlib import suppress

import yaml
import pkg_resources
import importlib_metadata
from importlib_metadata import distribution, files
from qiskit import QuantumCircuit
from qiskit.transpiler.pass_manager_config import PassManagerConfig
from qiskit.transpiler import CouplingMap

import benchmark


class ResultEncoder(JSONEncoder):
  def default(self, obj):
    if isinstance(obj, QuantumCircuit):
      return obj.name
    if isinstance(obj, PassManagerConfig):
      return obj.__dict__
    if isinstance(obj, CouplingMap):
      return obj.get_edges()
    return JSONEncoder.default(self, obj)


def test_entry_points(contributions_path, contribution_key, results_path, overwrite=False):
  contribution_results = {}

  with open(contributions_path) as file:
    contributions = yaml.load(file, Loader=yaml.SafeLoader)

  entry_points = next(filter(lambda m: contribution_key in m, contributions))[contribution_key]

  for one_entry_point in entry_points:
    module_fqn, function_name = one_entry_point.split(':')
    module = importlib.import_module(module_fqn)
    metadata = get_metadata(module)
    try:
      function = getattr(module, function_name)
      if contribution_key not in contribution_results:
        contribution_results[contribution_key] = { **asdict(metadata), 'results': [] }

      entry_point_results = test(function)
      contribution_results[contribution_key]['results'].append((one_entry_point, entry_point_results))
    except AttributeError:
      notify_cannot_find_entry_point(metadata.author_email, one_entry_point)

  results = {}
  if os.path.exists(results_path):
    with open(results_path, 'r') as file:
      with suppress(json.decoder.JSONDecodeError):
        results = load(file)

  results.update(contribution_results)

  with open(results_path, 'w') as file:
    file.write(dumps(results, cls=ResultEncoder, indent=2))

def get_metadata(module):
  module_path = module.__file__
  for dist in pkg_resources.working_set:
    for path in get_dist_files(dist):
      if module_path == path:
        meta = importlib_metadata.metadata(dist.project_name)
        return metadata(
          name=meta['Name'],
          author=meta['Author'],
          author_email=meta['Author-email'],
          description=meta['Summary'],
          timestamp=str(datetime.now()),
          version=meta['Version']
        )

@dataclass
class metadata:

  name: str

  description: str

  author: str

  author_email: str

  timestamp: str

  version: str


def get_dist_files(dist):
  for path in files(dist.project_name):
    path = os.path.normpath(os.path.join(dist.location, path))
    yield path

def test(function):
  return benchmark.test(function)

def notify_cannot_find_entry_point(email, entry_point):
  print(f'send ""{entry_point} not working"" @ {email}')

if __name__ == '__main__':
  contributions_path = os.path.join(os.getcwd(), sys.argv[1])
  contribution_key = sys.argv[2]
  results_path = os.path.join(os.getcwd(), sys.argv[3])
  test_entry_points(contributions_path, contribution_key, results_path)"
https://github.com/qiskit-community/qiskit-benchmarks,qiskit-community,"from qiskit import *
from qiskit.transpiler.pass_manager_config import PassManagerConfig
from qiskit.transpiler import CouplingMap

qr = QuantumRegister(3)
circuit1 = QuantumCircuit(qr, name='circuit1')
circuit1.h(qr)
circuit1.cx(qr[0], qr[1])
circuit1.h(qr[0])
circuit1.cx(qr[0], qr[1])

qr = QuantumRegister(3)
circuit2 = QuantumCircuit(qr, name='circuit2')
circuit2.h(qr)
circuit2.cx(qr[0], qr[1])
circuit2.h(qr[0])
circuit2.cx(qr[1], qr[0])

coupling1 = [[1, 0], [1, 2], [2, 3], [4, 3], [4, 10], [5, 4],
             [5, 6], [5, 9], [6, 8], [7, 8], [9, 8], [9, 10],
             [11, 3], [11, 10], [11, 12], [12, 2], [13, 1], [13, 12]]
coupling2 = [[1, 0], [1, 2], [2, 3], [4, 3]]

pm_config1 = PassManagerConfig(seed_transpiler=42, basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],
                               coupling_map=CouplingMap(coupling1))
pm_config2 = PassManagerConfig(seed_transpiler=42, basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],
                               coupling_map=CouplingMap(coupling2))

pm_config1.name = 'pm_config1'
pm_config2.name = 'pm_config2'


def get_case():
    return [(circuit1, pm_config1),
            (circuit2, pm_config2)]
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""
===============================================================================
Qiskit Transpiler Service (:mod:`qiskit_transpiler_service.transpiler_service`)
===============================================================================

.. currentmodule:: qiskit_transpiler_service.transpiler_service

Classes
=======
.. autosummary::
   :toctree: ../stubs/

   TranspilerService

""""""

import logging
from typing import Dict, List, Union, Literal

from qiskit import QuantumCircuit

from .wrappers.transpile import TranspileAPI

logger = logging.getLogger(__name__)


class TranspilerService:
    """"""Class for using the transpiler service.

    :param optimization_level: The optimization level to use during the transpilation. There are 4 optimization levels ranging from 0 to 3, where 0 is intended for not performing any optimizations and 3 spends the most effort to optimize the circuit.
    :type optimization_level: int
    :param ai: Specifies if the transpilation should use AI or not, defaults to True.
    :type ai: str, optional
    :param coupling_map: A list of pairs that represents physical links between qubits.
    :type coupling_map: list[list[int]], optional
    :param backend_name: Name of the backend used for doing the transpilation.
    :type backend_name: str, optional
    :param qiskit_transpile_options: Other options to transpile with qiskit.
    :type qiskit_transpile_options: dict, optional
    :param ai_layout_mode: Specifies how to handle the layout selection. There are 3 layout modes: keep (respects the layout set by the previous transpiler passes), improve (uses the layout set by the previous transpiler passes as a starting point) and optimize (ignores previous layout selections).
    :type ai_layout_mode: str, optional
    """"""

    def __init__(
        self,
        optimization_level: int,
        ai: Literal[""true"", ""false"", ""auto""] = ""true"",
        coupling_map: Union[List[List[int]], None] = None,
        backend_name: Union[str, None] = None,
        qiskit_transpile_options: Dict = None,
        ai_layout_mode: str = None,
    ) -> None:
        """"""Initializes the instance.""""""

        self.transpiler_service = TranspileAPI()

        self.backend_name = backend_name
        self.coupling_map = coupling_map
        self.optimization_level = optimization_level
        self.ai = ai
        self.qiskit_transpile_options = qiskit_transpile_options

        if ai_layout_mode is not None:
            if ai_layout_mode.upper() not in [""KEEP"", ""OPTIMIZE"", ""IMPROVE""]:
                raise (
                    f""ERROR. Unknown ai_layout_mode: {ai_layout_mode.upper()}. Valid modes: 'KEEP', 'OPTIMIZE', 'IMPROVE'""
                )
            self.ai_layout_mode = ai_layout_mode.upper()
        else:
            self.ai_layout_mode = ai_layout_mode
        super().__init__()

    def run(
        self,
        circuits: Union[List[Union[str, QuantumCircuit]], Union[str, QuantumCircuit]],
    ):
        """"""Transpile the circuit(s) by calling the service /transpile endpoint.

        Args:
            circuits: circuit(s) to transpile.

        Returns:
            The transpiled circuit(s)

        """"""
        logger.info(f""Requesting transpile to the service"")
        transpile_result = self.transpiler_service.transpile(
            circuits=circuits,
            backend=self.backend_name,
            coupling_map=self.coupling_map,
            optimization_level=self.optimization_level,
            ai=self.ai,
            qiskit_transpile_options=self.qiskit_transpile_options,
        )
        if transpile_result is None:
            logger.warning(
                ""Qiskit transpiler service couldn't transpile the circuit(s)""
            )
            return None

        logger.info(""Qiskit transpiler service returned a result"")
        return transpile_result
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"import pydoc
import re

import pytket.passes as tkps

def get_arguments_from_doc(tket_pass):
    arguments = []

    _doc = pydoc.getdoc(tket_pass)
    if 'Overloaded function.' in _doc:
        #Return the first signature
        #TODO: We should return all possible signatures. This would requires changes in ToQiskitPass also.
        matches = re.findall(""[1-9]\. ("" + tket_pass.__name__ + '[^\n]+)', _doc)
        synopsis_line = matches[0]
    else:
        synopsis_line = pydoc.splitdoc(_doc)[0]

    # To avoid issue caused by callable parentheses:
    synopsis_line = re.sub('Callable\[\[[^\[]+\][^\[]+\]', 'Callable', synopsis_line)

    match = re.search(""\(([^(]+)\)"", synopsis_line)
    if match is not None:
        splitted_args = match.group(1).split(', ')
        for arg_str in splitted_args:
            if arg_str == '**kwargs':
                continue
            else:
                argument = arg_str.split(': ')
                eq_index = argument[1].find('=')
                if eq_index > 0:
                    (_type, _default) = argument[1].split(' = ')
                    arguments.append((argument[0], _type, _default))
                else:
                    arguments.append(tuple(argument))

    return arguments

# This is **temp**. Conversion should be done in a better way
# https://github.com/CQCL/pytket-qiskit/blob/develop/pytket/extensions/qiskit/qiskit_convert.py

from pytket.extensions.qiskit import qiskit_to_tk, tk_to_qiskit
from qiskit.converters import dag_to_circuit, circuit_to_dag

from pytket.circuit import Circuit
from qiskit.dagcircuit import DAGCircuit

def qiskit_dag_to_tk(dag: DAGCircuit):
    # Replace any gate that is not known to pyket by its definition
    from pytket.extensions.qiskit.qiskit_convert import _known_qiskit_gate
    for node in dag.op_nodes():
        if not type(node.op) in _known_qiskit_gate:
            dag.substitute_node_with_dag(node, circuit_to_dag(node.op.definition))

    return qiskit_to_tk(dag_to_circuit(dag))

def tk_to_qiskit_dag(tkcirc: Circuit):
    return circuit_to_dag(tk_to_qiskit(tkcirc))"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Replace each sequence of Clifford, Linear Function or Permutation gates by a single block of these types of gate.""""""

from functools import partial

from qiskit import QuantumCircuit
from qiskit.circuit import Instruction
from qiskit.circuit.barrier import Barrier
from qiskit.circuit.library import LinearFunction, PermutationGate
from qiskit.converters import circuit_to_dag, dag_to_dagdependency, dagdependency_to_dag
from qiskit.dagcircuit.dagcircuit import DAGCircuit
from qiskit.quantum_info.operators import Clifford
from qiskit.transpiler.basepasses import TransformationPass
from qiskit.transpiler.passes.optimization.collect_and_collapse import (
    CollectAndCollapse,
    collapse_to_operation,
)
from qiskit.transpiler.passes.utils import control_flow

CLIFFORD_MAX_BLOCK_SIZE = 9
LINEAR_MAX_BLOCK_SIZE = 9
PERMUTATION_MAX_BLOCK_SIZE = 12


clifford_gate_names = [
    ""x"",
    ""y"",
    ""z"",
    ""h"",
    ""s"",
    ""sdg"",
    ""cx"",
    ""cy"",
    ""cz"",
    ""swap"",
    ""clifford"",
    ""linear_function"",
    ""pauli"",
]

linear_gate_names = [""cx"", ""swap"", ""linear_function""]

permutation_gate_names = [""swap""]


class Flatten(TransformationPass):
    """"""Replaces all instructions that contain a circuit with their circuit""""""

    def __init__(self, node_names):
        super().__init__()
        self.node_names = node_names

    def run(self, dag: DAGCircuit):
        for node in dag.named_nodes(*self.node_names):
            if (
                hasattr(node.op, ""params"")
                and len(node.op.params) > 1
                and isinstance(node.op.params[1], QuantumCircuit)
            ):
                dag.substitute_node_with_dag(node, circuit_to_dag(node.op.params[1]))

        return dag


_flatten_cliffords = Flatten((""clifford"", ""Clifford""))
_flatten_linearfunctions = Flatten((""linear_function"", ""Linear_function""))
_flatten_permutations = Flatten((""permutation"", ""Permutation""))

from qiskit.dagcircuit.collect_blocks import BlockCollector


class GreedyBlockCollector(BlockCollector):
    def __init__(self, dag, max_block_size):
        super().__init__(dag)
        self.max_block_size = max_block_size

    def collect_matching_block(self, filter_fn):
        """"""Iteratively collects the largest block of input nodes (that is, nodes with
        ``_in_degree`` equal to 0) that match a given filtering function, limiting the
        maximum size of the block.
        """"""
        current_block = []
        unprocessed_pending_nodes = self._pending_nodes
        self._pending_nodes = []
        block_qargs = set()

        # Iteratively process unprocessed_pending_nodes:
        # - any node that does not match filter_fn is added to pending_nodes
        # - any node that match filter_fn is added to the current_block,
        #   and some of its successors may be moved to unprocessed_pending_nodes.
        while unprocessed_pending_nodes:
            node = unprocessed_pending_nodes.pop()
            if isinstance(node.op, Barrier):
                continue

            new_qargs = block_qargs.copy()
            for q in node.qargs:
                new_qargs.add(q)

            if filter_fn(node) and len(new_qargs) <= self.max_block_size:
                current_block.append(node)
                block_qargs = new_qargs

                # update the _in_degree of node's successors
                for suc in self._direct_succs(node):
                    self._in_degree[suc] -= 1
                    if self._in_degree[suc] == 0:
                        unprocessed_pending_nodes.append(suc)
            else:
                self._pending_nodes.append(node)

        return current_block


class BlockChecker:
    def __init__(self, gates, block_class):
        self.gates = gates
        self.block_class = block_class
        self.current_set = set()

    def select(self, node):
        """"""Decides if the node should be added to the block.""""""
        return (
            node.op.name in self.gates and getattr(node.op, ""condition"", None) is None
        )

    def collapse(self, circuit):
        """"""Construcs an Gate object for the block.""""""
        self.current_set = set()
        return self.block_class(circuit)


class CliffordInstruction(Instruction):
    def __init__(self, circuit):
        circuit = _flatten_cliffords(circuit)
        super().__init__(
            name=""Clifford"",
            num_qubits=circuit.num_qubits,
            num_clbits=0,
            params=[Clifford(circuit), circuit],
        )


def construct_permutation_gate(circuit):
    circuit = _flatten_permutations(circuit)
    return PermutationGate(LinearFunction(circuit).permutation_pattern())


def construct_linearfunction_gate(circuit):
    circuit = _flatten_linearfunctions(circuit)
    return LinearFunction(circuit)


class RepeatedCollectAndCollapse(CollectAndCollapse):
    def __init__(
        self,
        block_checker: BlockChecker,
        do_commutative_analysis=True,
        split_blocks=True,
        min_block_size=2,
        max_block_size=1000,
        split_layers=False,
        collect_from_back=False,
        num_reps=10,
    ):
        collect_function = lambda dag: GreedyBlockCollector(
            dag, max_block_size
        ).collect_all_matching_blocks(
            filter_fn=block_checker.select,
            split_blocks=split_blocks,
            min_block_size=min_block_size,
            split_layers=split_layers,
            collect_from_back=collect_from_back,
        )
        collapse_function = partial(
            collapse_to_operation, collapse_function=block_checker.collapse
        )
        super().__init__(
            collect_function=collect_function,
            collapse_function=collapse_function,
            do_commutative_analysis=do_commutative_analysis,
        )
        self.num_reps = num_reps

    @control_flow.trivial_recurse
    def run(self, dag):
        """"""Run the CollectLinearFunctions pass on `dag`.
        Args:
            dag (DAGCircuit): the DAG to be optimized.
        Returns:
            DAGCircuit: the optimized DAG.
        """"""

        # If the option commutative_analysis is set, construct DAGDependency from the given DAGCircuit.
        if self.do_commutative_analysis:
            dag = dag_to_dagdependency(dag)

        for _ in range(self.num_reps):
            # call collect_function to collect blocks from DAG
            blocks = self.collect_function(dag)

            # call collapse_function to collapse each block in the DAG
            self.collapse_function(dag, blocks)

        # If the option commutative_analysis is set, construct back DAGCircuit from DAGDependency.
        if self.do_commutative_analysis:
            dag = dagdependency_to_dag(dag)

        return dag


class CollectCliffords(RepeatedCollectAndCollapse):
    """"""CollectCliffords(do_commutative_analysis: bool = True, min_block_size: int = 2, max_block_size: int = CLIFFORD_MAX_BLOCK_SIZE, collect_from_back: bool = False, num_reps: int = 10)

    Collects Clifford blocks as `Instruction` objects and stores the original sub-circuit to compare against it after synthesis.

    :param do_commutative_analysis: Enable or disable commutative analysis, defaults to True
    :type do_commutative_analysis: bool, optional
    :param min_block_size: Set the minimum size for blocks generated during the collect Cliffords pass, defaults to 2.
    :type min_block_size: int, optional
    :param max_block_size: Set the maximum size for blocks generated during the collect Cliffords pass, defaults to 9.
    :type max_block_size: int, optional
    :param collect_from_back: Specify if collect blocks in reverse order or not, defaults to False.
    :type collect_from_back: bool, optional
    :param num_reps: Specify how many times to repeat the optimization process, defaults to 10.
    :type num_reps: int, optional
    """"""

    def __init__(
        self,
        do_commutative_analysis=True,
        min_block_size=2,
        max_block_size=CLIFFORD_MAX_BLOCK_SIZE,
        collect_from_back=False,
        num_reps=10,
    ):
        super().__init__(
            BlockChecker(
                gates=clifford_gate_names,
                block_class=CliffordInstruction,
            ),
            do_commutative_analysis=do_commutative_analysis,
            split_blocks=True,
            min_block_size=min_block_size,
            max_block_size=max_block_size,
            split_layers=False,
            collect_from_back=collect_from_back,
            num_reps=num_reps,
        )


class CollectLinearFunctions(RepeatedCollectAndCollapse):
    """"""CollectLinearFunctions(do_commutative_analysis: bool = True, min_block_size: int = 4, max_block_size: int = LINEAR_MAX_BLOCK_SIZE, collect_from_back: bool = False, num_reps: int = 10)

    Collects blocks of `SWAP` and `CX` as `LinearFunction` objects and stores the original sub-circuit to compare against it after synthesis.

    :param do_commutative_analysis: Enable or disable commutative analysis, defaults to True
    :type do_commutative_analysis: bool, optional
    :param min_block_size: Set the minimum size for blocks generated during the collect linear functions pass, defaults to 4.
    :type min_block_size: int, optional
    :param max_block_size: Set the maximum size for blocks generated during the collect linear functions pass, defaults to 9.
    :type max_block_size: int, optional
    :param collect_from_back: Specify if collect blocks in reverse order or not, defaults to False.
    :type collect_from_back: bool, optional
    :param num_reps: Specify how many times to repeat the optimization process, defaults to 10.
    :type num_reps: int, optional
    """"""

    def __init__(
        self,
        do_commutative_analysis=True,
        min_block_size=4,
        max_block_size=LINEAR_MAX_BLOCK_SIZE,
        collect_from_back=False,
        num_reps=10,
    ):
        super().__init__(
            BlockChecker(
                gates=linear_gate_names,
                block_class=construct_linearfunction_gate,
            ),
            do_commutative_analysis=do_commutative_analysis,
            split_blocks=True,
            min_block_size=min_block_size,
            max_block_size=max_block_size,
            split_layers=False,
            collect_from_back=collect_from_back,
            num_reps=num_reps,
        )


class CollectPermutations(RepeatedCollectAndCollapse):
    """"""CollectPermutations(do_commutative_analysis: bool = True, min_block_size: int = 4, max_block_size: int = PERMUTATION_MAX_BLOCK_SIZE, collect_from_back: bool = False, num_reps: int = 10)

    Collects blocks of `SWAP` circuits as `Permutations`.

    :param do_commutative_analysis: Enable or disable commutative analysis, defaults to True
    :type do_commutative_analysis: bool, optional
    :param min_block_size: Set the minimum size for blocks generated during the collect permutations pass, defaults to 4.
    :type min_block_size: int, optional
    :param max_block_size: Set the maximum size for blocks generated during the collect permutations pass, defaults to 12.
    :type max_block_size: int, optional
    :param collect_from_back: Specify if collect blocks in reverse order or not, defaults to False.
    :type collect_from_back: bool, optional
    :param num_reps: Specify how many times to repeat the optimization process, defaults to 10.
    :type num_reps: int, optional
    """"""

    def __init__(
        self,
        do_commutative_analysis=True,
        min_block_size=4,
        max_block_size=PERMUTATION_MAX_BLOCK_SIZE,
        collect_from_back=False,
        num_reps=10,
    ):
        super().__init__(
            BlockChecker(
                gates=permutation_gate_names,
                block_class=construct_permutation_gate,
            ),
            do_commutative_analysis=do_commutative_analysis,
            split_blocks=True,
            min_block_size=min_block_size,
            max_block_size=max_block_size,
            split_layers=False,
            collect_from_back=collect_from_back,
            num_reps=num_reps,
        )
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Routing and Layout selection with AI""""""
# import torch

# torch.set_num_threads(1)

import numpy as np
from qiskit import ClassicalRegister, QuantumCircuit
from qiskit.converters import circuit_to_dag, dag_to_circuit
from qiskit.transpiler import CouplingMap, TranspilerError
from qiskit.transpiler.basepasses import TransformationPass
from qiskit.transpiler.layout import Layout

from qiskit_transpiler_service.wrappers import AIRoutingAPI


class AIRouting(TransformationPass):
    """"""AIRouting(backend_name: str | None = None, coupling_map: list[list[int]] | None = None, optimization_level: int = 2, layout_mode: str = ""OPTIMIZE"")

    The `AIRouting` pass acts both as a layout stage and a routing stage.

    :param backend_name: Name of the backend used for doing the transpilation.
    :type backend_name: str, optional
    :param coupling_map: A list of pairs that represents physical links between qubits.
    :type coupling_map: list[list[int]], optional
    :param optimization_level: With a range from 1 to 3, determines the computational effort to spend in the process (higher usually gives better results but takes longer), defaults to 2.
    :type optimization_level: int
    :param layout_mode: Specifies how to handle the layout selection. There are 3 layout modes: keep (respects the layout set by the previous transpiler passes), improve (uses the layout set by the previous transpiler passes as a starting point) and optimize (ignores previous layout selections), defaults to `OPTIMIZE`.
    :type layout_mode: str
    """"""

    def __init__(
        self,
        backend_name=None,
        coupling_map=None,
        optimization_level: int = 2,
        layout_mode: str = ""OPTIMIZE"",
    ):
        super().__init__()
        if backend_name is not None and coupling_map is not None:
            raise ValueError(
                f""ERROR. Both backend_name and coupling_map were specified as options. Please just use one of them.""
            )
        if backend_name is not None:
            self.backend = backend_name
        elif coupling_map is not None:
            if isinstance(coupling_map, CouplingMap):
                self.backend = list(coupling_map.get_edges())
            elif isinstance(coupling_map, list):
                self.backend = coupling_map
            else:
                raise ValueError(
                    f""ERROR. coupling_map should either be a list of int tuples or a Qiskit CouplingMap object.""
                )
        else:
            raise ValueError(f""ERROR. Either backend_name OR coupling_map must be set."")

        self.optimization_level = optimization_level

        if layout_mode is not None and layout_mode.upper() not in [
            ""KEEP"",
            ""OPTIMIZE"",
            ""IMPROVE"",
        ]:
            raise ValueError(
                f""ERROR. Unknown ai_layout_mode: {layout_mode}. Valid modes: 'KEEP', 'OPTIMIZE', 'IMPROVE'""
            )
        self.layout_mode = layout_mode.upper()
        self.service = AIRoutingAPI()

    def run(self, dag):
        """"""Run the AIRouting pass on `dag`.

        Args:
            dag (DAGCircuit): the directed acyclic graph to be mapped.
        Returns:
            DAGCircuit: A dag mapped to be compatible with the coupling_map.
        Raises:
            TranspilerError: if the coupling map or the layout are not
            compatible with the DAG, or if the coupling_map=None
        """"""
        if len(dag.qregs) != 1 or dag.qregs.get(""q"", None) is None:
            raise TranspilerError(""AIRouting runs on physical circuits only"")

        # Pass dag to circuit for sending to AIRouting
        qc = dag_to_circuit(dag)

        # Remove measurements before sending to AIRouting
        # TODO: Fix this for mid-circuit measurements
        cregs = []
        measurements = []
        if len(qc.cregs) > 0:
            cregs = qc.cregs.copy()
            measurements = [g for g in qc if g.operation.name == ""measure""]
            qc.remove_final_measurements(inplace=True)

        routed_qc, init_layout, final_layout = self.service.routing(
            qc,
            self.backend,
            self.optimization_level,
            False,
            self.layout_mode,
        )

        # TODO: Improve this
        nq = max(init_layout) + 1
        routed_qc = QuantumCircuit(nq).compose(
            routed_qc, qubits=range(routed_qc.num_qubits)
        )

        # Restore final measurements if they were removed
        if len(measurements) > 0:
            meas_qubits = [final_layout[g.qubits[0]._index] for g in measurements]
            routed_qc.barrier(meas_qubits)
            for creg in cregs:
                routed_qc.add_register(creg)
            for g, q in zip(measurements, meas_qubits):
                routed_qc.append(g.operation, qargs=(q,), cargs=g.clbits)

        # Pass routed circuit to dag
        # TODO: Improve this
        routed_dag = circuit_to_dag(routed_qc)
        if routed_qc.num_qubits > dag.num_qubits():
            new_dag = copy_dag_metadata(dag, routed_dag)
        else:
            new_dag = dag.copy_empty_like()
            new_dag.compose(routed_dag)

        qubits = new_dag.qubits
        input_qubit_mapping = {q: i for i, q in enumerate(qubits)}

        full_initial_layout = init_layout + sorted(
            set(range(len(qubits))) - set(init_layout)
        )
        full_final_layout = final_layout + list(range(len(final_layout), len(qubits)))
        full_final_layout_p = [
            full_final_layout[i] for i in np.argsort(full_initial_layout)
        ]

        initial_layout_qiskit = Layout(dict(zip(full_initial_layout, qubits)))
        final_layout_qiskit = Layout(dict(zip(full_final_layout_p, qubits)))

        self.property_set[""layout""] = initial_layout_qiskit
        self.property_set[""original_qubit_indices""] = input_qubit_mapping
        self.property_set[""final_layout""] = final_layout_qiskit

        return new_dag


def add_measurements(circ, qubits):
    circ.add_register(ClassicalRegister(len(qubits)))
    circ.barrier()
    for i, q in enumerate(qubits):
        circ.measure(q, i)
    return circ


def copy_dag_metadata(dag, target_dag):
    """"""Return a copy of self with the same structure but empty.

    That structure includes:
        * name and other metadata
        * global phase
        * duration
        * all the qubits and clbits, including the registers.

    Returns:
        DAGCircuit: An empty copy of self.
    """"""
    target_dag.name = dag.name
    target_dag._global_phase = dag._global_phase
    target_dag.duration = dag.duration
    target_dag.unit = dag.unit
    target_dag.metadata = dag.metadata
    target_dag._key_cache = dag._key_cache

    return target_dag
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import os
from urllib.parse import urljoin

from qiskit import QuantumCircuit, qasm2, qasm3
from qiskit.qasm2 import QASM2ExportError

from .base import QiskitTranspilerService


class AIRoutingAPI(QiskitTranspilerService):
    """"""A helper class that covers some basic funcionality from the AIRouting API""""""

    def __init__(self):
        super().__init__(""routing"")

    def routing(
        self,
        circuit: QuantumCircuit,
        coupling_map,
        optimization_level: int = 1,
        check_result: bool = False,
        layout_mode: str = ""OPTIMIZE"",
    ):
        is_qasm3 = False
        try:
            qasm = qasm2.dumps(circuit)
        except QASM2ExportError:
            qasm = qasm3.dumps(circuit)
            is_qasm3 = True

        json_args = {""qasm"": qasm.replace(""\n"", "" ""), ""coupling_map"": coupling_map}

        params = {
            ""check_result"": check_result,
            ""layout_mode"": layout_mode,
            ""optimization_level"": optimization_level,
        }

        routing_resp = self.request_and_wait(
            endpoint=""routing"", body=json_args, params=params
        )

        if routing_resp.get(""success""):
            routed_circuit = (
                qasm3.loads(routing_resp[""qasm""])
                if is_qasm3
                else QuantumCircuit.from_qasm_str(routing_resp[""qasm""])
            )
            return (
                routed_circuit,
                routing_resp[""layout""][""initial""],
                routing_resp[""layout""][""final""],
            )
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2023 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import logging
from typing import Union, List

from qiskit import QuantumCircuit
from qiskit.circuit.library import LinearFunction
from qiskit.quantum_info import Clifford

from .base import QiskitTranspilerService

logging.basicConfig()
logging.getLogger(__name__).setLevel(logging.INFO)


class AICliffordAPI(QiskitTranspilerService):
    """"""A helper class that covers some basic funcionality from the Clifford AI Synthesis API""""""

    def __init__(self):
        super().__init__(""clifford"")

    def transpile(
        self,
        circuits: List[Union[QuantumCircuit, Clifford]],
        backend: str,
        qargs: List[List[int]],
    ):
        transpile_resps = self.request_and_wait(
            endpoint=""transpile"",
            body={
                ""clifford_dict"": [Clifford(circuit).to_dict() for circuit in circuits],
                ""qargs"": qargs,
            },
            params={""backend"": backend},
        )

        results = []
        for transpile_resp in transpile_resps:
            if transpile_resp.get(""success"") and transpile_resp.get(""qasm"") is not None:
                results.append(QuantumCircuit.from_qasm_str(transpile_resp.get(""qasm"")))
            else:
                results.append(None)
        return results


class AILinearFunctionAPI(QiskitTranspilerService):
    """"""A helper class that covers some basic funcionality from the Linear Function AI Synthesis API""""""

    def __init__(self):
        super().__init__(""linear_functions"")

    def transpile(
        self,
        circuits: List[Union[QuantumCircuit, LinearFunction]],
        backend: str,
        qargs: List[List[int]],
    ):
        transpile_resps = self.request_and_wait(
            endpoint=""transpile"",
            body={
                ""clifford_dict"": [Clifford(circuit).to_dict() for circuit in circuits],
                ""qargs"": qargs,
            },
            params={""backend"": backend},
        )

        results = []
        for transpile_resp in transpile_resps:
            if transpile_resp.get(""success"") and transpile_resp.get(""qasm"") is not None:
                results.append(QuantumCircuit.from_qasm_str(transpile_resp.get(""qasm"")))
            else:
                results.append(None)
        return results


class AIPermutationAPI(QiskitTranspilerService):
    """"""A helper class that covers some basic funcionality from the Permutation AI Synthesis API""""""

    def __init__(self):
        super().__init__(""permutations"")

    def transpile(
        self,
        patterns: List[List[int]],
        backend: str,
        qargs: List[List[int]],
    ):
        transpile_resps = self.request_and_wait(
            endpoint=""transpile"",
            body={""permutation"": patterns, ""qargs"": qargs},
            params={""backend"": backend},
        )

        results = []
        for transpile_resp in transpile_resps:
            if transpile_resp.get(""success"") and transpile_resp.get(""qasm"") is not None:
                results.append(QuantumCircuit.from_qasm_str(transpile_resp.get(""qasm"")))
            else:
                results.append(None)
        return results
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import logging
from typing import Dict, List, Union, Literal

import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, qasm2, qasm3
from qiskit.circuit import QuantumCircuit, QuantumRegister, Qubit
from qiskit.qasm2 import QASM2ExportError, QASM2ParseError
from qiskit.transpiler import TranspileLayout
from qiskit.transpiler.layout import Layout

from qiskit_transpiler_service.wrappers import QiskitTranspilerService

# setting backoff logger to error level to avoid too much logging
logging.getLogger(""backoff"").setLevel(logging.ERROR)
logger = logging.getLogger(__name__)


class TranspileAPI(QiskitTranspilerService):
    """"""A helper class that covers some basic funcionality from the Qiskit Transpiler API""""""

    def __init__(self):
        super().__init__()

    def transpile(
        self,
        circuits: Union[
            Union[List[str], str], Union[List[QuantumCircuit], QuantumCircuit]
        ],
        optimization_level: int = 1,
        backend: Union[str, None] = None,
        coupling_map: Union[List[List[int]], None] = None,
        ai: Literal[""true"", ""false"", ""auto""] = ""true"",
        qiskit_transpile_options: Dict = None,
        ai_layout_mode: str = None,
    ):
        circuits = circuits if isinstance(circuits, list) else [circuits]

        qasm_circuits = [_input_to_qasm(circ) for circ in circuits]

        json_args = {
            ""qasm_circuits"": qasm_circuits,
        }

        if qiskit_transpile_options is not None:
            json_args[""qiskit_transpile_options""] = qiskit_transpile_options
        if coupling_map is not None:
            json_args[""backend_coupling_map""] = coupling_map

        params = {
            ""backend"": backend,
            ""optimization_level"": optimization_level,
            ""ai"": ai,
        }

        if ai_layout_mode is not None:
            params[""ai_layout_mode""] = ai_layout_mode

        transpile_resp = self.request_and_wait(
            endpoint=""transpile"", body=json_args, params=params
        )

        logger.debug(f""transpile_resp={transpile_resp}"")

        transpiled_circuits = []

        for res, orig_circ in zip(transpile_resp, circuits):
            try:
                transpiled_circuits.append(_get_circuit_from_result(res, orig_circ))
            except Exception as ex:
                logger.error(""Error transforming the result to a QuantumCircuit object"")
                raise

        return (
            transpiled_circuits
            if len(transpiled_circuits) > 1
            else transpiled_circuits[0]
        )

    def benchmark(
        self,
        circuits: Union[
            Union[List[str], str], Union[List[QuantumCircuit], QuantumCircuit]
        ],
        backend: str,
        optimization_level: int = 1,
        qiskit_transpile_options: Dict = None,
    ):
        raise Exception(""Not implemented"")


def _input_to_qasm(input_circ: Union[QuantumCircuit, str]):
    if isinstance(input_circ, QuantumCircuit):
        try:
            qasm = qasm2.dumps(input_circ).replace(""\n"", "" "")
        except QASM2ExportError:
            qasm = qasm3.dumps(input_circ).replace(""\n"", "" "")
    elif isinstance(input_circ, str):
        qasm = input_circ.replace(""\n"", "" "")
    else:
        raise TypeError(""Input circuits must be QuantumCircuit or qasm string."")
    return qasm


def _get_circuit_from_result(transpile_resp, orig_circuit):
    transpiled_circuit = _get_circuit_from_qasm(transpile_resp[""qasm""])

    init_layout = transpile_resp[""layout""][""initial""]
    final_layout = transpile_resp[""layout""][""final""]

    orig_circuit = (
        _get_circuit_from_qasm(orig_circuit)
        if isinstance(orig_circuit, str)
        else orig_circuit
    )

    transpiled_circuit = QuantumCircuit(len(init_layout)).compose(transpiled_circuit)
    transpiled_circuit._layout = _create_transpile_layout(
        init_layout, final_layout, transpiled_circuit, orig_circuit
    )
    return transpiled_circuit


def _create_initial_layout(initial, n_used_qubits):
    """"""Create initial layout using the initial index layout and the number of active qubits.""""""
    total_qubits = len(initial)
    q_total = n_used_qubits
    a_total = total_qubits - q_total
    initial_layout = Layout()
    for q in range(q_total):
        initial_layout.add(initial[q], Qubit(QuantumRegister(q_total, ""q""), q))
    for a in range(q_total, total_qubits):
        initial_layout.add(
            initial[a], Qubit(QuantumRegister(a_total, ""ancilla""), a - q_total)
        )
    return initial_layout


def _create_input_qubit_mapping(qubits_used, total_qubits):
    """"""Create input qubit mapping with the number of active qubits and the total number of qubits.""""""
    input_qubit_mapping = {
        Qubit(QuantumRegister(qubits_used, ""q""), q): q for q in range(qubits_used)
    }
    input_ancilla_mapping = {
        Qubit(
            QuantumRegister(total_qubits - qubits_used, ""ancilla""), q - qubits_used
        ): q
        for q in range(qubits_used, total_qubits)
    }
    input_qubit_mapping.update(input_ancilla_mapping)
    return input_qubit_mapping


def _create_final_layout(initial, final, circuit):
    """"""Create final layout with the initial and final index layout and the circuit.""""""
    final_layout = Layout()
    q_total = len(initial)
    q_reg = QuantumRegister(q_total, ""q"")
    for i, j in zip(final, initial):
        q_index = circuit.find_bit(Qubit(q_reg, j)).index
        qubit = circuit.qubits[q_index]
        final_layout.add(i, qubit)

    return final_layout


def _create_transpile_layout(initial, final, circuit, orig_circuit):
    """"""Build the full transpile layout.""""""
    n_used_qubits = orig_circuit.num_qubits
    return TranspileLayout(
        initial_layout=_create_initial_layout(
            initial=initial, n_used_qubits=n_used_qubits
        ),  # final=final),
        input_qubit_mapping=_create_input_qubit_mapping(
            qubits_used=n_used_qubits, total_qubits=len(initial)
        ),
        final_layout=_create_final_layout(
            initial=initial, final=final, circuit=circuit
        ),
        _input_qubit_count=n_used_qubits,
        _output_qubit_list=circuit.qubits,
    )


def _get_circuit_from_qasm(qasm_string):
    try:
        return qasm2.loads(
            qasm_string,
            custom_instructions=qasm2.LEGACY_CUSTOM_INSTRUCTIONS,
        )
    except QASM2ParseError:
        return qasm3.loads(qasm_string)
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Unit-testing Transpiler Service""""""

import numpy as np
import pytest
from qiskit import QuantumCircuit, qasm2, qasm3
from qiskit.circuit.library import IQP, EfficientSU2, QuantumVolume
from qiskit.circuit.random import random_circuit
from qiskit.compiler import transpile
from qiskit.quantum_info import SparsePauliOp, random_hermitian

from qiskit_transpiler_service.transpiler_service import TranspilerService
from qiskit_transpiler_service.wrappers import _get_circuit_from_result


@pytest.mark.parametrize(
    ""optimization_level"", [1, 2, 3], ids=[""opt_level_1"", ""opt_level_2"", ""opt_level_3""]
)
@pytest.mark.parametrize(""ai"", [""false"", ""true""], ids=[""no_ai"", ""ai""])
@pytest.mark.parametrize(
    ""qiskit_transpile_options"",
    [None, {""seed_transpiler"": 0}],
    ids=[""no opt"", ""one option""],
)
def test_rand_circ_backend_routing(optimization_level, ai, qiskit_transpile_options):
    backend_name = ""ibm_brisbane""
    random_circ = random_circuit(5, depth=3, seed=42)

    cloud_transpiler_service = TranspilerService(
        backend_name=backend_name,
        ai=ai,
        optimization_level=optimization_level,
        qiskit_transpile_options=qiskit_transpile_options,
    )
    transpiled_circuit = cloud_transpiler_service.run(random_circ)

    assert isinstance(transpiled_circuit, QuantumCircuit)


@pytest.mark.parametrize(
    ""optimization_level"", [1, 2, 3], ids=[""opt_level_1"", ""opt_level_2"", ""opt_level_3""]
)
@pytest.mark.parametrize(""ai"", [""false"", ""true""], ids=[""no_ai"", ""ai""])
@pytest.mark.parametrize(
    ""qiskit_transpile_options"",
    [None, {""seed_transpiler"": 0}],
    ids=[""no opt"", ""one option""],
)
def test_qv_backend_routing(optimization_level, ai, qiskit_transpile_options):
    backend_name = ""ibm_brisbane""
    qv_circ = QuantumVolume(27, depth=3, seed=42).decompose(reps=3)

    cloud_transpiler_service = TranspilerService(
        backend_name=backend_name,
        ai=ai,
        optimization_level=optimization_level,
        qiskit_transpile_options=qiskit_transpile_options,
    )
    transpiled_circuit = cloud_transpiler_service.run(qv_circ)

    assert isinstance(transpiled_circuit, QuantumCircuit)


@pytest.mark.parametrize(
    ""coupling_map"",
    [
        [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]],
        [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]],
    ],
)
@pytest.mark.parametrize(""optimization_level"", [1, 2, 3])
@pytest.mark.parametrize(""ai"", [""false"", ""true""], ids=[""no_ai"", ""ai""])
@pytest.mark.parametrize(""qiskit_transpile_options"", [None, {""seed_transpiler"": 0}])
def test_rand_circ_cmap_routing(
    coupling_map, optimization_level, ai, qiskit_transpile_options
):
    random_circ = random_circuit(5, depth=3, seed=42).decompose(reps=3)

    cloud_transpiler_service = TranspilerService(
        coupling_map=coupling_map,
        ai=ai,
        optimization_level=optimization_level,
        qiskit_transpile_options=qiskit_transpile_options,
    )
    transpiled_circuit = cloud_transpiler_service.run(random_circ)

    assert isinstance(transpiled_circuit, QuantumCircuit)


def test_qv_circ_several_circuits_routing():
    qv_circ = QuantumVolume(5, depth=3, seed=42).decompose(reps=3)

    cloud_transpiler_service = TranspilerService(
        backend_name=""ibm_brisbane"",
        ai=""true"",
        optimization_level=1,
    )
    transpiled_circuit = cloud_transpiler_service.run([qv_circ] * 2)
    for circ in transpiled_circuit:
        assert isinstance(circ, QuantumCircuit)

    transpiled_circuit = cloud_transpiler_service.run([qasm2.dumps(qv_circ)] * 2)
    for circ in transpiled_circuit:
        assert isinstance(circ, QuantumCircuit)

    transpiled_circuit = cloud_transpiler_service.run([qasm2.dumps(qv_circ), qv_circ])
    for circ in transpiled_circuit:
        assert isinstance(circ, QuantumCircuit)


def test_qv_circ_wrong_input_routing():
    qv_circ = QuantumVolume(5, depth=3, seed=42).decompose(reps=3)

    cloud_transpiler_service = TranspilerService(
        backend_name=""ibm_brisbane"",
        ai=""true"",
        optimization_level=1,
    )

    circ_dict = {""a"": qv_circ}
    with pytest.raises(TypeError):
        cloud_transpiler_service.run(circ_dict)


@pytest.mark.parametrize(""ai"", [""false"", ""true""], ids=[""no_ai"", ""ai""])
def test_transpile_layout_reconstruction(ai):
    n_qubits = 27

    mat = np.real(random_hermitian(n_qubits, seed=1234))
    circuit = IQP(mat)
    observable = SparsePauliOp(""Z"" * n_qubits)

    cloud_transpiler_service = TranspilerService(
        backend_name=""ibm_brisbane"",
        ai=ai,
        optimization_level=1,
    )
    transpiled_circuit = cloud_transpiler_service.run(circuit)
    # This fails if initial layout is not correct
    try:
        observable.apply_layout(transpiled_circuit.layout)
    except Exception:
        pytest.fail(
            ""This should not fail. Probably something wrong with the reconstructed layout.""
        )


def test_transpile_non_valid_backend():
    circuit = EfficientSU2(100, entanglement=""circular"", reps=1).decompose()
    non_valid_backend_name = ""ibm_torin""
    transpiler_service = TranspilerService(
        backend_name=non_valid_backend_name,
        ai=""false"",
        optimization_level=3,
    )

    try:
        transpiler_service.run(circuit)
        pytest.fail(""Error expected"")
    except Exception as e:
        assert (
            str(e)
            == f'""User doesn\'t have access to the specified backend: {non_valid_backend_name}""'
        )


def test_transpile_exceed_circuit_size():
    circuit = EfficientSU2(100, entanglement=""circular"", reps=50).decompose()
    transpiler_service = TranspilerService(
        backend_name=""ibm_kyoto"",
        ai=""false"",
        optimization_level=3,
    )

    try:
        transpiler_service.run(circuit)
        pytest.fail(""Error expected"")
    except Exception as e:
        assert str(e) == ""'Circuit has more gates than the allowed maximum of 5000.'""


def test_transpile_malformed_body():
    circuit = EfficientSU2(100, entanglement=""circular"", reps=1).decompose()
    transpiler_service = TranspilerService(
        backend_name=""ibm_kyoto"",
        ai=""false"",
        optimization_level=3,
        qiskit_transpile_options={""failing_option"": 0},
    )

    try:
        transpiler_service.run(circuit)
        pytest.fail(""Error expected"")
    except Exception as e:
        assert (
            str(e)
            == ""\""transpile() got an unexpected keyword argument 'failing_option'\""""
        )


def test_transpile_failing_task():
    open_qasm_circuit = 'OPENQASM 2.0;\ninclude ""qelib1.inc"";\ngate dcx q0,q1 { cx q0,q1; cx q1,q0; }\nqreg q[3];\ncz q[0],q[2];\nsdg q[1];\ndcx q[2],q[1];\nu3(3.890139082217223,3.447697582994976,1.1583481971959322) q[0];\ncrx(2.3585459177723522) q[1],q[0];\ny q[2];'
    circuit = QuantumCircuit.from_qasm_str(open_qasm_circuit)
    transpiler_service = TranspilerService(
        backend_name=""ibm_kyoto"",
        ai=""false"",
        optimization_level=3,
        coupling_map=[[1, 2], [2, 1]],
        qiskit_transpile_options={
            ""basis_gates"": [""u1"", ""u2"", ""u3"", ""cx""],
            ""seed_transpiler"": 0,
        },
    )

    try:
        transpiler_service.run(circuit)
        pytest.fail(""Error expected"")
    except Exception as e:
        assert ""The background task"" in str(e)
        assert ""FAILED"" in str(e)


def compare_layouts(plugin_circ, non_ai_circ):
    assert (
        plugin_circ.layout.initial_layout == non_ai_circ.layout.initial_layout
    ), ""initial_layouts differs""
    assert (
        plugin_circ.layout.initial_index_layout()
        == non_ai_circ.layout.initial_index_layout()
    ), ""initial_index_layout differs""
    assert (
        plugin_circ.layout.input_qubit_mapping == non_ai_circ.layout.input_qubit_mapping
    ), ""input_qubit_mapping differs""
    assert (
        plugin_circ.layout._input_qubit_count == non_ai_circ.layout._input_qubit_count
    ), ""_input_qubit_count differs""
    assert (
        plugin_circ.layout._output_qubit_list == non_ai_circ.layout._output_qubit_list
    ), ""_output_qubit_list differs""
    # Sometimes qiskit transpilation does not add final_layout
    if non_ai_circ.layout.final_layout:
        assert (
            plugin_circ.layout.final_layout == non_ai_circ.layout.final_layout
        ), ""final_layout differs""
    assert (
        plugin_circ.layout.final_index_layout()
        == non_ai_circ.layout.final_index_layout()
    ), ""final_index_layout differs""


def get_circuit_as_in_service(circuit):
    return {
        ""qasm"": qasm3.dumps(circuit),
        ""layout"": {
            ""initial"": circuit.layout.initial_index_layout(),
            ""final"": circuit.layout.final_index_layout(False),
        },
    }


def transpile_and_check_layout(cmap, circuit):
    non_ai_circ = transpile(
        circuits=circuit,
        coupling_map=cmap,
        optimization_level=1,
    )
    service_resp = get_circuit_as_in_service(non_ai_circ)
    plugin_circ = _get_circuit_from_result(service_resp, circuit)
    compare_layouts(plugin_circ, non_ai_circ)


def test_layout_construction_no_service(backend, cmap_backend):
    for n_qubits in [5, 10, 15, 20, 27]:
        circuit = random_circuit(n_qubits, 4, measure=True)
        transpile_and_check_layout(cmap_backend[backend], circuit)
    for n_qubits in [5, 10, 15, 20, 27]:
        circuit = EfficientSU2(n_qubits, entanglement=""circular"", reps=1).decompose()
        transpile_and_check_layout(cmap_backend[backend], circuit)

    for n_qubits in [5, 10, 15, 20, 27]:
        circuit = QuantumCircuit(n_qubits)
        circuit.cx(0, 1)
        circuit.cx(1, 2)
        circuit.h(4)
        transpile_and_check_layout(cmap_backend[backend], circuit)
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

import numpy as np
import pytest
from qiskit import QuantumCircuit
from qiskit.circuit.library import QuantumVolume
from qiskit.quantum_info import random_clifford
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager


def create_random_circuit(total_n_ubits, cliffords_n_qubits, clifford_num):
    circuit = QuantumCircuit(total_n_ubits)
    nq = cliffords_n_qubits
    for c in range(clifford_num):
        qs = np.random.choice(range(circuit.num_qubits), size=nq, replace=False)
        circuit.compose(
            random_clifford(nq, seed=42).to_circuit(), qubits=qs.tolist(), inplace=True
        )
        for q in qs:
            circuit.t(q)
    return circuit


def create_linear_circuit(n_qubits, gates):
    circuit = QuantumCircuit(n_qubits)
    for q in range(n_qubits - 1):
        if gates == ""cx"":
            circuit.cx(q, q + 1)
        elif gates == ""swap"":
            circuit.swap(q, q + 1)
        elif gates == ""cz"":
            circuit.cz(q, q + 1)
        elif gates == ""rzz"":
            circuit.rzz(1.23, q, q + 1)
    return circuit


@pytest.fixture(scope=""module"")
def random_circuit_transpiled(backend, cmap_backend):
    circuit = create_random_circuit(27, 4, 2)
    qiskit_lvl3_transpiler = generate_preset_pass_manager(
        optimization_level=3, coupling_map=cmap_backend[backend]
    )
    return qiskit_lvl3_transpiler.run(circuit)


@pytest.fixture(scope=""module"")
def qv_circ():
    return QuantumVolume(10, depth=3, seed=42).decompose(reps=1)


@pytest.fixture(scope=""module"", params=[3, 10, 30])
def cnot_circ(request):
    return create_linear_circuit(request.param, ""cx"")


@pytest.fixture(scope=""module"", params=[3, 10, 30])
def swap_circ(request):
    return create_linear_circuit(request.param, ""swap"")


@pytest.fixture(scope=""module"", params=[3, 10, 30])
def cz_circ(request):
    return create_linear_circuit(request.param, ""cz"")


@pytest.fixture(scope=""module"", params=[3, 10, 30])
def rzz_circ(request):
    return create_linear_circuit(request.param, ""rzz"")
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Unit-testing clifford_ai""""""
from qiskit import QuantumCircuit
from qiskit.transpiler import PassManager

from qiskit_transpiler_service.ai.collection import CollectCliffords
from qiskit_transpiler_service.ai.synthesis import AICliffordSynthesis


def test_clifford_function(random_circuit_transpiled, backend):
    ai_optimize_lf = PassManager(
        [
            CollectCliffords(),
            AICliffordSynthesis(backend_name=backend),
        ]
    )
    ai_optimized_circuit = ai_optimize_lf.run(random_circuit_transpiled)
    assert isinstance(ai_optimized_circuit, QuantumCircuit)


def test_clifford_wrong_backend(random_circuit_transpiled, caplog):
    ai_optimize_lf = PassManager(
        [
            CollectCliffords(),
            AICliffordSynthesis(backend_name=""wrong_backend""),
        ]
    )
    ai_optimized_circuit = ai_optimize_lf.run(random_circuit_transpiled)
    assert ""couldn't synthesize the circuit"" in caplog.text
    assert ""Keeping the original circuit"" in caplog.text
    assert isinstance(ai_optimized_circuit, QuantumCircuit)
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Unit-testing linear_function_collection""""""
from qiskit import QuantumCircuit
from qiskit.transpiler import PassManager

from qiskit_transpiler_service.ai.collection import CollectCliffords


def test_clifford_collection_pass(random_circuit_transpiled):
    collect = PassManager(
        [
            CollectCliffords(),
        ]
    )
    collected_circuit = collect.run(random_circuit_transpiled)

    assert isinstance(collected_circuit, QuantumCircuit)


def test_clifford_collection_pass_collect(cz_circ):
    collect = PassManager(
        [
            CollectCliffords(min_block_size=1, max_block_size=5),
        ]
    )
    collected_circuit = collect.run(cz_circ)

    assert isinstance(collected_circuit, QuantumCircuit)
    assert any(g.operation.name.lower() == ""clifford"" for g in collected_circuit)


def test_clifford_collection_pass_no_collect(rzz_circ):
    collect = PassManager(
        [
            CollectCliffords(min_block_size=7, max_block_size=12),
        ]
    )
    collected_circuit = collect.run(rzz_circ)

    assert all(g.operation.name.lower() != ""clifford"" for g in collected_circuit)


def test_clifford_collection_max_block_size(cz_circ):
    collect = PassManager(
        [
            CollectCliffords(max_block_size=7),
        ]
    )
    collected_circuit = collect.run(cz_circ)

    assert all(len(g.qubits) <= 7 for g in collected_circuit)


def test_clifford_collection_min_block_size(cz_circ):
    collect = PassManager(
        [
            CollectCliffords(min_block_size=7, max_block_size=12),
        ]
    )
    collected_circuit = collect.run(cz_circ)

    assert all(
        len(g.qubits) >= 7 or g.operation.name.lower() != ""clifford""
        for g in collected_circuit
    )
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Unit-testing linear_function_ai""""""
import pytest
from qiskit import QuantumCircuit
from qiskit.transpiler import PassManager

from qiskit_transpiler_service.ai.collection import CollectLinearFunctions
from qiskit_transpiler_service.ai.synthesis import AILinearFunctionSynthesis


def test_linear_function_pass(random_circuit_transpiled, backend, caplog):
    ai_optimize_lf = PassManager(
        [
            CollectLinearFunctions(),
            AILinearFunctionSynthesis(backend_name=backend),
        ]
    )
    ai_optimized_circuit = ai_optimize_lf.run(random_circuit_transpiled)

    assert isinstance(ai_optimized_circuit, QuantumCircuit)


def test_linear_function_wrong_backend(caplog):
    circuit = QuantumCircuit(10)
    for i in range(8):
        circuit.cx(i, i + 1)
    for i in range(8):
        circuit.h(i)
    for i in range(8):
        circuit.cx(i, i + 1)
    ai_optimize_lf = PassManager(
        [
            CollectLinearFunctions(),
            AILinearFunctionSynthesis(backend_name=""a_wrong_backend""),
        ]
    )
    ai_optimized_circuit = ai_optimize_lf.run(circuit)
    assert ""couldn't synthesize the circuit"" in caplog.text
    assert ""Keeping the original circuit"" in caplog.text
    assert isinstance(ai_optimized_circuit, QuantumCircuit)


def test_linear_always_replace(backend, caplog):
    orig_qc = QuantumCircuit(3)
    orig_qc.cx(0, 1)
    orig_qc.cx(1, 2)
    ai_optimize_lf = PassManager(
        [
            CollectLinearFunctions(),
            AILinearFunctionSynthesis(
                backend_name=backend, replace_only_if_better=False
            ),
        ]
    )
    ai_optimized_circuit = ai_optimize_lf.run(orig_qc)
    assert ""Keeping the original circuit"" not in caplog.text
    assert isinstance(ai_optimized_circuit, QuantumCircuit)


def test_linear_function_only_replace_if_better(backend, caplog):
    orig_qc = QuantumCircuit(3)
    orig_qc.cx(0, 1)
    orig_qc.cx(1, 2)
    ai_optimize_lf = PassManager(
        [
            CollectLinearFunctions(min_block_size=2),
            AILinearFunctionSynthesis(backend_name=backend),
        ]
    )
    ai_optimized_circuit = ai_optimize_lf.run(orig_qc)
    assert ai_optimized_circuit == orig_qc
    assert ""Keeping the original circuit"" in caplog.text
    assert isinstance(ai_optimized_circuit, QuantumCircuit)
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Unit-testing linear_function_collection""""""
import pytest
from qiskit import QuantumCircuit
from qiskit.transpiler import PassManager

from qiskit_transpiler_service.ai.collection import CollectLinearFunctions


def test_lf_collection_pass(random_circuit_transpiled):
    collect = PassManager(
        [
            CollectLinearFunctions(),
        ]
    )
    collected_circuit = collect.run(random_circuit_transpiled)

    assert isinstance(collected_circuit, QuantumCircuit)


def test_lf_collection_pass_collect(cnot_circ):
    collect = PassManager(
        [
            CollectLinearFunctions(min_block_size=1, max_block_size=5),
        ]
    )
    collected_circuit = collect.run(cnot_circ)

    assert isinstance(collected_circuit, QuantumCircuit)
    assert any(g.operation.name.lower() == ""linear_function"" for g in collected_circuit)


def test_lf_collection_pass_no_collect(rzz_circ):
    collect = PassManager(
        [
            CollectLinearFunctions(min_block_size=7, max_block_size=12),
        ]
    )
    collected_circuit = collect.run(rzz_circ)

    assert all(g.operation.name.lower() != ""linear_function"" for g in collected_circuit)


def test_lf_collection_max_block_size(cnot_circ):
    collect = PassManager(
        [
            CollectLinearFunctions(max_block_size=7),
        ]
    )
    collected_circuit = collect.run(cnot_circ)

    assert all(len(g.qubits) <= 7 for g in collected_circuit)


def test_lf_collection_min_block_size(cnot_circ):
    collect = PassManager(
        [
            CollectLinearFunctions(min_block_size=7, max_block_size=12),
        ]
    )
    collected_circuit = collect.run(cnot_circ)

    assert all(
        len(g.qubits) >= 7 or g.operation.name.lower() != ""linear_function""
        for g in collected_circuit
    )


@pytest.mark.timeout(10)
def test_collection_with_barrier(cnot_circ):
    cnot_circ.measure_all()
    collect = PassManager(
        [
            CollectLinearFunctions(min_block_size=7, max_block_size=12),
        ]
    )
    # Without proper handling this test timeouts (actually the collect runs forever)
    collect.run(cnot_circ)
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Unit-testing permutation_ai""""""
import pytest
from qiskit import QuantumCircuit
from qiskit.transpiler import PassManager
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

from qiskit_transpiler_service.ai.collection import CollectPermutations
from qiskit_transpiler_service.ai.synthesis import AIPermutationSynthesis


@pytest.fixture
def permutations_circuit(backend, cmap_backend):
    coupling_map = cmap_backend[backend]
    cmap = list(coupling_map.get_edges())
    orig_qc = QuantumCircuit(27)
    for i, j in cmap:
        orig_qc.h(i)
        orig_qc.cx(i, j)
    for i, j in cmap:
        orig_qc.swap(i, j)
    for i, j in cmap:
        orig_qc.h(i)
        orig_qc.cx(i, j)
    for i, j in cmap[:4]:
        orig_qc.swap(i, j)
    for i, j in cmap:
        orig_qc.cx(i, j)
    return orig_qc


def test_permutation_collector(permutations_circuit, backend, cmap_backend):
    qiskit_lvl3_transpiler = generate_preset_pass_manager(
        optimization_level=1, coupling_map=cmap_backend[backend]
    )
    permutations_circuit = qiskit_lvl3_transpiler.run(permutations_circuit)

    pm = PassManager(
        [
            CollectPermutations(max_block_size=27),
        ]
    )
    perm_only_circ = pm.run(permutations_circuit)
    from qiskit.converters import circuit_to_dag

    dag = circuit_to_dag(perm_only_circ)
    perm_nodes = dag.named_nodes(""permutation"", ""Permutation"")
    assert len(perm_nodes) == 2
    assert perm_nodes[0].op.num_qubits == 27
    assert perm_nodes[1].op.num_qubits == 4
    assert not dag.named_nodes(""linear_function"", ""Linear_function"")
    assert not dag.named_nodes(""clifford"", ""Clifford"")


def test_permutation_pass(permutations_circuit, backend, cmap_backend, caplog):
    qiskit_lvl3_transpiler = generate_preset_pass_manager(
        optimization_level=1, coupling_map=cmap_backend[backend]
    )
    permutations_circuit = qiskit_lvl3_transpiler.run(permutations_circuit)

    ai_optimize_lf = PassManager(
        [
            CollectPermutations(max_block_size=27),
            AIPermutationSynthesis(backend_name=backend),
        ]
    )
    ai_optimized_circuit = ai_optimize_lf.run(permutations_circuit)
    assert ""Using the synthesized circuit"" in caplog.text
    assert isinstance(ai_optimized_circuit, QuantumCircuit)


def test_permutation_wrong_backend(caplog):
    orig_qc = QuantumCircuit(3)
    orig_qc.swap(0, 1)
    orig_qc.swap(1, 2)

    ai_optimize_lf = PassManager(
        [
            CollectPermutations(min_block_size=2, max_block_size=27),
            AIPermutationSynthesis(backend_name=""a_wrong_backend""),
        ]
    )
    ai_optimized_circuit = ai_optimize_lf.run(orig_qc)
    assert ""couldn't synthesize the circuit"" in caplog.text
    assert ""Keeping the original circuit"" in caplog.text
    assert isinstance(ai_optimized_circuit, QuantumCircuit)
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Unit-testing linear_function_collection""""""
from qiskit import QuantumCircuit
from qiskit.transpiler import PassManager

from qiskit_transpiler_service.ai.collection import CollectPermutations


def test_permutation_collection_pass(random_circuit_transpiled):
    collect = PassManager(
        [
            CollectPermutations(),
        ]
    )
    collected_circuit = collect.run(random_circuit_transpiled)

    assert isinstance(collected_circuit, QuantumCircuit)


def test_permutation_collection_pass_collect(swap_circ):
    collect = PassManager(
        [
            CollectPermutations(min_block_size=1, max_block_size=5),
        ]
    )
    collected_circuit = collect.run(swap_circ)

    assert isinstance(collected_circuit, QuantumCircuit)
    assert any(g.operation.name.lower() == ""permutation"" for g in collected_circuit)


def test_permutation_collection_pass_no_collect(rzz_circ):
    collect = PassManager(
        [
            CollectPermutations(min_block_size=7, max_block_size=12),
        ]
    )
    collected_circuit = collect.run(rzz_circ)

    assert all(g.operation.name.lower() != ""permutation"" for g in collected_circuit)


def test_permutation_collection_max_block_size(swap_circ):
    collect = PassManager(
        [
            CollectPermutations(max_block_size=7),
        ]
    )
    collected_circuit = collect.run(swap_circ)

    assert all(len(g.qubits) <= 7 for g in collected_circuit)


def test_permutation_collection_min_block_size(swap_circ):
    collect = PassManager(
        [
            CollectPermutations(min_block_size=7, max_block_size=12),
        ]
    )
    collected_circuit = collect.run(swap_circ)

    assert all(
        len(g.qubits) >= 7 or g.operation.name.lower() != ""permutation""
        for g in collected_circuit
    )
"
https://github.com/Qiskit/qiskit-transpiler-service,Qiskit,"# -*- coding: utf-8 -*-

# (C) Copyright 2024 IBM. All Rights Reserved.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Unit-testing routing_ai""""""

import pytest
from qiskit import QuantumCircuit
from qiskit.transpiler import PassManager
from qiskit.transpiler.exceptions import TranspilerError

from qiskit_transpiler_service.ai.routing import AIRouting


@pytest.mark.parametrize(""layout_mode"", [""KEEP"", ""OPTIMIZE"", ""IMPROVE""])
@pytest.mark.parametrize(""optimization_level"", [1, 2, 3])
def test_qv_routing(optimization_level, layout_mode, backend, qv_circ):
    pm = PassManager(
        [
            AIRouting(
                optimization_level=optimization_level,
                layout_mode=layout_mode,
                backend_name=backend,
            )
        ]
    )
    circuit = pm.run(qv_circ)

    assert isinstance(circuit, QuantumCircuit)


@pytest.mark.parametrize(""optimization_level"", [0, 4, 5])
def test_qv_routing_wrong_opt_level(optimization_level, backend, qv_circ):
    pm = PassManager(
        [AIRouting(optimization_level=optimization_level, backend_name=backend)]
    )
    with pytest.raises(TranspilerError):
        pm.run(qv_circ)


@pytest.mark.parametrize(""layout_mode"", [""RECREATE"", ""BOOST""])
def test_qv_routing_wrong_layout_mode(layout_mode, backend, qv_circ):
    with pytest.raises(ValueError):
        PassManager([AIRouting(layout_mode=layout_mode, backend_name=backend)])
"
https://github.com/qiskit-community/qiskit-tket-passes,qiskit-community,"import re
from collections import OrderedDict

from qiskit import QuantumCircuit
from qiskit.transpiler import TransformationPass
from qiskit.transpiler.target import Target, target_to_backend_properties
from pytket.architecture import Architecture
from pytket.circuit import OpType
from pytket.passes import BasePass
from pytket.passes._decompositions import _TK1_to_X_SX_Rz, _TK1_to_U
from pytket.transform import CXConfigType, PauliSynthStrat
from pytket.extensions.qiskit import qiskit_to_tk
from pytket.placement import GraphPlacement, LinePlacement, NoiseAwarePlacement

from .utils import get_arguments_from_doc, qiskit_dag_to_tk, tk_to_qiskit_dag

def ToQiskitPass(tket_pass, target: Target = None, **kwargs):
    class TketPassClass(TransformationPass):
        def __init__(self, target: Target = None, **kwargs):
            if isinstance(tket_pass, BasePass):
                self._pass = tket_pass
                _dict = tket_pass.to_dict()
                class_name = _dict[_dict['pass_class']]['name']

                self.requires = []
                self.preserves = []
            else:
                self.target = target
                super().__init__()
                class_name = tket_pass.__name__

                self._args_dict = OrderedDict()
                parsed_args = get_arguments_from_doc(tket_pass)
                for parsed_arg in parsed_args:
                    arg_name = parsed_arg[0]
                    arg_type = parsed_arg[1]
                    if arg_type.endswith('architecture.Architecture'):
                        if arg_name in kwargs:
                            arc = kwargs.pop(arg_name)
                            if type(arc) == list:
                                connections = []
                                for edge in arc:
                                    connections.append(tuple(edge))
                                arc = Architecture(connections)
                            self._args_dict[arg_name] = arc
                        elif self.target:
                            arc = self._arch_from_target()
                            self._args_dict[arg_name] = arc
                    elif arg_type.endswith('placement.Placement'):
                        if arg_name in kwargs:
                            placer_str = kwargs.pop(arg_name)
                        else:
                            placer_str = 'NoiseAware'

                        if placer_str == 'Graph':
                            placer = GraphPlacement(self._arch_from_target())
                            self._args_dict[arg_name] = placer
                        elif placer_str == 'Line':
                            placer = LinePlacement(self._arch_from_target())
                            self._args_dict[arg_name] = placer
                        elif placer_str == 'NoiseAware':
                            if self.target:
                                placer = self._noise_aware_placer_from_target()
                                self._args_dict[arg_name] = placer
                        else:
                            raise ValueError('Unsupported placer type:', placer_str)
                    elif arg_type.endswith('circuit.Circuit'):
                        if arg_name in kwargs:
                            circ = kwargs.pop(arg_name)
                            tkcirc = qiskit_to_tk(circ)
                            self._args_dict[arg_name] = tkcirc
                        elif self.target:
                            if class_name == 'DecomposeSwapsToCircuit' and arg_name == 'replacement_circuit':
                                # Construct SWAP replacement circuit based on target's gate set.
                                circ = self._swap_decomposition_from_target()
                                tkcirc = qiskit_to_tk(circ)
                                self._args_dict[arg_name] = tkcirc
                            elif class_name == 'RebaseCustom' and arg_name == 'cx_replacement':
                                # Construct CNOT replacement circuit based on target's gate set.
                                circ = self._cnot_decomposition_from_target()
                                tkcirc = qiskit_to_tk(circ)
                                self._args_dict[arg_name] = tkcirc
                    elif arg_type.endswith('circuit.OpType'):
                        if arg_name in kwargs:
                            op_str = kwargs.pop(arg_name)
                            op_type = self._optype_from_str(op_str)
                            self._args_dict[arg_name] = op_type
                    elif re.match(""Set\[.+\.circuit\.OpType\]"", arg_type) is not None:
                        if arg_name in kwargs:
                            _value = kwargs.pop(arg_name)
                            if all(isinstance(elem, str) for elem in _value):
                                op_types = set()
                                for op_str in _value:
                                    op_types.add(self._optype_from_str(op_str))

                                self._args_dict[arg_name] = op_types
                            elif isinstance(_value, set) and all(isinstance(elem, OpType) for elem in _value):
                                self._args_dict[arg_name] = _value
                        elif self.target and class_name == 'RebaseCustom' and arg_name == 'gateset':
                            # Get the target's gate set.
                            self._args_dict[arg_name] = self._gateset_from_target()
                    elif arg_type.endswith('transform.PauliSynthStrat'):
                        if arg_name in kwargs:
                            strategy = kwargs.pop(arg_name)
                            strategies_map = {
                                'Individual': PauliSynthStrat.Individual,
                                'Pairwise': PauliSynthStrat.Pairwise,
                                'Sets': PauliSynthStrat.Sets,
                            }
                            value = strategies_map[strategy]
                            self._args_dict[arg_name] = value
                    elif arg_type.endswith('transform.CXConfigType'):
                        if arg_name in kwargs:
                            cx_config = kwargs.pop(arg_name)
                            cx_config_map = {
                                'Snake': CXConfigType.Snake,
                                'Star': CXConfigType.Star,
                                'Tree': CXConfigType.Tree,
                                'MultiQGate': CXConfigType.MultiQGate
                            }
                            value = cx_config_map[cx_config]
                            self._args_dict[arg_name] = value
                    elif arg_name == 'tk1_replacement':
                        if self.target:
                            self._args_dict[arg_name] = self._tk1_replacement_from_target()
                        else:
                            self._args_dict[arg_name] = _TK1_to_U
                    else:
                        if arg_name in kwargs:
                            value = kwargs.pop(arg_name)
                            self._args_dict[arg_name] = value

                args =  self._args_dict.values()
                self._pass = tket_pass(*args, **kwargs)
            __class__.__name__ = 'TketPass_' + class_name

        def run(self, dag):
            tkcirc = qiskit_dag_to_tk(dag)
            self._pass.apply(tkcirc)
            return tk_to_qiskit_dag(tkcirc)

        def tket_argument(self, arg_name):
            if arg_name in self._args_dict:
                return self._args_dict[arg_name]
            else:
                raise ValueError(f""{__class__.__name__} has no argument with the name {arg_name}."")

        #TODO: May be we should move the following methods to utils file instead of having them as class methods
        def _optype_from_str(self, op_str):
            for op_type in dir(OpType):
                if op_str.upper() == op_type.upper():
                    return OpType.from_name(op_type)

            ops_map = {
                'id': 'noop',
                'u': 'U3',
                'cu': 'CU3',
                'iswap': 'ISWAPMax',
                'rxx': 'XXPhase',
                'ryy': 'YYPhase',
                'rzz': 'ZZPhase',
                'p': 'U1',
                'cp': 'CU1',
                'r': 'PhasedX',
            }
            return OpType.from_name(ops_map[op_str])

        def _gateset_from_target(self):

            operation_names = list(self.target.operation_names)
            for op in ['delay', 'if_else', 'rzx']:
                if op in operation_names:
                    operation_names.remove(op)

            return { self._optype_from_str(op_str) for op_str in operation_names }

        def _arch_from_target(self):
            _coupling_map = self.target.build_coupling_map()
            if _coupling_map is None:
                return Architecture([])
            else:
                return Architecture(_coupling_map.get_edges())

        def _cnot_decomposition_from_target(self):
            circ = QuantumCircuit(2)
            circ.cx(0, 1)
            if 'cx' not in self.target.operation_names:
                from qiskit import transpile
                circ = transpile(circ, basis_gates=list(self.target.operation_names))
            return circ

        def _swap_decomposition_from_target(self):
            from qiskit import transpile
            circ = QuantumCircuit(2)
            circ.swap(0, 1)
            return transpile(circ, basis_gates=list(self.target.operation_names))

        def _tk1_replacement_from_target(self):
            if {'x', 'sx', 'rz'}.issubset(self.target.operation_names):
                return _TK1_to_X_SX_Rz
            else:
                return _TK1_to_U

        def _noise_aware_placer_from_target(self):
            """"""
            Get noise data from target.
            This code is a modified copy from `process_characterisation` & `get_avg_characterisation` functions in pytket-qiskit module.
            """"""
            from collections import defaultdict
            from pytket.circuit import Node


            node_errors = defaultdict(dict)
            edge_errors = defaultdict(dict)
            readout_errors = {}

            coupling_map = target.build_coupling_map()
            arc = self._arch_from_target()
            properties = target_to_backend_properties(target)
            if properties is None:
                return None
            else:
                for gate in properties.gates:
                    for param in gate.parameters:
                        if param.name == 'gate_error':
                            optype = self._optype_from_str(gate.gate)
                            gate_error = param.value
                            if len(gate.qubits) == 1:
                                node_errors[Node(gate.qubits[0])].update({optype: gate_error})
                            else:
                                edge_errors[(Node(gate.qubits[0]), Node(gate.qubits[1]))].update({optype: gate_error})
                                if gate.qubits[::-1] not in coupling_map:
                                    edge_errors[(Node(gate.qubits[1]), Node(gate.qubits[0]))].update({optype: 2 * gate_error})

                props_dict = properties.to_dict()
                for n in range(target.num_qubits):
                    if len(props_dict['qubits']) > n:
                        readout_error = properties.readout_error(n)
                    else:
                        readout_error = 0

                    readout_errors[Node(n)] = [       
                        [1.0 - readout_error, readout_error],
                        [readout_error, 1.0 - readout_error],
                    ]

                avg = lambda xs: sum(xs.values()) / len(xs)
                avg_mat = (lambda xs: (xs[0][1] + xs[1][0]) / 2.0)
                map_values = lambda f, d: { k: f(v) for k, v in d.items() }

                avg_node_errors = map_values(avg, node_errors)
                avg_edge_errors = map_values(avg, edge_errors)
                avg_readout_errors = map_values(avg_mat, readout_errors)

                return NoiseAwarePlacement(
                    arc,
                    avg_node_errors,
                    avg_edge_errors,
                    avg_readout_errors
                )

    return TketPassClass(target, **kwargs)"
https://github.com/qiskit-community/qiskit-tket-passes,qiskit-community,"import pydoc
import re

import pytket.passes as tkps

def get_arguments_from_doc(tket_pass):
    arguments = []

    _doc = pydoc.getdoc(tket_pass)
    if 'Overloaded function.' in _doc:
        #Return the first signature
        #TODO: We should return all possible signatures. This would requires changes in ToQiskitPass also.
        matches = re.findall(""[1-9]\. ("" + tket_pass.__name__ + '[^\n]+)', _doc)
        synopsis_line = matches[0]
    else:
        synopsis_line = pydoc.splitdoc(_doc)[0]

    # To avoid issue caused by callable parentheses:
    synopsis_line = re.sub('Callable\[\[[^\[]+\][^\[]+\]', 'Callable', synopsis_line)

    match = re.search(""\(([^(]+)\)"", synopsis_line)
    if match is not None:
        splitted_args = match.group(1).split(', ')
        for arg_str in splitted_args:
            if arg_str == '**kwargs':
                continue
            else:
                argument = arg_str.split(': ')
                eq_index = argument[1].find('=')
                if eq_index > 0:
                    (_type, _default) = argument[1].split(' = ')
                    arguments.append((argument[0], _type, _default))
                else:
                    arguments.append(tuple(argument))

    return arguments

# This is **temp**. Conversion should be done in a better way
# https://github.com/CQCL/pytket-qiskit/blob/develop/pytket/extensions/qiskit/qiskit_convert.py

from pytket.extensions.qiskit import qiskit_to_tk, tk_to_qiskit
from qiskit.converters import dag_to_circuit, circuit_to_dag

from pytket.circuit import Circuit
from qiskit.dagcircuit import DAGCircuit

def qiskit_dag_to_tk(dag: DAGCircuit):
    # Replace any gate that is not known to pyket by its definition
    from pytket.extensions.qiskit.qiskit_convert import _known_qiskit_gate
    for node in dag.op_nodes():
        if not type(node.op) in _known_qiskit_gate:
            dag.substitute_node_with_dag(node, circuit_to_dag(node.op.definition))

    return qiskit_to_tk(dag_to_circuit(dag))

def tk_to_qiskit_dag(tkcirc: Circuit):
    return circuit_to_dag(tk_to_qiskit(tkcirc))"
https://github.com/qiskit-community/qiskit-tket-passes,qiskit-community,"import unittest

from qiskit.transpiler.preset_passmanagers.plugin import (
    list_stage_plugins,
    passmanager_stage_plugins,
)
import qiskit_tket_passes.plugins as plgn
    
class TestPassManagerStagePlugins(unittest.TestCase):
    def test_plugins_are_installed(self):
        for stage_name in ['init', 'layout', 'routing', 'translation', 'optimization']:
            installed_plugins = list_stage_plugins(stage_name)
            self.assertIn('tket', installed_plugins)

    def test_plugins_are_used(self):
        plugins = passmanager_stage_plugins('init')
        self.assertIsInstance(isinstance(plugins['tket'], plgn.TketInitPassManager))

        plugins = passmanager_stage_plugins('layout')
        self.assertIsInstance(plugins['tket'], plgn.TketLayoutPassManager)

        plugins = passmanager_stage_plugins('routing')
        self.assertIsInstance(plugins['tket'], plgn.TketRoutingPassManager)

        plugins = passmanager_stage_plugins('translation')
        self.assertIsInstance(plugins['tket'], plgn.TketTranslationPassManager)

        plugins = passmanager_stage_plugins('optimization')
        self.assertIsInstance(plugins['tket'], plgn.TketOptimizationPassManager)


if __name__ == '__main__':
    unittest.main()"
https://github.com/qiskit-community/qiskit-scheduling-extension,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Test the CompactScheduling pass""""""

from qiskit import QuantumCircuit
from qiskit.test import QiskitTestCase
from qiskit.transpiler.instruction_durations import InstructionDurations
from qiskit.transpiler.passes import PadDelay
from qiskit.transpiler.passmanager import PassManager

from qiskit_scheduling_extension.compact import CompactScheduleAnalysis


class TestCompactScheduling(QiskitTestCase):
    """"""Tests the CompactScheduling pass""""""

    def test_compact(self):
        """"""Test if Compact scheduling yields expected schedule.

        (input)
                ┌───┐               ┌───┐ ░ ┌─┐
           q_0: ┤ H ├──■─────────■──┤ H ├─░─┤M├──────
                └───┘┌─┴─┐     ┌─┴─┐└───┘ ░ └╥┘┌─┐
           q_1: ─────┤ X ├──■──┤ X ├──────░──╫─┤M├───
                ┌───┐└───┘┌─┴─┐├───┤      ░  ║ └╥┘┌─┐
           q_2: ┤ H ├─────┤ X ├┤ H ├──────░──╫──╫─┤M├
                └───┘     └───┘└───┘      ░  ║  ║ └╥┘
        meas: 3/═════════════════════════════╩══╩══╩═
                                             0  1  2

        (Compact scheduled)
                      ┌───┐            ┌────────────────┐           ┌───┐        ░ ┌─┐
           q_0: ──────┤ H ├─────────■──┤ Delay(900[dt]) ├──■────────┤ H ├────────░─┤M├──────
                ┌─────┴───┴──────┐┌─┴─┐└────────────────┘┌─┴─┐┌─────┴───┴──────┐ ░ └╥┘┌─┐
           q_1: ┤ Delay(200[dt]) ├┤ X ├────────■─────────┤ X ├┤ Delay(200[dt]) ├─░──╫─┤M├───
                ├────────────────┤├───┤      ┌─┴─┐       ├───┤├────────────────┤ ░  ║ └╥┘┌─┐
           q_2: ┤ Delay(700[dt]) ├┤ H ├──────┤ X ├───────┤ H ├┤ Delay(700[dt]) ├─░──╫──╫─┤M├
                └────────────────┘└───┘      └───┘       └───┘└────────────────┘ ░  ║  ║ └╥┘
        meas: 3/════════════════════════════════════════════════════════════════════╩══╩══╩═
                                                                                    0  1  2
        """"""
        qc = QuantumCircuit(3)
        qc.h([0, 2])
        qc.cx(0, 1)
        qc.cx(1, 2)
        qc.cx(0, 1)
        qc.h([0, 2])
        qc.measure_all()

        durations = InstructionDurations(
            [(""h"", None, 200), (""cx"", [0, 1], 700), (""cx"", [1, 2], 900), (""measure"", None, 1000)]
        )

        pm = PassManager([CompactScheduleAnalysis(durations), PadDelay()])
        compact_qc = pm.run(qc)

        expected = QuantumCircuit(3)
        expected.delay(200, 1)
        expected.delay(700, 2)
        expected.h([0, 2])
        expected.cx(0, 1)
        expected.cx(1, 2)
        expected.delay(900, 0)
        expected.cx(0, 1)
        expected.h([0, 2])
        expected.delay(200, 1)
        expected.delay(700, 2)
        expected.measure_all()

        self.assertEqual(expected, compact_qc)

    def test_compact_can_shift_block(self):
        """"""Test if Compact scheduling can shift front blocks towards the back and
        back blocks towards the front.

        (input)
                                                              ░ ┌─┐
           q_0: ──■─────────────────────────────■─────────────░─┤M├─────────
                ┌─┴─┐                         ┌─┴─┐           ░ └╥┘┌─┐
           q_1: ┤ X ├────────────■─────────■──┤ X ├───────────░──╫─┤M├──────
                └───┘     ┌───┐┌─┴─┐     ┌─┴─┐├───┤           ░  ║ └╥┘┌─┐
           q_2: ───────■──┤ H ├┤ X ├──■──┤ X ├┤ H ├──■────────░──╫──╫─┤M├───
                ┌───┐┌─┴─┐├───┤└───┘┌─┴─┐├───┤└───┘┌─┴─┐┌───┐ ░  ║  ║ └╥┘┌─┐
           q_3: ┤ H ├┤ X ├┤ H ├─────┤ X ├┤ H ├─────┤ X ├┤ H ├─░──╫──╫──╫─┤M├
                └───┘└───┘└───┘     └───┘└───┘     └───┘└───┘ ░  ║  ║  ║ └╥┘
        meas: 4/═════════════════════════════════════════════════╩══╩══╩══╩═
                                                                 0  1  2  3
        (Compact scheduled)
                                  ┌─────────────────┐                            »
           q_0: ────────■─────────┤ Delay(1000[dt]) ├────────────────────────────»
                      ┌─┴─┐       └─────────────────┘                            »
           q_1: ──────┤ X ├────────────────────────────────────────────■─────────»
                ┌─────┴───┴──────┐                        ┌───┐      ┌─┴─┐       »
           q_2: ┤ Delay(750[dt]) ├─────────────────────■──┤ H ├──────┤ X ├───────»
                ├────────────────┤       ┌───┐       ┌─┴─┐├───┤┌─────┴───┴──────┐»
           q_3: ┤ Delay(700[dt]) ├───────┤ H ├───────┤ X ├┤ H ├┤ Delay(400[dt]) ├»
                └────────────────┘       └───┘       └───┘└───┘└────────────────┘»
        meas: 4/═════════════════════════════════════════════════════════════════»
                                                                                 »
        «                                                                        »
        «   q_0: ───────────────────────────────■────────────────────────────────»
        «        ┌────────────────┐           ┌─┴─┐                              »
        «   q_1: ┤ Delay(200[dt]) ├──■────────┤ X ├──────────────────────────────»
        «        └────────────────┘┌─┴─┐      ├───┤            ┌────────────────┐»
        «   q_2: ────────■─────────┤ X ├──────┤ H ├─────────■──┤ Delay(750[dt]) ├»
        «              ┌─┴─┐       ├───┤┌─────┴───┴──────┐┌─┴─┐└─────┬───┬──────┘»
        «   q_3: ──────┤ X ├───────┤ H ├┤ Delay(400[dt]) ├┤ X ├──────┤ H ├───────»
        «              └───┘       └───┘└────────────────┘└───┘      └───┘       »
        «meas: 4/════════════════════════════════════════════════════════════════»
        «                                                                        »
        «                           ░ ┌─┐
        «   q_0: ───────────────────░─┤M├─────────
        «                           ░ └╥┘┌─┐
        «   q_1: ───────────────────░──╫─┤M├──────
        «                           ░  ║ └╥┘┌─┐
        «   q_2: ───────────────────░──╫──╫─┤M├───
        «        ┌────────────────┐ ░  ║  ║ └╥┘┌─┐
        «   q_3: ┤ Delay(700[dt]) ├─░──╫──╫──╫─┤M├
        «        └────────────────┘ ░  ║  ║  ║ └╥┘
        «meas: 4/══════════════════════╩══╩══╩══╩═
        «                              0  1  2  3
        """"""
        qc = QuantumCircuit(4)
        qc.cx(0, 1)
        qc.h(3)
        qc.cx(2, 3)
        qc.h([2, 3])
        qc.cx(1, 2)
        qc.cx(2, 3)
        qc.cx(1, 2)
        qc.h([2, 3])
        qc.cx(2, 3)
        qc.h(3)
        qc.cx(0, 1)
        qc.measure_all()

        durations = InstructionDurations(
            [
                (""h"", None, 50),
                (""cx"", [0, 1], 1000),
                (""cx"", [1, 2], 400),
                (""cx"", [2, 3], 200),
                (""measure"", None, 1000),
            ]
        )
        pm = PassManager([CompactScheduleAnalysis(durations), PadDelay()])
        compact_qc = pm.run(qc)

        expected = QuantumCircuit(4)
        expected.delay(750, 2)
        expected.delay(700, 3)
        expected.cx(0, 1)
        expected.h(3)
        expected.cx(2, 3)
        expected.h([2, 3])
        expected.delay(400, 3)
        expected.cx(1, 2)
        expected.delay(1000, 0)
        expected.delay(200, 1)
        expected.cx(2, 3)
        expected.cx(1, 2)
        expected.h([2, 3])
        expected.delay(400, 3)
        expected.cx(2, 3)
        expected.h(3)
        expected.cx(0, 1)
        expected.delay(750, 2)
        expected.delay(700, 3)
        expected.measure_all()

        self.assertEqual(expected, compact_qc)
"
https://github.com/qiskit-community/qiskit-scheduling-extension,qiskit-community,"# This code is part of Qiskit.
#
# (C) Copyright IBM 2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

""""""Test the CompactScheduling pass""""""

from qiskit import QuantumCircuit, transpile
from qiskit.test import QiskitTestCase
from qiskit.transpiler.preset_passmanagers.plugin import list_stage_plugins


class TestCompactScheduling(QiskitTestCase):
    """"""Tests the CompactScheduling plugin""""""

    def test_plugin_in_list(self):
        """"""Test compact scheduling plugin is installed.""""""
        self.assertIn(""compact"", list_stage_plugins(""scheduling""))

    def test_compact(self):
        """"""Test if Compact scheduling yields expected schedule.

        (input)
                ┌───┐               ┌───┐ ░ ┌─┐
           q_0: ┤ H ├──■─────────■──┤ H ├─░─┤M├──────
                └───┘┌─┴─┐     ┌─┴─┐└───┘ ░ └╥┘┌─┐
           q_1: ─────┤ X ├──■──┤ X ├──────░──╫─┤M├───
                ┌───┐└───┘┌─┴─┐├───┤      ░  ║ └╥┘┌─┐
           q_2: ┤ H ├─────┤ X ├┤ H ├──────░──╫──╫─┤M├
                └───┘     └───┘└───┘      ░  ║  ║ └╥┘
        meas: 3/═════════════════════════════╩══╩══╩═
                                             0  1  2

        (Compact scheduled)
                      ┌───┐            ┌────────────────┐           ┌───┐        ░ ┌─┐
           q_0: ──────┤ H ├─────────■──┤ Delay(900[dt]) ├──■────────┤ H ├────────░─┤M├──────
                ┌─────┴───┴──────┐┌─┴─┐└────────────────┘┌─┴─┐┌─────┴───┴──────┐ ░ └╥┘┌─┐
           q_1: ┤ Delay(200[dt]) ├┤ X ├────────■─────────┤ X ├┤ Delay(200[dt]) ├─░──╫─┤M├───
                ├────────────────┤├───┤      ┌─┴─┐       ├───┤├────────────────┤ ░  ║ └╥┘┌─┐
           q_2: ┤ Delay(700[dt]) ├┤ H ├──────┤ X ├───────┤ H ├┤ Delay(700[dt]) ├─░──╫──╫─┤M├
                └────────────────┘└───┘      └───┘       └───┘└────────────────┘ ░  ║  ║ └╥┘
        meas: 3/════════════════════════════════════════════════════════════════════╩══╩══╩═
                                                                                    0  1  2
        """"""
        qc = QuantumCircuit(3)
        qc.h([0, 2])
        qc.cx(0, 1)
        qc.cx(1, 2)
        qc.cx(0, 1)
        qc.h([0, 2])
        qc.measure_all()

        durations = [
            (""h"", None, 200),
            (""cx"", [0, 1], 700),
            (""cx"", [1, 2], 900),
            (""measure"", None, 1000)
        ]

        actual = transpile(
            qc, instruction_durations=durations, scheduling_method=""compact"", optimization_level=0
        )

        expected = QuantumCircuit(3)
        expected.delay(200, 1)
        expected.delay(700, 2)
        expected.h([0, 2])
        expected.cx(0, 1)
        expected.cx(1, 2)
        expected.delay(900, 0)
        expected.cx(0, 1)
        expected.h([0, 2])
        expected.delay(200, 1)
        expected.delay(700, 2)
        expected.measure_all()

        self.assertEqual(expected, actual)
"
